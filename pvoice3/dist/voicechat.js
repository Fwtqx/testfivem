/*
 * pvoice3 v3.0.0
 * GLife | Voice Chat
 * Copyright: 2017-2021 Vinipux322 & pichotm (a little)...
 * License: All Rights Reserved
 */

(function(){function r(e,n,t){function o(i,f){if(!n[i]){if(!e[i]){var c="function"==typeof require&&require;if(!f&&c)return c(i,!0);if(u)return u(i,!0);var a=new Error("Cannot find module '"+i+"'");throw a.code="MODULE_NOT_FOUND",a}var p=n[i]={exports:{}};e[i][0].call(p.exports,function(r){var n=e[i][1][r];return o(n||r)},p,p.exports,r,e,n,t)}return n[i].exports}for(var u="function"==typeof require&&require,i=0;i<t.length;i++)o(t[i]);return o}return r})()({"/home/ubuntu/umbrella-voice2/app/lib/Logger.js":[function(require,module,exports){
  "use strict";
  
  var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;
  
  var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
  
  var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
  
  var _debug = _interopRequireDefault(require("debug"));
  
  var APP_NAME = 'mediasoup-demo';
  
  var Logger = /*#__PURE__*/function () {
    function Logger(prefix) {
      (0, _classCallCheck2["default"])(this, Logger);
  
      if (prefix) {
        this._debug = (0, _debug["default"])("".concat(APP_NAME, ":").concat(prefix));
        this._warn = (0, _debug["default"])("".concat(APP_NAME, ":WARN:").concat(prefix));
        this._error = (0, _debug["default"])("".concat(APP_NAME, ":ERROR:").concat(prefix));
      } else {
        this._debug = (0, _debug["default"])(APP_NAME);
        this._warn = (0, _debug["default"])("".concat(APP_NAME, ":WARN"));
        this._error = (0, _debug["default"])("".concat(APP_NAME, ":ERROR"));
      }
      /* eslint-disable no-console */
  
  
      this._debug.log = console.info.bind(console);
      this._warn.log = console.warn.bind(console);
      this._error.log = console.error.bind(console);
      /* eslint-enable no-console */
    }
  
    (0, _createClass2["default"])(Logger, [{
      key: "debug",
      get: function get() {
        return this._debug;
      }
    }, {
      key: "warn",
      get: function get() {
        return this._warn;
      }
    }, {
      key: "error",
      get: function get() {
        return this._error;
      }
    }]);
    return Logger;
  }();
  
  exports["default"] = Logger;
  
  },{"@babel/runtime/helpers/classCallCheck":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/classCallCheck.js","@babel/runtime/helpers/createClass":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/createClass.js","@babel/runtime/helpers/interopRequireDefault":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/interopRequireDefault.js","debug":"/home/ubuntu/umbrella-voice2/app/node_modules/debug/src/browser.js"}],"/home/ubuntu/umbrella-voice2/app/lib/RoomClient.js":[function(require,module,exports){
  "use strict";
  
  var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
  
  var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;
  
  var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
  
  var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  
  var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
  
  var _classCallCheck2 = _interopRequireDefault(require("@babel/runtime/helpers/classCallCheck"));
  
  var _createClass2 = _interopRequireDefault(require("@babel/runtime/helpers/createClass"));
  
  var _protooClient = _interopRequireDefault(require("protoo-client"));
  
  var mediasoupClient = _interopRequireWildcard(require("mediasoup-client"));
  
  var _Logger = _interopRequireDefault(require("./Logger"));
  
  var _urlFactory = require("./urlFactory");
  
  var _events = _interopRequireDefault(require("./events"));
  
  var utils = _interopRequireWildcard(require("./utils"));
  
  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
  
  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  
  var PC_PROPRIETARY_CONSTRAINTS = {
    optional: [{
      googDscp: true
    }]
  };
  var iceServers = [{
    urls: 'stun:stun.l.google.com:19302',
    username: '',
    credential: ''
  }, {
    urls: 'stun:stun1.l.google.com:19302',
    username: '',
    credential: ''
  }, {
    urls: 'stun:stun2.l.google.com:19302',
    username: '',
    credential: ''
  }, {
    urls: 'stun:stun3.l.google.com:19302',
    username: '',
    credential: ''
  }, {
    urls: 'stun:stun4.l.google.com:19302',
    username: '',
    credential: ''
  }];
  var logger = new _Logger["default"]('RoomClient');
  
  var RoomClient = /*#__PURE__*/function () {
    /**
     * @param  {Object} data
     * @param  {Object} data.store - The Redux store.
     */
    // static init(data)
    // {
    // 	store = data.store;
    // }
    function RoomClient(_ref) {
      var roomId = _ref.roomId,
          peerId = _ref.peerId,
          device = _ref.device,
          handlerName = _ref.handlerName,
          useSimulcast = _ref.useSimulcast,
          forceTcp = _ref.forceTcp,
          produce = _ref.produce,
          consume = _ref.consume,
          forceH264 = _ref.forceH264,
          forceVP9 = _ref.forceVP9,
          datachannel = _ref.datachannel;
      (0, _classCallCheck2["default"])(this, RoomClient);
      logger.debug('constructor() [roomId:"%s", peerId:"%s", device:%s]', roomId, peerId, device.flag);
      this.audioContext = new AudioContext();
      this.mainVolume = this.audioContext.createGain();
      this.mainVolume.connect(this.audioContext.destination);
      this.mainVolume.gain.setValueAtTime(1, this.audioContext.currentTime);
      this.roomId = roomId;
      this.peerId = peerId; // Closed flag.
      // @type {Boolean}
  
      this._closed = false; // Device info.
      // @type {Object}
  
      this._device = device; // Whether we want to force RTC over TCP.
      // @type {Boolean}
  
      this._forceTcp = forceTcp; // Whether we want to produce audio/video.
      // @type {Boolean}
  
      this._produce = produce; // Whether we should consume.
      // @type {Boolean}
  
      this._consume = consume; // Whether we want DataChannels.
      // @type {Boolean}
  
      this._useDataChannel = datachannel; // Force H264 codec for sending.
  
      this._forceH264 = Boolean(forceH264); // Force VP9 codec for sending.
  
      this._forceVP9 = Boolean(forceVP9); // External video.
      // @type {HTMLVideoElement}
  
      this._externalVideo = null; // Next expected dataChannel test number.
      // @type {Number}
  
      this._nextDataChannelTestNumber = 0; // Custom mediasoup-client handler name (to override default browser
      // detection if desired).
      // @type {String}
  
      this._handlerName = handlerName; // Whether simulcast should be used.
      // @type {Boolean}
  
      this._useSimulcast = useSimulcast; // protoo-client Peer instance.
      // @type {protooClient.Peer}
  
      this._protoo = null; // mediasoup-client Device instance.
      // @type {mediasoupClient.Device}
  
      this._mediasoupDevice = null; // mediasoup Transport for sending.
      // @type {mediasoupClient.Transport}
  
      this._sendTransport = null; // mediasoup Transport for receiving.
      // @type {mediasoupClient.Transport}
  
      this._recvTransport = null; // Local mic mediasoup Producer.
      // @type {mediasoupClient.Producer}
  
      this._micProducer = null; // mediasoup Consumers.
      // @type {Map<String, mediasoupClient.Consumer>}
  
      this._consumers = new Map(); // mediasoup Consumers.
      // @type {Map<String, mediasoupClient.Consumer>}
  
      this._peers = new Map();
    }
  
    (0, _createClass2["default"])(RoomClient, [{
      key: "close",
      value: function close() {
        if (this._closed) return;
        this._closed = true;
        logger.debug('close()'); // Close protoo Peer
  
        this._protoo.close();
  
        _events["default"].triggerClientChangeStateConnection(this.roomId, 'disconnected'); // Close mediasoup Transports.
  
  
        if (this._sendTransport) this._sendTransport.close();
        if (this._recvTransport) this._recvTransport.close();
      }
    }, {
      key: "join",
      value: function () {
        var _join = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2() {
          var _this = this;
  
          var protooUrl, protooTransport;
          return _regenerator["default"].wrap(function _callee2$(_context2) {
            while (1) {
              switch (_context2.prev = _context2.next) {
                case 0:
                  protooUrl = (0, _urlFactory.getProtooUrl)({
                    roomId: this.roomId,
                    peerId: this.peerId
                  });
                  protooTransport = new _protooClient["default"].WebSocketTransport(protooUrl);
                  this._protoo = new _protooClient["default"].Peer(protooTransport);
  
                  this._protoo.on('open', function () {
                    return _this._joinRoom();
                  });
  
                  this._protoo.on('failed', function () {
                    logger.error('proto connect failed');
  
                    _events["default"].triggerClientChangeStateConnection(_this.roomId, 'disconnected');
                  });
  
                  this._protoo.on('disconnected', function () {
                    logger.debug('proto disconnected');
  
                    _events["default"].triggerClientChangeStateConnection(_this.roomId, 'disconnected'); // Close mediasoup Transports.
  
  
                    if (_this._sendTransport) {
                      _this._sendTransport.close();
  
                      _this._sendTransport = null;
                    }
  
                    if (_this._recvTransport) {
                      _this._recvTransport.close();
  
                      _this._recvTransport = null;
                    }
                  });
  
                  this._protoo.on('close', function () {
                    if (_this._closed) return;
  
                    _this.close();
                  }); // eslint-disable-next-line no-unused-vars
  
  
                  this._protoo.on('request', /*#__PURE__*/function () {
                    var _ref2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(request, accept, reject) {
                      var _request$data, peerId, producerId, id, kind, rtpParameters, appData, consumer;
  
                      return _regenerator["default"].wrap(function _callee$(_context) {
                        while (1) {
                          switch (_context.prev = _context.next) {
                            case 0:
                              logger.debug('proto "request" event [method:%s, data:%o]', request.method, request.data);
                              _context.t0 = request.method;
                              _context.next = _context.t0 === 'newConsumer' ? 4 : 24;
                              break;
  
                            case 4:
                              if (_this._consume) {
                                _context.next = 7;
                                break;
                              }
  
                              reject(403, 'I do not want to consume');
                              return _context.abrupt("break", 24);
  
                            case 7:
                              _request$data = request.data, peerId = _request$data.peerId, producerId = _request$data.producerId, id = _request$data.id, kind = _request$data.kind, rtpParameters = _request$data.rtpParameters, appData = _request$data.appData;
                              _context.prev = 8;
                              _context.next = 11;
                              return _this._recvTransport.consume({
                                id: id,
                                producerId: producerId,
                                kind: kind,
                                rtpParameters: rtpParameters,
                                appData: _objectSpread(_objectSpread({}, appData), {}, {
                                  peerId: peerId
                                }) // Trick.
  
                              });
  
                            case 11:
                              consumer = _context.sent;
  
                              // Store in the map.
                              _this._consumers.set(consumer.id, consumer);
  
                              _this._peers.set(peerId, consumer.id);
  
                              consumer.on('transportclose', function () {
                                _this._peers["delete"](consumer.peerId);
  
                                _this._consumers["delete"](consumer.id);
                              }); // const { spatialLayers, temporalLayers } =
                              // 	mediasoupClient.parseScalabilityMode(
                              // 		consumer.rtpParameters.encodings[0].scalabilityMode);
  
                              _this.initConsumerAudio(consumer.id); // We are ready. Answer the protoo request so the server will
                              // resume this Consumer (which was paused for now if video).
  
  
                              accept(); // If audio-only mode is enabled, pause it.
                              // if (consumer.kind === 'video' && store.getState().me.audioOnly)
                              // 	this._pauseConsumer(consumer);
  
                              _context.next = 23;
                              break;
  
                            case 19:
                              _context.prev = 19;
                              _context.t1 = _context["catch"](8);
                              logger.error('"newConsumer" request failed:%o', _context.t1);
                              throw _context.t1;
  
                            case 23:
                              return _context.abrupt("break", 24);
  
                            case 24:
                            case "end":
                              return _context.stop();
                          }
                        }
                      }, _callee, null, [[8, 19]]);
                    }));
  
                    return function (_x, _x2, _x3) {
                      return _ref2.apply(this, arguments);
                    };
                  }());
  
                  this._protoo.on('notification', function (notification) {
                    if (notification.method !== 'activeSpeaker') {
                      logger.debug('proto "notification" event [method:%s, data:%o]', notification.method, notification.data);
                    }
  
                    switch (notification.method) {
                      case 'consumerClosed':
                        {
                          var consumerId = notification.data.consumerId;
  
                          var consumer = _this._consumers.get(consumerId);
  
                          if (!consumer) break;
                          consumer.close();
  
                          _this.removeConsumerAudio(consumerId);
  
                          _this._peers["delete"](consumer.peerId);
  
                          _this._consumers["delete"](consumerId); // const { peerId } = consumer.appData;
  
  
                          break;
                        }
  
                      case 'consumerPaused':
                        {
                          var _consumerId = notification.data.consumerId;
  
                          var _consumer = _this._consumers.get(_consumerId);
  
                          if (!_consumer) break;
  
                          _consumer.pause();
  
                          break;
                        }
  
                      case 'consumerResumed':
                        {
                          var _consumerId2 = notification.data.consumerId;
  
                          var _consumer2 = _this._consumers.get(_consumerId2);
  
                          if (!_consumer2) break;
  
                          _consumer2.resume();
  
                          break;
                        }
  
                      default:
                        {
                          logger.error('unknown protoo notification.method "%s"', notification.method);
                        }
                    }
                  });
  
                case 9:
                case "end":
                  return _context2.stop();
              }
            }
          }, _callee2, this);
        }));
  
        function join() {
          return _join.apply(this, arguments);
        }
  
        return join;
      }()
    }, {
      key: "enableMic",
      value: function () {
        var _enableMic = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee3() {
          var _this2 = this;
  
          var track, constraints, stream;
          return _regenerator["default"].wrap(function _callee3$(_context3) {
            while (1) {
              switch (_context3.prev = _context3.next) {
                case 0:
                  logger.debug('enableMic()');
  
                  if (!this._micProducer) {
                    _context3.next = 3;
                    break;
                  }
  
                  return _context3.abrupt("return");
  
                case 3:
                  if (this._mediasoupDevice.canProduce('audio')) {
                    _context3.next = 6;
                    break;
                  }
  
                  logger.error('enableMic() | cannot produce audio');
                  return _context3.abrupt("return");
  
                case 6:
                  _context3.prev = 6;
                  logger.debug('enableMic() | calling getUserMedia()');
                  constraints = {
                    audio: {
                      // echoCancellation: isUsb ? false : null,
                      echoCancellation: false,
                      noiseSuppression: true,
                      autoGainControl: false // deviceId : deviceId
  
                    }
                  };
                  _context3.next = 11;
                  return navigator.mediaDevices.getUserMedia(constraints);
  
                case 11:
                  stream = _context3.sent;
                  track = stream.getAudioTracks()[0];
                  _context3.next = 15;
                  return this._sendTransport.produce({
                    track: track,
                    codecOptions: {
                      opusStereo: 1,
                      opusDtx: 1
                    } // NOTE: for testing codec selection.
                    // codec : this._mediasoupDevice.rtpCapabilities.codecs
                    // 	.find((codec) => codec.mimeType.toLowerCase() === 'audio/pcma')
  
                  });
  
                case 15:
                  this._micProducer = _context3.sent;
  
                  this._micProducer.pause();
  
                  this._micProducer.on('transportclose', function () {
                    _this2._micProducer = null;
                  });
  
                  this._micProducer.on('trackended', function () {
                    _this2.disableMic()["catch"](function () {});
                  });
  
                  _context3.next = 25;
                  break;
  
                case 21:
                  _context3.prev = 21;
                  _context3.t0 = _context3["catch"](6);
                  logger.error('enableMic() | failed:%o', _context3.t0);
                  if (track) track.stop();
  
                case 25:
                case "end":
                  return _context3.stop();
              }
            }
          }, _callee3, this, [[6, 21]]);
        }));
  
        function enableMic() {
          return _enableMic.apply(this, arguments);
        }
  
        return enableMic;
      }()
    }, {
      key: "disableMic",
      value: function () {
        var _disableMic = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee4() {
          return _regenerator["default"].wrap(function _callee4$(_context4) {
            while (1) {
              switch (_context4.prev = _context4.next) {
                case 0:
                  logger.debug('disableMic()');
  
                  if (this._micProducer) {
                    _context4.next = 3;
                    break;
                  }
  
                  return _context4.abrupt("return");
  
                case 3:
                  this._micProducer.close();
  
                  _context4.prev = 4;
                  _context4.next = 7;
                  return this._protoo.request('closeProducer', {
                    producerId: this._micProducer.id
                  });
  
                case 7:
                  _context4.next = 12;
                  break;
  
                case 9:
                  _context4.prev = 9;
                  _context4.t0 = _context4["catch"](4);
                  logger.error(_context4.t0);
  
                case 12:
                  this._micProducer = null;
  
                case 13:
                case "end":
                  return _context4.stop();
              }
            }
          }, _callee4, this, [[4, 9]]);
        }));
  
        function disableMic() {
          return _disableMic.apply(this, arguments);
        }
  
        return disableMic;
      }()
    }, {
      key: "muteMic",
      value: function () {
        var _muteMic = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee5() {
          return _regenerator["default"].wrap(function _callee5$(_context5) {
            while (1) {
              switch (_context5.prev = _context5.next) {
                case 0:
                  logger.debug('muteMic()');
  
                  this._micProducer.pause();
  
                  _context5.prev = 2;
                  _context5.next = 5;
                  return this._protoo.request('pauseProducer', {
                    producerId: this._micProducer.id
                  });
  
                case 5:
                  _context5.next = 10;
                  break;
  
                case 7:
                  _context5.prev = 7;
                  _context5.t0 = _context5["catch"](2);
                  logger.error('muteMic() | failed: %o', _context5.t0);
  
                case 10:
                case "end":
                  return _context5.stop();
              }
            }
          }, _callee5, this, [[2, 7]]);
        }));
  
        function muteMic() {
          return _muteMic.apply(this, arguments);
        }
  
        return muteMic;
      }()
    }, {
      key: "unmuteMic",
      value: function () {
        var _unmuteMic = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee6() {
          return _regenerator["default"].wrap(function _callee6$(_context6) {
            while (1) {
              switch (_context6.prev = _context6.next) {
                case 0:
                  logger.debug('unmuteMic()');
  
                  this._micProducer.resume();
  
                  _context6.prev = 2;
                  _context6.next = 5;
                  return this._protoo.request('resumeProducer', {
                    producerId: this._micProducer.id
                  });
  
                case 5:
                  _context6.next = 10;
                  break;
  
                case 7:
                  _context6.prev = 7;
                  _context6.t0 = _context6["catch"](2);
                  logger.error('unmuteMic() | failed: %o', _context6.t0);
  
                case 10:
                case "end":
                  return _context6.stop();
              }
            }
          }, _callee6, this, [[2, 7]]);
        }));
  
        function unmuteMic() {
          return _unmuteMic.apply(this, arguments);
        }
  
        return unmuteMic;
      }()
    }, {
      key: "requestMediaPeer",
      value: function () {
        var _requestMediaPeer = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee7(peerId) {
          var _this3 = this;
  
          return _regenerator["default"].wrap(function _callee7$(_context7) {
            while (1) {
              switch (_context7.prev = _context7.next) {
                case 0:
                  logger.debug("request peer: ".concat(peerId));
  
                  this._protoo.request('requestPeer', {
                    peerId: peerId
                  }).then(function () {
                    _events["default"].triggerClientRequestMediaPeerResponse(_this3.roomId, peerId, true);
                  })["catch"](function (err) {
                    // console.log(err);
                    logger.error('requestCloseMediaPeer - error', peerId, err);
  
                    _events["default"].triggerClientRequestMediaPeerResponse(_this3.roomId, peerId, false);
                  });
  
                case 2:
                case "end":
                  return _context7.stop();
              }
            }
          }, _callee7, this);
        }));
  
        function requestMediaPeer(_x4) {
          return _requestMediaPeer.apply(this, arguments);
        }
  
        return requestMediaPeer;
      }()
    }, {
      key: "requestCloseMediaPeer",
      value: function () {
        var _requestCloseMediaPeer = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee8(peerId) {
          var consumerId, consumer;
          return _regenerator["default"].wrap(function _callee8$(_context8) {
            while (1) {
              switch (_context8.prev = _context8.next) {
                case 0:
                  // this._protoo.request(
                  // 	'requestClosePeer', { peerId });
                  consumerId = this._peers.get(peerId);
  
                  if (consumerId) {
                    _context8.next = 3;
                    break;
                  }
  
                  return _context8.abrupt("return");
  
                case 3:
                  consumer = this._consumers.get(consumerId);
  
                  this._closeConsumer(consumer, peerId);
  
                case 5:
                case "end":
                  return _context8.stop();
              }
            }
          }, _callee8, this);
        }));
  
        function requestCloseMediaPeer(_x5) {
          return _requestCloseMediaPeer.apply(this, arguments);
        }
  
        return requestCloseMediaPeer;
      }()
    }, {
      key: "muteAudio",
      value: function () {
        var _muteAudio = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee9() {
          return _regenerator["default"].wrap(function _callee9$(_context9) {
            while (1) {
              switch (_context9.prev = _context9.next) {
                case 0:
                  logger.debug('muteAudio()');
  
                case 1:
                case "end":
                  return _context9.stop();
              }
            }
          }, _callee9);
        }));
  
        function muteAudio() {
          return _muteAudio.apply(this, arguments);
        }
  
        return muteAudio;
      }()
    }, {
      key: "unmuteAudio",
      value: function () {
        var _unmuteAudio = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee10() {
          return _regenerator["default"].wrap(function _callee10$(_context10) {
            while (1) {
              switch (_context10.prev = _context10.next) {
                case 0:
                  logger.debug('unmuteAudio()');
  
                case 1:
                case "end":
                  return _context10.stop();
              }
            }
          }, _callee10);
        }));
  
        function unmuteAudio() {
          return _unmuteAudio.apply(this, arguments);
        }
  
        return unmuteAudio;
      }()
    }, {
      key: "restartIce",
      value: function () {
        var _restartIce = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee11() {
          var iceParameters, _iceParameters;
  
          return _regenerator["default"].wrap(function _callee11$(_context11) {
            while (1) {
              switch (_context11.prev = _context11.next) {
                case 0:
                  logger.debug('restartIce()');
                  _context11.prev = 1;
  
                  if (!this._sendTransport) {
                    _context11.next = 8;
                    break;
                  }
  
                  _context11.next = 5;
                  return this._protoo.request('restartIce', {
                    transportId: this._sendTransport.id
                  });
  
                case 5:
                  iceParameters = _context11.sent;
                  _context11.next = 8;
                  return this._sendTransport.restartIce({
                    iceParameters: iceParameters
                  });
  
                case 8:
                  if (!this._recvTransport) {
                    _context11.next = 14;
                    break;
                  }
  
                  _context11.next = 11;
                  return this._protoo.request('restartIce', {
                    transportId: this._recvTransport.id
                  });
  
                case 11:
                  _iceParameters = _context11.sent;
                  _context11.next = 14;
                  return this._recvTransport.restartIce({
                    iceParameters: _iceParameters
                  });
  
                case 14:
                  _context11.next = 19;
                  break;
  
                case 16:
                  _context11.prev = 16;
                  _context11.t0 = _context11["catch"](1);
                  logger.error('restartIce() | failed:%o', _context11.t0);
  
                case 19:
                case "end":
                  return _context11.stop();
              }
            }
          }, _callee11, this, [[1, 16]]);
        }));
  
        function restartIce() {
          return _restartIce.apply(this, arguments);
        }
  
        return restartIce;
      }()
    }, {
      key: "setConsumerPreferredLayers",
      value: function () {
        var _setConsumerPreferredLayers = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee12(consumerId, spatialLayer, temporalLayer) {
          return _regenerator["default"].wrap(function _callee12$(_context12) {
            while (1) {
              switch (_context12.prev = _context12.next) {
                case 0:
                  logger.debug('setConsumerPreferredLayers() [consumerId:%s, spatialLayer:%s, temporalLayer:%s]', consumerId, spatialLayer, temporalLayer);
                  _context12.prev = 1;
                  _context12.next = 4;
                  return this._protoo.request('setConsumerPreferredLayers', {
                    consumerId: consumerId,
                    spatialLayer: spatialLayer,
                    temporalLayer: temporalLayer
                  });
  
                case 4:
                  _context12.next = 9;
                  break;
  
                case 6:
                  _context12.prev = 6;
                  _context12.t0 = _context12["catch"](1);
                  logger.error('setConsumerPreferredLayers() | failed:%o', _context12.t0);
  
                case 9:
                case "end":
                  return _context12.stop();
              }
            }
          }, _callee12, this, [[1, 6]]);
        }));
  
        function setConsumerPreferredLayers(_x6, _x7, _x8) {
          return _setConsumerPreferredLayers.apply(this, arguments);
        }
  
        return setConsumerPreferredLayers;
      }()
    }, {
      key: "setConsumerPriority",
      value: function () {
        var _setConsumerPriority = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee13(consumerId, priority) {
          return _regenerator["default"].wrap(function _callee13$(_context13) {
            while (1) {
              switch (_context13.prev = _context13.next) {
                case 0:
                  logger.debug('setConsumerPriority() [consumerId:%s, priority:%d]', consumerId, priority);
                  _context13.prev = 1;
                  _context13.next = 4;
                  return this._protoo.request('setConsumerPriority', {
                    consumerId: consumerId,
                    priority: priority
                  });
  
                case 4:
                  _context13.next = 9;
                  break;
  
                case 6:
                  _context13.prev = 6;
                  _context13.t0 = _context13["catch"](1);
                  logger.error('setConsumerPriority() | failed:%o', _context13.t0);
  
                case 9:
                case "end":
                  return _context13.stop();
              }
            }
          }, _callee13, this, [[1, 6]]);
        }));
  
        function setConsumerPriority(_x9, _x10) {
          return _setConsumerPriority.apply(this, arguments);
        }
  
        return setConsumerPriority;
      }()
    }, {
      key: "getSendTransportRemoteStats",
      value: function () {
        var _getSendTransportRemoteStats = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee14() {
          return _regenerator["default"].wrap(function _callee14$(_context14) {
            while (1) {
              switch (_context14.prev = _context14.next) {
                case 0:
                  logger.debug('getSendTransportRemoteStats()');
  
                  if (this._sendTransport) {
                    _context14.next = 3;
                    break;
                  }
  
                  return _context14.abrupt("return");
  
                case 3:
                  return _context14.abrupt("return", this._protoo.request('getTransportStats', {
                    transportId: this._sendTransport.id
                  }));
  
                case 4:
                case "end":
                  return _context14.stop();
              }
            }
          }, _callee14, this);
        }));
  
        function getSendTransportRemoteStats() {
          return _getSendTransportRemoteStats.apply(this, arguments);
        }
  
        return getSendTransportRemoteStats;
      }()
    }, {
      key: "getRecvTransportRemoteStats",
      value: function () {
        var _getRecvTransportRemoteStats = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee15() {
          return _regenerator["default"].wrap(function _callee15$(_context15) {
            while (1) {
              switch (_context15.prev = _context15.next) {
                case 0:
                  logger.debug('getRecvTransportRemoteStats()');
  
                  if (this._recvTransport) {
                    _context15.next = 3;
                    break;
                  }
  
                  return _context15.abrupt("return");
  
                case 3:
                  return _context15.abrupt("return", this._protoo.request('getTransportStats', {
                    transportId: this._recvTransport.id
                  }));
  
                case 4:
                case "end":
                  return _context15.stop();
              }
            }
          }, _callee15, this);
        }));
  
        function getRecvTransportRemoteStats() {
          return _getRecvTransportRemoteStats.apply(this, arguments);
        }
  
        return getRecvTransportRemoteStats;
      }()
    }, {
      key: "getAudioRemoteStats",
      value: function () {
        var _getAudioRemoteStats = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee16() {
          return _regenerator["default"].wrap(function _callee16$(_context16) {
            while (1) {
              switch (_context16.prev = _context16.next) {
                case 0:
                  logger.debug('getAudioRemoteStats()');
  
                  if (this._micProducer) {
                    _context16.next = 3;
                    break;
                  }
  
                  return _context16.abrupt("return");
  
                case 3:
                  return _context16.abrupt("return", this._protoo.request('getProducerStats', {
                    producerId: this._micProducer.id
                  }));
  
                case 4:
                case "end":
                  return _context16.stop();
              }
            }
          }, _callee16, this);
        }));
  
        function getAudioRemoteStats() {
          return _getAudioRemoteStats.apply(this, arguments);
        }
  
        return getAudioRemoteStats;
      }()
    }, {
      key: "getConsumerRemoteStats",
      value: function () {
        var _getConsumerRemoteStats = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee17(consumerId) {
          var consumer;
          return _regenerator["default"].wrap(function _callee17$(_context17) {
            while (1) {
              switch (_context17.prev = _context17.next) {
                case 0:
                  logger.debug('getConsumerRemoteStats()');
                  consumer = this._consumers.get(consumerId);
  
                  if (consumer) {
                    _context17.next = 4;
                    break;
                  }
  
                  return _context17.abrupt("return");
  
                case 4:
                  return _context17.abrupt("return", this._protoo.request('getConsumerStats', {
                    consumerId: consumerId
                  }));
  
                case 5:
                case "end":
                  return _context17.stop();
              }
            }
          }, _callee17, this);
        }));
  
        function getConsumerRemoteStats(_x11) {
          return _getConsumerRemoteStats.apply(this, arguments);
        }
  
        return getConsumerRemoteStats;
      }()
    }, {
      key: "getBotDataProducerRemoteStats",
      value: function () {
        var _getBotDataProducerRemoteStats = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee18() {
          var dataProducer;
          return _regenerator["default"].wrap(function _callee18$(_context18) {
            while (1) {
              switch (_context18.prev = _context18.next) {
                case 0:
                  logger.debug('getBotDataProducerRemoteStats()');
                  dataProducer = this._botDataProducer;
  
                  if (dataProducer) {
                    _context18.next = 4;
                    break;
                  }
  
                  return _context18.abrupt("return");
  
                case 4:
                  return _context18.abrupt("return", this._protoo.request('getDataProducerStats', {
                    dataProducerId: dataProducer.id
                  }));
  
                case 5:
                case "end":
                  return _context18.stop();
              }
            }
          }, _callee18, this);
        }));
  
        function getBotDataProducerRemoteStats() {
          return _getBotDataProducerRemoteStats.apply(this, arguments);
        }
  
        return getBotDataProducerRemoteStats;
      }()
    }, {
      key: "getDataConsumerRemoteStats",
      value: function () {
        var _getDataConsumerRemoteStats = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee19(dataConsumerId) {
          var dataConsumer;
          return _regenerator["default"].wrap(function _callee19$(_context19) {
            while (1) {
              switch (_context19.prev = _context19.next) {
                case 0:
                  logger.debug('getDataConsumerRemoteStats()');
                  dataConsumer = this._dataConsumers.get(dataConsumerId);
  
                  if (dataConsumer) {
                    _context19.next = 4;
                    break;
                  }
  
                  return _context19.abrupt("return");
  
                case 4:
                  return _context19.abrupt("return", this._protoo.request('getDataConsumerStats', {
                    dataConsumerId: dataConsumerId
                  }));
  
                case 5:
                case "end":
                  return _context19.stop();
              }
            }
          }, _callee19, this);
        }));
  
        function getDataConsumerRemoteStats(_x12) {
          return _getDataConsumerRemoteStats.apply(this, arguments);
        }
  
        return getDataConsumerRemoteStats;
      }()
    }, {
      key: "getSendTransportLocalStats",
      value: function () {
        var _getSendTransportLocalStats = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee20() {
          return _regenerator["default"].wrap(function _callee20$(_context20) {
            while (1) {
              switch (_context20.prev = _context20.next) {
                case 0:
                  logger.debug('getSendTransportLocalStats()');
  
                  if (this._sendTransport) {
                    _context20.next = 3;
                    break;
                  }
  
                  return _context20.abrupt("return");
  
                case 3:
                  return _context20.abrupt("return", this._sendTransport.getStats());
  
                case 4:
                case "end":
                  return _context20.stop();
              }
            }
          }, _callee20, this);
        }));
  
        function getSendTransportLocalStats() {
          return _getSendTransportLocalStats.apply(this, arguments);
        }
  
        return getSendTransportLocalStats;
      }()
    }, {
      key: "getRecvTransportLocalStats",
      value: function () {
        var _getRecvTransportLocalStats = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee21() {
          return _regenerator["default"].wrap(function _callee21$(_context21) {
            while (1) {
              switch (_context21.prev = _context21.next) {
                case 0:
                  logger.debug('getRecvTransportLocalStats()');
  
                  if (this._recvTransport) {
                    _context21.next = 3;
                    break;
                  }
  
                  return _context21.abrupt("return");
  
                case 3:
                  return _context21.abrupt("return", this._recvTransport.getStats());
  
                case 4:
                case "end":
                  return _context21.stop();
              }
            }
          }, _callee21, this);
        }));
  
        function getRecvTransportLocalStats() {
          return _getRecvTransportLocalStats.apply(this, arguments);
        }
  
        return getRecvTransportLocalStats;
      }()
    }, {
      key: "getAudioLocalStats",
      value: function () {
        var _getAudioLocalStats = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee22() {
          return _regenerator["default"].wrap(function _callee22$(_context22) {
            while (1) {
              switch (_context22.prev = _context22.next) {
                case 0:
                  logger.debug('getAudioLocalStats()');
  
                  if (this._micProducer) {
                    _context22.next = 3;
                    break;
                  }
  
                  return _context22.abrupt("return");
  
                case 3:
                  return _context22.abrupt("return", this._micProducer.getStats());
  
                case 4:
                case "end":
                  return _context22.stop();
              }
            }
          }, _callee22, this);
        }));
  
        function getAudioLocalStats() {
          return _getAudioLocalStats.apply(this, arguments);
        }
  
        return getAudioLocalStats;
      }()
    }, {
      key: "getConsumerLocalStats",
      value: function () {
        var _getConsumerLocalStats = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee23(consumerId) {
          var consumer;
          return _regenerator["default"].wrap(function _callee23$(_context23) {
            while (1) {
              switch (_context23.prev = _context23.next) {
                case 0:
                  consumer = this._consumers.get(consumerId);
  
                  if (consumer) {
                    _context23.next = 3;
                    break;
                  }
  
                  return _context23.abrupt("return");
  
                case 3:
                  return _context23.abrupt("return", consumer.getStats());
  
                case 4:
                case "end":
                  return _context23.stop();
              }
            }
          }, _callee23, this);
        }));
  
        function getConsumerLocalStats(_x13) {
          return _getConsumerLocalStats.apply(this, arguments);
        }
  
        return getConsumerLocalStats;
      }()
    }, {
      key: "applyNetworkThrottle",
      value: function () {
        var _applyNetworkThrottle = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee24(_ref3) {
          var uplink, downlink, rtt, secret;
          return _regenerator["default"].wrap(function _callee24$(_context24) {
            while (1) {
              switch (_context24.prev = _context24.next) {
                case 0:
                  uplink = _ref3.uplink, downlink = _ref3.downlink, rtt = _ref3.rtt, secret = _ref3.secret;
                  logger.debug('applyNetworkThrottle() [uplink:%s, downlink:%s, rtt:%s]', uplink, downlink, rtt);
                  _context24.prev = 2;
                  _context24.next = 5;
                  return this._protoo.request('applyNetworkThrottle', {
                    uplink: uplink,
                    downlink: downlink,
                    rtt: rtt,
                    secret: secret
                  });
  
                case 5:
                  _context24.next = 10;
                  break;
  
                case 7:
                  _context24.prev = 7;
                  _context24.t0 = _context24["catch"](2);
                  logger.error('applyNetworkThrottle() | failed:%o', _context24.t0);
  
                case 10:
                case "end":
                  return _context24.stop();
              }
            }
          }, _callee24, this, [[2, 7]]);
        }));
  
        function applyNetworkThrottle(_x14) {
          return _applyNetworkThrottle.apply(this, arguments);
        }
  
        return applyNetworkThrottle;
      }()
    }, {
      key: "resetNetworkThrottle",
      value: function () {
        var _resetNetworkThrottle = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee25(_ref4) {
          var _ref4$silent, silent, secret;
  
          return _regenerator["default"].wrap(function _callee25$(_context25) {
            while (1) {
              switch (_context25.prev = _context25.next) {
                case 0:
                  _ref4$silent = _ref4.silent, silent = _ref4$silent === void 0 ? false : _ref4$silent, secret = _ref4.secret;
                  logger.debug('resetNetworkThrottle()');
                  _context25.prev = 2;
                  _context25.next = 5;
                  return this._protoo.request('resetNetworkThrottle', {
                    secret: secret
                  });
  
                case 5:
                  _context25.next = 10;
                  break;
  
                case 7:
                  _context25.prev = 7;
                  _context25.t0 = _context25["catch"](2);
  
                  if (!silent) {
                    logger.error('resetNetworkThrottle() | failed:%o', _context25.t0);
                  }
  
                case 10:
                case "end":
                  return _context25.stop();
              }
            }
          }, _callee25, this, [[2, 7]]);
        }));
  
        function resetNetworkThrottle(_x15) {
          return _resetNetworkThrottle.apply(this, arguments);
        }
  
        return resetNetworkThrottle;
      }()
    }, {
      key: "_joinRoom",
      value: function () {
        var _joinRoom2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee28() {
          var _this4 = this;
  
          var routerRtpCapabilities, constraints, stream, audioTrack, transportInfo, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, _transportInfo, _id3, _iceParameters2, _iceCandidates, _dtlsParameters, _sctpParameters;
  
          return _regenerator["default"].wrap(function _callee28$(_context28) {
            while (1) {
              switch (_context28.prev = _context28.next) {
                case 0:
                  logger.debug('_joinRoom()');
                  _context28.prev = 1;
                  this._mediasoupDevice = new mediasoupClient.Device({
                    handlerName: this._handlerName
                  });
                  _context28.next = 5;
                  return this._protoo.request('getRouterRtpCapabilities');
  
                case 5:
                  routerRtpCapabilities = _context28.sent;
                  _context28.next = 8;
                  return this._mediasoupDevice.load({
                    routerRtpCapabilities: routerRtpCapabilities
                  });
  
                case 8:
                  // NOTE: Stuff to play remote audios due to browsers' new autoplay policy.
                  //
                  // Just get access to the mic and DO NOT close the mic track for a while.
                  // Super hack!
                  constraints = {
                    audio: {
                      // echoCancellation: isUsb ? false : null,
                      echoCancellation: false,
                      noiseSuppression: true,
                      autoGainControl: false // deviceId : deviceId
  
                    }
                  };
                  _context28.next = 11;
                  return navigator.mediaDevices.getUserMedia(constraints);
  
                case 11:
                  stream = _context28.sent;
                  audioTrack = stream.getAudioTracks()[0];
                  audioTrack.enabled = false;
                  setTimeout(function () {
                    return audioTrack.stop();
                  }, 120000); // Create mediasoup Transport for sending (unless we don't want to produce).
  
                  if (!this._produce) {
                    _context28.next = 24;
                    break;
                  }
  
                  _context28.next = 18;
                  return this._protoo.request('createWebRtcTransport', {
                    forceTcp: this._forceTcp,
                    producing: true,
                    consuming: false,
                    sctpCapabilities: this._useDataChannel ? this._mediasoupDevice.sctpCapabilities : undefined
                  });
  
                case 18:
                  transportInfo = _context28.sent;
                  id = transportInfo.id, iceParameters = transportInfo.iceParameters, iceCandidates = transportInfo.iceCandidates, dtlsParameters = transportInfo.dtlsParameters, sctpParameters = transportInfo.sctpParameters;
                  this._sendTransport = this._mediasoupDevice.createSendTransport({
                    id: id,
                    iceParameters: iceParameters,
                    iceCandidates: iceCandidates,
                    dtlsParameters: dtlsParameters,
                    sctpParameters: sctpParameters,
                    iceServers: iceServers,
                    proprietaryConstraints: PC_PROPRIETARY_CONSTRAINTS
                  });
  
                  this._sendTransport.on('connect', function (_ref5, callback, errback) // eslint-disable-line no-shadow
                  {
                    var dtlsParameters = _ref5.dtlsParameters;
  
                    _this4._protoo.request('connectWebRtcTransport', {
                      transportId: _this4._sendTransport.id,
                      dtlsParameters: dtlsParameters
                    }).then(callback)["catch"](errback);
                  });
  
                  this._sendTransport.on('produce', /*#__PURE__*/function () {
                    var _ref7 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee26(_ref6, callback, errback) {
                      var kind, rtpParameters, appData, _yield$_this4$_protoo, _id;
  
                      return _regenerator["default"].wrap(function _callee26$(_context26) {
                        while (1) {
                          switch (_context26.prev = _context26.next) {
                            case 0:
                              kind = _ref6.kind, rtpParameters = _ref6.rtpParameters, appData = _ref6.appData;
                              _context26.prev = 1;
                              _context26.next = 4;
                              return _this4._protoo.request('produce', {
                                transportId: _this4._sendTransport.id,
                                kind: kind,
                                rtpParameters: rtpParameters,
                                appData: appData
                              });
  
                            case 4:
                              _yield$_this4$_protoo = _context26.sent;
                              _id = _yield$_this4$_protoo.id;
                              callback({
                                id: _id
                              });
                              _context26.next = 12;
                              break;
  
                            case 9:
                              _context26.prev = 9;
                              _context26.t0 = _context26["catch"](1);
                              errback(_context26.t0);
  
                            case 12:
                            case "end":
                              return _context26.stop();
                          }
                        }
                      }, _callee26, null, [[1, 9]]);
                    }));
  
                    return function (_x16, _x17, _x18) {
                      return _ref7.apply(this, arguments);
                    };
                  }());
  
                  this._sendTransport.on('producedata', /*#__PURE__*/function () {
                    var _ref9 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee27(_ref8, callback, errback) {
                      var sctpStreamParameters, label, protocol, appData, _yield$_this4$_protoo2, _id2;
  
                      return _regenerator["default"].wrap(function _callee27$(_context27) {
                        while (1) {
                          switch (_context27.prev = _context27.next) {
                            case 0:
                              sctpStreamParameters = _ref8.sctpStreamParameters, label = _ref8.label, protocol = _ref8.protocol, appData = _ref8.appData;
                              logger.debug('"producedata" event: [sctpStreamParameters:%o, appData:%o]', sctpStreamParameters, appData);
                              _context27.prev = 2;
                              _context27.next = 5;
                              return _this4._protoo.request('produceData', {
                                transportId: _this4._sendTransport.id,
                                sctpStreamParameters: sctpStreamParameters,
                                label: label,
                                protocol: protocol,
                                appData: appData
                              });
  
                            case 5:
                              _yield$_this4$_protoo2 = _context27.sent;
                              _id2 = _yield$_this4$_protoo2.id;
                              callback({
                                id: _id2
                              });
                              _context27.next = 13;
                              break;
  
                            case 10:
                              _context27.prev = 10;
                              _context27.t0 = _context27["catch"](2);
                              errback(_context27.t0);
  
                            case 13:
                            case "end":
                              return _context27.stop();
                          }
                        }
                      }, _callee27, null, [[2, 10]]);
                    }));
  
                    return function (_x19, _x20, _x21) {
                      return _ref9.apply(this, arguments);
                    };
                  }());
  
                case 24:
                  if (!this._consume) {
                    _context28.next = 31;
                    break;
                  }
  
                  _context28.next = 27;
                  return this._protoo.request('createWebRtcTransport', {
                    forceTcp: this._forceTcp,
                    producing: false,
                    consuming: true,
                    sctpCapabilities: this._useDataChannel ? this._mediasoupDevice.sctpCapabilities : undefined
                  });
  
                case 27:
                  _transportInfo = _context28.sent;
                  _id3 = _transportInfo.id, _iceParameters2 = _transportInfo.iceParameters, _iceCandidates = _transportInfo.iceCandidates, _dtlsParameters = _transportInfo.dtlsParameters, _sctpParameters = _transportInfo.sctpParameters;
                  this._recvTransport = this._mediasoupDevice.createRecvTransport({
                    id: _id3,
                    iceParameters: _iceParameters2,
                    iceCandidates: _iceCandidates,
                    dtlsParameters: _dtlsParameters,
                    sctpParameters: _sctpParameters,
                    iceServers: iceServers
                  });
  
                  this._recvTransport.on('connect', function (_ref10, callback, errback) // eslint-disable-line no-shadow
                  {
                    var dtlsParameters = _ref10.dtlsParameters;
  
                    _this4._protoo.request('connectWebRtcTransport', {
                      transportId: _this4._recvTransport.id,
                      dtlsParameters: dtlsParameters
                    }).then(callback)["catch"](errback);
                  });
  
                case 31:
                  _context28.next = 33;
                  return this._protoo.request('join', {
                    displayName: this.peerId,
                    device: this._device,
                    rtpCapabilities: this._consume ? this._mediasoupDevice.rtpCapabilities : undefined,
                    sctpCapabilities: this._useDataChannel && this._consume ? this._mediasoupDevice.sctpCapabilities : undefined
                  });
  
                case 33:
                  // Enable mic.
                  if (this._produce) {
                    // Set our media capabilities.
                    this.enableMic(); // this._sendTransport.on('connectionstatechange', (connectionState) =>
                    // {
                    // 	// Events.triggerClientChangeStateConnection(connectionState)
                    // });
                  }
  
                  _events["default"].triggerClientChangeStateConnection(this.roomId, 'connected');
  
                  _context28.next = 41;
                  break;
  
                case 37:
                  _context28.prev = 37;
                  _context28.t0 = _context28["catch"](1);
                  logger.error('_joinRoom() failed:%o', _context28.t0);
                  this.close();
  
                case 41:
                case "end":
                  return _context28.stop();
              }
            }
          }, _callee28, this, [[1, 37]]);
        }));
  
        function _joinRoom() {
          return _joinRoom2.apply(this, arguments);
        }
  
        return _joinRoom;
      }()
    }, {
      key: "_pauseConsumer",
      value: function () {
        var _pauseConsumer2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee29(consumer) {
          return _regenerator["default"].wrap(function _callee29$(_context29) {
            while (1) {
              switch (_context29.prev = _context29.next) {
                case 0:
                  if (!consumer.paused) {
                    _context29.next = 2;
                    break;
                  }
  
                  return _context29.abrupt("return");
  
                case 2:
                  _context29.prev = 2;
                  _context29.next = 5;
                  return this._protoo.request('pauseConsumer', {
                    consumerId: consumer.id
                  });
  
                case 5:
                  consumer.pause();
                  _context29.next = 11;
                  break;
  
                case 8:
                  _context29.prev = 8;
                  _context29.t0 = _context29["catch"](2);
                  logger.error('_pauseConsumer() | failed:%o', _context29.t0);
  
                case 11:
                case "end":
                  return _context29.stop();
              }
            }
          }, _callee29, this, [[2, 8]]);
        }));
  
        function _pauseConsumer(_x22) {
          return _pauseConsumer2.apply(this, arguments);
        }
  
        return _pauseConsumer;
      }()
    }, {
      key: "_resumeConsumer",
      value: function () {
        var _resumeConsumer2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee30(consumer) {
          return _regenerator["default"].wrap(function _callee30$(_context30) {
            while (1) {
              switch (_context30.prev = _context30.next) {
                case 0:
                  if (consumer.paused) {
                    _context30.next = 2;
                    break;
                  }
  
                  return _context30.abrupt("return");
  
                case 2:
                  _context30.prev = 2;
                  _context30.next = 5;
                  return this._protoo.request('resumeConsumer', {
                    consumerId: consumer.id
                  });
  
                case 5:
                  consumer.resume();
                  _context30.next = 11;
                  break;
  
                case 8:
                  _context30.prev = 8;
                  _context30.t0 = _context30["catch"](2);
                  logger.error('_resumeConsumer() | failed:%o', _context30.t0);
  
                case 11:
                case "end":
                  return _context30.stop();
              }
            }
          }, _callee30, this, [[2, 8]]);
        }));
  
        function _resumeConsumer(_x23) {
          return _resumeConsumer2.apply(this, arguments);
        }
  
        return _resumeConsumer;
      }()
    }, {
      key: "_closeConsumer",
      value: function () {
        var _closeConsumer2 = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee31(consumer, peerId) {
          var _this5 = this;
  
          return _regenerator["default"].wrap(function _callee31$(_context31) {
            while (1) {
              switch (_context31.prev = _context31.next) {
                case 0:
                  if (!(!consumer || consumer.closed)) {
                    _context31.next = 2;
                    break;
                  }
  
                  return _context31.abrupt("return");
  
                case 2:
                  try {
                    this._protoo.request('closeConsumer', {
                      consumerId: consumer.id
                    }).then(function () {
                      _events["default"].triggerClientRequestCloseMediaPeerResponse(_this5.roomId, peerId, true);
  
                      consumer.close();
  
                      _this5.removeConsumerAudio(consumer.id);
  
                      _this5._peers["delete"](consumer.peerId);
  
                      _this5._consumers["delete"](consumer.id);
                    })["catch"](function (err) {
                      // console.log(err);
                      logger.error('requestCloseMediaPeer - error', peerId, err);
  
                      _events["default"].triggerClientRequestCloseMediaPeerResponse(_this5.roomId, peerId, false);
                    });
                  } catch (error) {
                    logger.error('_closeConsumer() | failed:%o', error);
                  }
  
                case 3:
                case "end":
                  return _context31.stop();
              }
            }
          }, _callee31, this);
        }));
  
        function _closeConsumer(_x24, _x25) {
          return _closeConsumer2.apply(this, arguments);
        }
  
        return _closeConsumer;
      }()
    }, {
      key: "initConsumerAudio",
      value: function () {
        var _initConsumerAudio = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee32(consumerId) {
          var consumer, stream, audio, source, panner;
          return _regenerator["default"].wrap(function _callee32$(_context32) {
            while (1) {
              switch (_context32.prev = _context32.next) {
                case 0:
                  consumer = this._consumers.get(consumerId);
                  stream = new MediaStream();
                  audio = new Audio();
                  audio.autoplay = false;
                  audio.volume = 0;
                  stream.addTrack(consumer.track);
                  audio.srcObject = stream;
                  source = this.audioContext.createMediaStreamSource(stream); // GainNode (proximity)
  
                  consumer.gainNode = this.audioContext.createGain();
                  source.connect(consumer.gainNode); // consumer.gainNode.connect(this.mainVolume);
  
                  consumer.gainNode.gain.setValueAtTime(0, this.audioContext.currentTime); // PannerNode (stereo)
  
                  panner = this.audioContext.createPanner();
                  consumer.panner = panner;
                  consumer.gainNode.connect(consumer.panner);
                  consumer.panner.connect(this.mainVolume);
                  consumer.panner.setOrientation(0, 0, 1);
                  consumer.streamSource = source;
                  consumer.audioSource = audio;
                  consumer.currentActiveNode = consumer.panner;
                  consumer.defaultActiveNode = consumer.panner; // consumer.effects = {};
  
                case 20:
                case "end":
                  return _context32.stop();
              }
            }
          }, _callee32, this);
        }));
  
        function initConsumerAudio(_x26) {
          return _initConsumerAudio.apply(this, arguments);
        }
  
        return initConsumerAudio;
      }()
    }, {
      key: "removeConsumerAudio",
      value: function () {
        var _removeConsumerAudio = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee33(consumerId) {
          var consumer;
          return _regenerator["default"].wrap(function _callee33$(_context33) {
            while (1) {
              switch (_context33.prev = _context33.next) {
                case 0:
                  consumer = this._consumers.get(consumerId);
  
                  if (consumer) {
                    _context33.next = 3;
                    break;
                  }
  
                  return _context33.abrupt("return");
  
                case 3:
                  if (consumer.streamSource) {
                    if (consumer.streamSource.numberOfOutputs > 0) {
                      consumer.streamSource.disconnect(consumer.gainNode);
                    }
  
                    if (consumer.gainNode.numberOfOutputs > 0) {
                      consumer.gainNode.disconnect(consumer.panner);
                    }
  
                    if (consumer.panner.numberOfOutputs > 0) {
                      consumer.panner.disconnect(this.mainVolume);
                    }
                  }
  
                  if (consumer && consumer.audioElement) {
                    consumer.audioElement.remove();
                  }
  
                case 5:
                case "end":
                  return _context33.stop();
              }
            }
          }, _callee33, this);
        }));
  
        function removeConsumerAudio(_x27) {
          return _removeConsumerAudio.apply(this, arguments);
        }
  
        return removeConsumerAudio;
      }()
    }, {
      key: "changeMainVolume",
      value: function () {
        var _changeMainVolume = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee34(volume) {
          return _regenerator["default"].wrap(function _callee34$(_context34) {
            while (1) {
              switch (_context34.prev = _context34.next) {
                case 0:
                  if (!isNaN(volume)) this.mainVolume.gain.setValueAtTime(volume, this.audioContext.currentTime);
  
                case 1:
                case "end":
                  return _context34.stop();
              }
            }
          }, _callee34, this);
        }));
  
        function changeMainVolume(_x28) {
          return _changeMainVolume.apply(this, arguments);
        }
  
        return changeMainVolume;
      }()
    }, {
      key: "changeConsumerVolume",
      value: function () {
        var _changeConsumerVolume = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee35(peerId, volume, balance) {
          var consumerId, consumer;
          return _regenerator["default"].wrap(function _callee35$(_context35) {
            while (1) {
              switch (_context35.prev = _context35.next) {
                case 0:
                  consumerId = this._peers.get(peerId);
  
                  if (consumerId) {
                    _context35.next = 3;
                    break;
                  }
  
                  return _context35.abrupt("return");
  
                case 3:
                  consumer = this._consumers.get(consumerId);
  
                  if (consumer) {
                    _context35.next = 6;
                    break;
                  }
  
                  return _context35.abrupt("return");
  
                case 6:
                  if (consumer.audioElement) {
                    consumer.audioElement.volume = volume;
                  }
  
                  if (consumer.gainNode && !isNaN(volume)) {
                    consumer.gainNode.gain.setValueAtTime(volume, this.audioContext.currentTime);
                    consumer.volume = volume;
                  }
  
                  if (consumer.panner && !isNaN(balance)) {
                    consumer.panner.setPosition(balance, 0, 1 - Math.abs(balance));
                    consumer.balance = balance;
                  }
  
                case 9:
                case "end":
                  return _context35.stop();
              }
            }
          }, _callee35, this);
        }));
  
        function changeConsumerVolume(_x29, _x30, _x31) {
          return _changeConsumerVolume.apply(this, arguments);
        }
  
        return changeConsumerVolume;
      }()
    }, {
      key: "changeConsumersVolume",
      value: function () {
        var _changeConsumersVolume = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee36(peers) {
          var _this6 = this;
  
          return _regenerator["default"].wrap(function _callee36$(_context36) {
            while (1) {
              switch (_context36.prev = _context36.next) {
                case 0:
                  peers = typeof peers === 'string' ? JSON.parse(peers) : peers;
                  peers.forEach(function (peer) {
                    if (peer) {
                      _this6.changeConsumerVolume(peer.name, peer.volume, peer.balance);
  
                      if (peer.clearEffects) {
                        _this6.clearConsumerAudioEffects(peer.name);
                      }
  
                      if (peer.effects) {
                        _this6.setConsumerAudioEffects(peer.name, peer.effects);
                      }
                    }
                  });
  
                case 2:
                case "end":
                  return _context36.stop();
              }
            }
          }, _callee36);
        }));
  
        function changeConsumersVolume(_x32) {
          return _changeConsumersVolume.apply(this, arguments);
        }
  
        return changeConsumersVolume;
      }()
    }, {
      key: "clearConsumerAudioEffects",
      value: function () {
        var _clearConsumerAudioEffects = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee37(peerId) {
          var consumerId, consumer;
          return _regenerator["default"].wrap(function _callee37$(_context37) {
            while (1) {
              switch (_context37.prev = _context37.next) {
                case 0:
                  consumerId = this._peers.get(peerId);
  
                  if (consumerId) {
                    _context37.next = 3;
                    break;
                  }
  
                  return _context37.abrupt("return");
  
                case 3:
                  consumer = this._consumers.get(consumerId);
  
                  if (consumer) {
                    _context37.next = 6;
                    break;
                  }
  
                  return _context37.abrupt("return");
  
                case 6:
                  if (consumer.effects) {
                    _context37.next = 8;
                    break;
                  }
  
                  return _context37.abrupt("return");
  
                case 8:
                  if (consumer.currentActiveNode.numberOfOutputs > 0) {
                    consumer.currentActiveNode.disconnect(this.mainVolume);
                    consumer.currentActiveNode = consumer.defaultActiveNode;
                    consumer.currentActiveNode.connect(this.mainVolume);
                    delete consumer.effects;
                  }
  
                case 9:
                case "end":
                  return _context37.stop();
              }
            }
          }, _callee37, this);
        }));
  
        function clearConsumerAudioEffects(_x33) {
          return _clearConsumerAudioEffects.apply(this, arguments);
        }
  
        return clearConsumerAudioEffects;
      }()
    }, {
      key: "makeDistortionCurve",
      value: function makeDistortionCurve(amount) {
        var k = typeof amount === 'number' ? amount : 50;
        var nSamples = 44100;
        var curve = new Float32Array(nSamples);
        var deg = Math.PI / 180;
        var i = 0;
        var x;
  
        for (; i < nSamples; ++i) {
          x = i * 2 / nSamples - 1;
          curve[i] = (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));
        }
  
        return curve;
      }
    }, {
      key: "setConsumerAudioEffects",
      value: function () {
        var _setConsumerAudioEffects = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee38(peerId, effects) {
          var consumerId, consumer, values, addedNewEffect, _i, _values, effect, filter, _filter, _filter2, previousNode, _i2, _Object$values, _effect;
  
          return _regenerator["default"].wrap(function _callee38$(_context38) {
            while (1) {
              switch (_context38.prev = _context38.next) {
                case 0:
                  consumerId = this._peers.get(peerId);
  
                  if (consumerId) {
                    _context38.next = 3;
                    break;
                  }
  
                  return _context38.abrupt("return");
  
                case 3:
                  consumer = this._consumers.get(consumerId);
  
                  if (consumer) {
                    _context38.next = 6;
                    break;
                  }
  
                  return _context38.abrupt("return");
  
                case 6:
                  values = Object.values(effects);
                  addedNewEffect = false;
                  _i = 0, _values = values;
  
                case 9:
                  if (!(_i < _values.length)) {
                    _context38.next = 35;
                    break;
                  }
  
                  effect = _values[_i];
                  if (!consumer.effects) consumer.effects = {};
  
                  if (!consumer.effects[effect.name]) {
                    _context38.next = 14;
                    break;
                  }
  
                  return _context38.abrupt("continue", 32);
  
                case 14:
                  _context38.t0 = effect.type;
                  _context38.next = _context38.t0 === 'biquad' ? 17 : _context38.t0 === 'compressor' ? 23 : _context38.t0 === 'distortion' ? 27 : 32;
                  break;
  
                case 17:
                  filter = consumer.effects[effect.name] || this.audioContext.createBiquadFilter();
                  filter.type = effect.data.type;
                  if (!isNaN(effect.data.frequency.value)) filter.frequency.value = effect.data.frequency.value;
                  consumer.effects[effect.name] = filter;
                  addedNewEffect = true;
                  return _context38.abrupt("break", 32);
  
                case 23:
                  _filter = consumer.effects[effect.name] || this.audioContext.createDynamicsCompressor(); // filter.type = effect.data.type;
                  // filter.frequency.value = effect.data.frequency.value;
  
                  consumer.effects[effect.name] = _filter;
                  addedNewEffect = true;
                  return _context38.abrupt("break", 32);
  
                case 27:
                  _filter2 = consumer.effects[effect.name] || this.audioContext.createWaveShaper();
                  _filter2.curve = this.makeDistortionCurve(); // filter.type = effect.data.type;
                  // filter.frequency.value = effect.data.frequency.value;
  
                  consumer.effects[effect.name] = _filter2;
                  addedNewEffect = true;
                  return _context38.abrupt("break", 32);
  
                case 32:
                  _i++;
                  _context38.next = 9;
                  break;
  
                case 35:
                  if (addedNewEffect) {
                    _context38.next = 37;
                    break;
                  }
  
                  return _context38.abrupt("return");
  
                case 37:
                  consumer.currentActiveNode.disconnect(this.mainVolume);
  
                  for (_i2 = 0, _Object$values = Object.values(consumer.effects); _i2 < _Object$values.length; _i2++) {
                    _effect = _Object$values[_i2];
  
                    if (!previousNode) {
                      consumer.currentActiveNode.connect(_effect);
                    } else {
                      previousNode.connect(_effect);
                    }
  
                    previousNode = _effect;
                  }
  
                  consumer.currentActiveNode = previousNode;
                  consumer.currentActiveNode.connect(this.mainVolume); // seems like shit code end
  
                case 41:
                case "end":
                  return _context38.stop();
              }
            }
          }, _callee38, this);
        }));
  
        function setConsumerAudioEffects(_x34, _x35) {
          return _setConsumerAudioEffects.apply(this, arguments);
        }
  
        return setConsumerAudioEffects;
      }()
    }]);
    return RoomClient;
  }();
  
  exports["default"] = RoomClient;
  
  },{"./Logger":"/home/ubuntu/umbrella-voice2/app/lib/Logger.js","./events":"/home/ubuntu/umbrella-voice2/app/lib/events.js","./urlFactory":"/home/ubuntu/umbrella-voice2/app/lib/urlFactory.js","./utils":"/home/ubuntu/umbrella-voice2/app/lib/utils.js","@babel/runtime/helpers/asyncToGenerator":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/classCallCheck":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/classCallCheck.js","@babel/runtime/helpers/createClass":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/createClass.js","@babel/runtime/helpers/defineProperty":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/helpers/interopRequireWildcard":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/interopRequireWildcard.js","@babel/runtime/regenerator":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/regenerator/index.js","mediasoup-client":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/index.js","protoo-client":"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/lib/index.js"}],"/home/ubuntu/umbrella-voice2/app/lib/deviceInfo.js":[function(require,module,exports){
  "use strict";
  
  var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = _default;
  
  var _bowser = _interopRequireDefault(require("bowser"));
  
  // TODO: For testing.
  window.BOWSER = _bowser["default"];
  
  function _default() {
    var ua = navigator.userAgent;
  
    var browser = _bowser["default"].getParser(ua);
  
    var flag;
    if (browser.satisfies({
      chrome: '>=0',
      chromium: '>=0'
    })) flag = 'chrome';else if (browser.satisfies({
      firefox: '>=0'
    })) flag = 'firefox';else if (browser.satisfies({
      safari: '>=0'
    })) flag = 'safari';else if (browser.satisfies({
      opera: '>=0'
    })) flag = 'opera';else if (browser.satisfies({
      'microsoft edge': '>=0'
    })) flag = 'edge';else flag = 'unknown';
    return {
      flag: flag,
      name: browser.getBrowserName(),
      version: browser.getBrowserVersion()
    };
  }
  
  },{"@babel/runtime/helpers/interopRequireDefault":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/interopRequireDefault.js","bowser":"/home/ubuntu/umbrella-voice2/app/node_modules/bowser/es5.js"}],"/home/ubuntu/umbrella-voice2/app/lib/events.js":[function(require,module,exports){
  "use strict";
  
  var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports["default"] = void 0;
  
  var _toConsumableArray2 = _interopRequireDefault(require("@babel/runtime/helpers/toConsumableArray"));
  
  var _defineProperty2 = _interopRequireDefault(require("@babel/runtime/helpers/defineProperty"));
  
  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }
  
  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { (0, _defineProperty2["default"])(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  
  /**
   * @type {Map<String, Set<Function>>}
  */
  var __events = new Map();
  
  var listenEvent = function listenEvent(eventName, eventFunction) {
    if (__events.has(eventName)) {
      var event = __events.get(eventName);
  
      if (!event.has(eventFunction)) {
        event.add(eventFunction);
      }
    } else {
      __events.set(eventName, new Set([eventFunction]));
    }
  };
  
  var callEvent = function callEvent(eventName) {
    for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
      args[_key - 1] = arguments[_key];
    }
  
    if (__events.has(eventName)) {
      var event = __events.get(eventName);
  
      event.forEach(function (eventFunction) {
        eventFunction.apply(void 0, args);
      });
    }
  };
  
  var removeEvent = function removeEvent(eventName, eventFunction) {
    if (__events.has(eventName)) {
      var event = __events.get(eventName);
  
      if (event.has(eventFunction)) {
        event["delete"](eventFunction);
      } else {
        event.clear();
      }
    }
  };
  
  var eventToClient = function eventToClient(eventName, args) {
    args = _objectSpread({}, args); // fetch(`http://${eventName}`, {
    // 	method : 'POST',
    // 	body   : JSON.stringify(args)
    // });
    // const ndata = args === undefined ? '{}' : JSON.stringify(args);
    // console.log("PIZDA")
    // console.log(`http://${eventName}`);
    // console.log(typeof(window.jQuery.post));
    // window.jQuery.post(`http://${eventName}`, JSON.stringify(args));
  
    var xhr = new XMLHttpRequest();
    xhr.open('POST', "https://".concat(eventName));
    xhr.send(JSON.stringify(args));
  };
  
  var triggerClientChangeStateConnection = function triggerClientChangeStateConnection(roomId, state) {
    eventToClient('pvoice3/changeStateConnection', {
      roomId: roomId,
      state: state
    });
  };
  
  var triggerClientRequestMediaPeerResponse = function triggerClientRequestMediaPeerResponse(roomId, peerName, status) {
    eventToClient('pvoice3/requestMediaPeerResponse', {
      roomId: roomId,
      peerName: peerName,
      status: status
    });
  };
  
  var triggerClientRequestCloseMediaPeerResponse = function triggerClientRequestCloseMediaPeerResponse(roomId, peerName, status) {
    eventToClient('pvoice3/requestCloseMediaPeerResponse', {
      roomId: roomId,
      peerName: peerName,
      status: status
    });
  };
  
  var triggerClientChangeProducerVolume = function triggerClientChangeProducerVolume(volume) {
    eventToClient('pvoice3/changeProducerVolume', {
      volume: volume
    });
  };
  
  var triggerClientChangeConsumerVolume = function triggerClientChangeConsumerVolume(roomId, peerName, volume) {
    eventToClient('pvoice3/changeConsumerVolume', {
      roomId: roomId,
      peerName: peerName,
      volume: volume
    });
  };
  
  var triggerClientChangeConsumersVolume = function triggerClientChangeConsumersVolume(roomId, consumers) {
    eventToClient('pvoice3/changeConsumersVolume', {
      roomId: roomId,
      consumers: consumers
    });
  };
  
  var triggerClientMicrophoneEnabled = function triggerClientMicrophoneEnabled(roomId, peerName, isEnabled) {
    eventToClient('pvoice3/toggleMicrophone', {
      roomId: roomId,
      peerName: peerName,
      isEnabled: isEnabled
    });
  };
  
  window.addEventListener('message', function (event) {
    var data = event.data;
  
    if (__events.has(data.type)) {
      var args = data.args || [];
      callEvent.apply(void 0, [data.type].concat((0, _toConsumableArray2["default"])(args)));
    }
  });
  var _default = {
    on: listenEvent,
    call: callEvent,
    remove: removeEvent,
    triggerClientChangeStateConnection: triggerClientChangeStateConnection,
    triggerClientRequestMediaPeerResponse: triggerClientRequestMediaPeerResponse,
    triggerClientRequestCloseMediaPeerResponse: triggerClientRequestCloseMediaPeerResponse,
    triggerClientChangeProducerVolume: triggerClientChangeProducerVolume,
    triggerClientChangeConsumerVolume: triggerClientChangeConsumerVolume,
    triggerClientChangeConsumersVolume: triggerClientChangeConsumersVolume,
    triggerClientMicrophoneEnabled: triggerClientMicrophoneEnabled,
    __events: __events
  };
  exports["default"] = _default;
  
  },{"@babel/runtime/helpers/defineProperty":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/defineProperty.js","@babel/runtime/helpers/interopRequireDefault":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/helpers/toConsumableArray":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/toConsumableArray.js"}],"/home/ubuntu/umbrella-voice2/app/lib/index.js":[function(require,module,exports){
  "use strict";
  
  var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");
  
  var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
  
  var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
  
  var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
  
  var _domready = _interopRequireDefault(require("domready"));
  
  var _urlParse = _interopRequireDefault(require("url-parse"));
  
  var _Logger = _interopRequireDefault(require("./Logger"));
  
  var utils = _interopRequireWildcard(require("./utils"));
  
  var _deviceInfo = _interopRequireDefault(require("./deviceInfo"));
  
  var _RoomClient = _interopRequireDefault(require("./RoomClient"));
  
  var _events = _interopRequireDefault(require("./events"));
  
  var _urlFactory = require("./urlFactory");
  
  // import { createLogger as createReduxLogger } from 're dux-logger';
  var logger = new _Logger["default"](); // if (process.env.NODE_ENV === 'development')
  // {
  // 	const reduxLogger = createReduxLogger(
  // 		{
  // 			duration  : true,
  // 			timestamp : false,
  // 			level     : 'log',
  // 			logErrors : true
  // 		});
  // 	reduxMiddlewares.push(reduxLogger);
  // }
  
  var rooms = {};
  (0, _domready["default"])( /*#__PURE__*/(0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee() {
    return _regenerator["default"].wrap(function _callee$(_context) {
      while (1) {
        switch (_context.prev = _context.next) {
          case 0:
            logger.debug('DOM ready');
            _context.next = 3;
            return utils.initialize();
  
          case 3:
          case "end":
            return _context.stop();
        }
      }
    }, _callee);
  })));
  
  function run(_x, _x2) {
    return _run.apply(this, arguments);
  }
  
  function _run() {
    _run = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee2(roomId, peerId) {
      var urlParser, handler, useSimulcast, forceTcp, produce, consume, forceH264, forceVP9, datachannel, roomUrlParser, _i2, _Object$keys, key, device;
  
      return _regenerator["default"].wrap(function _callee2$(_context2) {
        while (1) {
          switch (_context2.prev = _context2.next) {
            case 0:
              logger.debug('run() [environment:%s]', "development");
              urlParser = new _urlParse["default"](window.location.href, true); // const peerId = randomString({ length: 8 }).toLowerCase() || peerId;
              // let roomId = urlParser.query.roomId;
  
              handler = urlParser.query.handler;
              useSimulcast = urlParser.query.simulcast !== 'false';
              forceTcp = urlParser.query.forceTcp === 'true';
              produce = urlParser.query.produce !== 'false';
              consume = urlParser.query.consume !== 'false';
              forceH264 = urlParser.query.forceH264 === 'true';
              forceVP9 = urlParser.query.forceVP9 === 'true';
              datachannel = urlParser.query.datachannel !== 'false'; // Get the effective/shareable Room URL.
  
              roomUrlParser = new _urlParse["default"](window.location.href, true);
              _i2 = 0, _Object$keys = Object.keys(roomUrlParser.query);
  
            case 12:
              if (!(_i2 < _Object$keys.length)) {
                _context2.next = 22;
                break;
              }
  
              key = _Object$keys[_i2];
              _context2.t0 = key;
              _context2.next = _context2.t0 === 'roomId' ? 17 : _context2.t0 === 'handler' ? 17 : _context2.t0 === 'simulcast' ? 17 : _context2.t0 === 'sharingSimulcast' ? 17 : _context2.t0 === 'produce' ? 17 : _context2.t0 === 'consume' ? 17 : _context2.t0 === 'forceH264' ? 17 : _context2.t0 === 'forceVP9' ? 17 : _context2.t0 === 'forceTcp' ? 17 : _context2.t0 === 'svc' ? 17 : _context2.t0 === 'datachannel' ? 17 : _context2.t0 === 'info' ? 17 : _context2.t0 === 'faceDetection' ? 17 : _context2.t0 === 'externalVideo' ? 17 : _context2.t0 === 'throttleSecret' ? 17 : 18;
              break;
  
            case 17:
              return _context2.abrupt("break", 19);
  
            case 18:
              delete roomUrlParser.query[key];
  
            case 19:
              _i2++;
              _context2.next = 12;
              break;
  
            case 22:
              delete roomUrlParser.hash; // Get current device info.
  
              device = (0, _deviceInfo["default"])();
              rooms[roomId] = new _RoomClient["default"]({
                roomId: roomId,
                peerId: peerId,
                device: device,
                handlerName: handler,
                useSimulcast: useSimulcast,
                forceTcp: forceTcp,
                produce: produce,
                consume: consume,
                forceH264: forceH264,
                forceVP9: forceVP9,
                datachannel: datachannel
              }); // setTimeout(() => roomClient.enableShare(), 3000)
  
              setTimeout(function () {
                return rooms[roomId].join();
              }, 100);
  
            case 26:
            case "end":
              return _context2.stop();
          }
        }
      }, _callee2);
    }));
    return _run.apply(this, arguments);
  }
  
  _events["default"].on('run', function (roomId, peerId, token, deviceId, producerVolume, isUsb, isPositioning) {
    run(roomId, peerId, token, deviceId, producerVolume, isUsb, isPositioning);
  });
  
  _events["default"].on('streamIn', function (roomId, peerId) {
    var currentRoom = rooms[roomId];
  
    if (currentRoom && currentRoom._stateConnection !== 'closed') {
      currentRoom.requestMediaPeer(peerId);
    }
  });
  
  _events["default"].on('streamOut', function (roomId, peerId) {
    var currentRoom = rooms[roomId];
  
    if (currentRoom && currentRoom._stateConnection !== 'closed') {
      currentRoom.requestCloseMediaPeer(peerId);
    }
  });
  
  _events["default"].on('changeVolumeConsumer', function (roomId, peerId, volume, balance) {
    var currentRoom = rooms[roomId];
  
    if (currentRoom && currentRoom._stateConnection !== 'closed') {
      currentRoom.changeConsumerVolume(peerId, volume, balance);
    }
  });
  
  _events["default"].on('changeVolumeConsumers', function (roomId, peers) {
    var currentRoom = rooms[roomId];
  
    if (currentRoom && currentRoom._stateConnection !== 'closed') {
      currentRoom.changeConsumersVolume(peers);
    }
  });
  
  _events["default"].on('setConsumerAudioEffects', function (roomId, peerId, effects) {
    var currentRoom = rooms[roomId];
  
    if (currentRoom && currentRoom._stateConnection !== 'closed') {
      currentRoom.setConsumerAudioEffects(peerId, effects);
    }
  }); // Events.on('changeProducerVolume', (volume) => {
  // 	if (roomClient && roomClient._stateConnection !== 'closed') {
  // 		roomClient.changeProducerVolume(volume);
  // 	}
  // });
  
  
  _events["default"].on('changeMainVolume', function (roomId, volume) {
    var currentRoom = rooms[roomId];
  
    if (currentRoom && currentRoom._stateConnection !== 'closed') {
      currentRoom.changeMainVolume(volume);
    }
  }); // Events.on('changeProducer', (deviceId, producerVolume = 1) => {
  // 	if (roomClient && roomClient._stateConnection !== 'closed') {
  // 		roomClient.changeProducer(deviceId, producerVolume);
  // 	}
  // });
  // Events.on('changeProducerIsUsb', (isUsb) => {
  // 	if (roomClient && roomClient._stateConnection !== 'closed') {
  // 		roomClient.changeProducerIsUsb(isUsb);
  // 	}
  // });
  // Events.on('changePositioning', (isPositioning) => {
  // 	if (roomClient && roomClient._stateConnection !== 'closed') {
  // 		roomClient.changePositioning(isPositioning);
  // 	}
  // });
  
  
  _events["default"].on('muteMic', function (roomId, ids) {
    var currentRoom = rooms[roomId];
  
    if (currentRoom && currentRoom._stateConnection !== 'closed') {
      currentRoom.muteMic(ids);
    }
  });
  
  _events["default"].on('unmuteMic', function (roomId, ids) {
    var currentRoom = rooms[roomId];
  
    if (currentRoom && currentRoom._stateConnection !== 'closed') {
      currentRoom.unmuteMic(ids);
    }
  }); // Events.on('updateRooms', (rooms) => {
  // 	if (roomClient && roomClient._stateConnection !== 'closed') {
  // 		roomClient.updateRooms(rooms);
  // 	}
  // });
  
  
  _events["default"].on('restartIceAllRooms', function () {
    for (var _i = 0, _Object$values = Object.values(rooms); _i < _Object$values.length; _i++) {
      var room = _Object$values[_i];
  
      if (room._stateConnection !== 'closed') {
        room.restartIce();
      }
    }
  });
  
  _events["default"].on('restartIce', function (roomId) {
    var currentRoom = rooms[roomId];
  
    if (currentRoom && currentRoom._stateConnection !== 'closed') {
      currentRoom.restartIce();
    }
  });
  
  _events["default"].on('quit', function (roomId) {
    var currentRoom = rooms[roomId];
  
    if (currentRoom && currentRoom._stateConnection !== 'closed') {
      currentRoom.close();
  
      if (currentRoom._closed) {
        delete rooms[roomId];
      }
    }
  });
  
  _events["default"].on('setServerUrl', function (serverUrl, serverPort) {
    (0, _urlFactory.setProotooUrl)(serverUrl);
    (0, _urlFactory.setProotooPort)(serverPort);
  });
  
  },{"./Logger":"/home/ubuntu/umbrella-voice2/app/lib/Logger.js","./RoomClient":"/home/ubuntu/umbrella-voice2/app/lib/RoomClient.js","./deviceInfo":"/home/ubuntu/umbrella-voice2/app/lib/deviceInfo.js","./events":"/home/ubuntu/umbrella-voice2/app/lib/events.js","./urlFactory":"/home/ubuntu/umbrella-voice2/app/lib/urlFactory.js","./utils":"/home/ubuntu/umbrella-voice2/app/lib/utils.js","@babel/runtime/helpers/asyncToGenerator":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/helpers/interopRequireWildcard":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/interopRequireWildcard.js","@babel/runtime/regenerator":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/regenerator/index.js","domready":"/home/ubuntu/umbrella-voice2/app/node_modules/domready/ready.js","url-parse":"/home/ubuntu/umbrella-voice2/app/node_modules/url-parse/index.js"}],"/home/ubuntu/umbrella-voice2/app/lib/urlFactory.js":[function(require,module,exports){
  "use strict";
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.setProotooUrl = setProotooUrl;
  exports.setProotooPort = setProotooPort;
  exports.getProtooUrl = getProtooUrl;
  var protooPort = 4443;
  var protooUrl = 'mediasoup.umbrellarp.ru';
  
  function setProotooUrl(url) {
    protooUrl = url;
  }
  
  function setProotooPort(port) {
    protooPort = Number(port);
  }
  
  function getProtooUrl(_ref) {
    var roomId = _ref.roomId,
        peerId = _ref.peerId;
    return "wss://".concat(protooUrl, ":").concat(protooPort, "/?roomId=").concat(roomId, "&peerId=").concat(peerId);
  }
  
  },{}],"/home/ubuntu/umbrella-voice2/app/lib/utils.js":[function(require,module,exports){
  "use strict";
  
  var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");
  
  Object.defineProperty(exports, "__esModule", {
    value: true
  });
  exports.getUserMedia = getUserMedia;
  exports.initialize = initialize;
  exports.isDesktop = isDesktop;
  exports.isMobile = isMobile;
  
  var _regenerator = _interopRequireDefault(require("@babel/runtime/regenerator"));
  
  var _asyncToGenerator2 = _interopRequireDefault(require("@babel/runtime/helpers/asyncToGenerator"));
  
  /* eslint-disable no-console */
  var mediaQueryDetectorElem;
  var userMedia;
  
  function getUserMedia(_x) {
    return _getUserMedia.apply(this, arguments);
  }
  
  function _getUserMedia() {
    _getUserMedia = (0, _asyncToGenerator2["default"])( /*#__PURE__*/_regenerator["default"].mark(function _callee(constraints) {
      return _regenerator["default"].wrap(function _callee$(_context) {
        while (1) {
          switch (_context.prev = _context.next) {
            case 0:
              console.log("fuck - ".concat(userMedia));
  
              if (userMedia) {
                _context.next = 5;
                break;
              }
  
              _context.next = 4;
              return navigator.mediaDevices.getUserMedia(constraints);
  
            case 4:
              userMedia = _context.sent;
  
            case 5:
              return _context.abrupt("return", userMedia);
  
            case 6:
            case "end":
              return _context.stop();
          }
        }
      }, _callee);
    }));
    return _getUserMedia.apply(this, arguments);
  }
  
  function initialize() {
    // Media query detector stuff.
    mediaQueryDetectorElem = document.getElementById('mediasoup-demo-app-media-query-detector');
    return Promise.resolve();
  }
  
  function isDesktop() {
    return Boolean(mediaQueryDetectorElem.offsetParent);
  }
  
  function isMobile() {
    return !mediaQueryDetectorElem.offsetParent;
  }
  
  },{"@babel/runtime/helpers/asyncToGenerator":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/asyncToGenerator.js","@babel/runtime/helpers/interopRequireDefault":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/interopRequireDefault.js","@babel/runtime/regenerator":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/regenerator/index.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/arrayLikeToArray.js":[function(require,module,exports){
  function _arrayLikeToArray(arr, len) {
    if (len == null || len > arr.length) len = arr.length;
  
    for (var i = 0, arr2 = new Array(len); i < len; i++) {
      arr2[i] = arr[i];
    }
  
    return arr2;
  }
  
  module.exports = _arrayLikeToArray;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js":[function(require,module,exports){
  var arrayLikeToArray = require("./arrayLikeToArray.js");
  
  function _arrayWithoutHoles(arr) {
    if (Array.isArray(arr)) return arrayLikeToArray(arr);
  }
  
  module.exports = _arrayWithoutHoles;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  },{"./arrayLikeToArray.js":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/arrayLikeToArray.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/asyncToGenerator.js":[function(require,module,exports){
  function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
      var info = gen[key](arg);
      var value = info.value;
    } catch (error) {
      reject(error);
      return;
    }
  
    if (info.done) {
      resolve(value);
    } else {
      Promise.resolve(value).then(_next, _throw);
    }
  }
  
  function _asyncToGenerator(fn) {
    return function () {
      var self = this,
          args = arguments;
      return new Promise(function (resolve, reject) {
        var gen = fn.apply(self, args);
  
        function _next(value) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
        }
  
        function _throw(err) {
          asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
        }
  
        _next(undefined);
      });
    };
  }
  
  module.exports = _asyncToGenerator;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/classCallCheck.js":[function(require,module,exports){
  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }
  
  module.exports = _classCallCheck;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/createClass.js":[function(require,module,exports){
  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }
  
  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }
  
  module.exports = _createClass;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/defineProperty.js":[function(require,module,exports){
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }
  
    return obj;
  }
  
  module.exports = _defineProperty;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/interopRequireDefault.js":[function(require,module,exports){
  function _interopRequireDefault(obj) {
    return obj && obj.__esModule ? obj : {
      "default": obj
    };
  }
  
  module.exports = _interopRequireDefault;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/interopRequireWildcard.js":[function(require,module,exports){
  var _typeof = require("@babel/runtime/helpers/typeof")["default"];
  
  function _getRequireWildcardCache() {
    if (typeof WeakMap !== "function") return null;
    var cache = new WeakMap();
  
    _getRequireWildcardCache = function _getRequireWildcardCache() {
      return cache;
    };
  
    return cache;
  }
  
  function _interopRequireWildcard(obj) {
    if (obj && obj.__esModule) {
      return obj;
    }
  
    if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") {
      return {
        "default": obj
      };
    }
  
    var cache = _getRequireWildcardCache();
  
    if (cache && cache.has(obj)) {
      return cache.get(obj);
    }
  
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
  
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
  
        if (desc && (desc.get || desc.set)) {
          Object.defineProperty(newObj, key, desc);
        } else {
          newObj[key] = obj[key];
        }
      }
    }
  
    newObj["default"] = obj;
  
    if (cache) {
      cache.set(obj, newObj);
    }
  
    return newObj;
  }
  
  module.exports = _interopRequireWildcard;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  },{"@babel/runtime/helpers/typeof":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/typeof.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/iterableToArray.js":[function(require,module,exports){
  function _iterableToArray(iter) {
    if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter);
  }
  
  module.exports = _iterableToArray;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/nonIterableSpread.js":[function(require,module,exports){
  function _nonIterableSpread() {
    throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
  }
  
  module.exports = _nonIterableSpread;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/toConsumableArray.js":[function(require,module,exports){
  var arrayWithoutHoles = require("./arrayWithoutHoles.js");
  
  var iterableToArray = require("./iterableToArray.js");
  
  var unsupportedIterableToArray = require("./unsupportedIterableToArray.js");
  
  var nonIterableSpread = require("./nonIterableSpread.js");
  
  function _toConsumableArray(arr) {
    return arrayWithoutHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableSpread();
  }
  
  module.exports = _toConsumableArray;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  },{"./arrayWithoutHoles.js":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/arrayWithoutHoles.js","./iterableToArray.js":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/iterableToArray.js","./nonIterableSpread.js":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/nonIterableSpread.js","./unsupportedIterableToArray.js":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/typeof.js":[function(require,module,exports){
  function _typeof(obj) {
    "@babel/helpers - typeof";
  
    if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") {
      module.exports = _typeof = function _typeof(obj) {
        return typeof obj;
      };
  
      module.exports["default"] = module.exports, module.exports.__esModule = true;
    } else {
      module.exports = _typeof = function _typeof(obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
      };
  
      module.exports["default"] = module.exports, module.exports.__esModule = true;
    }
  
    return _typeof(obj);
  }
  
  module.exports = _typeof;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/unsupportedIterableToArray.js":[function(require,module,exports){
  var arrayLikeToArray = require("./arrayLikeToArray.js");
  
  function _unsupportedIterableToArray(o, minLen) {
    if (!o) return;
    if (typeof o === "string") return arrayLikeToArray(o, minLen);
    var n = Object.prototype.toString.call(o).slice(8, -1);
    if (n === "Object" && o.constructor) n = o.constructor.name;
    if (n === "Map" || n === "Set") return Array.from(o);
    if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
  }
  
  module.exports = _unsupportedIterableToArray;
  module.exports["default"] = module.exports, module.exports.__esModule = true;
  },{"./arrayLikeToArray.js":"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/helpers/arrayLikeToArray.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/@babel/runtime/regenerator/index.js":[function(require,module,exports){
  module.exports = require("regenerator-runtime");
  
  },{"regenerator-runtime":"/home/ubuntu/umbrella-voice2/app/node_modules/regenerator-runtime/runtime.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/awaitqueue/lib/index.js":[function(require,module,exports){
  "use strict";
  var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
      function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
      return new (P || (P = Promise))(function (resolve, reject) {
          function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
          function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
          function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
          step((generator = generator.apply(thisArg, _arguments || [])).next());
      });
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  class AwaitQueue {
      constructor({ ClosedErrorClass = Error, StoppedErrorClass = Error } = {
          ClosedErrorClass: Error,
          StoppedErrorClass: Error
      }) {
          // Closed flag.
          this.closed = false;
          // Queue of pending tasks.
          this.pendingTasks = [];
          // Error class used when rejecting a task due to AwaitQueue being closed.
          this.ClosedErrorClass = Error;
          // Error class used when rejecting a task due to AwaitQueue being stopped.
          this.StoppedErrorClass = Error;
          this.ClosedErrorClass = ClosedErrorClass;
          this.StoppedErrorClass = StoppedErrorClass;
      }
      /**
       * The number of ongoing enqueued tasks.
       */
      get size() {
          return this.pendingTasks.length;
      }
      /**
       * Closes the AwaitQueue. Pending tasks will be rejected with ClosedErrorClass
       * error.
       */
      close() {
          if (this.closed)
              return;
          this.closed = true;
          for (const pendingTask of this.pendingTasks) {
              pendingTask.stopped = true;
              pendingTask.reject(new this.ClosedErrorClass('AwaitQueue closed'));
          }
          // Enpty the pending tasks array.
          this.pendingTasks.length = 0;
      }
      /**
       * Accepts a task as argument (and an optional task name) and enqueues it after
       * pending tasks. Once processed, the push() method resolves (or rejects) with
       * the result returned by the given task.
       *
       * The given task must return a Promise or directly a value.
       */
      push(task, name) {
          return __awaiter(this, void 0, void 0, function* () {
              if (this.closed)
                  throw new this.ClosedErrorClass('AwaitQueue closed');
              if (typeof task !== 'function')
                  throw new TypeError('given task is not a function');
              if (!task.name && name) {
                  try {
                      Object.defineProperty(task, 'name', { value: name });
                  }
                  catch (error) { }
              }
              return new Promise((resolve, reject) => {
                  const pendingTask = {
                      task,
                      name,
                      resolve,
                      reject,
                      stopped: false,
                      enqueuedAt: new Date(),
                      executedAt: undefined
                  };
                  // Append task to the queue.
                  this.pendingTasks.push(pendingTask);
                  // And run it if this is the only task in the queue.
                  if (this.pendingTasks.length === 1)
                      this.next();
              });
          });
      }
      /**
       * Make ongoing pending tasks reject with the given StoppedErrorClass error.
       * The AwaitQueue instance is still usable for future tasks added via push()
       * method.
       */
      stop() {
          if (this.closed)
              return;
          for (const pendingTask of this.pendingTasks) {
              pendingTask.stopped = true;
              pendingTask.reject(new this.StoppedErrorClass('AwaitQueue stopped'));
          }
          // Enpty the pending tasks array.
          this.pendingTasks.length = 0;
      }
      dump() {
          const now = new Date();
          return this.pendingTasks.map((pendingTask) => {
              return {
                  task: pendingTask.task,
                  name: pendingTask.name,
                  enqueuedTime: pendingTask.executedAt
                      ? pendingTask.executedAt.getTime() - pendingTask.enqueuedAt.getTime()
                      : now.getTime() - pendingTask.enqueuedAt.getTime(),
                  executingTime: pendingTask.executedAt
                      ? now.getTime() - pendingTask.executedAt.getTime()
                      : 0
              };
          });
      }
      next() {
          return __awaiter(this, void 0, void 0, function* () {
              // Take the first pending task.
              const pendingTask = this.pendingTasks[0];
              if (!pendingTask)
                  return;
              // Execute it.
              yield this.executeTask(pendingTask);
              // Remove the first pending task (the completed one) from the queue.
              this.pendingTasks.shift();
              // And continue.
              this.next();
          });
      }
      executeTask(pendingTask) {
          return __awaiter(this, void 0, void 0, function* () {
              // If the task is stopped, ignore it.
              if (pendingTask.stopped)
                  return;
              pendingTask.executedAt = new Date();
              try {
                  const result = yield pendingTask.task();
                  // If the task is stopped, ignore it.
                  if (pendingTask.stopped)
                      return;
                  // Resolve the task with the returned result (if any).
                  pendingTask.resolve(result);
              }
              catch (error) {
                  // If the task is stopped, ignore it.
                  if (pendingTask.stopped)
                      return;
                  // Reject the task with its own error.
                  pendingTask.reject(error);
              }
          });
      }
  }
  exports.AwaitQueue = AwaitQueue;
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/bowser/es5.js":[function(require,module,exports){
  !function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.bowser=t():e.bowser=t()}(this,(function(){return function(e){var t={};function r(n){if(t[n])return t[n].exports;var i=t[n]={i:n,l:!1,exports:{}};return e[n].call(i.exports,i,i.exports,r),i.l=!0,i.exports}return r.m=e,r.c=t,r.d=function(e,t,n){r.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},r.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},r.t=function(e,t){if(1&t&&(e=r(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(r.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var i in e)r.d(n,i,function(t){return e[t]}.bind(null,i));return n},r.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return r.d(t,"a",t),t},r.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},r.p="",r(r.s=90)}({17:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n=r(18),i=function(){function e(){}return e.getFirstMatch=function(e,t){var r=t.match(e);return r&&r.length>0&&r[1]||""},e.getSecondMatch=function(e,t){var r=t.match(e);return r&&r.length>1&&r[2]||""},e.matchAndReturnConst=function(e,t,r){if(e.test(t))return r},e.getWindowsVersionName=function(e){switch(e){case"NT":return"NT";case"XP":return"XP";case"NT 5.0":return"2000";case"NT 5.1":return"XP";case"NT 5.2":return"2003";case"NT 6.0":return"Vista";case"NT 6.1":return"7";case"NT 6.2":return"8";case"NT 6.3":return"8.1";case"NT 10.0":return"10";default:return}},e.getMacOSVersionName=function(e){var t=e.split(".").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),10===t[0])switch(t[1]){case 5:return"Leopard";case 6:return"Snow Leopard";case 7:return"Lion";case 8:return"Mountain Lion";case 9:return"Mavericks";case 10:return"Yosemite";case 11:return"El Capitan";case 12:return"Sierra";case 13:return"High Sierra";case 14:return"Mojave";case 15:return"Catalina";default:return}},e.getAndroidVersionName=function(e){var t=e.split(".").splice(0,2).map((function(e){return parseInt(e,10)||0}));if(t.push(0),!(1===t[0]&&t[1]<5))return 1===t[0]&&t[1]<6?"Cupcake":1===t[0]&&t[1]>=6?"Donut":2===t[0]&&t[1]<2?"Eclair":2===t[0]&&2===t[1]?"Froyo":2===t[0]&&t[1]>2?"Gingerbread":3===t[0]?"Honeycomb":4===t[0]&&t[1]<1?"Ice Cream Sandwich":4===t[0]&&t[1]<4?"Jelly Bean":4===t[0]&&t[1]>=4?"KitKat":5===t[0]?"Lollipop":6===t[0]?"Marshmallow":7===t[0]?"Nougat":8===t[0]?"Oreo":9===t[0]?"Pie":void 0},e.getVersionPrecision=function(e){return e.split(".").length},e.compareVersions=function(t,r,n){void 0===n&&(n=!1);var i=e.getVersionPrecision(t),s=e.getVersionPrecision(r),a=Math.max(i,s),o=0,u=e.map([t,r],(function(t){var r=a-e.getVersionPrecision(t),n=t+new Array(r+1).join(".0");return e.map(n.split("."),(function(e){return new Array(20-e.length).join("0")+e})).reverse()}));for(n&&(o=a-Math.min(i,s)),a-=1;a>=o;){if(u[0][a]>u[1][a])return 1;if(u[0][a]===u[1][a]){if(a===o)return 0;a-=1}else if(u[0][a]<u[1][a])return-1}},e.map=function(e,t){var r,n=[];if(Array.prototype.map)return Array.prototype.map.call(e,t);for(r=0;r<e.length;r+=1)n.push(t(e[r]));return n},e.find=function(e,t){var r,n;if(Array.prototype.find)return Array.prototype.find.call(e,t);for(r=0,n=e.length;r<n;r+=1){var i=e[r];if(t(i,r))return i}},e.assign=function(e){for(var t,r,n=e,i=arguments.length,s=new Array(i>1?i-1:0),a=1;a<i;a++)s[a-1]=arguments[a];if(Object.assign)return Object.assign.apply(Object,[e].concat(s));var o=function(){var e=s[t];"object"==typeof e&&null!==e&&Object.keys(e).forEach((function(t){n[t]=e[t]}))};for(t=0,r=s.length;t<r;t+=1)o();return e},e.getBrowserAlias=function(e){return n.BROWSER_ALIASES_MAP[e]},e.getBrowserTypeByAlias=function(e){return n.BROWSER_MAP[e]||""},e}();t.default=i,e.exports=t.default},18:function(e,t,r){"use strict";t.__esModule=!0,t.ENGINE_MAP=t.OS_MAP=t.PLATFORMS_MAP=t.BROWSER_MAP=t.BROWSER_ALIASES_MAP=void 0;t.BROWSER_ALIASES_MAP={"Amazon Silk":"amazon_silk","Android Browser":"android",Bada:"bada",BlackBerry:"blackberry",Chrome:"chrome",Chromium:"chromium",Electron:"electron",Epiphany:"epiphany",Firefox:"firefox",Focus:"focus",Generic:"generic","Google Search":"google_search",Googlebot:"googlebot","Internet Explorer":"ie","K-Meleon":"k_meleon",Maxthon:"maxthon","Microsoft Edge":"edge","MZ Browser":"mz","NAVER Whale Browser":"naver",Opera:"opera","Opera Coast":"opera_coast",PhantomJS:"phantomjs",Puffin:"puffin",QupZilla:"qupzilla",QQ:"qq",QQLite:"qqlite",Safari:"safari",Sailfish:"sailfish","Samsung Internet for Android":"samsung_internet",SeaMonkey:"seamonkey",Sleipnir:"sleipnir",Swing:"swing",Tizen:"tizen","UC Browser":"uc",Vivaldi:"vivaldi","WebOS Browser":"webos",WeChat:"wechat","Yandex Browser":"yandex",Roku:"roku"};t.BROWSER_MAP={amazon_silk:"Amazon Silk",android:"Android Browser",bada:"Bada",blackberry:"BlackBerry",chrome:"Chrome",chromium:"Chromium",electron:"Electron",epiphany:"Epiphany",firefox:"Firefox",focus:"Focus",generic:"Generic",googlebot:"Googlebot",google_search:"Google Search",ie:"Internet Explorer",k_meleon:"K-Meleon",maxthon:"Maxthon",edge:"Microsoft Edge",mz:"MZ Browser",naver:"NAVER Whale Browser",opera:"Opera",opera_coast:"Opera Coast",phantomjs:"PhantomJS",puffin:"Puffin",qupzilla:"QupZilla",qq:"QQ Browser",qqlite:"QQ Browser Lite",safari:"Safari",sailfish:"Sailfish",samsung_internet:"Samsung Internet for Android",seamonkey:"SeaMonkey",sleipnir:"Sleipnir",swing:"Swing",tizen:"Tizen",uc:"UC Browser",vivaldi:"Vivaldi",webos:"WebOS Browser",wechat:"WeChat",yandex:"Yandex Browser"};t.PLATFORMS_MAP={tablet:"tablet",mobile:"mobile",desktop:"desktop",tv:"tv"};t.OS_MAP={WindowsPhone:"Windows Phone",Windows:"Windows",MacOS:"macOS",iOS:"iOS",Android:"Android",WebOS:"WebOS",BlackBerry:"BlackBerry",Bada:"Bada",Tizen:"Tizen",Linux:"Linux",ChromeOS:"Chrome OS",PlayStation4:"PlayStation 4",Roku:"Roku"};t.ENGINE_MAP={EdgeHTML:"EdgeHTML",Blink:"Blink",Trident:"Trident",Presto:"Presto",Gecko:"Gecko",WebKit:"WebKit"}},90:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n,i=(n=r(91))&&n.__esModule?n:{default:n},s=r(18);function a(e,t){for(var r=0;r<t.length;r++){var n=t[r];n.enumerable=n.enumerable||!1,n.configurable=!0,"value"in n&&(n.writable=!0),Object.defineProperty(e,n.key,n)}}var o=function(){function e(){}var t,r,n;return e.getParser=function(e,t){if(void 0===t&&(t=!1),"string"!=typeof e)throw new Error("UserAgent should be a string");return new i.default(e,t)},e.parse=function(e){return new i.default(e).getResult()},t=e,n=[{key:"BROWSER_MAP",get:function(){return s.BROWSER_MAP}},{key:"ENGINE_MAP",get:function(){return s.ENGINE_MAP}},{key:"OS_MAP",get:function(){return s.OS_MAP}},{key:"PLATFORMS_MAP",get:function(){return s.PLATFORMS_MAP}}],(r=null)&&a(t.prototype,r),n&&a(t,n),e}();t.default=o,e.exports=t.default},91:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n=u(r(92)),i=u(r(93)),s=u(r(94)),a=u(r(95)),o=u(r(17));function u(e){return e&&e.__esModule?e:{default:e}}var d=function(){function e(e,t){if(void 0===t&&(t=!1),null==e||""===e)throw new Error("UserAgent parameter can't be empty");this._ua=e,this.parsedResult={},!0!==t&&this.parse()}var t=e.prototype;return t.getUA=function(){return this._ua},t.test=function(e){return e.test(this._ua)},t.parseBrowser=function(){var e=this;this.parsedResult.browser={};var t=o.default.find(n.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.browser=t.describe(this.getUA())),this.parsedResult.browser},t.getBrowser=function(){return this.parsedResult.browser?this.parsedResult.browser:this.parseBrowser()},t.getBrowserName=function(e){return e?String(this.getBrowser().name).toLowerCase()||"":this.getBrowser().name||""},t.getBrowserVersion=function(){return this.getBrowser().version},t.getOS=function(){return this.parsedResult.os?this.parsedResult.os:this.parseOS()},t.parseOS=function(){var e=this;this.parsedResult.os={};var t=o.default.find(i.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.os=t.describe(this.getUA())),this.parsedResult.os},t.getOSName=function(e){var t=this.getOS().name;return e?String(t).toLowerCase()||"":t||""},t.getOSVersion=function(){return this.getOS().version},t.getPlatform=function(){return this.parsedResult.platform?this.parsedResult.platform:this.parsePlatform()},t.getPlatformType=function(e){void 0===e&&(e=!1);var t=this.getPlatform().type;return e?String(t).toLowerCase()||"":t||""},t.parsePlatform=function(){var e=this;this.parsedResult.platform={};var t=o.default.find(s.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.platform=t.describe(this.getUA())),this.parsedResult.platform},t.getEngine=function(){return this.parsedResult.engine?this.parsedResult.engine:this.parseEngine()},t.getEngineName=function(e){return e?String(this.getEngine().name).toLowerCase()||"":this.getEngine().name||""},t.parseEngine=function(){var e=this;this.parsedResult.engine={};var t=o.default.find(a.default,(function(t){if("function"==typeof t.test)return t.test(e);if(t.test instanceof Array)return t.test.some((function(t){return e.test(t)}));throw new Error("Browser's test function is not valid")}));return t&&(this.parsedResult.engine=t.describe(this.getUA())),this.parsedResult.engine},t.parse=function(){return this.parseBrowser(),this.parseOS(),this.parsePlatform(),this.parseEngine(),this},t.getResult=function(){return o.default.assign({},this.parsedResult)},t.satisfies=function(e){var t=this,r={},n=0,i={},s=0;if(Object.keys(e).forEach((function(t){var a=e[t];"string"==typeof a?(i[t]=a,s+=1):"object"==typeof a&&(r[t]=a,n+=1)})),n>0){var a=Object.keys(r),u=o.default.find(a,(function(e){return t.isOS(e)}));if(u){var d=this.satisfies(r[u]);if(void 0!==d)return d}var c=o.default.find(a,(function(e){return t.isPlatform(e)}));if(c){var f=this.satisfies(r[c]);if(void 0!==f)return f}}if(s>0){var l=Object.keys(i),h=o.default.find(l,(function(e){return t.isBrowser(e,!0)}));if(void 0!==h)return this.compareVersion(i[h])}},t.isBrowser=function(e,t){void 0===t&&(t=!1);var r=this.getBrowserName().toLowerCase(),n=e.toLowerCase(),i=o.default.getBrowserTypeByAlias(n);return t&&i&&(n=i.toLowerCase()),n===r},t.compareVersion=function(e){var t=[0],r=e,n=!1,i=this.getBrowserVersion();if("string"==typeof i)return">"===e[0]||"<"===e[0]?(r=e.substr(1),"="===e[1]?(n=!0,r=e.substr(2)):t=[],">"===e[0]?t.push(1):t.push(-1)):"="===e[0]?r=e.substr(1):"~"===e[0]&&(n=!0,r=e.substr(1)),t.indexOf(o.default.compareVersions(i,r,n))>-1},t.isOS=function(e){return this.getOSName(!0)===String(e).toLowerCase()},t.isPlatform=function(e){return this.getPlatformType(!0)===String(e).toLowerCase()},t.isEngine=function(e){return this.getEngineName(!0)===String(e).toLowerCase()},t.is=function(e,t){return void 0===t&&(t=!1),this.isBrowser(e,t)||this.isOS(e)||this.isPlatform(e)},t.some=function(e){var t=this;return void 0===e&&(e=[]),e.some((function(e){return t.is(e)}))},e}();t.default=d,e.exports=t.default},92:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n};var s=/version\/(\d+(\.?_?\d+)+)/i,a=[{test:[/googlebot/i],describe:function(e){var t={name:"Googlebot"},r=i.default.getFirstMatch(/googlebot\/(\d+(\.\d+))/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/opera/i],describe:function(e){var t={name:"Opera"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:opera)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opr\/|opios/i],describe:function(e){var t={name:"Opera"},r=i.default.getFirstMatch(/(?:opr|opios)[\s/](\S+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/SamsungBrowser/i],describe:function(e){var t={name:"Samsung Internet for Android"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:SamsungBrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Whale/i],describe:function(e){var t={name:"NAVER Whale Browser"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:whale)[\s/](\d+(?:\.\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MZBrowser/i],describe:function(e){var t={name:"MZ Browser"},r=i.default.getFirstMatch(/(?:MZBrowser)[\s/](\d+(?:\.\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/focus/i],describe:function(e){var t={name:"Focus"},r=i.default.getFirstMatch(/(?:focus)[\s/](\d+(?:\.\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/swing/i],describe:function(e){var t={name:"Swing"},r=i.default.getFirstMatch(/(?:swing)[\s/](\d+(?:\.\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/coast/i],describe:function(e){var t={name:"Opera Coast"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:coast)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/opt\/\d+(?:.?_?\d+)+/i],describe:function(e){var t={name:"Opera Touch"},r=i.default.getFirstMatch(/(?:opt)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/yabrowser/i],describe:function(e){var t={name:"Yandex Browser"},r=i.default.getFirstMatch(/(?:yabrowser)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/ucbrowser/i],describe:function(e){var t={name:"UC Browser"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:ucbrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/Maxthon|mxios/i],describe:function(e){var t={name:"Maxthon"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:Maxthon|mxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/epiphany/i],describe:function(e){var t={name:"Epiphany"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:epiphany)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/puffin/i],describe:function(e){var t={name:"Puffin"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:puffin)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sleipnir/i],describe:function(e){var t={name:"Sleipnir"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:sleipnir)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/k-meleon/i],describe:function(e){var t={name:"K-Meleon"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/(?:k-meleon)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/micromessenger/i],describe:function(e){var t={name:"WeChat"},r=i.default.getFirstMatch(/(?:micromessenger)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qqbrowser/i],describe:function(e){var t={name:/qqbrowserlite/i.test(e)?"QQ Browser Lite":"QQ Browser"},r=i.default.getFirstMatch(/(?:qqbrowserlite|qqbrowser)[/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/msie|trident/i],describe:function(e){var t={name:"Internet Explorer"},r=i.default.getFirstMatch(/(?:msie |rv:)(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/\sedg\//i],describe:function(e){var t={name:"Microsoft Edge"},r=i.default.getFirstMatch(/\sedg\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/edg([ea]|ios)/i],describe:function(e){var t={name:"Microsoft Edge"},r=i.default.getSecondMatch(/edg([ea]|ios)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/vivaldi/i],describe:function(e){var t={name:"Vivaldi"},r=i.default.getFirstMatch(/vivaldi\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/seamonkey/i],describe:function(e){var t={name:"SeaMonkey"},r=i.default.getFirstMatch(/seamonkey\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/sailfish/i],describe:function(e){var t={name:"Sailfish"},r=i.default.getFirstMatch(/sailfish\s?browser\/(\d+(\.\d+)?)/i,e);return r&&(t.version=r),t}},{test:[/silk/i],describe:function(e){var t={name:"Amazon Silk"},r=i.default.getFirstMatch(/silk\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/phantom/i],describe:function(e){var t={name:"PhantomJS"},r=i.default.getFirstMatch(/phantomjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/slimerjs/i],describe:function(e){var t={name:"SlimerJS"},r=i.default.getFirstMatch(/slimerjs\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe:function(e){var t={name:"BlackBerry"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/blackberry[\d]+\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t={name:"WebOS Browser"},r=i.default.getFirstMatch(s,e)||i.default.getFirstMatch(/w(?:eb)?[o0]sbrowser\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/bada/i],describe:function(e){var t={name:"Bada"},r=i.default.getFirstMatch(/dolfin\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/tizen/i],describe:function(e){var t={name:"Tizen"},r=i.default.getFirstMatch(/(?:tizen\s?)?browser\/(\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/qupzilla/i],describe:function(e){var t={name:"QupZilla"},r=i.default.getFirstMatch(/(?:qupzilla)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/firefox|iceweasel|fxios/i],describe:function(e){var t={name:"Firefox"},r=i.default.getFirstMatch(/(?:firefox|iceweasel|fxios)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/electron/i],describe:function(e){var t={name:"Electron"},r=i.default.getFirstMatch(/(?:electron)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/MiuiBrowser/i],describe:function(e){var t={name:"Miui"},r=i.default.getFirstMatch(/(?:MiuiBrowser)[\s/](\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/chromium/i],describe:function(e){var t={name:"Chromium"},r=i.default.getFirstMatch(/(?:chromium)[\s/](\d+(\.?_?\d+)+)/i,e)||i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/chrome|crios|crmo/i],describe:function(e){var t={name:"Chrome"},r=i.default.getFirstMatch(/(?:chrome|crios|crmo)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/GSA/i],describe:function(e){var t={name:"Google Search"},r=i.default.getFirstMatch(/(?:GSA)\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t={name:"Android Browser"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/playstation 4/i],describe:function(e){var t={name:"PlayStation 4"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/safari|applewebkit/i],describe:function(e){var t={name:"Safari"},r=i.default.getFirstMatch(s,e);return r&&(t.version=r),t}},{test:[/.*/i],describe:function(e){var t=-1!==e.search("\\(")?/^(.*)\/(.*)[ \t]\((.*)/:/^(.*)\/(.*) /;return{name:i.default.getFirstMatch(t,e),version:i.default.getSecondMatch(t,e)}}}];t.default=a,e.exports=t.default},93:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/Roku\/DVP/],describe:function(e){var t=i.default.getFirstMatch(/Roku\/DVP-(\d+\.\d+)/i,e);return{name:s.OS_MAP.Roku,version:t}}},{test:[/windows phone/i],describe:function(e){var t=i.default.getFirstMatch(/windows phone (?:os)?\s?(\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.WindowsPhone,version:t}}},{test:[/windows /i],describe:function(e){var t=i.default.getFirstMatch(/Windows ((NT|XP)( \d\d?.\d)?)/i,e),r=i.default.getWindowsVersionName(t);return{name:s.OS_MAP.Windows,version:t,versionName:r}}},{test:[/Macintosh(.*?) FxiOS(.*?)\//],describe:function(e){var t={name:s.OS_MAP.iOS},r=i.default.getSecondMatch(/(Version\/)(\d[\d.]+)/,e);return r&&(t.version=r),t}},{test:[/macintosh/i],describe:function(e){var t=i.default.getFirstMatch(/mac os x (\d+(\.?_?\d+)+)/i,e).replace(/[_\s]/g,"."),r=i.default.getMacOSVersionName(t),n={name:s.OS_MAP.MacOS,version:t};return r&&(n.versionName=r),n}},{test:[/(ipod|iphone|ipad)/i],describe:function(e){var t=i.default.getFirstMatch(/os (\d+([_\s]\d+)*) like mac os x/i,e).replace(/[_\s]/g,".");return{name:s.OS_MAP.iOS,version:t}}},{test:function(e){var t=!e.test(/like android/i),r=e.test(/android/i);return t&&r},describe:function(e){var t=i.default.getFirstMatch(/android[\s/-](\d+(\.\d+)*)/i,e),r=i.default.getAndroidVersionName(t),n={name:s.OS_MAP.Android,version:t};return r&&(n.versionName=r),n}},{test:[/(web|hpw)[o0]s/i],describe:function(e){var t=i.default.getFirstMatch(/(?:web|hpw)[o0]s\/(\d+(\.\d+)*)/i,e),r={name:s.OS_MAP.WebOS};return t&&t.length&&(r.version=t),r}},{test:[/blackberry|\bbb\d+/i,/rim\stablet/i],describe:function(e){var t=i.default.getFirstMatch(/rim\stablet\sos\s(\d+(\.\d+)*)/i,e)||i.default.getFirstMatch(/blackberry\d+\/(\d+([_\s]\d+)*)/i,e)||i.default.getFirstMatch(/\bbb(\d+)/i,e);return{name:s.OS_MAP.BlackBerry,version:t}}},{test:[/bada/i],describe:function(e){var t=i.default.getFirstMatch(/bada\/(\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.Bada,version:t}}},{test:[/tizen/i],describe:function(e){var t=i.default.getFirstMatch(/tizen[/\s](\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.Tizen,version:t}}},{test:[/linux/i],describe:function(){return{name:s.OS_MAP.Linux}}},{test:[/CrOS/],describe:function(){return{name:s.OS_MAP.ChromeOS}}},{test:[/PlayStation 4/],describe:function(e){var t=i.default.getFirstMatch(/PlayStation 4[/\s](\d+(\.\d+)*)/i,e);return{name:s.OS_MAP.PlayStation4,version:t}}}];t.default=a,e.exports=t.default},94:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:[/googlebot/i],describe:function(){return{type:"bot",vendor:"Google"}}},{test:[/huawei/i],describe:function(e){var t=i.default.getFirstMatch(/(can-l01)/i,e)&&"Nova",r={type:s.PLATFORMS_MAP.mobile,vendor:"Huawei"};return t&&(r.model=t),r}},{test:[/nexus\s*(?:7|8|9|10).*/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Nexus"}}},{test:[/ipad/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Apple",model:"iPad"}}},{test:[/Macintosh(.*?) FxiOS(.*?)\//],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Apple",model:"iPad"}}},{test:[/kftt build/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Amazon",model:"Kindle Fire HD 7"}}},{test:[/silk/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet,vendor:"Amazon"}}},{test:[/tablet(?! pc)/i],describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){var t=e.test(/ipod|iphone/i),r=e.test(/like (ipod|iphone)/i);return t&&!r},describe:function(e){var t=i.default.getFirstMatch(/(ipod|iphone)/i,e);return{type:s.PLATFORMS_MAP.mobile,vendor:"Apple",model:t}}},{test:[/nexus\s*[0-6].*/i,/galaxy nexus/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:"Nexus"}}},{test:[/[^-]mobi/i],describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return"blackberry"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:"BlackBerry"}}},{test:function(e){return"bada"===e.getBrowserName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return"windows phone"===e.getBrowserName()},describe:function(){return{type:s.PLATFORMS_MAP.mobile,vendor:"Microsoft"}}},{test:function(e){var t=Number(String(e.getOSVersion()).split(".")[0]);return"android"===e.getOSName(!0)&&t>=3},describe:function(){return{type:s.PLATFORMS_MAP.tablet}}},{test:function(e){return"android"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.mobile}}},{test:function(e){return"macos"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop,vendor:"Apple"}}},{test:function(e){return"windows"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return"linux"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.desktop}}},{test:function(e){return"playstation 4"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}},{test:function(e){return"roku"===e.getOSName(!0)},describe:function(){return{type:s.PLATFORMS_MAP.tv}}}];t.default=a,e.exports=t.default},95:function(e,t,r){"use strict";t.__esModule=!0,t.default=void 0;var n,i=(n=r(17))&&n.__esModule?n:{default:n},s=r(18);var a=[{test:function(e){return"microsoft edge"===e.getBrowserName(!0)},describe:function(e){if(/\sedg\//i.test(e))return{name:s.ENGINE_MAP.Blink};var t=i.default.getFirstMatch(/edge\/(\d+(\.?_?\d+)+)/i,e);return{name:s.ENGINE_MAP.EdgeHTML,version:t}}},{test:[/trident/i],describe:function(e){var t={name:s.ENGINE_MAP.Trident},r=i.default.getFirstMatch(/trident\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){return e.test(/presto/i)},describe:function(e){var t={name:s.ENGINE_MAP.Presto},r=i.default.getFirstMatch(/presto\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:function(e){var t=e.test(/gecko/i),r=e.test(/like gecko/i);return t&&!r},describe:function(e){var t={name:s.ENGINE_MAP.Gecko},r=i.default.getFirstMatch(/gecko\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}},{test:[/(apple)?webkit\/537\.36/i],describe:function(){return{name:s.ENGINE_MAP.Blink}}},{test:[/(apple)?webkit/i],describe:function(e){var t={name:s.ENGINE_MAP.WebKit},r=i.default.getFirstMatch(/webkit\/(\d+(\.?_?\d+)+)/i,e);return r&&(t.version=r),t}}];t.default=a,e.exports=t.default}})}));
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/browserify/node_modules/events/events.js":[function(require,module,exports){
  // Copyright Joyent, Inc. and other Node contributors.
  //
  // Permission is hereby granted, free of charge, to any person obtaining a
  // copy of this software and associated documentation files (the
  // "Software"), to deal in the Software without restriction, including
  // without limitation the rights to use, copy, modify, merge, publish,
  // distribute, sublicense, and/or sell copies of the Software, and to permit
  // persons to whom the Software is furnished to do so, subject to the
  // following conditions:
  //
  // The above copyright notice and this permission notice shall be included
  // in all copies or substantial portions of the Software.
  //
  // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
  // OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  // MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
  // NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
  // DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
  // OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
  // USE OR OTHER DEALINGS IN THE SOFTWARE.
  
  var objectCreate = Object.create || objectCreatePolyfill
  var objectKeys = Object.keys || objectKeysPolyfill
  var bind = Function.prototype.bind || functionBindPolyfill
  
  function EventEmitter() {
    if (!this._events || !Object.prototype.hasOwnProperty.call(this, '_events')) {
      this._events = objectCreate(null);
      this._eventsCount = 0;
    }
  
    this._maxListeners = this._maxListeners || undefined;
  }
  module.exports = EventEmitter;
  
  // Backwards-compat with node 0.10.x
  EventEmitter.EventEmitter = EventEmitter;
  
  EventEmitter.prototype._events = undefined;
  EventEmitter.prototype._maxListeners = undefined;
  
  // By default EventEmitters will print a warning if more than 10 listeners are
  // added to it. This is a useful default which helps finding memory leaks.
  var defaultMaxListeners = 10;
  
  var hasDefineProperty;
  try {
    var o = {};
    if (Object.defineProperty) Object.defineProperty(o, 'x', { value: 0 });
    hasDefineProperty = o.x === 0;
  } catch (err) { hasDefineProperty = false }
  if (hasDefineProperty) {
    Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
      enumerable: true,
      get: function() {
        return defaultMaxListeners;
      },
      set: function(arg) {
        // check whether the input is a positive number (whose value is zero or
        // greater and not a NaN).
        if (typeof arg !== 'number' || arg < 0 || arg !== arg)
          throw new TypeError('"defaultMaxListeners" must be a positive number');
        defaultMaxListeners = arg;
      }
    });
  } else {
    EventEmitter.defaultMaxListeners = defaultMaxListeners;
  }
  
  // Obviously not all Emitters should be limited to 10. This function allows
  // that to be increased. Set to zero for unlimited.
  EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
    if (typeof n !== 'number' || n < 0 || isNaN(n))
      throw new TypeError('"n" argument must be a positive number');
    this._maxListeners = n;
    return this;
  };
  
  function $getMaxListeners(that) {
    if (that._maxListeners === undefined)
      return EventEmitter.defaultMaxListeners;
    return that._maxListeners;
  }
  
  EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
    return $getMaxListeners(this);
  };
  
  // These standalone emit* functions are used to optimize calling of event
  // handlers for fast cases because emit() itself often has a variable number of
  // arguments and can be deoptimized because of that. These functions always have
  // the same number of arguments and thus do not get deoptimized, so the code
  // inside them can execute faster.
  function emitNone(handler, isFn, self) {
    if (isFn)
      handler.call(self);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self);
    }
  }
  function emitOne(handler, isFn, self, arg1) {
    if (isFn)
      handler.call(self, arg1);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self, arg1);
    }
  }
  function emitTwo(handler, isFn, self, arg1, arg2) {
    if (isFn)
      handler.call(self, arg1, arg2);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self, arg1, arg2);
    }
  }
  function emitThree(handler, isFn, self, arg1, arg2, arg3) {
    if (isFn)
      handler.call(self, arg1, arg2, arg3);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].call(self, arg1, arg2, arg3);
    }
  }
  
  function emitMany(handler, isFn, self, args) {
    if (isFn)
      handler.apply(self, args);
    else {
      var len = handler.length;
      var listeners = arrayClone(handler, len);
      for (var i = 0; i < len; ++i)
        listeners[i].apply(self, args);
    }
  }
  
  EventEmitter.prototype.emit = function emit(type) {
    var er, handler, len, args, i, events;
    var doError = (type === 'error');
  
    events = this._events;
    if (events)
      doError = (doError && events.error == null);
    else if (!doError)
      return false;
  
    // If there is no 'error' event listener then throw.
    if (doError) {
      if (arguments.length > 1)
        er = arguments[1];
      if (er instanceof Error) {
        throw er; // Unhandled 'error' event
      } else {
        // At least give some kind of context to the user
        var err = new Error('Unhandled "error" event. (' + er + ')');
        err.context = er;
        throw err;
      }
      return false;
    }
  
    handler = events[type];
  
    if (!handler)
      return false;
  
    var isFn = typeof handler === 'function';
    len = arguments.length;
    switch (len) {
        // fast cases
      case 1:
        emitNone(handler, isFn, this);
        break;
      case 2:
        emitOne(handler, isFn, this, arguments[1]);
        break;
      case 3:
        emitTwo(handler, isFn, this, arguments[1], arguments[2]);
        break;
      case 4:
        emitThree(handler, isFn, this, arguments[1], arguments[2], arguments[3]);
        break;
        // slower
      default:
        args = new Array(len - 1);
        for (i = 1; i < len; i++)
          args[i - 1] = arguments[i];
        emitMany(handler, isFn, this, args);
    }
  
    return true;
  };
  
  function _addListener(target, type, listener, prepend) {
    var m;
    var events;
    var existing;
  
    if (typeof listener !== 'function')
      throw new TypeError('"listener" argument must be a function');
  
    events = target._events;
    if (!events) {
      events = target._events = objectCreate(null);
      target._eventsCount = 0;
    } else {
      // To avoid recursion in the case that type === "newListener"! Before
      // adding it to the listeners, first emit "newListener".
      if (events.newListener) {
        target.emit('newListener', type,
            listener.listener ? listener.listener : listener);
  
        // Re-assign `events` because a newListener handler could have caused the
        // this._events to be assigned to a new object
        events = target._events;
      }
      existing = events[type];
    }
  
    if (!existing) {
      // Optimize the case of one listener. Don't need the extra array object.
      existing = events[type] = listener;
      ++target._eventsCount;
    } else {
      if (typeof existing === 'function') {
        // Adding the second element, need to change to array.
        existing = events[type] =
            prepend ? [listener, existing] : [existing, listener];
      } else {
        // If we've already got an array, just append.
        if (prepend) {
          existing.unshift(listener);
        } else {
          existing.push(listener);
        }
      }
  
      // Check for listener leak
      if (!existing.warned) {
        m = $getMaxListeners(target);
        if (m && m > 0 && existing.length > m) {
          existing.warned = true;
          var w = new Error('Possible EventEmitter memory leak detected. ' +
              existing.length + ' "' + String(type) + '" listeners ' +
              'added. Use emitter.setMaxListeners() to ' +
              'increase limit.');
          w.name = 'MaxListenersExceededWarning';
          w.emitter = target;
          w.type = type;
          w.count = existing.length;
          if (typeof console === 'object' && console.warn) {
            console.warn('%s: %s', w.name, w.message);
          }
        }
      }
    }
  
    return target;
  }
  
  EventEmitter.prototype.addListener = function addListener(type, listener) {
    return _addListener(this, type, listener, false);
  };
  
  EventEmitter.prototype.on = EventEmitter.prototype.addListener;
  
  EventEmitter.prototype.prependListener =
      function prependListener(type, listener) {
        return _addListener(this, type, listener, true);
      };
  
  function onceWrapper() {
    if (!this.fired) {
      this.target.removeListener(this.type, this.wrapFn);
      this.fired = true;
      switch (arguments.length) {
        case 0:
          return this.listener.call(this.target);
        case 1:
          return this.listener.call(this.target, arguments[0]);
        case 2:
          return this.listener.call(this.target, arguments[0], arguments[1]);
        case 3:
          return this.listener.call(this.target, arguments[0], arguments[1],
              arguments[2]);
        default:
          var args = new Array(arguments.length);
          for (var i = 0; i < args.length; ++i)
            args[i] = arguments[i];
          this.listener.apply(this.target, args);
      }
    }
  }
  
  function _onceWrap(target, type, listener) {
    var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
    var wrapped = bind.call(onceWrapper, state);
    wrapped.listener = listener;
    state.wrapFn = wrapped;
    return wrapped;
  }
  
  EventEmitter.prototype.once = function once(type, listener) {
    if (typeof listener !== 'function')
      throw new TypeError('"listener" argument must be a function');
    this.on(type, _onceWrap(this, type, listener));
    return this;
  };
  
  EventEmitter.prototype.prependOnceListener =
      function prependOnceListener(type, listener) {
        if (typeof listener !== 'function')
          throw new TypeError('"listener" argument must be a function');
        this.prependListener(type, _onceWrap(this, type, listener));
        return this;
      };
  
  // Emits a 'removeListener' event if and only if the listener was removed.
  EventEmitter.prototype.removeListener =
      function removeListener(type, listener) {
        var list, events, position, i, originalListener;
  
        if (typeof listener !== 'function')
          throw new TypeError('"listener" argument must be a function');
  
        events = this._events;
        if (!events)
          return this;
  
        list = events[type];
        if (!list)
          return this;
  
        if (list === listener || list.listener === listener) {
          if (--this._eventsCount === 0)
            this._events = objectCreate(null);
          else {
            delete events[type];
            if (events.removeListener)
              this.emit('removeListener', type, list.listener || listener);
          }
        } else if (typeof list !== 'function') {
          position = -1;
  
          for (i = list.length - 1; i >= 0; i--) {
            if (list[i] === listener || list[i].listener === listener) {
              originalListener = list[i].listener;
              position = i;
              break;
            }
          }
  
          if (position < 0)
            return this;
  
          if (position === 0)
            list.shift();
          else
            spliceOne(list, position);
  
          if (list.length === 1)
            events[type] = list[0];
  
          if (events.removeListener)
            this.emit('removeListener', type, originalListener || listener);
        }
  
        return this;
      };
  
  EventEmitter.prototype.removeAllListeners =
      function removeAllListeners(type) {
        var listeners, events, i;
  
        events = this._events;
        if (!events)
          return this;
  
        // not listening for removeListener, no need to emit
        if (!events.removeListener) {
          if (arguments.length === 0) {
            this._events = objectCreate(null);
            this._eventsCount = 0;
          } else if (events[type]) {
            if (--this._eventsCount === 0)
              this._events = objectCreate(null);
            else
              delete events[type];
          }
          return this;
        }
  
        // emit removeListener for all listeners on all events
        if (arguments.length === 0) {
          var keys = objectKeys(events);
          var key;
          for (i = 0; i < keys.length; ++i) {
            key = keys[i];
            if (key === 'removeListener') continue;
            this.removeAllListeners(key);
          }
          this.removeAllListeners('removeListener');
          this._events = objectCreate(null);
          this._eventsCount = 0;
          return this;
        }
  
        listeners = events[type];
  
        if (typeof listeners === 'function') {
          this.removeListener(type, listeners);
        } else if (listeners) {
          // LIFO order
          for (i = listeners.length - 1; i >= 0; i--) {
            this.removeListener(type, listeners[i]);
          }
        }
  
        return this;
      };
  
  function _listeners(target, type, unwrap) {
    var events = target._events;
  
    if (!events)
      return [];
  
    var evlistener = events[type];
    if (!evlistener)
      return [];
  
    if (typeof evlistener === 'function')
      return unwrap ? [evlistener.listener || evlistener] : [evlistener];
  
    return unwrap ? unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
  }
  
  EventEmitter.prototype.listeners = function listeners(type) {
    return _listeners(this, type, true);
  };
  
  EventEmitter.prototype.rawListeners = function rawListeners(type) {
    return _listeners(this, type, false);
  };
  
  EventEmitter.listenerCount = function(emitter, type) {
    if (typeof emitter.listenerCount === 'function') {
      return emitter.listenerCount(type);
    } else {
      return listenerCount.call(emitter, type);
    }
  };
  
  EventEmitter.prototype.listenerCount = listenerCount;
  function listenerCount(type) {
    var events = this._events;
  
    if (events) {
      var evlistener = events[type];
  
      if (typeof evlistener === 'function') {
        return 1;
      } else if (evlistener) {
        return evlistener.length;
      }
    }
  
    return 0;
  }
  
  EventEmitter.prototype.eventNames = function eventNames() {
    return this._eventsCount > 0 ? Reflect.ownKeys(this._events) : [];
  };
  
  // About 1.5x faster than the two-arg version of Array#splice().
  function spliceOne(list, index) {
    for (var i = index, k = i + 1, n = list.length; k < n; i += 1, k += 1)
      list[i] = list[k];
    list.pop();
  }
  
  function arrayClone(arr, n) {
    var copy = new Array(n);
    for (var i = 0; i < n; ++i)
      copy[i] = arr[i];
    return copy;
  }
  
  function unwrapListeners(arr) {
    var ret = new Array(arr.length);
    for (var i = 0; i < ret.length; ++i) {
      ret[i] = arr[i].listener || arr[i];
    }
    return ret;
  }
  
  function objectCreatePolyfill(proto) {
    var F = function() {};
    F.prototype = proto;
    return new F;
  }
  function objectKeysPolyfill(obj) {
    var keys = [];
    for (var k in obj) if (Object.prototype.hasOwnProperty.call(obj, k)) {
      keys.push(k);
    }
    return k;
  }
  function functionBindPolyfill(context) {
    var fn = this;
    return function () {
      return fn.apply(context, arguments);
    };
  }
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/debug/src/browser.js":[function(require,module,exports){
  (function (process){(function (){
  /* eslint-env browser */
  
  /**
   * This is the web browser implementation of `debug()`.
   */
  
  exports.formatArgs = formatArgs;
  exports.save = save;
  exports.load = load;
  exports.useColors = useColors;
  exports.storage = localstorage();
  exports.destroy = (() => {
    let warned = false;
  
    return () => {
      if (!warned) {
        warned = true;
        console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
      }
    };
  })();
  
  /**
   * Colors.
   */
  
  exports.colors = [
    '#0000CC',
    '#0000FF',
    '#0033CC',
    '#0033FF',
    '#0066CC',
    '#0066FF',
    '#0099CC',
    '#0099FF',
    '#00CC00',
    '#00CC33',
    '#00CC66',
    '#00CC99',
    '#00CCCC',
    '#00CCFF',
    '#3300CC',
    '#3300FF',
    '#3333CC',
    '#3333FF',
    '#3366CC',
    '#3366FF',
    '#3399CC',
    '#3399FF',
    '#33CC00',
    '#33CC33',
    '#33CC66',
    '#33CC99',
    '#33CCCC',
    '#33CCFF',
    '#6600CC',
    '#6600FF',
    '#6633CC',
    '#6633FF',
    '#66CC00',
    '#66CC33',
    '#9900CC',
    '#9900FF',
    '#9933CC',
    '#9933FF',
    '#99CC00',
    '#99CC33',
    '#CC0000',
    '#CC0033',
    '#CC0066',
    '#CC0099',
    '#CC00CC',
    '#CC00FF',
    '#CC3300',
    '#CC3333',
    '#CC3366',
    '#CC3399',
    '#CC33CC',
    '#CC33FF',
    '#CC6600',
    '#CC6633',
    '#CC9900',
    '#CC9933',
    '#CCCC00',
    '#CCCC33',
    '#FF0000',
    '#FF0033',
    '#FF0066',
    '#FF0099',
    '#FF00CC',
    '#FF00FF',
    '#FF3300',
    '#FF3333',
    '#FF3366',
    '#FF3399',
    '#FF33CC',
    '#FF33FF',
    '#FF6600',
    '#FF6633',
    '#FF9900',
    '#FF9933',
    '#FFCC00',
    '#FFCC33'
  ];
  
  /**
   * Currently only WebKit-based Web Inspectors, Firefox >= v31,
   * and the Firebug extension (any Firefox version) are known
   * to support "%c" CSS customizations.
   *
   * TODO: add a `localStorage` variable to explicitly enable/disable colors
   */
  
  // eslint-disable-next-line complexity
  function useColors() {
    // NB: In an Electron preload script, document will be defined but not fully
    // initialized. Since we know we're in Chrome, we'll just detect this case
    // explicitly
    if (typeof window !== 'undefined' && window.process && (window.process.type === 'renderer' || window.process.__nwjs)) {
      return true;
    }
  
    // Internet Explorer and Edge do not support colors.
    if (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/(edge|trident)\/(\d+)/)) {
      return false;
    }
  
    // Is webkit? http://stackoverflow.com/a/16459606/376773
    // document is undefined in react-native: https://github.com/facebook/react-native/pull/1632
    return (typeof document !== 'undefined' && document.documentElement && document.documentElement.style && document.documentElement.style.WebkitAppearance) ||
      // Is firebug? http://stackoverflow.com/a/398120/376773
      (typeof window !== 'undefined' && window.console && (window.console.firebug || (window.console.exception && window.console.table))) ||
      // Is firefox >= v31?
      // https://developer.mozilla.org/en-US/docs/Tools/Web_Console#Styling_messages
      (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/firefox\/(\d+)/) && parseInt(RegExp.$1, 10) >= 31) ||
      // Double check webkit in userAgent just in case we are in a worker
      (typeof navigator !== 'undefined' && navigator.userAgent && navigator.userAgent.toLowerCase().match(/applewebkit\/(\d+)/));
  }
  
  /**
   * Colorize log arguments if enabled.
   *
   * @api public
   */
  
  function formatArgs(args) {
    args[0] = (this.useColors ? '%c' : '') +
      this.namespace +
      (this.useColors ? ' %c' : ' ') +
      args[0] +
      (this.useColors ? '%c ' : ' ') +
      '+' + module.exports.humanize(this.diff);
  
    if (!this.useColors) {
      return;
    }
  
    const c = 'color: ' + this.color;
    args.splice(1, 0, c, 'color: inherit');
  
    // The final "%c" is somewhat tricky, because there could be other
    // arguments passed either before or after the %c, so we need to
    // figure out the correct index to insert the CSS into
    let index = 0;
    let lastC = 0;
    args[0].replace(/%[a-zA-Z%]/g, match => {
      if (match === '%%') {
        return;
      }
      index++;
      if (match === '%c') {
        // We only are interested in the *last* %c
        // (the user may have provided their own)
        lastC = index;
      }
    });
  
    args.splice(lastC, 0, c);
  }
  
  /**
   * Invokes `console.debug()` when available.
   * No-op when `console.debug` is not a "function".
   * If `console.debug` is not available, falls back
   * to `console.log`.
   *
   * @api public
   */
  exports.log = console.debug || console.log || (() => {});
  
  /**
   * Save `namespaces`.
   *
   * @param {String} namespaces
   * @api private
   */
  function save(namespaces) {
    try {
      if (namespaces) {
        exports.storage.setItem('debug', namespaces);
      } else {
        exports.storage.removeItem('debug');
      }
    } catch (error) {
      // Swallow
      // XXX (@Qix-) should we be logging these?
    }
  }
  
  /**
   * Load `namespaces`.
   *
   * @return {String} returns the previously persisted debug modes
   * @api private
   */
  function load() {
    let r;
    try {
      r = exports.storage.getItem('debug');
    } catch (error) {
      // Swallow
      // XXX (@Qix-) should we be logging these?
    }
  
    // If debug isn't set in LS, and we're in Electron, try to load $DEBUG
    if (!r && typeof process !== 'undefined' && 'env' in process) {
      r = process.env.DEBUG;
    }
  
    return r;
  }
  
  /**
   * Localstorage attempts to return the localstorage.
   *
   * This is necessary because safari throws
   * when a user disables cookies/localstorage
   * and you attempt to access it.
   *
   * @return {LocalStorage}
   * @api private
   */
  
  function localstorage() {
    try {
      // TVMLKit (Apple TV JS Runtime) does not have a window object, just localStorage in the global context
      // The Browser also has localStorage in the global context.
      return localStorage;
    } catch (error) {
      // Swallow
      // XXX (@Qix-) should we be logging these?
    }
  }
  
  module.exports = require('./common')(exports);
  
  const {formatters} = module.exports;
  
  /**
   * Map %j to `JSON.stringify()`, since no Web Inspectors do that by default.
   */
  
  formatters.j = function (v) {
    try {
      return JSON.stringify(v);
    } catch (error) {
      return '[UnexpectedJSONParseError]: ' + error.message;
    }
  };
  
  }).call(this)}).call(this,require('_process'))
  
  },{"./common":"/home/ubuntu/umbrella-voice2/app/node_modules/debug/src/common.js","_process":"/home/ubuntu/umbrella-voice2/app/node_modules/process/browser.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/debug/src/common.js":[function(require,module,exports){
  
  /**
   * This is the common logic for both the Node.js and web browser
   * implementations of `debug()`.
   */
  
  function setup(env) {
    createDebug.debug = createDebug;
    createDebug.default = createDebug;
    createDebug.coerce = coerce;
    createDebug.disable = disable;
    createDebug.enable = enable;
    createDebug.enabled = enabled;
    createDebug.humanize = require('ms');
    createDebug.destroy = destroy;
  
    Object.keys(env).forEach(key => {
      createDebug[key] = env[key];
    });
  
    /**
    * The currently active debug mode names, and names to skip.
    */
  
    createDebug.names = [];
    createDebug.skips = [];
  
    /**
    * Map of special "%n" handling functions, for the debug "format" argument.
    *
    * Valid key names are a single, lower or upper-case letter, i.e. "n" and "N".
    */
    createDebug.formatters = {};
  
    /**
    * Selects a color for a debug namespace
    * @param {String} namespace The namespace string for the for the debug instance to be colored
    * @return {Number|String} An ANSI color code for the given namespace
    * @api private
    */
    function selectColor(namespace) {
      let hash = 0;
  
      for (let i = 0; i < namespace.length; i++) {
        hash = ((hash << 5) - hash) + namespace.charCodeAt(i);
        hash |= 0; // Convert to 32bit integer
      }
  
      return createDebug.colors[Math.abs(hash) % createDebug.colors.length];
    }
    createDebug.selectColor = selectColor;
  
    /**
    * Create a debugger with the given `namespace`.
    *
    * @param {String} namespace
    * @return {Function}
    * @api public
    */
    function createDebug(namespace) {
      let prevTime;
      let enableOverride = null;
  
      function debug(...args) {
        // Disabled?
        if (!debug.enabled) {
          return;
        }
  
        const self = debug;
  
        // Set `diff` timestamp
        const curr = Number(new Date());
        const ms = curr - (prevTime || curr);
        self.diff = ms;
        self.prev = prevTime;
        self.curr = curr;
        prevTime = curr;
  
        args[0] = createDebug.coerce(args[0]);
  
        if (typeof args[0] !== 'string') {
          // Anything else let's inspect with %O
          args.unshift('%O');
        }
  
        // Apply any `formatters` transformations
        let index = 0;
        args[0] = args[0].replace(/%([a-zA-Z%])/g, (match, format) => {
          // If we encounter an escaped % then don't increase the array index
          if (match === '%%') {
            return '%';
          }
          index++;
          const formatter = createDebug.formatters[format];
          if (typeof formatter === 'function') {
            const val = args[index];
            match = formatter.call(self, val);
  
            // Now we need to remove `args[index]` since it's inlined in the `format`
            args.splice(index, 1);
            index--;
          }
          return match;
        });
  
        // Apply env-specific formatting (colors, etc.)
        createDebug.formatArgs.call(self, args);
  
        const logFn = self.log || createDebug.log;
        logFn.apply(self, args);
      }
  
      debug.namespace = namespace;
      debug.useColors = createDebug.useColors();
      debug.color = createDebug.selectColor(namespace);
      debug.extend = extend;
      debug.destroy = createDebug.destroy; // XXX Temporary. Will be removed in the next major release.
  
      Object.defineProperty(debug, 'enabled', {
        enumerable: true,
        configurable: false,
        get: () => enableOverride === null ? createDebug.enabled(namespace) : enableOverride,
        set: v => {
          enableOverride = v;
        }
      });
  
      // Env-specific initialization logic for debug instances
      if (typeof createDebug.init === 'function') {
        createDebug.init(debug);
      }
  
      return debug;
    }
  
    function extend(namespace, delimiter) {
      const newDebug = createDebug(this.namespace + (typeof delimiter === 'undefined' ? ':' : delimiter) + namespace);
      newDebug.log = this.log;
      return newDebug;
    }
  
    /**
    * Enables a debug mode by namespaces. This can include modes
    * separated by a colon and wildcards.
    *
    * @param {String} namespaces
    * @api public
    */
    function enable(namespaces) {
      createDebug.save(namespaces);
  
      createDebug.names = [];
      createDebug.skips = [];
  
      let i;
      const split = (typeof namespaces === 'string' ? namespaces : '').split(/[\s,]+/);
      const len = split.length;
  
      for (i = 0; i < len; i++) {
        if (!split[i]) {
          // ignore empty strings
          continue;
        }
  
        namespaces = split[i].replace(/\*/g, '.*?');
  
        if (namespaces[0] === '-') {
          createDebug.skips.push(new RegExp('^' + namespaces.substr(1) + '$'));
        } else {
          createDebug.names.push(new RegExp('^' + namespaces + '$'));
        }
      }
    }
  
    /**
    * Disable debug output.
    *
    * @return {String} namespaces
    * @api public
    */
    function disable() {
      const namespaces = [
        ...createDebug.names.map(toNamespace),
        ...createDebug.skips.map(toNamespace).map(namespace => '-' + namespace)
      ].join(',');
      createDebug.enable('');
      return namespaces;
    }
  
    /**
    * Returns true if the given mode name is enabled, false otherwise.
    *
    * @param {String} name
    * @return {Boolean}
    * @api public
    */
    function enabled(name) {
      if (name[name.length - 1] === '*') {
        return true;
      }
  
      let i;
      let len;
  
      for (i = 0, len = createDebug.skips.length; i < len; i++) {
        if (createDebug.skips[i].test(name)) {
          return false;
        }
      }
  
      for (i = 0, len = createDebug.names.length; i < len; i++) {
        if (createDebug.names[i].test(name)) {
          return true;
        }
      }
  
      return false;
    }
  
    /**
    * Convert regexp to namespace
    *
    * @param {RegExp} regxep
    * @return {String} namespace
    * @api private
    */
    function toNamespace(regexp) {
      return regexp.toString()
        .substring(2, regexp.toString().length - 2)
        .replace(/\.\*\?$/, '*');
    }
  
    /**
    * Coerce `val`.
    *
    * @param {Mixed} val
    * @return {Mixed}
    * @api private
    */
    function coerce(val) {
      if (val instanceof Error) {
        return val.stack || val.message;
      }
      return val;
    }
  
    /**
    * XXX DO NOT USE. This is a temporary stub function.
    * XXX It WILL be removed in the next major release.
    */
    function destroy() {
      console.warn('Instance method `debug.destroy()` is deprecated and no longer does anything. It will be removed in the next major version of `debug`.');
    }
  
    createDebug.enable(createDebug.load());
  
    return createDebug;
  }
  
  module.exports = setup;
  
  },{"ms":"/home/ubuntu/umbrella-voice2/app/node_modules/ms/index.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/domready/ready.js":[function(require,module,exports){
  /*!
    * domready (c) Dustin Diaz 2014 - License MIT
    */
  !function (name, definition) {
  
    if (typeof module != 'undefined') module.exports = definition()
    else if (typeof define == 'function' && typeof define.amd == 'object') define(definition)
    else this[name] = definition()
  
  }('domready', function () {
  
    var fns = [], listener
      , doc = document
      , hack = doc.documentElement.doScroll
      , domContentLoaded = 'DOMContentLoaded'
      , loaded = (hack ? /^loaded|^c/ : /^loaded|^i|^c/).test(doc.readyState)
  
  
    if (!loaded)
    doc.addEventListener(domContentLoaded, listener = function () {
      doc.removeEventListener(domContentLoaded, listener)
      loaded = 1
      while (listener = fns.shift()) listener()
    })
  
    return function (fn) {
      loaded ? setTimeout(fn, 0) : fns.push(fn)
    }
  
  });
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/es5-ext/global.js":[function(require,module,exports){
  var naiveFallback = function () {
    if (typeof self === "object" && self) return self;
    if (typeof window === "object" && window) return window;
    throw new Error("Unable to resolve global `this`");
  };
  
  module.exports = (function () {
    if (this) return this;
  
    // Unexpected strict mode (may happen if e.g. bundled into ESM module)
  
    // Fallback to standard globalThis if available
    if (typeof globalThis === "object" && globalThis) return globalThis;
  
    // Thanks @mathiasbynens -> https://mathiasbynens.be/notes/globalthis
    // In all ES5+ engines global object inherits from Object.prototype
    // (if you approached one that doesn't please report)
    try {
      Object.defineProperty(Object.prototype, "__global__", {
        get: function () { return this; },
        configurable: true
      });
    } catch (error) {
      // Unfortunate case of updates to Object.prototype being restricted
      // via preventExtensions, seal or freeze
      return naiveFallback();
    }
    try {
      // Safari case (window.__global__ works, but __global__ does not)
      if (!__global__) return naiveFallback();
      return __global__;
    } finally {
      delete Object.prototype.__global__;
    }
  })();
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/h264-profile-level-id/index.js":[function(require,module,exports){
  const debug = require('debug')('h264-profile-level-id');
  
  /* eslint-disable no-console */
  debug.log = console.info.bind(console);
  /* eslint-enable no-console */
  
  const ProfileConstrainedBaseline = 1;
  const ProfileBaseline = 2;
  const ProfileMain = 3;
  const ProfileConstrainedHigh = 4;
  const ProfileHigh = 5;
  
  exports.ProfileConstrainedBaseline = ProfileConstrainedBaseline;
  exports.ProfileBaseline = ProfileBaseline;
  exports.ProfileMain = ProfileMain;
  exports.ProfileConstrainedHigh = ProfileConstrainedHigh;
  exports.ProfileHigh = ProfileHigh;
  
  // All values are equal to ten times the level number, except level 1b which is
  // special.
  const Level1_b = 0;
  const Level1 = 10;
  const Level1_1 = 11;
  const Level1_2 = 12;
  const Level1_3 = 13;
  const Level2 = 20;
  const Level2_1 = 21;
  const Level2_2 = 22;
  const Level3 = 30;
  const Level3_1 = 31;
  const Level3_2 = 32;
  const Level4 = 40;
  const Level4_1 = 41;
  const Level4_2 = 42;
  const Level5 = 50;
  const Level5_1 = 51;
  const Level5_2 = 52;
  
  exports.Level1_b = Level1_b;
  exports.Level1 = Level1;
  exports.Level1_1 = Level1_1;
  exports.Level1_2 = Level1_2;
  exports.Level1_3 = Level1_3;
  exports.Level2 = Level2;
  exports.Level2_1 = Level2_1;
  exports.Level2_2 = Level2_2;
  exports.Level3 = Level3;
  exports.Level3_1 = Level3_1;
  exports.Level3_2 = Level3_2;
  exports.Level4 = Level4;
  exports.Level4_1 = Level4_1;
  exports.Level4_2 = Level4_2;
  exports.Level5 = Level5;
  exports.Level5_1 = Level5_1;
  exports.Level5_2 = Level5_2;
  
  class ProfileLevelId
  {
    constructor(profile, level)
    {
      this.profile = profile;
      this.level = level;
    }
  }
  
  exports.ProfileLevelId = ProfileLevelId;
  
  // Default ProfileLevelId.
  //
  // TODO: The default should really be profile Baseline and level 1 according to
  // the spec: https://tools.ietf.org/html/rfc6184#section-8.1. In order to not
  // break backwards compatibility with older versions of WebRTC where external
  // codecs don't have any parameters, use profile ConstrainedBaseline level 3_1
  // instead. This workaround will only be done in an interim period to allow
  // external clients to update their code.
  //
  // http://crbug/webrtc/6337.
  const DefaultProfileLevelId =
    new ProfileLevelId(ProfileConstrainedBaseline, Level3_1);
  
  // For level_idc=11 and profile_idc=0x42, 0x4D, or 0x58, the constraint set3
  // flag specifies if level 1b or level 1.1 is used.
  const ConstraintSet3Flag = 0x10;
  
  // Class for matching bit patterns such as "x1xx0000" where 'x' is allowed to be
  // either 0 or 1.
  class BitPattern
  {
    constructor(str)
    {
      this._mask = ~byteMaskString('x', str);
      this._maskedValue = byteMaskString('1', str);
    }
  
    isMatch(value)
    {
      return this._maskedValue === (value & this._mask);
    }
  }
  
  // Class for converting between profile_idc/profile_iop to Profile.
  class ProfilePattern
  {
    constructor(profile_idc, profile_iop, profile)
    {
      this.profile_idc = profile_idc;
      this.profile_iop = profile_iop;
      this.profile = profile;
    }
  }
  
  // This is from https://tools.ietf.org/html/rfc6184#section-8.1.
  const ProfilePatterns =
  [
    new ProfilePattern(0x42, new BitPattern('x1xx0000'), ProfileConstrainedBaseline),
    new ProfilePattern(0x4D, new BitPattern('1xxx0000'), ProfileConstrainedBaseline),
    new ProfilePattern(0x58, new BitPattern('11xx0000'), ProfileConstrainedBaseline),
    new ProfilePattern(0x42, new BitPattern('x0xx0000'), ProfileBaseline),
    new ProfilePattern(0x58, new BitPattern('10xx0000'), ProfileBaseline),
    new ProfilePattern(0x4D, new BitPattern('0x0x0000'), ProfileMain),
    new ProfilePattern(0x64, new BitPattern('00000000'), ProfileHigh),
    new ProfilePattern(0x64, new BitPattern('00001100'), ProfileConstrainedHigh)
  ];
  
  /**
   * Parse profile level id that is represented as a string of 3 hex bytes.
   * Nothing will be returned if the string is not a recognized H264 profile
   * level id.
   *
   * @param {String} str - profile-level-id value as a string of 3 hex bytes.
   *
   * @returns {ProfileLevelId}
   */
  exports.parseProfileLevelId = function(str)
  {
    // The string should consist of 3 bytes in hexadecimal format.
    if (typeof str !== 'string' || str.length !== 6)
      return null;
  
    const profile_level_id_numeric = parseInt(str, 16);
  
    if (profile_level_id_numeric === 0)
      return null;
  
    // Separate into three bytes.
    const level_idc = profile_level_id_numeric & 0xFF;
    const profile_iop = (profile_level_id_numeric >> 8) & 0xFF;
    const profile_idc = (profile_level_id_numeric >> 16) & 0xFF;
  
    // Parse level based on level_idc and constraint set 3 flag.
    let level;
  
    switch (level_idc)
    {
      case Level1_1:
      {
        level = (profile_iop & ConstraintSet3Flag) !== 0 ? Level1_b : Level1_1;
        break;
      }
      case Level1:
      case Level1_2:
      case Level1_3:
      case Level2:
      case Level2_1:
      case Level2_2:
      case Level3:
      case Level3_1:
      case Level3_2:
      case Level4:
      case Level4_1:
      case Level4_2:
      case Level5:
      case Level5_1:
      case Level5_2:
      {
        level = level_idc;
        break;
      }
      // Unrecognized level_idc.
      default:
      {
        debug('parseProfileLevelId() | unrecognized level_idc:%s', level_idc);
  
        return null;
      }
    }
  
    // Parse profile_idc/profile_iop into a Profile enum.
    for (const pattern of ProfilePatterns)
    {
      if (
        profile_idc === pattern.profile_idc &&
        pattern.profile_iop.isMatch(profile_iop)
      )
      {
        return new ProfileLevelId(pattern.profile, level);
      }
    }
  
    debug('parseProfileLevelId() | unrecognized profile_idc/profile_iop combination');
  
    return null;
  };
  
  /**
   * Returns canonical string representation as three hex bytes of the profile
   * level id, or returns nothing for invalid profile level ids.
   *
   * @param {ProfileLevelId} profile_level_id
   *
   * @returns {String}
   */
  exports.profileLevelIdToString = function(profile_level_id)
  {
    // Handle special case level == 1b.
    if (profile_level_id.level == Level1_b)
    {
      switch (profile_level_id.profile)
      {
        case ProfileConstrainedBaseline:
        {
          return '42f00b';
        }
        case ProfileBaseline:
        {
          return '42100b';
        }
        case ProfileMain:
        {
          return '4d100b';
        }
        // Level 1_b is not allowed for other profiles.
        default:
        {
          debug(
            'profileLevelIdToString() | Level 1_b not is allowed for profile:%s',
            profile_level_id.profile);
  
          return null;
        }
      }
    }
  
    let profile_idc_iop_string;
  
    switch (profile_level_id.profile)
    {
      case ProfileConstrainedBaseline:
      {
        profile_idc_iop_string = '42e0';
        break;
      }
      case ProfileBaseline:
      {
        profile_idc_iop_string = '4200';
        break;
      }
      case ProfileMain:
      {
        profile_idc_iop_string = '4d00';
        break;
      }
      case ProfileConstrainedHigh:
      {
        profile_idc_iop_string = '640c';
        break;
      }
      case ProfileHigh:
      {
        profile_idc_iop_string = '6400';
        break;
      }
      default:
      {
        debug(
          'profileLevelIdToString() | unrecognized profile:%s',
          profile_level_id.profile);
  
        return null;
      }
    }
  
    let levelStr = (profile_level_id.level).toString(16);
  
    if (levelStr.length === 1)
      levelStr = `0${levelStr}`;
  
    return `${profile_idc_iop_string}${levelStr}`;
  };
  
  /**
   * Parse profile level id that is represented as a string of 3 hex bytes
   * contained in an SDP key-value map. A default profile level id will be
   * returned if the profile-level-id key is missing. Nothing will be returned if
   * the key is present but the string is invalid.
   *
   * @param {Object} [params={}] - Codec parameters object.
   *
   * @returns {ProfileLevelId}
   */
  exports.parseSdpProfileLevelId = function(params = {})
  {
    const profile_level_id = params['profile-level-id'];
  
    return !profile_level_id
      ? DefaultProfileLevelId
      : exports.parseProfileLevelId(profile_level_id);
  };
  
  /**
   * Returns true if the parameters have the same H264 profile, i.e. the same
   * H264 profile (Baseline, High, etc).
   *
   * @param {Object} [params1={}] - Codec parameters object.
   * @param {Object} [params2={}] - Codec parameters object.
   *
   * @returns {Boolean}
   */
  exports.isSameProfile = function(params1 = {}, params2 = {})
  {
    const profile_level_id_1 = exports.parseSdpProfileLevelId(params1);
    const profile_level_id_2 = exports.parseSdpProfileLevelId(params2);
  
    // Compare H264 profiles, but not levels.
    return Boolean(
      profile_level_id_1 &&
      profile_level_id_2 &&
      profile_level_id_1.profile === profile_level_id_2.profile
    );
  };
  
  /**
   * Generate codec parameters that will be used as answer in an SDP negotiation
   * based on local supported parameters and remote offered parameters. Both
   * local_supported_params and remote_offered_params represent sendrecv media
   * descriptions, i.e they are a mix of both encode and decode capabilities. In
   * theory, when the profile in local_supported_params represent a strict superset
   * of the profile in remote_offered_params, we could limit the profile in the
   * answer to the profile in remote_offered_params.
   *
   * However, to simplify the code, each supported H264 profile should be listed
   * explicitly in the list of local supported codecs, even if they are redundant.
   * Then each local codec in the list should be tested one at a time against the
   * remote codec, and only when the profiles are equal should this function be
   * called. Therefore, this function does not need to handle profile intersection,
   * and the profile of local_supported_params and remote_offered_params must be
   * equal before calling this function. The parameters that are used when
   * negotiating are the level part of profile-level-id and level-asymmetry-allowed.
   *
   * @param {Object} [local_supported_params={}]
   * @param {Object} [remote_offered_params={}]
   *
   * @returns {String} Canonical string representation as three hex bytes of the
   *   profile level id, or null if no one of the params have profile-level-id.
   *
   * @throws {TypeError} If Profile mismatch or invalid params.
   */
  exports.generateProfileLevelIdForAnswer = function(
    local_supported_params = {},
    remote_offered_params = {}
  )
  {
    // If both local and remote params do not contain profile-level-id, they are
    // both using the default profile. In this case, don't return anything.
    if (
      !local_supported_params['profile-level-id'] &&
      !remote_offered_params['profile-level-id']
    )
    {
      debug(
        'generateProfileLevelIdForAnswer() | no profile-level-id in local and remote params');
  
      return null;
    }
  
    // Parse profile-level-ids.
    const local_profile_level_id =
      exports.parseSdpProfileLevelId(local_supported_params);
    const remote_profile_level_id =
      exports.parseSdpProfileLevelId(remote_offered_params);
  
    // The local and remote codec must have valid and equal H264 Profiles.
    if (!local_profile_level_id)
      throw new TypeError('invalid local_profile_level_id');
  
    if (!remote_profile_level_id)
      throw new TypeError('invalid remote_profile_level_id');
  
    if (local_profile_level_id.profile !== remote_profile_level_id.profile)
      throw new TypeError('H264 Profile mismatch');
  
    // Parse level information.
    const level_asymmetry_allowed = (
      isLevelAsymmetryAllowed(local_supported_params) &&
      isLevelAsymmetryAllowed(remote_offered_params)
    );
  
    const local_level = local_profile_level_id.level;
    const remote_level = remote_profile_level_id.level;
    const min_level = minLevel(local_level, remote_level);
  
    // Determine answer level. When level asymmetry is not allowed, level upgrade
    // is not allowed, i.e., the level in the answer must be equal to or lower
    // than the level in the offer.
    const answer_level = level_asymmetry_allowed ? local_level : min_level;
  
    debug(
      'generateProfileLevelIdForAnswer() | result: [profile:%s, level:%s]',
      local_profile_level_id.profile, answer_level);
  
    // Return the resulting profile-level-id for the answer parameters.
    return exports.profileLevelIdToString(
      new ProfileLevelId(local_profile_level_id.profile, answer_level));
  };
  
  // Convert a string of 8 characters into a byte where the positions containing
  // character c will have their bit set. For example, c = 'x', str = "x1xx0000"
  // will return 0b10110000.
  function byteMaskString(c, str)
  {
    return (
      ((str[0] === c) << 7) | ((str[1] === c) << 6) | ((str[2] === c) << 5) |
      ((str[3] === c) << 4)	| ((str[4] === c) << 3)	| ((str[5] === c) << 2)	|
      ((str[6] === c) << 1)	| ((str[7] === c) << 0)
    );
  }
  
  // Compare H264 levels and handle the level 1b case.
  function isLessLevel(a, b)
  {
    if (a === Level1_b)
      return b !== Level1 && b !== Level1_b;
  
    if (b === Level1_b)
      return a !== Level1;
  
    return a < b;
  }
  
  function minLevel(a, b)
  {
    return isLessLevel(a, b) ? a : b;
  }
  
  function isLevelAsymmetryAllowed(params = {})
  {
    const level_asymmetry_allowed = params['level-asymmetry-allowed'];
  
    return (
      level_asymmetry_allowed === 1 ||
      level_asymmetry_allowed === '1'
    );
  }
  
  },{"debug":"/home/ubuntu/umbrella-voice2/app/node_modules/debug/src/browser.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Consumer.js":[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Consumer = void 0;
  const Logger_1 = require("./Logger");
  const EnhancedEventEmitter_1 = require("./EnhancedEventEmitter");
  const errors_1 = require("./errors");
  const logger = new Logger_1.Logger('Consumer');
  class Consumer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
      /**
       * @emits transportclose
       * @emits trackended
       * @emits @getstats
       * @emits @close
       */
      constructor({ id, localId, producerId, rtpReceiver, track, rtpParameters, appData }) {
          super();
          // Closed flag.
          this._closed = false;
          // Observer instance.
          this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
          logger.debug('constructor()');
          this._id = id;
          this._localId = localId;
          this._producerId = producerId;
          this._rtpReceiver = rtpReceiver;
          this._track = track;
          this._rtpParameters = rtpParameters;
          this._paused = !track.enabled;
          this._appData = appData;
          this._onTrackEnded = this._onTrackEnded.bind(this);
          this._handleTrack();
      }
      /**
       * Consumer id.
       */
      get id() {
          return this._id;
      }
      /**
       * Local id.
       */
      get localId() {
          return this._localId;
      }
      /**
       * Associated Producer id.
       */
      get producerId() {
          return this._producerId;
      }
      /**
       * Whether the Consumer is closed.
       */
      get closed() {
          return this._closed;
      }
      /**
       * Media kind.
       */
      get kind() {
          return this._track.kind;
      }
      /**
       * Associated RTCRtpReceiver.
       */
      get rtpReceiver() {
          return this._rtpReceiver;
      }
      /**
       * The associated track.
       */
      get track() {
          return this._track;
      }
      /**
       * RTP parameters.
       */
      get rtpParameters() {
          return this._rtpParameters;
      }
      /**
       * Whether the Consumer is paused.
       */
      get paused() {
          return this._paused;
      }
      /**
       * App custom data.
       */
      get appData() {
          return this._appData;
      }
      /**
       * Invalid setter.
       */
      set appData(appData) {
          throw new Error('cannot override appData object');
      }
      /**
       * Observer.
       *
       * @emits close
       * @emits pause
       * @emits resume
       * @emits trackended
       */
      get observer() {
          return this._observer;
      }
      /**
       * Closes the Consumer.
       */
      close() {
          if (this._closed)
              return;
          logger.debug('close()');
          this._closed = true;
          this._destroyTrack();
          this.emit('@close');
          // Emit observer event.
          this._observer.safeEmit('close');
      }
      /**
       * Transport was closed.
       */
      transportClosed() {
          if (this._closed)
              return;
          logger.debug('transportClosed()');
          this._closed = true;
          this._destroyTrack();
          this.safeEmit('transportclose');
          // Emit observer event.
          this._observer.safeEmit('close');
      }
      /**
       * Get associated RTCRtpReceiver stats.
       */
      async getStats() {
          if (this._closed)
              throw new errors_1.InvalidStateError('closed');
          return this.safeEmitAsPromise('@getstats');
      }
      /**
       * Pauses receiving media.
       */
      pause() {
          logger.debug('pause()');
          if (this._closed) {
              logger.error('pause() | Consumer closed');
              return;
          }
          this._paused = true;
          this._track.enabled = false;
          // Emit observer event.
          this._observer.safeEmit('pause');
      }
      /**
       * Resumes receiving media.
       */
      resume() {
          logger.debug('resume()');
          if (this._closed) {
              logger.error('resume() | Consumer closed');
              return;
          }
          this._paused = false;
          this._track.enabled = true;
          // Emit observer event.
          this._observer.safeEmit('resume');
      }
      _onTrackEnded() {
          logger.debug('track "ended" event');
          this.safeEmit('trackended');
          // Emit observer event.
          this._observer.safeEmit('trackended');
      }
      _handleTrack() {
          this._track.addEventListener('ended', this._onTrackEnded);
      }
      _destroyTrack() {
          try {
              this._track.removeEventListener('ended', this._onTrackEnded);
              this._track.stop();
          }
          catch (error) { }
      }
  }
  exports.Consumer = Consumer;
  
  },{"./EnhancedEventEmitter":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/EnhancedEventEmitter.js","./Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Logger.js","./errors":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/errors.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/DataConsumer.js":[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DataConsumer = void 0;
  const Logger_1 = require("./Logger");
  const EnhancedEventEmitter_1 = require("./EnhancedEventEmitter");
  const logger = new Logger_1.Logger('DataConsumer');
  class DataConsumer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
      /**
       * @emits transportclose
       * @emits open
       * @emits error - (error: Error)
       * @emits close
       * @emits message - (message: any)
       * @emits @close
       */
      constructor({ id, dataProducerId, dataChannel, sctpStreamParameters, appData }) {
          super();
          // Closed flag.
          this._closed = false;
          // Observer instance.
          this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
          logger.debug('constructor()');
          this._id = id;
          this._dataProducerId = dataProducerId;
          this._dataChannel = dataChannel;
          this._sctpStreamParameters = sctpStreamParameters;
          this._appData = appData;
          this._handleDataChannel();
      }
      /**
       * DataConsumer id.
       */
      get id() {
          return this._id;
      }
      /**
       * Associated DataProducer id.
       */
      get dataProducerId() {
          return this._dataProducerId;
      }
      /**
       * Whether the DataConsumer is closed.
       */
      get closed() {
          return this._closed;
      }
      /**
       * SCTP stream parameters.
       */
      get sctpStreamParameters() {
          return this._sctpStreamParameters;
      }
      /**
       * DataChannel readyState.
       */
      get readyState() {
          return this._dataChannel.readyState;
      }
      /**
       * DataChannel label.
       */
      get label() {
          return this._dataChannel.label;
      }
      /**
       * DataChannel protocol.
       */
      get protocol() {
          return this._dataChannel.protocol;
      }
      /**
       * DataChannel binaryType.
       */
      get binaryType() {
          return this._dataChannel.binaryType;
      }
      /**
       * Set DataChannel binaryType.
       */
      set binaryType(binaryType) {
          this._dataChannel.binaryType = binaryType;
      }
      /**
       * App custom data.
       */
      get appData() {
          return this._appData;
      }
      /**
       * Invalid setter.
       */
      set appData(appData) {
          throw new Error('cannot override appData object');
      }
      /**
       * Observer.
       *
       * @emits close
       */
      get observer() {
          return this._observer;
      }
      /**
       * Closes the DataConsumer.
       */
      close() {
          if (this._closed)
              return;
          logger.debug('close()');
          this._closed = true;
          this._dataChannel.close();
          this.emit('@close');
          // Emit observer event.
          this._observer.safeEmit('close');
      }
      /**
       * Transport was closed.
       */
      transportClosed() {
          if (this._closed)
              return;
          logger.debug('transportClosed()');
          this._closed = true;
          this._dataChannel.close();
          this.safeEmit('transportclose');
          // Emit observer event.
          this._observer.safeEmit('close');
      }
      _handleDataChannel() {
          this._dataChannel.addEventListener('open', () => {
              if (this._closed)
                  return;
              logger.debug('DataChannel "open" event');
              this.safeEmit('open');
          });
          this._dataChannel.addEventListener('error', (event) => {
              if (this._closed)
                  return;
              let { error } = event;
              if (!error)
                  error = new Error('unknown DataChannel error');
              if (error.errorDetail === 'sctp-failure') {
                  logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);
              }
              else {
                  logger.error('DataChannel "error" event: %o', error);
              }
              this.safeEmit('error', error);
          });
          this._dataChannel.addEventListener('close', () => {
              if (this._closed)
                  return;
              logger.warn('DataChannel "close" event');
              this._closed = true;
              this.emit('@close');
              this.safeEmit('close');
          });
          this._dataChannel.addEventListener('message', (event) => {
              if (this._closed)
                  return;
              this.safeEmit('message', event.data);
          });
      }
  }
  exports.DataConsumer = DataConsumer;
  
  },{"./EnhancedEventEmitter":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/EnhancedEventEmitter.js","./Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Logger.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/DataProducer.js":[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.DataProducer = void 0;
  const Logger_1 = require("./Logger");
  const EnhancedEventEmitter_1 = require("./EnhancedEventEmitter");
  const errors_1 = require("./errors");
  const logger = new Logger_1.Logger('DataProducer');
  class DataProducer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
      /**
       * @emits transportclose
       * @emits open
       * @emits error - (error: Error)
       * @emits close
       * @emits bufferedamountlow
       * @emits @close
       */
      constructor({ id, dataChannel, sctpStreamParameters, appData }) {
          super();
          // Closed flag.
          this._closed = false;
          // Observer instance.
          this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
          logger.debug('constructor()');
          this._id = id;
          this._dataChannel = dataChannel;
          this._sctpStreamParameters = sctpStreamParameters;
          this._appData = appData;
          this._handleDataChannel();
      }
      /**
       * DataProducer id.
       */
      get id() {
          return this._id;
      }
      /**
       * Whether the DataProducer is closed.
       */
      get closed() {
          return this._closed;
      }
      /**
       * SCTP stream parameters.
       */
      get sctpStreamParameters() {
          return this._sctpStreamParameters;
      }
      /**
       * DataChannel readyState.
       */
      get readyState() {
          return this._dataChannel.readyState;
      }
      /**
       * DataChannel label.
       */
      get label() {
          return this._dataChannel.label;
      }
      /**
       * DataChannel protocol.
       */
      get protocol() {
          return this._dataChannel.protocol;
      }
      /**
       * DataChannel bufferedAmount.
       */
      get bufferedAmount() {
          return this._dataChannel.bufferedAmount;
      }
      /**
       * DataChannel bufferedAmountLowThreshold.
       */
      get bufferedAmountLowThreshold() {
          return this._dataChannel.bufferedAmountLowThreshold;
      }
      /**
       * Set DataChannel bufferedAmountLowThreshold.
       */
      set bufferedAmountLowThreshold(bufferedAmountLowThreshold) {
          this._dataChannel.bufferedAmountLowThreshold = bufferedAmountLowThreshold;
      }
      /**
       * App custom data.
       */
      get appData() {
          return this._appData;
      }
      /**
       * Invalid setter.
       */
      set appData(appData) {
          throw new Error('cannot override appData object');
      }
      /**
       * Observer.
       *
       * @emits close
       */
      get observer() {
          return this._observer;
      }
      /**
       * Closes the DataProducer.
       */
      close() {
          if (this._closed)
              return;
          logger.debug('close()');
          this._closed = true;
          this._dataChannel.close();
          this.emit('@close');
          // Emit observer event.
          this._observer.safeEmit('close');
      }
      /**
       * Transport was closed.
       */
      transportClosed() {
          if (this._closed)
              return;
          logger.debug('transportClosed()');
          this._closed = true;
          this._dataChannel.close();
          this.safeEmit('transportclose');
          // Emit observer event.
          this._observer.safeEmit('close');
      }
      /**
       * Send a message.
       *
       * @param {String|Blob|ArrayBuffer|ArrayBufferView} data.
       */
      send(data) {
          logger.debug('send()');
          if (this._closed)
              throw new errors_1.InvalidStateError('closed');
          this._dataChannel.send(data);
      }
      _handleDataChannel() {
          this._dataChannel.addEventListener('open', () => {
              if (this._closed)
                  return;
              logger.debug('DataChannel "open" event');
              this.safeEmit('open');
          });
          this._dataChannel.addEventListener('error', (event) => {
              if (this._closed)
                  return;
              let { error } = event;
              if (!error)
                  error = new Error('unknown DataChannel error');
              if (error.errorDetail === 'sctp-failure') {
                  logger.error('DataChannel SCTP error [sctpCauseCode:%s]: %s', error.sctpCauseCode, error.message);
              }
              else {
                  logger.error('DataChannel "error" event: %o', error);
              }
              this.safeEmit('error', error);
          });
          this._dataChannel.addEventListener('close', () => {
              if (this._closed)
                  return;
              logger.warn('DataChannel "close" event');
              this._closed = true;
              this.emit('@close');
              this.safeEmit('close');
          });
          this._dataChannel.addEventListener('message', () => {
              if (this._closed)
                  return;
              logger.warn('DataChannel "message" event in a DataProducer, message discarded');
          });
          this._dataChannel.addEventListener('bufferedamountlow', () => {
              if (this._closed)
                  return;
              this.safeEmit('bufferedamountlow');
          });
      }
  }
  exports.DataProducer = DataProducer;
  
  },{"./EnhancedEventEmitter":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/EnhancedEventEmitter.js","./Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Logger.js","./errors":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/errors.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Device.js":[function(require,module,exports){
  "use strict";
  /* global RTCRtpTransceiver */
  var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
      o["default"] = v;
  });
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
  };
  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Device = exports.detectDevice = void 0;
  const bowser_1 = __importDefault(require("bowser"));
  const Logger_1 = require("./Logger");
  const EnhancedEventEmitter_1 = require("./EnhancedEventEmitter");
  const errors_1 = require("./errors");
  const utils = __importStar(require("./utils"));
  const ortc = __importStar(require("./ortc"));
  const Transport_1 = require("./Transport");
  const Chrome74_1 = require("./handlers/Chrome74");
  const Chrome70_1 = require("./handlers/Chrome70");
  const Chrome67_1 = require("./handlers/Chrome67");
  const Chrome55_1 = require("./handlers/Chrome55");
  const Firefox60_1 = require("./handlers/Firefox60");
  const Safari12_1 = require("./handlers/Safari12");
  const Safari11_1 = require("./handlers/Safari11");
  const Edge11_1 = require("./handlers/Edge11");
  const ReactNative_1 = require("./handlers/ReactNative");
  const logger = new Logger_1.Logger('Device');
  function detectDevice() {
      // React-Native.
      // NOTE: react-native-webrtc >= 1.75.0 is required.
      if (typeof navigator === 'object' && navigator.product === 'ReactNative') {
          if (typeof RTCPeerConnection === 'undefined') {
              logger.warn('this._detectDevice() | unsupported ReactNative without RTCPeerConnection');
              return undefined;
          }
          logger.debug('this._detectDevice() | ReactNative handler chosen');
          return 'ReactNative';
      }
      // Browser.
      else if (typeof navigator === 'object' && typeof navigator.userAgent === 'string') {
          const ua = navigator.userAgent;
          const browser = bowser_1.default.getParser(ua);
          const engine = browser.getEngine();
          // Chrome and Chromium.
          if (browser.satisfies({ chrome: '>=74', chromium: '>=74' })) {
              return 'Chrome74';
          }
          else if (browser.satisfies({ chrome: '>=70', chromium: '>=70' })) {
              return 'Chrome70';
          }
          else if (browser.satisfies({ chrome: '>=67', chromium: '>=67' })) {
              return 'Chrome67';
          }
          else if (browser.satisfies({ chrome: '>=55', chromium: '>=55' })) {
              return 'Chrome55';
          }
          // Firefox.
          else if (browser.satisfies({ firefox: '>=60' })) {
              return 'Firefox60';
          }
          // Safari with Unified-Plan support enabled.
          else if (browser.satisfies({ safari: '>=12.0' }) &&
              typeof RTCRtpTransceiver !== 'undefined' &&
              RTCRtpTransceiver.prototype.hasOwnProperty('currentDirection')) {
              return 'Safari12';
          }
          // Safari with Plab-B support.
          else if (browser.satisfies({ safari: '>=11' })) {
              return 'Safari11';
          }
          // Old Edge with ORTC support.
          else if (browser.satisfies({ 'microsoft edge': '>=11' }) &&
              browser.satisfies({ 'microsoft edge': '<=18' })) {
              return 'Edge11';
          }
          // Best effort for Chromium based browsers.
          else if (engine.name && engine.name.toLowerCase() === 'blink') {
              const match = ua.match(/(?:(?:Chrome|Chromium))[ /](\w+)/i);
              if (match) {
                  const version = Number(match[1]);
                  if (version >= 74) {
                      return 'Chrome74';
                  }
                  else if (version >= 70) {
                      return 'Chrome70';
                  }
                  else if (version >= 67) {
                      return 'Chrome67';
                  }
                  else {
                      return 'Chrome55';
                  }
              }
              else {
                  return 'Chrome74';
              }
          }
          // Unsupported browser.
          else {
              logger.warn('this._detectDevice() | browser not supported [name:%s, version:%s]', browser.getBrowserName(), browser.getBrowserVersion());
              return undefined;
          }
      }
      // Unknown device.
      else {
          logger.warn('this._detectDevice() | unknown device');
          return undefined;
      }
  }
  exports.detectDevice = detectDevice;
  class Device {
      /**
       * Create a new Device to connect to mediasoup server.
       *
       * @throws {UnsupportedError} if device is not supported.
       */
      constructor({ handlerName, handlerFactory, Handler } = {}) {
          // Loaded flag.
          this._loaded = false;
          // Observer instance.
          this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
          logger.debug('constructor()');
          // Handle deprecated option.
          if (Handler) {
              logger.warn('constructor() | Handler option is DEPRECATED, use handlerName or handlerFactory instead');
              if (typeof Handler === 'string')
                  handlerName = Handler;
              else
                  throw new TypeError('non string Handler option no longer supported, use handlerFactory instead');
          }
          if (handlerName && handlerFactory) {
              throw new TypeError('just one of handlerName or handlerInterface can be given');
          }
          if (handlerFactory) {
              this._handlerFactory = handlerFactory;
          }
          else {
              if (handlerName) {
                  logger.debug('constructor() | handler given: %s', handlerName);
              }
              else {
                  handlerName = detectDevice();
                  if (handlerName)
                      logger.debug('constructor() | detected handler: %s', handlerName);
                  else
                      throw new errors_1.UnsupportedError('device not supported');
              }
              switch (handlerName) {
                  case 'Chrome74':
                      this._handlerFactory = Chrome74_1.Chrome74.createFactory();
                      break;
                  case 'Chrome70':
                      this._handlerFactory = Chrome70_1.Chrome70.createFactory();
                      break;
                  case 'Chrome67':
                      this._handlerFactory = Chrome67_1.Chrome67.createFactory();
                      break;
                  case 'Chrome55':
                      this._handlerFactory = Chrome55_1.Chrome55.createFactory();
                      break;
                  case 'Firefox60':
                      this._handlerFactory = Firefox60_1.Firefox60.createFactory();
                      break;
                  case 'Safari12':
                      this._handlerFactory = Safari12_1.Safari12.createFactory();
                      break;
                  case 'Safari11':
                      this._handlerFactory = Safari11_1.Safari11.createFactory();
                      break;
                  case 'Edge11':
                      this._handlerFactory = Edge11_1.Edge11.createFactory();
                      break;
                  case 'ReactNative':
                      this._handlerFactory = ReactNative_1.ReactNative.createFactory();
                      break;
                  default:
                      throw new TypeError(`unknown handlerName "${handlerName}"`);
              }
          }
          // Create a temporal handler to get its name.
          const handler = this._handlerFactory();
          this._handlerName = handler.name;
          handler.close();
          this._extendedRtpCapabilities = undefined;
          this._recvRtpCapabilities = undefined;
          this._canProduceByKind =
              {
                  audio: false,
                  video: false
              };
          this._sctpCapabilities = undefined;
      }
      /**
       * The RTC handler name.
       */
      get handlerName() {
          return this._handlerName;
      }
      /**
       * Whether the Device is loaded.
       */
      get loaded() {
          return this._loaded;
      }
      /**
       * RTP capabilities of the Device for receiving media.
       *
       * @throws {InvalidStateError} if not loaded.
       */
      get rtpCapabilities() {
          if (!this._loaded)
              throw new errors_1.InvalidStateError('not loaded');
          return this._recvRtpCapabilities;
      }
      /**
       * SCTP capabilities of the Device.
       *
       * @throws {InvalidStateError} if not loaded.
       */
      get sctpCapabilities() {
          if (!this._loaded)
              throw new errors_1.InvalidStateError('not loaded');
          return this._sctpCapabilities;
      }
      /**
       * Observer.
       *
       * @emits newtransport - (transport: Transport)
       */
      get observer() {
          return this._observer;
      }
      /**
       * Initialize the Device.
       */
      async load({ routerRtpCapabilities }) {
          logger.debug('load() [routerRtpCapabilities:%o]', routerRtpCapabilities);
          routerRtpCapabilities = utils.clone(routerRtpCapabilities, undefined);
          // Temporal handler to get its capabilities.
          let handler;
          try {
              if (this._loaded)
                  throw new errors_1.InvalidStateError('already loaded');
              // This may throw.
              ortc.validateRtpCapabilities(routerRtpCapabilities);
              handler = this._handlerFactory();
              const nativeRtpCapabilities = await handler.getNativeRtpCapabilities();
              logger.debug('load() | got native RTP capabilities:%o', nativeRtpCapabilities);
              // This may throw.
              ortc.validateRtpCapabilities(nativeRtpCapabilities);
              // Get extended RTP capabilities.
              this._extendedRtpCapabilities = ortc.getExtendedRtpCapabilities(nativeRtpCapabilities, routerRtpCapabilities);
              logger.debug('load() | got extended RTP capabilities:%o', this._extendedRtpCapabilities);
              // Check whether we can produce audio/video.
              this._canProduceByKind.audio =
                  ortc.canSend('audio', this._extendedRtpCapabilities);
              this._canProduceByKind.video =
                  ortc.canSend('video', this._extendedRtpCapabilities);
              // Generate our receiving RTP capabilities for receiving media.
              this._recvRtpCapabilities =
                  ortc.getRecvRtpCapabilities(this._extendedRtpCapabilities);
              // This may throw.
              ortc.validateRtpCapabilities(this._recvRtpCapabilities);
              logger.debug('load() | got receiving RTP capabilities:%o', this._recvRtpCapabilities);
              // Generate our SCTP capabilities.
              this._sctpCapabilities = await handler.getNativeSctpCapabilities();
              logger.debug('load() | got native SCTP capabilities:%o', this._sctpCapabilities);
              // This may throw.
              ortc.validateSctpCapabilities(this._sctpCapabilities);
              logger.debug('load() succeeded');
              this._loaded = true;
              handler.close();
          }
          catch (error) {
              if (handler)
                  handler.close();
              throw error;
          }
      }
      /**
       * Whether we can produce audio/video.
       *
       * @throws {InvalidStateError} if not loaded.
       * @throws {TypeError} if wrong arguments.
       */
      canProduce(kind) {
          if (!this._loaded)
              throw new errors_1.InvalidStateError('not loaded');
          else if (kind !== 'audio' && kind !== 'video')
              throw new TypeError(`invalid kind "${kind}"`);
          return this._canProduceByKind[kind];
      }
      /**
       * Creates a Transport for sending media.
       *
       * @throws {InvalidStateError} if not loaded.
       * @throws {TypeError} if wrong arguments.
       */
      createSendTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData = {} }) {
          logger.debug('createSendTransport()');
          return this._createTransport({
              direction: 'send',
              id: id,
              iceParameters: iceParameters,
              iceCandidates: iceCandidates,
              dtlsParameters: dtlsParameters,
              sctpParameters: sctpParameters,
              iceServers: iceServers,
              iceTransportPolicy: iceTransportPolicy,
              additionalSettings: additionalSettings,
              proprietaryConstraints: proprietaryConstraints,
              appData: appData
          });
      }
      /**
       * Creates a Transport for receiving media.
       *
       * @throws {InvalidStateError} if not loaded.
       * @throws {TypeError} if wrong arguments.
       */
      createRecvTransport({ id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData = {} }) {
          logger.debug('createRecvTransport()');
          return this._createTransport({
              direction: 'recv',
              id: id,
              iceParameters: iceParameters,
              iceCandidates: iceCandidates,
              dtlsParameters: dtlsParameters,
              sctpParameters: sctpParameters,
              iceServers: iceServers,
              iceTransportPolicy: iceTransportPolicy,
              additionalSettings: additionalSettings,
              proprietaryConstraints: proprietaryConstraints,
              appData: appData
          });
      }
      _createTransport({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData = {} }) {
          if (!this._loaded)
              throw new errors_1.InvalidStateError('not loaded');
          else if (typeof id !== 'string')
              throw new TypeError('missing id');
          else if (typeof iceParameters !== 'object')
              throw new TypeError('missing iceParameters');
          else if (!Array.isArray(iceCandidates))
              throw new TypeError('missing iceCandidates');
          else if (typeof dtlsParameters !== 'object')
              throw new TypeError('missing dtlsParameters');
          else if (sctpParameters && typeof sctpParameters !== 'object')
              throw new TypeError('wrong sctpParameters');
          else if (appData && typeof appData !== 'object')
              throw new TypeError('if given, appData must be an object');
          // Create a new Transport.
          const transport = new Transport_1.Transport({
              direction,
              id,
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
              iceServers,
              iceTransportPolicy,
              additionalSettings,
              proprietaryConstraints,
              appData,
              handlerFactory: this._handlerFactory,
              extendedRtpCapabilities: this._extendedRtpCapabilities,
              canProduceByKind: this._canProduceByKind
          });
          // Emit observer event.
          this._observer.safeEmit('newtransport', transport);
          return transport;
      }
  }
  exports.Device = Device;
  
  },{"./EnhancedEventEmitter":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/EnhancedEventEmitter.js","./Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Logger.js","./Transport":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Transport.js","./errors":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/errors.js","./handlers/Chrome55":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/Chrome55.js","./handlers/Chrome67":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/Chrome67.js","./handlers/Chrome70":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/Chrome70.js","./handlers/Chrome74":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/Chrome74.js","./handlers/Edge11":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/Edge11.js","./handlers/Firefox60":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/Firefox60.js","./handlers/ReactNative":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/ReactNative.js","./handlers/Safari11":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/Safari11.js","./handlers/Safari12":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/Safari12.js","./ortc":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/ortc.js","./utils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/utils.js","bowser":"/home/ubuntu/umbrella-voice2/app/node_modules/bowser/es5.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/EnhancedEventEmitter.js":[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.EnhancedEventEmitter = void 0;
  const events_1 = require("events");
  const Logger_1 = require("./Logger");
  const logger = new Logger_1.Logger('EnhancedEventEmitter');
  class EnhancedEventEmitter extends events_1.EventEmitter {
      constructor() {
          super();
          this.setMaxListeners(Infinity);
      }
      safeEmit(event, ...args) {
          const numListeners = this.listenerCount(event);
          try {
              return this.emit(event, ...args);
          }
          catch (error) {
              logger.error('safeEmit() | event listener threw an error [event:%s]:%o', event, error);
              return Boolean(numListeners);
          }
      }
      async safeEmitAsPromise(event, ...args) {
          return new Promise((resolve, reject) => {
              try {
                  this.emit(event, ...args, resolve, reject);
              }
              catch (error) {
                  logger.error('safeEmitAsPromise() | event listener threw an error [event:%s]:%o', event, error);
                  reject(error);
              }
          });
      }
  }
  exports.EnhancedEventEmitter = EnhancedEventEmitter;
  
  },{"./Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Logger.js","events":"/home/ubuntu/umbrella-voice2/app/node_modules/browserify/node_modules/events/events.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Logger.js":[function(require,module,exports){
  "use strict";
  var __importDefault = (this && this.__importDefault) || function (mod) {
      return (mod && mod.__esModule) ? mod : { "default": mod };
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Logger = void 0;
  const debug_1 = __importDefault(require("debug"));
  const APP_NAME = 'mediasoup-client';
  class Logger {
      constructor(prefix) {
          if (prefix) {
              this._debug = debug_1.default(`${APP_NAME}:${prefix}`);
              this._warn = debug_1.default(`${APP_NAME}:WARN:${prefix}`);
              this._error = debug_1.default(`${APP_NAME}:ERROR:${prefix}`);
          }
          else {
              this._debug = debug_1.default(APP_NAME);
              this._warn = debug_1.default(`${APP_NAME}:WARN`);
              this._error = debug_1.default(`${APP_NAME}:ERROR`);
          }
          /* eslint-disable no-console */
          this._debug.log = console.info.bind(console);
          this._warn.log = console.warn.bind(console);
          this._error.log = console.error.bind(console);
          /* eslint-enable no-console */
      }
      get debug() {
          return this._debug;
      }
      get warn() {
          return this._warn;
      }
      get error() {
          return this._error;
      }
  }
  exports.Logger = Logger;
  
  },{"debug":"/home/ubuntu/umbrella-voice2/app/node_modules/debug/src/browser.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Producer.js":[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Producer = void 0;
  const Logger_1 = require("./Logger");
  const EnhancedEventEmitter_1 = require("./EnhancedEventEmitter");
  const errors_1 = require("./errors");
  const logger = new Logger_1.Logger('Producer');
  class Producer extends EnhancedEventEmitter_1.EnhancedEventEmitter {
      /**
       * @emits transportclose
       * @emits trackended
       * @emits @replacetrack - (track: MediaStreamTrack | null)
       * @emits @setmaxspatiallayer - (spatialLayer: string)
       * @emits @setrtpencodingparameters - (params: any)
       * @emits @getstats
       * @emits @close
       */
      constructor({ id, localId, rtpSender, track, rtpParameters, stopTracks, disableTrackOnPause, zeroRtpOnPause, appData }) {
          super();
          // Closed flag.
          this._closed = false;
          // Observer instance.
          this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
          logger.debug('constructor()');
          this._id = id;
          this._localId = localId;
          this._rtpSender = rtpSender;
          this._track = track;
          this._kind = track.kind;
          this._rtpParameters = rtpParameters;
          this._paused = disableTrackOnPause ? !track.enabled : false;
          this._maxSpatialLayer = undefined;
          this._stopTracks = stopTracks;
          this._disableTrackOnPause = disableTrackOnPause;
          this._zeroRtpOnPause = zeroRtpOnPause;
          this._appData = appData;
          this._onTrackEnded = this._onTrackEnded.bind(this);
          // NOTE: Minor issue. If zeroRtpOnPause is true, we cannot emit the
          // '@replacetrack' event here, so RTCRtpSender.track won't be null.
          this._handleTrack();
      }
      /**
       * Producer id.
       */
      get id() {
          return this._id;
      }
      /**
       * Local id.
       */
      get localId() {
          return this._localId;
      }
      /**
       * Whether the Producer is closed.
       */
      get closed() {
          return this._closed;
      }
      /**
       * Media kind.
       */
      get kind() {
          return this._kind;
      }
      /**
       * Associated RTCRtpSender.
       */
      get rtpSender() {
          return this._rtpSender;
      }
      /**
       * The associated track.
       */
      get track() {
          return this._track;
      }
      /**
       * RTP parameters.
       */
      get rtpParameters() {
          return this._rtpParameters;
      }
      /**
       * Whether the Producer is paused.
       */
      get paused() {
          return this._paused;
      }
      /**
       * Max spatial layer.
       *
       * @type {Number | undefined}
       */
      get maxSpatialLayer() {
          return this._maxSpatialLayer;
      }
      /**
       * App custom data.
       */
      get appData() {
          return this._appData;
      }
      /**
       * Invalid setter.
       */
      set appData(appData) {
          throw new Error('cannot override appData object');
      }
      /**
       * Observer.
       *
       * @emits close
       * @emits pause
       * @emits resume
       * @emits trackended
       */
      get observer() {
          return this._observer;
      }
      /**
       * Closes the Producer.
       */
      close() {
          if (this._closed)
              return;
          logger.debug('close()');
          this._closed = true;
          this._destroyTrack();
          this.emit('@close');
          // Emit observer event.
          this._observer.safeEmit('close');
      }
      /**
       * Transport was closed.
       */
      transportClosed() {
          if (this._closed)
              return;
          logger.debug('transportClosed()');
          this._closed = true;
          this._destroyTrack();
          this.safeEmit('transportclose');
          // Emit observer event.
          this._observer.safeEmit('close');
      }
      /**
       * Get associated RTCRtpSender stats.
       */
      async getStats() {
          if (this._closed)
              throw new errors_1.InvalidStateError('closed');
          return this.safeEmitAsPromise('@getstats');
      }
      /**
       * Pauses sending media.
       */
      pause() {
          logger.debug('pause()');
          if (this._closed) {
              logger.error('pause() | Producer closed');
              return;
          }
          this._paused = true;
          if (this._track && this._disableTrackOnPause) {
              this._track.enabled = false;
          }
          if (this._zeroRtpOnPause) {
              this.safeEmitAsPromise('@replacetrack', null)
                  .catch(() => { });
          }
          // Emit observer event.
          this._observer.safeEmit('pause');
      }
      /**
       * Resumes sending media.
       */
      resume() {
          logger.debug('resume()');
          if (this._closed) {
              logger.error('resume() | Producer closed');
              return;
          }
          this._paused = false;
          if (this._track && this._disableTrackOnPause) {
              this._track.enabled = true;
          }
          if (this._zeroRtpOnPause) {
              this.safeEmitAsPromise('@replacetrack', this._track)
                  .catch(() => { });
          }
          // Emit observer event.
          this._observer.safeEmit('resume');
      }
      /**
       * Replaces the current track with a new one or null.
       */
      async replaceTrack({ track }) {
          logger.debug('replaceTrack() [track:%o]', track);
          if (this._closed) {
              // This must be done here. Otherwise there is no chance to stop the given
              // track.
              if (track && this._stopTracks) {
                  try {
                      track.stop();
                  }
                  catch (error) { }
              }
              throw new errors_1.InvalidStateError('closed');
          }
          else if (track && track.readyState === 'ended') {
              throw new errors_1.InvalidStateError('track ended');
          }
          // Do nothing if this is the same track as the current handled one.
          if (track === this._track) {
              logger.debug('replaceTrack() | same track, ignored');
              return;
          }
          if (!this._zeroRtpOnPause || !this._paused) {
              await this.safeEmitAsPromise('@replacetrack', track);
          }
          // Destroy the previous track.
          this._destroyTrack();
          // Set the new track.
          this._track = track;
          // If this Producer was paused/resumed and the state of the new
          // track does not match, fix it.
          if (this._track && this._disableTrackOnPause) {
              if (!this._paused)
                  this._track.enabled = true;
              else if (this._paused)
                  this._track.enabled = false;
          }
          // Handle the effective track.
          this._handleTrack();
      }
      /**
       * Sets the video max spatial layer to be sent.
       */
      async setMaxSpatialLayer(spatialLayer) {
          if (this._closed)
              throw new errors_1.InvalidStateError('closed');
          else if (this._kind !== 'video')
              throw new errors_1.UnsupportedError('not a video Producer');
          else if (typeof spatialLayer !== 'number')
              throw new TypeError('invalid spatialLayer');
          if (spatialLayer === this._maxSpatialLayer)
              return;
          await this.safeEmitAsPromise('@setmaxspatiallayer', spatialLayer);
          this._maxSpatialLayer = spatialLayer;
      }
      /**
       * Sets the DSCP value.
       */
      async setRtpEncodingParameters(params) {
          if (this._closed)
              throw new errors_1.InvalidStateError('closed');
          else if (typeof params !== 'object')
              throw new TypeError('invalid params');
          await this.safeEmitAsPromise('@setrtpencodingparameters', params);
      }
      _onTrackEnded() {
          logger.debug('track "ended" event');
          this.safeEmit('trackended');
          // Emit observer event.
          this._observer.safeEmit('trackended');
      }
      _handleTrack() {
          if (!this._track)
              return;
          this._track.addEventListener('ended', this._onTrackEnded);
      }
      _destroyTrack() {
          if (!this._track)
              return;
          try {
              this._track.removeEventListener('ended', this._onTrackEnded);
              // Just stop the track unless the app set stopTracks: false.
              if (this._stopTracks)
                  this._track.stop();
          }
          catch (error) { }
      }
  }
  exports.Producer = Producer;
  
  },{"./EnhancedEventEmitter":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/EnhancedEventEmitter.js","./Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Logger.js","./errors":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/errors.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/RtpParameters.js":[function(require,module,exports){
  "use strict";
  /**
   * The RTP capabilities define what mediasoup or an endpoint can receive at
   * media level.
   */
  Object.defineProperty(exports, "__esModule", { value: true });
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/SctpParameters.js":[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Transport.js":[function(require,module,exports){
  "use strict";
  var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
      o["default"] = v;
  });
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Transport = void 0;
  const awaitqueue_1 = require("awaitqueue");
  const Logger_1 = require("./Logger");
  const EnhancedEventEmitter_1 = require("./EnhancedEventEmitter");
  const errors_1 = require("./errors");
  const utils = __importStar(require("./utils"));
  const ortc = __importStar(require("./ortc"));
  const Producer_1 = require("./Producer");
  const Consumer_1 = require("./Consumer");
  const DataProducer_1 = require("./DataProducer");
  const DataConsumer_1 = require("./DataConsumer");
  const logger = new Logger_1.Logger('Transport');
  class Transport extends EnhancedEventEmitter_1.EnhancedEventEmitter {
      /**
       * @emits connect - (transportLocalParameters: any, callback: Function, errback: Function)
       * @emits connectionstatechange - (connectionState: ConnectionState)
       * @emits produce - (producerLocalParameters: any, callback: Function, errback: Function)
       * @emits producedata - (dataProducerLocalParameters: any, callback: Function, errback: Function)
       */
      constructor({ direction, id, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, appData, handlerFactory, extendedRtpCapabilities, canProduceByKind }) {
          super();
          // Closed flag.
          this._closed = false;
          // Transport connection state.
          this._connectionState = 'new';
          // Map of Producers indexed by id.
          this._producers = new Map();
          // Map of Consumers indexed by id.
          this._consumers = new Map();
          // Map of DataProducers indexed by id.
          this._dataProducers = new Map();
          // Map of DataConsumers indexed by id.
          this._dataConsumers = new Map();
          // Whether the Consumer for RTP probation has been created.
          this._probatorConsumerCreated = false;
          // AwaitQueue instance to make async tasks happen sequentially.
          this._awaitQueue = new awaitqueue_1.AwaitQueue({ ClosedErrorClass: errors_1.InvalidStateError });
          // Observer instance.
          this._observer = new EnhancedEventEmitter_1.EnhancedEventEmitter();
          logger.debug('constructor() [id:%s, direction:%s]', id, direction);
          this._id = id;
          this._direction = direction;
          this._extendedRtpCapabilities = extendedRtpCapabilities;
          this._canProduceByKind = canProduceByKind;
          this._maxSctpMessageSize =
              sctpParameters ? sctpParameters.maxMessageSize : null;
          // Clone and sanitize additionalSettings.
          additionalSettings = utils.clone(additionalSettings, {});
          delete additionalSettings.iceServers;
          delete additionalSettings.iceTransportPolicy;
          delete additionalSettings.bundlePolicy;
          delete additionalSettings.rtcpMuxPolicy;
          delete additionalSettings.sdpSemantics;
          this._handler = handlerFactory();
          this._handler.run({
              direction,
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
              iceServers,
              iceTransportPolicy,
              additionalSettings,
              proprietaryConstraints,
              extendedRtpCapabilities
          });
          this._appData = appData;
          this._handleHandler();
      }
      /**
       * Transport id.
       */
      get id() {
          return this._id;
      }
      /**
       * Whether the Transport is closed.
       */
      get closed() {
          return this._closed;
      }
      /**
       * Transport direction.
       */
      get direction() {
          return this._direction;
      }
      /**
       * RTC handler instance.
       */
      get handler() {
          return this._handler;
      }
      /**
       * Connection state.
       */
      get connectionState() {
          return this._connectionState;
      }
      /**
       * App custom data.
       */
      get appData() {
          return this._appData;
      }
      /**
       * Invalid setter.
       */
      set appData(appData) {
          throw new Error('cannot override appData object');
      }
      /**
       * Observer.
       *
       * @emits close
       * @emits newproducer - (producer: Producer)
       * @emits newconsumer - (producer: Producer)
       * @emits newdataproducer - (dataProducer: DataProducer)
       * @emits newdataconsumer - (dataProducer: DataProducer)
       */
      get observer() {
          return this._observer;
      }
      /**
       * Close the Transport.
       */
      close() {
          if (this._closed)
              return;
          logger.debug('close()');
          this._closed = true;
          // Close the AwaitQueue.
          this._awaitQueue.close();
          // Close the handler.
          this._handler.close();
          // Close all Producers.
          for (const producer of this._producers.values()) {
              producer.transportClosed();
          }
          this._producers.clear();
          // Close all Consumers.
          for (const consumer of this._consumers.values()) {
              consumer.transportClosed();
          }
          this._consumers.clear();
          // Close all DataProducers.
          for (const dataProducer of this._dataProducers.values()) {
              dataProducer.transportClosed();
          }
          this._dataProducers.clear();
          // Close all DataConsumers.
          for (const dataConsumer of this._dataConsumers.values()) {
              dataConsumer.transportClosed();
          }
          this._dataConsumers.clear();
          // Emit observer event.
          this._observer.safeEmit('close');
      }
      /**
       * Get associated Transport (RTCPeerConnection) stats.
       *
       * @returns {RTCStatsReport}
       */
      async getStats() {
          if (this._closed)
              throw new errors_1.InvalidStateError('closed');
          return this._handler.getTransportStats();
      }
      /**
       * Restart ICE connection.
       */
      async restartIce({ iceParameters }) {
          logger.debug('restartIce()');
          if (this._closed)
              throw new errors_1.InvalidStateError('closed');
          else if (!iceParameters)
              throw new TypeError('missing iceParameters');
          // Enqueue command.
          return this._awaitQueue.push(async () => this._handler.restartIce(iceParameters), 'transport.restartIce()');
      }
      /**
       * Update ICE servers.
       */
      async updateIceServers({ iceServers } = {}) {
          logger.debug('updateIceServers()');
          if (this._closed)
              throw new errors_1.InvalidStateError('closed');
          else if (!Array.isArray(iceServers))
              throw new TypeError('missing iceServers');
          // Enqueue command.
          return this._awaitQueue.push(async () => this._handler.updateIceServers(iceServers), 'transport.updateIceServers()');
      }
      /**
       * Create a Producer.
       */
      async produce({ track, encodings, codecOptions, codec, stopTracks = true, disableTrackOnPause = true, zeroRtpOnPause = false, appData = {} } = {}) {
          logger.debug('produce() [track:%o]', track);
          if (!track)
              throw new TypeError('missing track');
          else if (this._direction !== 'send')
              throw new errors_1.UnsupportedError('not a sending Transport');
          else if (!this._canProduceByKind[track.kind])
              throw new errors_1.UnsupportedError(`cannot produce ${track.kind}`);
          else if (track.readyState === 'ended')
              throw new errors_1.InvalidStateError('track ended');
          else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')
              throw new TypeError('no "connect" listener set into this transport');
          else if (this.listenerCount('produce') === 0)
              throw new TypeError('no "produce" listener set into this transport');
          else if (appData && typeof appData !== 'object')
              throw new TypeError('if given, appData must be an object');
          // Enqueue command.
          return this._awaitQueue.push(async () => {
              let normalizedEncodings;
              if (encodings && !Array.isArray(encodings)) {
                  throw TypeError('encodings must be an array');
              }
              else if (encodings && encodings.length === 0) {
                  normalizedEncodings = undefined;
              }
              else if (encodings) {
                  normalizedEncodings = encodings
                      .map((encoding) => {
                      const normalizedEncoding = { active: true };
                      if (encoding.active === false)
                          normalizedEncoding.active = false;
                      if (typeof encoding.dtx === 'boolean')
                          normalizedEncoding.dtx = encoding.dtx;
                      if (typeof encoding.scalabilityMode === 'string')
                          normalizedEncoding.scalabilityMode = encoding.scalabilityMode;
                      if (typeof encoding.scaleResolutionDownBy === 'number')
                          normalizedEncoding.scaleResolutionDownBy = encoding.scaleResolutionDownBy;
                      if (typeof encoding.maxBitrate === 'number')
                          normalizedEncoding.maxBitrate = encoding.maxBitrate;
                      if (typeof encoding.maxFramerate === 'number')
                          normalizedEncoding.maxFramerate = encoding.maxFramerate;
                      if (typeof encoding.adaptivePtime === 'boolean')
                          normalizedEncoding.adaptivePtime = encoding.adaptivePtime;
                      if (typeof encoding.priority === 'string')
                          normalizedEncoding.priority = encoding.priority;
                      if (typeof encoding.networkPriority === 'string')
                          normalizedEncoding.networkPriority = encoding.networkPriority;
                      return normalizedEncoding;
                  });
              }
              const { localId, rtpParameters, rtpSender } = await this._handler.send({
                  track,
                  encodings: normalizedEncodings,
                  codecOptions,
                  codec
              });
              try {
                  // This will fill rtpParameters's missing fields with default values.
                  ortc.validateRtpParameters(rtpParameters);
                  const { id } = await this.safeEmitAsPromise('produce', {
                      kind: track.kind,
                      rtpParameters,
                      appData
                  });
                  const producer = new Producer_1.Producer({
                      id,
                      localId,
                      rtpSender,
                      track,
                      rtpParameters,
                      stopTracks,
                      disableTrackOnPause,
                      zeroRtpOnPause,
                      appData
                  });
                  this._producers.set(producer.id, producer);
                  this._handleProducer(producer);
                  // Emit observer event.
                  this._observer.safeEmit('newproducer', producer);
                  return producer;
              }
              catch (error) {
                  this._handler.stopSending(localId)
                      .catch(() => { });
                  throw error;
              }
          }, 'transport.produce()')
              // This catch is needed to stop the given track if the command above
              // failed due to closed Transport.
              .catch((error) => {
              if (stopTracks) {
                  try {
                      track.stop();
                  }
                  catch (error2) { }
              }
              throw error;
          });
      }
      /**
       * Create a Consumer to consume a remote Producer.
       */
      async consume({ id, producerId, kind, rtpParameters, appData = {} }) {
          logger.debug('consume()');
          rtpParameters = utils.clone(rtpParameters, undefined);
          if (this._closed)
              throw new errors_1.InvalidStateError('closed');
          else if (this._direction !== 'recv')
              throw new errors_1.UnsupportedError('not a receiving Transport');
          else if (typeof id !== 'string')
              throw new TypeError('missing id');
          else if (typeof producerId !== 'string')
              throw new TypeError('missing producerId');
          else if (kind !== 'audio' && kind !== 'video')
              throw new TypeError(`invalid kind '${kind}'`);
          else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')
              throw new TypeError('no "connect" listener set into this transport');
          else if (appData && typeof appData !== 'object')
              throw new TypeError('if given, appData must be an object');
          // Enqueue command.
          return this._awaitQueue.push(async () => {
              // Ensure the device can consume it.
              const canConsume = ortc.canReceive(rtpParameters, this._extendedRtpCapabilities);
              if (!canConsume)
                  throw new errors_1.UnsupportedError('cannot consume this Producer');
              const { localId, rtpReceiver, track } = await this._handler.receive({ trackId: id, kind, rtpParameters });
              const consumer = new Consumer_1.Consumer({
                  id,
                  localId,
                  producerId,
                  rtpReceiver,
                  track,
                  rtpParameters,
                  appData
              });
              this._consumers.set(consumer.id, consumer);
              this._handleConsumer(consumer);
              // If this is the first video Consumer and the Consumer for RTP probation
              // has not yet been created, create it now.
              if (!this._probatorConsumerCreated && kind === 'video') {
                  try {
                      const probatorRtpParameters = ortc.generateProbatorRtpParameters(consumer.rtpParameters);
                      await this._handler.receive({
                          trackId: 'probator',
                          kind: 'video',
                          rtpParameters: probatorRtpParameters
                      });
                      logger.debug('consume() | Consumer for RTP probation created');
                      this._probatorConsumerCreated = true;
                  }
                  catch (error) {
                      logger.error('consume() | failed to create Consumer for RTP probation:%o', error);
                  }
              }
              // Emit observer event.
              this._observer.safeEmit('newconsumer', consumer);
              return consumer;
          }, 'transport.consume()');
      }
      /**
       * Create a DataProducer
       */
      async produceData({ ordered = true, maxPacketLifeTime, maxRetransmits, label = '', protocol = '', appData = {} } = {}) {
          logger.debug('produceData()');
          if (this._direction !== 'send')
              throw new errors_1.UnsupportedError('not a sending Transport');
          else if (!this._maxSctpMessageSize)
              throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');
          else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')
              throw new TypeError('no "connect" listener set into this transport');
          else if (this.listenerCount('producedata') === 0)
              throw new TypeError('no "producedata" listener set into this transport');
          else if (appData && typeof appData !== 'object')
              throw new TypeError('if given, appData must be an object');
          if (maxPacketLifeTime || maxRetransmits)
              ordered = false;
          // Enqueue command.
          return this._awaitQueue.push(async () => {
              const { dataChannel, sctpStreamParameters } = await this._handler.sendDataChannel({
                  ordered,
                  maxPacketLifeTime,
                  maxRetransmits,
                  label,
                  protocol
              });
              // This will fill sctpStreamParameters's missing fields with default values.
              ortc.validateSctpStreamParameters(sctpStreamParameters);
              const { id } = await this.safeEmitAsPromise('producedata', {
                  sctpStreamParameters,
                  label,
                  protocol,
                  appData
              });
              const dataProducer = new DataProducer_1.DataProducer({ id, dataChannel, sctpStreamParameters, appData });
              this._dataProducers.set(dataProducer.id, dataProducer);
              this._handleDataProducer(dataProducer);
              // Emit observer event.
              this._observer.safeEmit('newdataproducer', dataProducer);
              return dataProducer;
          }, 'transport.produceData()');
      }
      /**
       * Create a DataConsumer
       */
      async consumeData({ id, dataProducerId, sctpStreamParameters, label = '', protocol = '', appData = {} }) {
          logger.debug('consumeData()');
          sctpStreamParameters = utils.clone(sctpStreamParameters, undefined);
          if (this._closed)
              throw new errors_1.InvalidStateError('closed');
          else if (this._direction !== 'recv')
              throw new errors_1.UnsupportedError('not a receiving Transport');
          else if (!this._maxSctpMessageSize)
              throw new errors_1.UnsupportedError('SCTP not enabled by remote Transport');
          else if (typeof id !== 'string')
              throw new TypeError('missing id');
          else if (typeof dataProducerId !== 'string')
              throw new TypeError('missing dataProducerId');
          else if (this.listenerCount('connect') === 0 && this._connectionState === 'new')
              throw new TypeError('no "connect" listener set into this transport');
          else if (appData && typeof appData !== 'object')
              throw new TypeError('if given, appData must be an object');
          // This may throw.
          ortc.validateSctpStreamParameters(sctpStreamParameters);
          // Enqueue command.
          return this._awaitQueue.push(async () => {
              const { dataChannel } = await this._handler.receiveDataChannel({
                  sctpStreamParameters,
                  label,
                  protocol
              });
              const dataConsumer = new DataConsumer_1.DataConsumer({
                  id,
                  dataProducerId,
                  dataChannel,
                  sctpStreamParameters,
                  appData
              });
              this._dataConsumers.set(dataConsumer.id, dataConsumer);
              this._handleDataConsumer(dataConsumer);
              // Emit observer event.
              this._observer.safeEmit('newdataconsumer', dataConsumer);
              return dataConsumer;
          }, 'transport.consumeData()');
      }
      _handleHandler() {
          const handler = this._handler;
          handler.on('@connect', ({ dtlsParameters }, callback, errback) => {
              if (this._closed) {
                  errback(new errors_1.InvalidStateError('closed'));
                  return;
              }
              this.safeEmit('connect', { dtlsParameters }, callback, errback);
          });
          handler.on('@connectionstatechange', (connectionState) => {
              if (connectionState === this._connectionState)
                  return;
              logger.debug('connection state changed to %s', connectionState);
              this._connectionState = connectionState;
              if (!this._closed)
                  this.safeEmit('connectionstatechange', connectionState);
          });
      }
      _handleProducer(producer) {
          producer.on('@close', () => {
              this._producers.delete(producer.id);
              if (this._closed)
                  return;
              this._awaitQueue.push(async () => this._handler.stopSending(producer.localId), 'producer @close event')
                  .catch((error) => logger.warn('producer.close() failed:%o', error));
          });
          producer.on('@replacetrack', (track, callback, errback) => {
              this._awaitQueue.push(async () => this._handler.replaceTrack(producer.localId, track), 'producer @replacetrack event')
                  .then(callback)
                  .catch(errback);
          });
          producer.on('@setmaxspatiallayer', (spatialLayer, callback, errback) => {
              this._awaitQueue.push(async () => (this._handler.setMaxSpatialLayer(producer.localId, spatialLayer)), 'producer @setmaxspatiallayer event')
                  .then(callback)
                  .catch(errback);
          });
          producer.on('@setrtpencodingparameters', (params, callback, errback) => {
              this._awaitQueue.push(async () => (this._handler.setRtpEncodingParameters(producer.localId, params)), 'producer @setrtpencodingparameters event')
                  .then(callback)
                  .catch(errback);
          });
          producer.on('@getstats', (callback, errback) => {
              if (this._closed)
                  return errback(new errors_1.InvalidStateError('closed'));
              this._handler.getSenderStats(producer.localId)
                  .then(callback)
                  .catch(errback);
          });
      }
      _handleConsumer(consumer) {
          consumer.on('@close', () => {
              this._consumers.delete(consumer.id);
              if (this._closed)
                  return;
              this._awaitQueue.push(async () => this._handler.stopReceiving(consumer.localId), 'consumer @close event')
                  .catch(() => { });
          });
          consumer.on('@getstats', (callback, errback) => {
              if (this._closed)
                  return errback(new errors_1.InvalidStateError('closed'));
              this._handler.getReceiverStats(consumer.localId)
                  .then(callback)
                  .catch(errback);
          });
      }
      _handleDataProducer(dataProducer) {
          dataProducer.on('@close', () => {
              this._dataProducers.delete(dataProducer.id);
          });
      }
      _handleDataConsumer(dataConsumer) {
          dataConsumer.on('@close', () => {
              this._dataConsumers.delete(dataConsumer.id);
          });
      }
  }
  exports.Transport = Transport;
  
  },{"./Consumer":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Consumer.js","./DataConsumer":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/DataConsumer.js","./DataProducer":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/DataProducer.js","./EnhancedEventEmitter":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/EnhancedEventEmitter.js","./Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Logger.js","./Producer":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Producer.js","./errors":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/errors.js","./ortc":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/ortc.js","./utils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/utils.js","awaitqueue":"/home/ubuntu/umbrella-voice2/app/node_modules/awaitqueue/lib/index.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/errors.js":[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.InvalidStateError = exports.UnsupportedError = void 0;
  /**
   * Error indicating not support for something.
   */
  class UnsupportedError extends Error {
      constructor(message) {
          super(message);
          this.name = 'UnsupportedError';
          if (Error.hasOwnProperty('captureStackTrace')) // Just in V8.
           {
              // @ts-ignore
              Error.captureStackTrace(this, UnsupportedError);
          }
          else {
              this.stack = (new Error(message)).stack;
          }
      }
  }
  exports.UnsupportedError = UnsupportedError;
  /**
   * Error produced when calling a method in an invalid state.
   */
  class InvalidStateError extends Error {
      constructor(message) {
          super(message);
          this.name = 'InvalidStateError';
          if (Error.hasOwnProperty('captureStackTrace')) // Just in V8.
           {
              // @ts-ignore
              Error.captureStackTrace(this, InvalidStateError);
          }
          else {
              this.stack = (new Error(message)).stack;
          }
      }
  }
  exports.InvalidStateError = InvalidStateError;
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/Chrome55.js":[function(require,module,exports){
  "use strict";
  var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
      o["default"] = v;
  });
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Chrome55 = void 0;
  const sdpTransform = __importStar(require("sdp-transform"));
  const Logger_1 = require("../Logger");
  const errors_1 = require("../errors");
  const utils = __importStar(require("../utils"));
  const ortc = __importStar(require("../ortc"));
  const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
  const sdpPlanBUtils = __importStar(require("./sdp/planBUtils"));
  const HandlerInterface_1 = require("./HandlerInterface");
  const RemoteSdp_1 = require("./sdp/RemoteSdp");
  const logger = new Logger_1.Logger('Chrome55');
  const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
  class Chrome55 extends HandlerInterface_1.HandlerInterface {
      constructor() {
          super();
          // Local stream for sending.
          this._sendStream = new MediaStream();
          // Map of sending MediaStreamTracks indexed by localId.
          this._mapSendLocalIdTrack = new Map();
          // Next sending localId.
          this._nextSendLocalId = 0;
          // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
          // Value is an Object with mid, rtpParameters and rtpReceiver.
          this._mapRecvLocalIdInfo = new Map();
          // Whether a DataChannel m=application section has been created.
          this._hasDataChannelMediaSection = false;
          // Sending DataChannel id value counter. Incremented for each new DataChannel.
          this._nextSendSctpStreamId = 0;
          // Got transport local and remote parameters.
          this._transportReady = false;
      }
      /**
       * Creates a factory function.
       */
      static createFactory() {
          return () => new Chrome55();
      }
      get name() {
          return 'Chrome55';
      }
      close() {
          logger.debug('close()');
          // Close RTCPeerConnection.
          if (this._pc) {
              try {
                  this._pc.close();
              }
              catch (error) { }
          }
      }
      async getNativeRtpCapabilities() {
          logger.debug('getNativeRtpCapabilities()');
          const pc = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: 'all',
              bundlePolicy: 'max-bundle',
              rtcpMuxPolicy: 'require',
              sdpSemantics: 'plan-b'
          });
          try {
              const offer = await pc.createOffer({
                  offerToReceiveAudio: true,
                  offerToReceiveVideo: true
              });
              try {
                  pc.close();
              }
              catch (error) { }
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });
              return nativeRtpCapabilities;
          }
          catch (error) {
              try {
                  pc.close();
              }
              catch (error2) { }
              throw error;
          }
      }
      async getNativeSctpCapabilities() {
          logger.debug('getNativeSctpCapabilities()');
          return {
              numStreams: SCTP_NUM_STREAMS
          };
      }
      run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger.debug('run()');
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
              planB: true
          });
          this._sendingRtpParametersByKind =
              {
                  audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
                  video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
              };
          this._sendingRemoteRtpParametersByKind =
              {
                  audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
                  video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
              };
          this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'plan-b' }, additionalSettings), proprietaryConstraints);
          // Handle RTCPeerConnection connection status.
          this._pc.addEventListener('iceconnectionstatechange', () => {
              switch (this._pc.iceConnectionState) {
                  case 'checking':
                      this.emit('@connectionstatechange', 'connecting');
                      break;
                  case 'connected':
                  case 'completed':
                      this.emit('@connectionstatechange', 'connected');
                      break;
                  case 'failed':
                      this.emit('@connectionstatechange', 'failed');
                      break;
                  case 'disconnected':
                      this.emit('@connectionstatechange', 'disconnected');
                      break;
                  case 'closed':
                      this.emit('@connectionstatechange', 'closed');
                      break;
              }
          });
      }
      async updateIceServers(iceServers) {
          logger.debug('updateIceServers()');
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
      }
      async restartIce(iceParameters) {
          logger.debug('restartIce()');
          // Provide the remote SDP handler with new remote ICE parameters.
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady)
              return;
          if (this._direction === 'send') {
              const offer = await this._pc.createOffer({ iceRestart: true });
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              await this._pc.setLocalDescription(offer);
              const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setRemoteDescription(answer);
          }
          else {
              const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
              await this._pc.setLocalDescription(answer);
          }
      }
      async getTransportStats() {
          return this._pc.getStats();
      }
      async send({ track, encodings, codecOptions, codec }) {
          this._assertSendDirection();
          logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
          if (codec) {
              logger.warn('send() | codec selection is not available in %s handler', this.name);
          }
          this._sendStream.addTrack(track);
          this._pc.addStream(this._sendStream);
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
          sendingRtpParameters.codecs =
              ortc.reduceCodecs(sendingRtpParameters.codecs);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
          sendingRemoteRtpParameters.codecs =
              ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
          if (!this._transportReady)
              await this._setupTransport({ localDtlsRole: 'server', localSdpObject });
          if (track.kind === 'video' && encodings && encodings.length > 1) {
              logger.debug('send() | enabling simulcast');
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');
              sdpPlanBUtils.addLegacySimulcast({
                  offerMediaObject,
                  track,
                  numStreams: encodings.length
              });
              offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
          }
          logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
          await this._pc.setLocalDescription(offer);
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media
              .find((m) => m.type === track.kind);
          // Set RTCP CNAME.
          sendingRtpParameters.rtcp.cname =
              sdpCommonUtils.getCname({ offerMediaObject });
          // Set RTP encodings.
          sendingRtpParameters.encodings =
              sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });
          // Complete encodings with given values.
          if (encodings) {
              for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                  if (encodings[idx])
                      Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
          }
          // If VP8 and there is effective simulcast, add scalabilityMode to each
          // encoding.
          if (sendingRtpParameters.encodings.length > 1 &&
              sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {
              for (const encoding of sendingRtpParameters.encodings) {
                  encoding.scalabilityMode = 'S1T3';
              }
          }
          this._remoteSdp.send({
              offerMediaObject,
              offerRtpParameters: sendingRtpParameters,
              answerRtpParameters: sendingRemoteRtpParameters,
              codecOptions
          });
          const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
          logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
          await this._pc.setRemoteDescription(answer);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          // Insert into the map.
          this._mapSendLocalIdTrack.set(localId, track);
          return {
              localId: localId,
              rtpParameters: sendingRtpParameters
          };
      }
      async stopSending(localId) {
          this._assertSendDirection();
          logger.debug('stopSending() [localId:%s]', localId);
          const track = this._mapSendLocalIdTrack.get(localId);
          if (!track)
              throw new Error('track not found');
          this._mapSendLocalIdTrack.delete(localId);
          this._sendStream.removeTrack(track);
          this._pc.addStream(this._sendStream);
          const offer = await this._pc.createOffer();
          logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
          try {
              await this._pc.setLocalDescription(offer);
          }
          catch (error) {
              // NOTE: If there are no sending tracks, setLocalDescription() will fail with
              // "Failed to create channels". If so, ignore it.
              if (this._sendStream.getTracks().length === 0) {
                  logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());
                  return;
              }
              throw error;
          }
          if (this._pc.signalingState === 'stable')
              return;
          const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
          logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
          await this._pc.setRemoteDescription(answer);
      }
      async replaceTrack(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localId, track) {
          throw new errors_1.UnsupportedError('not implemented');
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async setMaxSpatialLayer(localId, spatialLayer) {
          throw new errors_1.UnsupportedError(' not implemented');
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async setRtpEncodingParameters(localId, params) {
          throw new errors_1.UnsupportedError('not supported');
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async getSenderStats(localId) {
          throw new errors_1.UnsupportedError('not implemented');
      }
      async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this._assertSendDirection();
          const options = {
              negotiated: true,
              id: this._nextSendSctpStreamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmitTime: maxPacketLifeTime,
              maxRetransmits,
              protocol
          };
          logger.debug('sendDataChannel() [options:%o]', options);
          const dataChannel = this._pc.createDataChannel(label, options);
          // Increase next id.
          this._nextSendSctpStreamId =
              ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          // If this is the first DataChannel we need to create the SDP answer with
          // m=application section.
          if (!this._hasDataChannelMediaSection) {
              const offer = await this._pc.createOffer();
              const localSdpObject = sdpTransform.parse(offer.sdp);
              const offerMediaObject = localSdpObject.media
                  .find((m) => m.type === 'application');
              if (!this._transportReady)
                  await this._setupTransport({ localDtlsRole: 'server', localSdpObject });
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              await this._pc.setLocalDescription(offer);
              this._remoteSdp.sendSctpAssociation({ offerMediaObject });
              const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setRemoteDescription(answer);
              this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
              streamId: options.id,
              ordered: options.ordered,
              maxPacketLifeTime: options.maxPacketLifeTime,
              maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
      }
      async receive({ trackId, kind, rtpParameters }) {
          this._assertRecvDirection();
          logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
          const localId = trackId;
          const mid = kind;
          const streamId = rtpParameters.rtcp.cname;
          this._remoteSdp.receive({
              mid,
              kind,
              offerRtpParameters: rtpParameters,
              streamId,
              trackId
          });
          const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
          logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          const answerMediaObject = localSdpObject.media
              .find((m) => String(m.mid) === mid);
          // May need to modify codec parameters in the answer based on codec
          // parameters in the offer.
          sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
          });
          answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady)
              await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
          logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
          await this._pc.setLocalDescription(answer);
          const stream = this._pc.getRemoteStreams()
              .find((s) => s.id === streamId);
          const track = stream.getTrackById(localId);
          if (!track)
              throw new Error('remote track not found');
          // Insert into the map.
          this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });
          return { localId, track };
      }
      async stopReceiving(localId) {
          this._assertRecvDirection();
          logger.debug('stopReceiving() [localId:%s]', localId);
          const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};
          // Remove from the map.
          this._mapRecvLocalIdInfo.delete(localId);
          this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });
          const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
          logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
          await this._pc.setLocalDescription(answer);
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async getReceiverStats(localId) {
          throw new errors_1.UnsupportedError('not implemented');
      }
      async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this._assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
              negotiated: true,
              id: streamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmitTime: maxPacketLifeTime,
              maxRetransmits,
              protocol
          };
          logger.debug('receiveDataChannel() [options:%o]', options);
          const dataChannel = this._pc.createDataChannel(label, options);
          // If this is the first DataChannel we need to create the SDP offer with
          // m=application section.
          if (!this._hasDataChannelMediaSection) {
              this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
              const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              if (!this._transportReady) {
                  const localSdpObject = sdpTransform.parse(answer.sdp);
                  await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
              }
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setLocalDescription(answer);
              this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
      }
      async _setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject)
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          // Get our local DTLS parameters.
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });
          // Set our DTLS role.
          dtlsParameters.role = localDtlsRole;
          // Update the remote DTLS role in the SDP.
          this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
          // Need to tell the remote transport about our parameters.
          await this.safeEmitAsPromise('@connect', { dtlsParameters });
          this._transportReady = true;
      }
      _assertSendDirection() {
          if (this._direction !== 'send') {
              throw new Error('method can just be called for handlers with "send" direction');
          }
      }
      _assertRecvDirection() {
          if (this._direction !== 'recv') {
              throw new Error('method can just be called for handlers with "recv" direction');
          }
      }
  }
  exports.Chrome55 = Chrome55;
  
  },{"../Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Logger.js","../errors":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/errors.js","../ortc":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/ortc.js","../utils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/utils.js","./HandlerInterface":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js","./sdp/RemoteSdp":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js","./sdp/commonUtils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js","./sdp/planBUtils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js","sdp-transform":"/home/ubuntu/umbrella-voice2/app/node_modules/sdp-transform/lib/index.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/Chrome67.js":[function(require,module,exports){
  "use strict";
  var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
      o["default"] = v;
  });
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Chrome67 = void 0;
  const sdpTransform = __importStar(require("sdp-transform"));
  const Logger_1 = require("../Logger");
  const utils = __importStar(require("../utils"));
  const ortc = __importStar(require("../ortc"));
  const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
  const sdpPlanBUtils = __importStar(require("./sdp/planBUtils"));
  const HandlerInterface_1 = require("./HandlerInterface");
  const RemoteSdp_1 = require("./sdp/RemoteSdp");
  const logger = new Logger_1.Logger('Chrome67');
  const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
  class Chrome67 extends HandlerInterface_1.HandlerInterface {
      constructor() {
          super();
          // Local stream for sending.
          this._sendStream = new MediaStream();
          // Map of RTCRtpSender indexed by localId.
          this._mapSendLocalIdRtpSender = new Map();
          // Next sending localId.
          this._nextSendLocalId = 0;
          // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
          // Value is an Object with mid, rtpParameters and rtpReceiver.
          this._mapRecvLocalIdInfo = new Map();
          // Whether a DataChannel m=application section has been created.
          this._hasDataChannelMediaSection = false;
          // Sending DataChannel id value counter. Incremented for each new DataChannel.
          this._nextSendSctpStreamId = 0;
          // Got transport local and remote parameters.
          this._transportReady = false;
      }
      /**
       * Creates a factory function.
       */
      static createFactory() {
          return () => new Chrome67();
      }
      get name() {
          return 'Chrome67';
      }
      close() {
          logger.debug('close()');
          // Close RTCPeerConnection.
          if (this._pc) {
              try {
                  this._pc.close();
              }
              catch (error) { }
          }
      }
      async getNativeRtpCapabilities() {
          logger.debug('getNativeRtpCapabilities()');
          const pc = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: 'all',
              bundlePolicy: 'max-bundle',
              rtcpMuxPolicy: 'require',
              sdpSemantics: 'plan-b'
          });
          try {
              const offer = await pc.createOffer({
                  offerToReceiveAudio: true,
                  offerToReceiveVideo: true
              });
              try {
                  pc.close();
              }
              catch (error) { }
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });
              return nativeRtpCapabilities;
          }
          catch (error) {
              try {
                  pc.close();
              }
              catch (error2) { }
              throw error;
          }
      }
      async getNativeSctpCapabilities() {
          logger.debug('getNativeSctpCapabilities()');
          return {
              numStreams: SCTP_NUM_STREAMS
          };
      }
      run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger.debug('run()');
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
              planB: true
          });
          this._sendingRtpParametersByKind =
              {
                  audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
                  video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
              };
          this._sendingRemoteRtpParametersByKind =
              {
                  audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
                  video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
              };
          this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'plan-b' }, additionalSettings), proprietaryConstraints);
          // Handle RTCPeerConnection connection status.
          this._pc.addEventListener('iceconnectionstatechange', () => {
              switch (this._pc.iceConnectionState) {
                  case 'checking':
                      this.emit('@connectionstatechange', 'connecting');
                      break;
                  case 'connected':
                  case 'completed':
                      this.emit('@connectionstatechange', 'connected');
                      break;
                  case 'failed':
                      this.emit('@connectionstatechange', 'failed');
                      break;
                  case 'disconnected':
                      this.emit('@connectionstatechange', 'disconnected');
                      break;
                  case 'closed':
                      this.emit('@connectionstatechange', 'closed');
                      break;
              }
          });
      }
      async updateIceServers(iceServers) {
          logger.debug('updateIceServers()');
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
      }
      async restartIce(iceParameters) {
          logger.debug('restartIce()');
          // Provide the remote SDP handler with new remote ICE parameters.
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady)
              return;
          if (this._direction === 'send') {
              const offer = await this._pc.createOffer({ iceRestart: true });
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              await this._pc.setLocalDescription(offer);
              const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setRemoteDescription(answer);
          }
          else {
              const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
              await this._pc.setLocalDescription(answer);
          }
      }
      async getTransportStats() {
          return this._pc.getStats();
      }
      async send({ track, encodings, codecOptions, codec }) {
          this._assertSendDirection();
          logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
          if (codec) {
              logger.warn('send() | codec selection is not available in %s handler', this.name);
          }
          this._sendStream.addTrack(track);
          this._pc.addTrack(track, this._sendStream);
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
          sendingRtpParameters.codecs =
              ortc.reduceCodecs(sendingRtpParameters.codecs);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
          sendingRemoteRtpParameters.codecs =
              ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
          if (!this._transportReady)
              await this._setupTransport({ localDtlsRole: 'server', localSdpObject });
          if (track.kind === 'video' && encodings && encodings.length > 1) {
              logger.debug('send() | enabling simulcast');
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media
                  .find((m) => m.type === 'video');
              sdpPlanBUtils.addLegacySimulcast({
                  offerMediaObject,
                  track,
                  numStreams: encodings.length
              });
              offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
          }
          logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
          await this._pc.setLocalDescription(offer);
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media
              .find((m) => m.type === track.kind);
          // Set RTCP CNAME.
          sendingRtpParameters.rtcp.cname =
              sdpCommonUtils.getCname({ offerMediaObject });
          // Set RTP encodings.
          sendingRtpParameters.encodings =
              sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });
          // Complete encodings with given values.
          if (encodings) {
              for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                  if (encodings[idx])
                      Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
          }
          // If VP8 and there is effective simulcast, add scalabilityMode to each
          // encoding.
          if (sendingRtpParameters.encodings.length > 1 &&
              sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {
              for (const encoding of sendingRtpParameters.encodings) {
                  encoding.scalabilityMode = 'S1T3';
              }
          }
          this._remoteSdp.send({
              offerMediaObject,
              offerRtpParameters: sendingRtpParameters,
              answerRtpParameters: sendingRemoteRtpParameters,
              codecOptions
          });
          const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
          logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
          await this._pc.setRemoteDescription(answer);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          const rtpSender = this._pc.getSenders()
              .find((s) => s.track === track);
          // Insert into the map.
          this._mapSendLocalIdRtpSender.set(localId, rtpSender);
          return {
              localId: localId,
              rtpParameters: sendingRtpParameters,
              rtpSender
          };
      }
      async stopSending(localId) {
          this._assertSendDirection();
          logger.debug('stopSending() [localId:%s]', localId);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender)
              throw new Error('associated RTCRtpSender not found');
          this._pc.removeTrack(rtpSender);
          if (rtpSender.track)
              this._sendStream.removeTrack(rtpSender.track);
          this._mapSendLocalIdRtpSender.delete(localId);
          const offer = await this._pc.createOffer();
          logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
          try {
              await this._pc.setLocalDescription(offer);
          }
          catch (error) {
              // NOTE: If there are no sending tracks, setLocalDescription() will fail with
              // "Failed to create channels". If so, ignore it.
              if (this._sendStream.getTracks().length === 0) {
                  logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());
                  return;
              }
              throw error;
          }
          if (this._pc.signalingState === 'stable')
              return;
          const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
          logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
          await this._pc.setRemoteDescription(answer);
      }
      async replaceTrack(localId, track) {
          this._assertSendDirection();
          if (track) {
              logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
          }
          else {
              logger.debug('replaceTrack() [localId:%s, no track]', localId);
          }
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender)
              throw new Error('associated RTCRtpSender not found');
          const oldTrack = rtpSender.track;
          await rtpSender.replaceTrack(track);
          // Remove the old track from the local stream.
          if (oldTrack)
              this._sendStream.removeTrack(oldTrack);
          // Add the new track to the local stream.
          if (track)
              this._sendStream.addTrack(track);
      }
      async setMaxSpatialLayer(localId, spatialLayer) {
          this._assertSendDirection();
          logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender)
              throw new Error('associated RTCRtpSender not found');
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
              if (idx <= spatialLayer)
                  encoding.active = true;
              else
                  encoding.active = false;
          });
          await rtpSender.setParameters(parameters);
      }
      async setRtpEncodingParameters(localId, params) {
          this._assertSendDirection();
          logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender)
              throw new Error('associated RTCRtpSender not found');
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
              parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);
          });
          await rtpSender.setParameters(parameters);
      }
      async getSenderStats(localId) {
          this._assertSendDirection();
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender)
              throw new Error('associated RTCRtpSender not found');
          return rtpSender.getStats();
      }
      async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this._assertSendDirection();
          const options = {
              negotiated: true,
              id: this._nextSendSctpStreamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmitTime: maxPacketLifeTime,
              maxRetransmits,
              protocol
          };
          logger.debug('sendDataChannel() [options:%o]', options);
          const dataChannel = this._pc.createDataChannel(label, options);
          // Increase next id.
          this._nextSendSctpStreamId =
              ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          // If this is the first DataChannel we need to create the SDP answer with
          // m=application section.
          if (!this._hasDataChannelMediaSection) {
              const offer = await this._pc.createOffer();
              const localSdpObject = sdpTransform.parse(offer.sdp);
              const offerMediaObject = localSdpObject.media
                  .find((m) => m.type === 'application');
              if (!this._transportReady)
                  await this._setupTransport({ localDtlsRole: 'server', localSdpObject });
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              await this._pc.setLocalDescription(offer);
              this._remoteSdp.sendSctpAssociation({ offerMediaObject });
              const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setRemoteDescription(answer);
              this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
              streamId: options.id,
              ordered: options.ordered,
              maxPacketLifeTime: options.maxPacketLifeTime,
              maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
      }
      async receive({ trackId, kind, rtpParameters }) {
          this._assertRecvDirection();
          logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
          const localId = trackId;
          const mid = kind;
          this._remoteSdp.receive({
              mid,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: rtpParameters.rtcp.cname,
              trackId
          });
          const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
          logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          const answerMediaObject = localSdpObject.media
              .find((m) => String(m.mid) === mid);
          // May need to modify codec parameters in the answer based on codec
          // parameters in the offer.
          sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
          });
          answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady)
              await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
          logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
          await this._pc.setLocalDescription(answer);
          const rtpReceiver = this._pc.getReceivers()
              .find((r) => r.track && r.track.id === localId);
          if (!rtpReceiver)
              throw new Error('new RTCRtpReceiver not');
          // Insert into the map.
          this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters, rtpReceiver });
          return {
              localId,
              track: rtpReceiver.track,
              rtpReceiver
          };
      }
      async stopReceiving(localId) {
          this._assertRecvDirection();
          logger.debug('stopReceiving() [localId:%s]', localId);
          const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};
          // Remove from the map.
          this._mapRecvLocalIdInfo.delete(localId);
          this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });
          const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
          logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
          await this._pc.setLocalDescription(answer);
      }
      async getReceiverStats(localId) {
          this._assertRecvDirection();
          const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};
          if (!rtpReceiver)
              throw new Error('associated RTCRtpReceiver not found');
          return rtpReceiver.getStats();
      }
      async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this._assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
              negotiated: true,
              id: streamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmitTime: maxPacketLifeTime,
              maxRetransmits,
              protocol
          };
          logger.debug('receiveDataChannel() [options:%o]', options);
          const dataChannel = this._pc.createDataChannel(label, options);
          // If this is the first DataChannel we need to create the SDP offer with
          // m=application section.
          if (!this._hasDataChannelMediaSection) {
              this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
              const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              if (!this._transportReady) {
                  const localSdpObject = sdpTransform.parse(answer.sdp);
                  await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
              }
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setLocalDescription(answer);
              this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
      }
      async _setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject)
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          // Get our local DTLS parameters.
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });
          // Set our DTLS role.
          dtlsParameters.role = localDtlsRole;
          // Update the remote DTLS role in the SDP.
          this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
          // Need to tell the remote transport about our parameters.
          await this.safeEmitAsPromise('@connect', { dtlsParameters });
          this._transportReady = true;
      }
      _assertSendDirection() {
          if (this._direction !== 'send') {
              throw new Error('method can just be called for handlers with "send" direction');
          }
      }
      _assertRecvDirection() {
          if (this._direction !== 'recv') {
              throw new Error('method can just be called for handlers with "recv" direction');
          }
      }
  }
  exports.Chrome67 = Chrome67;
  
  },{"../Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Logger.js","../ortc":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/ortc.js","../utils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/utils.js","./HandlerInterface":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js","./sdp/RemoteSdp":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js","./sdp/commonUtils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js","./sdp/planBUtils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js","sdp-transform":"/home/ubuntu/umbrella-voice2/app/node_modules/sdp-transform/lib/index.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/Chrome70.js":[function(require,module,exports){
  "use strict";
  var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
      o["default"] = v;
  });
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Chrome70 = void 0;
  const sdpTransform = __importStar(require("sdp-transform"));
  const Logger_1 = require("../Logger");
  const utils = __importStar(require("../utils"));
  const ortc = __importStar(require("../ortc"));
  const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
  const sdpUnifiedPlanUtils = __importStar(require("./sdp/unifiedPlanUtils"));
  const HandlerInterface_1 = require("./HandlerInterface");
  const RemoteSdp_1 = require("./sdp/RemoteSdp");
  const scalabilityModes_1 = require("../scalabilityModes");
  const logger = new Logger_1.Logger('Chrome70');
  const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
  class Chrome70 extends HandlerInterface_1.HandlerInterface {
      constructor() {
          super();
          // Map of RTCTransceivers indexed by MID.
          this._mapMidTransceiver = new Map();
          // Local stream for sending.
          this._sendStream = new MediaStream();
          // Whether a DataChannel m=application section has been created.
          this._hasDataChannelMediaSection = false;
          // Sending DataChannel id value counter. Incremented for each new DataChannel.
          this._nextSendSctpStreamId = 0;
          // Got transport local and remote parameters.
          this._transportReady = false;
      }
      /**
       * Creates a factory function.
       */
      static createFactory() {
          return () => new Chrome70();
      }
      get name() {
          return 'Chrome70';
      }
      close() {
          logger.debug('close()');
          // Close RTCPeerConnection.
          if (this._pc) {
              try {
                  this._pc.close();
              }
              catch (error) { }
          }
      }
      async getNativeRtpCapabilities() {
          logger.debug('getNativeRtpCapabilities()');
          const pc = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: 'all',
              bundlePolicy: 'max-bundle',
              rtcpMuxPolicy: 'require',
              sdpSemantics: 'unified-plan'
          });
          try {
              pc.addTransceiver('audio');
              pc.addTransceiver('video');
              const offer = await pc.createOffer();
              try {
                  pc.close();
              }
              catch (error) { }
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });
              return nativeRtpCapabilities;
          }
          catch (error) {
              try {
                  pc.close();
              }
              catch (error2) { }
              throw error;
          }
      }
      async getNativeSctpCapabilities() {
          logger.debug('getNativeSctpCapabilities()');
          return {
              numStreams: SCTP_NUM_STREAMS
          };
      }
      run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger.debug('run()');
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters
          });
          this._sendingRtpParametersByKind =
              {
                  audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
                  video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
              };
          this._sendingRemoteRtpParametersByKind =
              {
                  audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
                  video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
              };
          this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'unified-plan' }, additionalSettings), proprietaryConstraints);
          // Handle RTCPeerConnection connection status.
          this._pc.addEventListener('iceconnectionstatechange', () => {
              switch (this._pc.iceConnectionState) {
                  case 'checking':
                      this.emit('@connectionstatechange', 'connecting');
                      break;
                  case 'connected':
                  case 'completed':
                      this.emit('@connectionstatechange', 'connected');
                      break;
                  case 'failed':
                      this.emit('@connectionstatechange', 'failed');
                      break;
                  case 'disconnected':
                      this.emit('@connectionstatechange', 'disconnected');
                      break;
                  case 'closed':
                      this.emit('@connectionstatechange', 'closed');
                      break;
              }
          });
      }
      async updateIceServers(iceServers) {
          logger.debug('updateIceServers()');
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
      }
      async restartIce(iceParameters) {
          logger.debug('restartIce()');
          // Provide the remote SDP handler with new remote ICE parameters.
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady)
              return;
          if (this._direction === 'send') {
              const offer = await this._pc.createOffer({ iceRestart: true });
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              await this._pc.setLocalDescription(offer);
              const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setRemoteDescription(answer);
          }
          else {
              const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
              await this._pc.setLocalDescription(answer);
          }
      }
      async getTransportStats() {
          return this._pc.getStats();
      }
      async send({ track, encodings, codecOptions, codec }) {
          this._assertSendDirection();
          logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
          // This may throw.
          sendingRtpParameters.codecs =
              ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
          // This may throw.
          sendingRemoteRtpParameters.codecs =
              ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
          const transceiver = this._pc.addTransceiver(track, { direction: 'sendonly', streams: [this._sendStream] });
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          if (!this._transportReady)
              await this._setupTransport({ localDtlsRole: 'server', localSdpObject });
          if (encodings && encodings.length > 1) {
              logger.debug('send() | enabling legacy simulcast');
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              sdpUnifiedPlanUtils.addLegacySimulcast({
                  offerMediaObject,
                  numStreams: encodings.length
              });
              offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
          }
          // Special case for VP9 with SVC.
          let hackVp9Svc = false;
          const layers = scalabilityModes_1.parse((encodings || [{}])[0].scalabilityMode);
          if (encodings &&
              encodings.length === 1 &&
              layers.spatialLayers > 1 &&
              sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
              logger.debug('send() | enabling legacy simulcast for VP9 SVC');
              hackVp9Svc = true;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              sdpUnifiedPlanUtils.addLegacySimulcast({
                  offerMediaObject,
                  numStreams: layers.spatialLayers
              });
              offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
          }
          logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
          await this._pc.setLocalDescription(offer);
          // If encodings are given, apply them now.
          if (encodings) {
              logger.debug('send() | applying given encodings');
              const parameters = transceiver.sender.getParameters();
              for (let idx = 0; idx < (parameters.encodings || []).length; ++idx) {
                  const encoding = parameters.encodings[idx];
                  const desiredEncoding = encodings[idx];
                  // Should not happen but just in case.
                  if (!desiredEncoding)
                      break;
                  parameters.encodings[idx] = Object.assign(encoding, desiredEncoding);
              }
              await transceiver.sender.setParameters(parameters);
          }
          // We can now get the transceiver.mid.
          const localId = transceiver.mid;
          // Set MID.
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          // Set RTCP CNAME.
          sendingRtpParameters.rtcp.cname =
              sdpCommonUtils.getCname({ offerMediaObject });
          // Set RTP encodings.
          sendingRtpParameters.encodings =
              sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });
          // Complete encodings with given values.
          if (encodings) {
              for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                  if (encodings[idx])
                      Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
          }
          // Hack for VP9 SVC.
          if (hackVp9Svc) {
              sendingRtpParameters.encodings = [sendingRtpParameters.encodings[0]];
          }
          // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
          // each encoding.
          if (sendingRtpParameters.encodings.length > 1 &&
              (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                  sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
              for (const encoding of sendingRtpParameters.encodings) {
                  encoding.scalabilityMode = 'S1T3';
              }
          }
          this._remoteSdp.send({
              offerMediaObject,
              reuseMid: mediaSectionIdx.reuseMid,
              offerRtpParameters: sendingRtpParameters,
              answerRtpParameters: sendingRemoteRtpParameters,
              codecOptions
          });
          const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
          logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
          await this._pc.setRemoteDescription(answer);
          // Store in the map.
          this._mapMidTransceiver.set(localId, transceiver);
          return {
              localId,
              rtpParameters: sendingRtpParameters,
              rtpSender: transceiver.sender
          };
      }
      async stopSending(localId) {
          this._assertSendDirection();
          logger.debug('stopSending() [localId:%s]', localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          this._remoteSdp.closeMediaSection(transceiver.mid);
          const offer = await this._pc.createOffer();
          logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
          logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
          await this._pc.setRemoteDescription(answer);
      }
      async replaceTrack(localId, track) {
          this._assertSendDirection();
          if (track) {
              logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
          }
          else {
              logger.debug('replaceTrack() [localId:%s, no track]', localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          await transceiver.sender.replaceTrack(track);
      }
      async setMaxSpatialLayer(localId, spatialLayer) {
          this._assertSendDirection();
          logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
              if (idx <= spatialLayer)
                  encoding.active = true;
              else
                  encoding.active = false;
          });
          await transceiver.sender.setParameters(parameters);
      }
      async setRtpEncodingParameters(localId, params) {
          this._assertSendDirection();
          logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
              parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);
          });
          await transceiver.sender.setParameters(parameters);
      }
      async getSenderStats(localId) {
          this._assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          return transceiver.sender.getStats();
      }
      async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this._assertSendDirection();
          const options = {
              negotiated: true,
              id: this._nextSendSctpStreamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmitTime: maxPacketLifeTime,
              maxRetransmits,
              protocol
          };
          logger.debug('sendDataChannel() [options:%o]', options);
          const dataChannel = this._pc.createDataChannel(label, options);
          // Increase next id.
          this._nextSendSctpStreamId =
              ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          // If this is the first DataChannel we need to create the SDP answer with
          // m=application section.
          if (!this._hasDataChannelMediaSection) {
              const offer = await this._pc.createOffer();
              const localSdpObject = sdpTransform.parse(offer.sdp);
              const offerMediaObject = localSdpObject.media
                  .find((m) => m.type === 'application');
              if (!this._transportReady)
                  await this._setupTransport({ localDtlsRole: 'server', localSdpObject });
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              await this._pc.setLocalDescription(offer);
              this._remoteSdp.sendSctpAssociation({ offerMediaObject });
              const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setRemoteDescription(answer);
              this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
              streamId: options.id,
              ordered: options.ordered,
              maxPacketLifeTime: options.maxPacketLifeTime,
              maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
      }
      async receive({ trackId, kind, rtpParameters }) {
          this._assertRecvDirection();
          logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
          const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
          this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: rtpParameters.rtcp.cname,
              trackId
          });
          const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
          logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          const answerMediaObject = localSdpObject.media
              .find((m) => String(m.mid) === localId);
          // May need to modify codec parameters in the answer based on codec
          // parameters in the offer.
          sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
          });
          answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady)
              await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
          logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
          await this._pc.setLocalDescription(answer);
          const transceiver = this._pc.getTransceivers()
              .find((t) => t.mid === localId);
          if (!transceiver)
              throw new Error('new RTCRtpTransceiver not found');
          // Store in the map.
          this._mapMidTransceiver.set(localId, transceiver);
          return {
              localId,
              track: transceiver.receiver.track,
              rtpReceiver: transceiver.receiver
          };
      }
      async stopReceiving(localId) {
          this._assertRecvDirection();
          logger.debug('stopReceiving() [localId:%s]', localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          this._remoteSdp.closeMediaSection(transceiver.mid);
          const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
          logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
          await this._pc.setLocalDescription(answer);
      }
      async getReceiverStats(localId) {
          this._assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          return transceiver.receiver.getStats();
      }
      async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this._assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
              negotiated: true,
              id: streamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmitTime: maxPacketLifeTime,
              maxRetransmits,
              protocol
          };
          logger.debug('receiveDataChannel() [options:%o]', options);
          const dataChannel = this._pc.createDataChannel(label, options);
          // If this is the first DataChannel we need to create the SDP offer with
          // m=application section.
          if (!this._hasDataChannelMediaSection) {
              this._remoteSdp.receiveSctpAssociation();
              const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              if (!this._transportReady) {
                  const localSdpObject = sdpTransform.parse(answer.sdp);
                  await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
              }
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setLocalDescription(answer);
              this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
      }
      async _setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject)
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          // Get our local DTLS parameters.
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });
          // Set our DTLS role.
          dtlsParameters.role = localDtlsRole;
          // Update the remote DTLS role in the SDP.
          this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
          // Need to tell the remote transport about our parameters.
          await this.safeEmitAsPromise('@connect', { dtlsParameters });
          this._transportReady = true;
      }
      _assertSendDirection() {
          if (this._direction !== 'send') {
              throw new Error('method can just be called for handlers with "send" direction');
          }
      }
      _assertRecvDirection() {
          if (this._direction !== 'recv') {
              throw new Error('method can just be called for handlers with "recv" direction');
          }
      }
  }
  exports.Chrome70 = Chrome70;
  
  },{"../Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Logger.js","../ortc":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/ortc.js","../scalabilityModes":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/scalabilityModes.js","../utils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/utils.js","./HandlerInterface":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js","./sdp/RemoteSdp":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js","./sdp/commonUtils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js","./sdp/unifiedPlanUtils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js","sdp-transform":"/home/ubuntu/umbrella-voice2/app/node_modules/sdp-transform/lib/index.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/Chrome74.js":[function(require,module,exports){
  "use strict";
  var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
      o["default"] = v;
  });
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Chrome74 = void 0;
  const sdpTransform = __importStar(require("sdp-transform"));
  const Logger_1 = require("../Logger");
  const utils = __importStar(require("../utils"));
  const ortc = __importStar(require("../ortc"));
  const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
  const sdpUnifiedPlanUtils = __importStar(require("./sdp/unifiedPlanUtils"));
  const HandlerInterface_1 = require("./HandlerInterface");
  const RemoteSdp_1 = require("./sdp/RemoteSdp");
  const scalabilityModes_1 = require("../scalabilityModes");
  const logger = new Logger_1.Logger('Chrome74');
  const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
  class Chrome74 extends HandlerInterface_1.HandlerInterface {
      constructor() {
          super();
          // Map of RTCTransceivers indexed by MID.
          this._mapMidTransceiver = new Map();
          // Local stream for sending.
          this._sendStream = new MediaStream();
          // Whether a DataChannel m=application section has been created.
          this._hasDataChannelMediaSection = false;
          // Sending DataChannel id value counter. Incremented for each new DataChannel.
          this._nextSendSctpStreamId = 0;
          // Got transport local and remote parameters.
          this._transportReady = false;
      }
      /**
       * Creates a factory function.
       */
      static createFactory() {
          return () => new Chrome74();
      }
      get name() {
          return 'Chrome74';
      }
      close() {
          logger.debug('close()');
          // Close RTCPeerConnection.
          if (this._pc) {
              try {
                  this._pc.close();
              }
              catch (error) { }
          }
      }
      async getNativeRtpCapabilities() {
          logger.debug('getNativeRtpCapabilities()');
          const pc = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: 'all',
              bundlePolicy: 'max-bundle',
              rtcpMuxPolicy: 'require',
              sdpSemantics: 'unified-plan'
          });
          try {
              pc.addTransceiver('audio');
              pc.addTransceiver('video');
              const offer = await pc.createOffer();
              try {
                  pc.close();
              }
              catch (error) { }
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });
              return nativeRtpCapabilities;
          }
          catch (error) {
              try {
                  pc.close();
              }
              catch (error2) { }
              throw error;
          }
      }
      async getNativeSctpCapabilities() {
          logger.debug('getNativeSctpCapabilities()');
          return {
              numStreams: SCTP_NUM_STREAMS
          };
      }
      run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger.debug('run()');
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters
          });
          this._sendingRtpParametersByKind =
              {
                  audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
                  video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
              };
          this._sendingRemoteRtpParametersByKind =
              {
                  audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
                  video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
              };
          this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'unified-plan' }, additionalSettings), proprietaryConstraints);
          // Handle RTCPeerConnection connection status.
          this._pc.addEventListener('iceconnectionstatechange', () => {
              switch (this._pc.iceConnectionState) {
                  case 'checking':
                      this.emit('@connectionstatechange', 'connecting');
                      break;
                  case 'connected':
                  case 'completed':
                      this.emit('@connectionstatechange', 'connected');
                      break;
                  case 'failed':
                      this.emit('@connectionstatechange', 'failed');
                      break;
                  case 'disconnected':
                      this.emit('@connectionstatechange', 'disconnected');
                      break;
                  case 'closed':
                      this.emit('@connectionstatechange', 'closed');
                      break;
              }
          });
      }
      async updateIceServers(iceServers) {
          logger.debug('updateIceServers()');
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
      }
      async restartIce(iceParameters) {
          logger.debug('restartIce()');
          // Provide the remote SDP handler with new remote ICE parameters.
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady)
              return;
          if (this._direction === 'send') {
              const offer = await this._pc.createOffer({ iceRestart: true });
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              await this._pc.setLocalDescription(offer);
              const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setRemoteDescription(answer);
          }
          else {
              const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
              await this._pc.setLocalDescription(answer);
          }
      }
      async getTransportStats() {
          return this._pc.getStats();
      }
      async send({ track, encodings, codecOptions, codec }) {
          this._assertSendDirection();
          logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
          if (encodings && encodings.length > 1) {
              encodings.forEach((encoding, idx) => {
                  encoding.rid = `r${idx}`;
              });
          }
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
          // This may throw.
          sendingRtpParameters.codecs =
              ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
          // This may throw.
          sendingRemoteRtpParameters.codecs =
              ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
          const transceiver = this._pc.addTransceiver(track, {
              direction: 'sendonly',
              streams: [this._sendStream],
              sendEncodings: encodings
          });
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          if (!this._transportReady)
              await this._setupTransport({ localDtlsRole: 'server', localSdpObject });
          // Special case for VP9 with SVC.
          let hackVp9Svc = false;
          const layers = scalabilityModes_1.parse((encodings || [{}])[0].scalabilityMode);
          if (encodings &&
              encodings.length === 1 &&
              layers.spatialLayers > 1 &&
              sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp9') {
              logger.debug('send() | enabling legacy simulcast for VP9 SVC');
              hackVp9Svc = true;
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              sdpUnifiedPlanUtils.addLegacySimulcast({
                  offerMediaObject,
                  numStreams: layers.spatialLayers
              });
              offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
          }
          logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
          await this._pc.setLocalDescription(offer);
          // We can now get the transceiver.mid.
          const localId = transceiver.mid;
          // Set MID.
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          // Set RTCP CNAME.
          sendingRtpParameters.rtcp.cname =
              sdpCommonUtils.getCname({ offerMediaObject });
          // Set RTP encodings by parsing the SDP offer if no encodings are given.
          if (!encodings) {
              sendingRtpParameters.encodings =
                  sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });
          }
          // Set RTP encodings by parsing the SDP offer and complete them with given
          // one if just a single encoding has been given.
          else if (encodings.length === 1) {
              let newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });
              Object.assign(newEncodings[0], encodings[0]);
              // Hack for VP9 SVC.
              if (hackVp9Svc)
                  newEncodings = [newEncodings[0]];
              sendingRtpParameters.encodings = newEncodings;
          }
          // Otherwise if more than 1 encoding are given use them verbatim.
          else {
              sendingRtpParameters.encodings = encodings;
          }
          // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
          // each encoding.
          if (sendingRtpParameters.encodings.length > 1 &&
              (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                  sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
              for (const encoding of sendingRtpParameters.encodings) {
                  encoding.scalabilityMode = 'S1T3';
              }
          }
          this._remoteSdp.send({
              offerMediaObject,
              reuseMid: mediaSectionIdx.reuseMid,
              offerRtpParameters: sendingRtpParameters,
              answerRtpParameters: sendingRemoteRtpParameters,
              codecOptions,
              extmapAllowMixed: true
          });
          const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
          logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
          await this._pc.setRemoteDescription(answer);
          // Store in the map.
          this._mapMidTransceiver.set(localId, transceiver);
          return {
              localId,
              rtpParameters: sendingRtpParameters,
              rtpSender: transceiver.sender
          };
      }
      async stopSending(localId) {
          this._assertSendDirection();
          logger.debug('stopSending() [localId:%s]', localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          this._remoteSdp.closeMediaSection(transceiver.mid);
          const offer = await this._pc.createOffer();
          logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
          logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
          await this._pc.setRemoteDescription(answer);
      }
      async replaceTrack(localId, track) {
          this._assertSendDirection();
          if (track) {
              logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
          }
          else {
              logger.debug('replaceTrack() [localId:%s, no track]', localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          await transceiver.sender.replaceTrack(track);
      }
      async setMaxSpatialLayer(localId, spatialLayer) {
          this._assertSendDirection();
          logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
              if (idx <= spatialLayer)
                  encoding.active = true;
              else
                  encoding.active = false;
          });
          await transceiver.sender.setParameters(parameters);
      }
      async setRtpEncodingParameters(localId, params) {
          this._assertSendDirection();
          logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
              parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);
          });
          await transceiver.sender.setParameters(parameters);
      }
      async getSenderStats(localId) {
          this._assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          return transceiver.sender.getStats();
      }
      async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this._assertSendDirection();
          const options = {
              negotiated: true,
              id: this._nextSendSctpStreamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol
          };
          logger.debug('sendDataChannel() [options:%o]', options);
          const dataChannel = this._pc.createDataChannel(label, options);
          // Increase next id.
          this._nextSendSctpStreamId =
              ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          // If this is the first DataChannel we need to create the SDP answer with
          // m=application section.
          if (!this._hasDataChannelMediaSection) {
              const offer = await this._pc.createOffer();
              const localSdpObject = sdpTransform.parse(offer.sdp);
              const offerMediaObject = localSdpObject.media
                  .find((m) => m.type === 'application');
              if (!this._transportReady)
                  await this._setupTransport({ localDtlsRole: 'server', localSdpObject });
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              await this._pc.setLocalDescription(offer);
              this._remoteSdp.sendSctpAssociation({ offerMediaObject });
              const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setRemoteDescription(answer);
              this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
              streamId: options.id,
              ordered: options.ordered,
              maxPacketLifeTime: options.maxPacketLifeTime,
              maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
      }
      async receive({ trackId, kind, rtpParameters }) {
          this._assertRecvDirection();
          logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
          const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
          this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: rtpParameters.rtcp.cname,
              trackId
          });
          const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
          logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          const answerMediaObject = localSdpObject.media
              .find((m) => String(m.mid) === localId);
          // May need to modify codec parameters in the answer based on codec
          // parameters in the offer.
          sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
          });
          answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady)
              await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
          logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
          await this._pc.setLocalDescription(answer);
          const transceiver = this._pc.getTransceivers()
              .find((t) => t.mid === localId);
          if (!transceiver)
              throw new Error('new RTCRtpTransceiver not found');
          // Store in the map.
          this._mapMidTransceiver.set(localId, transceiver);
          return {
              localId,
              track: transceiver.receiver.track,
              rtpReceiver: transceiver.receiver
          };
      }
      async stopReceiving(localId) {
          this._assertRecvDirection();
          logger.debug('stopReceiving() [localId:%s]', localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          this._remoteSdp.closeMediaSection(transceiver.mid);
          const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
          logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
          await this._pc.setLocalDescription(answer);
      }
      async getReceiverStats(localId) {
          this._assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          return transceiver.receiver.getStats();
      }
      async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this._assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
              negotiated: true,
              id: streamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol
          };
          logger.debug('receiveDataChannel() [options:%o]', options);
          const dataChannel = this._pc.createDataChannel(label, options);
          // If this is the first DataChannel we need to create the SDP offer with
          // m=application section.
          if (!this._hasDataChannelMediaSection) {
              this._remoteSdp.receiveSctpAssociation();
              const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              if (!this._transportReady) {
                  const localSdpObject = sdpTransform.parse(answer.sdp);
                  await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
              }
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setLocalDescription(answer);
              this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
      }
      async _setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject)
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          // Get our local DTLS parameters.
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });
          // Set our DTLS role.
          dtlsParameters.role = localDtlsRole;
          // Update the remote DTLS role in the SDP.
          this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
          // Need to tell the remote transport about our parameters.
          await this.safeEmitAsPromise('@connect', { dtlsParameters });
          this._transportReady = true;
      }
      _assertSendDirection() {
          if (this._direction !== 'send') {
              throw new Error('method can just be called for handlers with "send" direction');
          }
      }
      _assertRecvDirection() {
          if (this._direction !== 'recv') {
              throw new Error('method can just be called for handlers with "recv" direction');
          }
      }
  }
  exports.Chrome74 = Chrome74;
  
  },{"../Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Logger.js","../ortc":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/ortc.js","../scalabilityModes":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/scalabilityModes.js","../utils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/utils.js","./HandlerInterface":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js","./sdp/RemoteSdp":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js","./sdp/commonUtils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js","./sdp/unifiedPlanUtils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js","sdp-transform":"/home/ubuntu/umbrella-voice2/app/node_modules/sdp-transform/lib/index.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/Edge11.js":[function(require,module,exports){
  "use strict";
  var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
      o["default"] = v;
  });
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Edge11 = void 0;
  const Logger_1 = require("../Logger");
  const errors_1 = require("../errors");
  const utils = __importStar(require("../utils"));
  const ortc = __importStar(require("../ortc"));
  const edgeUtils = __importStar(require("./ortc/edgeUtils"));
  const HandlerInterface_1 = require("./HandlerInterface");
  const logger = new Logger_1.Logger('Edge11');
  class Edge11 extends HandlerInterface_1.HandlerInterface {
      constructor() {
          super();
          // Map of RTCRtpSenders indexed by id.
          this._rtpSenders = new Map();
          // Map of RTCRtpReceivers indexed by id.
          this._rtpReceivers = new Map();
          // Next localId for sending tracks.
          this._nextSendLocalId = 0;
          // Got transport local and remote parameters.
          this._transportReady = false;
      }
      /**
       * Creates a factory function.
       */
      static createFactory() {
          return () => new Edge11();
      }
      get name() {
          return 'Edge11';
      }
      close() {
          logger.debug('close()');
          // Close the ICE gatherer.
          // NOTE: Not yet implemented by Edge.
          try {
              this._iceGatherer.close();
          }
          catch (error) { }
          // Close the ICE transport.
          try {
              this._iceTransport.stop();
          }
          catch (error) { }
          // Close the DTLS transport.
          try {
              this._dtlsTransport.stop();
          }
          catch (error) { }
          // Close RTCRtpSenders.
          for (const rtpSender of this._rtpSenders.values()) {
              try {
                  rtpSender.stop();
              }
              catch (error) { }
          }
          // Close RTCRtpReceivers.
          for (const rtpReceiver of this._rtpReceivers.values()) {
              try {
                  rtpReceiver.stop();
              }
              catch (error) { }
          }
      }
      async getNativeRtpCapabilities() {
          logger.debug('getNativeRtpCapabilities()');
          return edgeUtils.getCapabilities();
      }
      async getNativeSctpCapabilities() {
          logger.debug('getNativeSctpCapabilities()');
          return {
              numStreams: { OS: 0, MIS: 0 }
          };
      }
      run({ direction, // eslint-disable-line @typescript-eslint/no-unused-vars
      iceParameters, iceCandidates, dtlsParameters, sctpParameters, // eslint-disable-line @typescript-eslint/no-unused-vars
      iceServers, iceTransportPolicy, additionalSettings, // eslint-disable-line @typescript-eslint/no-unused-vars
      proprietaryConstraints, // eslint-disable-line @typescript-eslint/no-unused-vars
      extendedRtpCapabilities }) {
          logger.debug('run()');
          this._sendingRtpParametersByKind =
              {
                  audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
                  video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
              };
          this._remoteIceParameters = iceParameters;
          this._remoteIceCandidates = iceCandidates;
          this._remoteDtlsParameters = dtlsParameters;
          this._cname = `CNAME-${utils.generateRandomNumber()}`;
          this._setIceGatherer({ iceServers, iceTransportPolicy });
          this._setIceTransport();
          this._setDtlsTransport();
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async updateIceServers(iceServers) {
          // NOTE: Edge 11 does not implement iceGatherer.gater().
          throw new errors_1.UnsupportedError('not supported');
      }
      async restartIce(iceParameters) {
          logger.debug('restartIce()');
          this._remoteIceParameters = iceParameters;
          if (!this._transportReady)
              return;
          logger.debug('restartIce() | calling iceTransport.start()');
          this._iceTransport.start(this._iceGatherer, iceParameters, 'controlling');
          for (const candidate of this._remoteIceCandidates) {
              this._iceTransport.addRemoteCandidate(candidate);
          }
          this._iceTransport.addRemoteCandidate({});
      }
      async getTransportStats() {
          return this._iceTransport.getStats();
      }
      async send(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      { track, encodings, codecOptions, codec }) {
          logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
          if (!this._transportReady)
              await this._setupTransport({ localDtlsRole: 'server' });
          logger.debug('send() | calling new RTCRtpSender()');
          const rtpSender = new RTCRtpSender(track, this._dtlsTransport);
          const rtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
          rtpParameters.codecs = ortc.reduceCodecs(rtpParameters.codecs, codec);
          const useRtx = rtpParameters.codecs
              .some((_codec) => /.+\/rtx$/i.test(_codec.mimeType));
          if (!encodings)
              encodings = [{}];
          for (const encoding of encodings) {
              encoding.ssrc = utils.generateRandomNumber();
              if (useRtx)
                  encoding.rtx = { ssrc: utils.generateRandomNumber() };
          }
          rtpParameters.encodings = encodings;
          // Fill RTCRtpParameters.rtcp.
          rtpParameters.rtcp =
              {
                  cname: this._cname,
                  reducedSize: true,
                  mux: true
              };
          // NOTE: Convert our standard RTCRtpParameters into those that Edge
          // expects.
          const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
          logger.debug('send() | calling rtpSender.send() [params:%o]', edgeRtpParameters);
          await rtpSender.send(edgeRtpParameters);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          // Store it.
          this._rtpSenders.set(localId, rtpSender);
          return { localId, rtpParameters, rtpSender };
      }
      async stopSending(localId) {
          logger.debug('stopSending() [localId:%s]', localId);
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender)
              throw new Error('RTCRtpSender not found');
          this._rtpSenders.delete(localId);
          try {
              logger.debug('stopSending() | calling rtpSender.stop()');
              rtpSender.stop();
          }
          catch (error) {
              logger.warn('stopSending() | rtpSender.stop() failed:%o', error);
              throw error;
          }
      }
      async replaceTrack(localId, track) {
          if (track) {
              logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
          }
          else {
              logger.debug('replaceTrack() [localId:%s, no track]', localId);
          }
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender)
              throw new Error('RTCRtpSender not found');
          rtpSender.setTrack(track);
      }
      async setMaxSpatialLayer(localId, spatialLayer) {
          logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender)
              throw new Error('RTCRtpSender not found');
          const parameters = rtpSender.getParameters();
          parameters.encodings
              .forEach((encoding, idx) => {
              if (idx <= spatialLayer)
                  encoding.active = true;
              else
                  encoding.active = false;
          });
          await rtpSender.setParameters(parameters);
      }
      async setRtpEncodingParameters(localId, params) {
          logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender)
              throw new Error('RTCRtpSender not found');
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
              parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);
          });
          await rtpSender.setParameters(parameters);
      }
      async getSenderStats(localId) {
          const rtpSender = this._rtpSenders.get(localId);
          if (!rtpSender)
              throw new Error('RTCRtpSender not found');
          return rtpSender.getStats();
      }
      async sendDataChannel(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      options) {
          throw new errors_1.UnsupportedError('not implemented');
      }
      async receive({ trackId, kind, rtpParameters }) {
          logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
          if (!this._transportReady)
              await this._setupTransport({ localDtlsRole: 'server' });
          logger.debug('receive() | calling new RTCRtpReceiver()');
          const rtpReceiver = new RTCRtpReceiver(this._dtlsTransport, kind);
          rtpReceiver.addEventListener('error', (event) => {
              logger.error('rtpReceiver "error" event [event:%o]', event);
          });
          // NOTE: Convert our standard RTCRtpParameters into those that Edge
          // expects.
          const edgeRtpParameters = edgeUtils.mangleRtpParameters(rtpParameters);
          logger.debug('receive() | calling rtpReceiver.receive() [params:%o]', edgeRtpParameters);
          await rtpReceiver.receive(edgeRtpParameters);
          const localId = trackId;
          // Store it.
          this._rtpReceivers.set(localId, rtpReceiver);
          return {
              localId,
              track: rtpReceiver.track,
              rtpReceiver
          };
      }
      async stopReceiving(localId) {
          logger.debug('stopReceiving() [localId:%s]', localId);
          const rtpReceiver = this._rtpReceivers.get(localId);
          if (!rtpReceiver)
              throw new Error('RTCRtpReceiver not found');
          this._rtpReceivers.delete(localId);
          try {
              logger.debug('stopReceiving() | calling rtpReceiver.stop()');
              rtpReceiver.stop();
          }
          catch (error) {
              logger.warn('stopReceiving() | rtpReceiver.stop() failed:%o', error);
          }
      }
      async getReceiverStats(localId) {
          const rtpReceiver = this._rtpReceivers.get(localId);
          if (!rtpReceiver)
              throw new Error('RTCRtpReceiver not found');
          return rtpReceiver.getStats();
      }
      async receiveDataChannel(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      options) {
          throw new errors_1.UnsupportedError('not implemented');
      }
      _setIceGatherer({ iceServers, iceTransportPolicy }) {
          const iceGatherer = new RTCIceGatherer({
              iceServers: iceServers || [],
              gatherPolicy: iceTransportPolicy || 'all'
          });
          iceGatherer.addEventListener('error', (event) => {
              logger.error('iceGatherer "error" event [event:%o]', event);
          });
          // NOTE: Not yet implemented by Edge, which starts gathering automatically.
          try {
              iceGatherer.gather();
          }
          catch (error) {
              logger.debug('_setIceGatherer() | iceGatherer.gather() failed: %s', error.toString());
          }
          this._iceGatherer = iceGatherer;
      }
      _setIceTransport() {
          const iceTransport = new RTCIceTransport(this._iceGatherer);
          // NOTE: Not yet implemented by Edge.
          iceTransport.addEventListener('statechange', () => {
              switch (iceTransport.state) {
                  case 'checking':
                      this.emit('@connectionstatechange', 'connecting');
                      break;
                  case 'connected':
                  case 'completed':
                      this.emit('@connectionstatechange', 'connected');
                      break;
                  case 'failed':
                      this.emit('@connectionstatechange', 'failed');
                      break;
                  case 'disconnected':
                      this.emit('@connectionstatechange', 'disconnected');
                      break;
                  case 'closed':
                      this.emit('@connectionstatechange', 'closed');
                      break;
              }
          });
          // NOTE: Not standard, but implemented by Edge.
          iceTransport.addEventListener('icestatechange', () => {
              switch (iceTransport.state) {
                  case 'checking':
                      this.emit('@connectionstatechange', 'connecting');
                      break;
                  case 'connected':
                  case 'completed':
                      this.emit('@connectionstatechange', 'connected');
                      break;
                  case 'failed':
                      this.emit('@connectionstatechange', 'failed');
                      break;
                  case 'disconnected':
                      this.emit('@connectionstatechange', 'disconnected');
                      break;
                  case 'closed':
                      this.emit('@connectionstatechange', 'closed');
                      break;
              }
          });
          iceTransport.addEventListener('candidatepairchange', (event) => {
              logger.debug('iceTransport "candidatepairchange" event [pair:%o]', event.pair);
          });
          this._iceTransport = iceTransport;
      }
      _setDtlsTransport() {
          const dtlsTransport = new RTCDtlsTransport(this._iceTransport);
          // NOTE: Not yet implemented by Edge.
          dtlsTransport.addEventListener('statechange', () => {
              logger.debug('dtlsTransport "statechange" event [state:%s]', dtlsTransport.state);
          });
          // NOTE: Not standard, but implemented by Edge.
          dtlsTransport.addEventListener('dtlsstatechange', () => {
              logger.debug('dtlsTransport "dtlsstatechange" event [state:%s]', dtlsTransport.state);
              if (dtlsTransport.state === 'closed')
                  this.emit('@connectionstatechange', 'closed');
          });
          dtlsTransport.addEventListener('error', (event) => {
              logger.error('dtlsTransport "error" event [event:%o]', event);
          });
          this._dtlsTransport = dtlsTransport;
      }
      async _setupTransport({ localDtlsRole }) {
          logger.debug('_setupTransport()');
          // Get our local DTLS parameters.
          const dtlsParameters = this._dtlsTransport.getLocalParameters();
          dtlsParameters.role = localDtlsRole;
          // Need to tell the remote transport about our parameters.
          await this.safeEmitAsPromise('@connect', { dtlsParameters });
          // Start the RTCIceTransport.
          this._iceTransport.start(this._iceGatherer, this._remoteIceParameters, 'controlling');
          // Add remote ICE candidates.
          for (const candidate of this._remoteIceCandidates) {
              this._iceTransport.addRemoteCandidate(candidate);
          }
          // Also signal a 'complete' candidate as per spec.
          // NOTE: It should be {complete: true} but Edge prefers {}.
          // NOTE: If we don't signal end of candidates, the Edge RTCIceTransport
          // won't enter the 'completed' state.
          this._iceTransport.addRemoteCandidate({});
          // NOTE: Edge does not like SHA less than 256.
          this._remoteDtlsParameters.fingerprints = this._remoteDtlsParameters.fingerprints
              .filter((fingerprint) => {
              return (fingerprint.algorithm === 'sha-256' ||
                  fingerprint.algorithm === 'sha-384' ||
                  fingerprint.algorithm === 'sha-512');
          });
          // Start the RTCDtlsTransport.
          this._dtlsTransport.start(this._remoteDtlsParameters);
          this._transportReady = true;
      }
  }
  exports.Edge11 = Edge11;
  
  },{"../Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Logger.js","../errors":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/errors.js","../ortc":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/ortc.js","../utils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/utils.js","./HandlerInterface":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js","./ortc/edgeUtils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/Firefox60.js":[function(require,module,exports){
  "use strict";
  var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
      o["default"] = v;
  });
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Firefox60 = void 0;
  const sdpTransform = __importStar(require("sdp-transform"));
  const Logger_1 = require("../Logger");
  const errors_1 = require("../errors");
  const utils = __importStar(require("../utils"));
  const ortc = __importStar(require("../ortc"));
  const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
  const sdpUnifiedPlanUtils = __importStar(require("./sdp/unifiedPlanUtils"));
  const HandlerInterface_1 = require("./HandlerInterface");
  const RemoteSdp_1 = require("./sdp/RemoteSdp");
  const logger = new Logger_1.Logger('Firefox60');
  const SCTP_NUM_STREAMS = { OS: 16, MIS: 2048 };
  class Firefox60 extends HandlerInterface_1.HandlerInterface {
      constructor() {
          super();
          // Map of RTCTransceivers indexed by MID.
          this._mapMidTransceiver = new Map();
          // Local stream for sending.
          this._sendStream = new MediaStream();
          // Whether a DataChannel m=application section has been created.
          this._hasDataChannelMediaSection = false;
          // Sending DataChannel id value counter. Incremented for each new DataChannel.
          this._nextSendSctpStreamId = 0;
          // Got transport local and remote parameters.
          this._transportReady = false;
      }
      /**
       * Creates a factory function.
       */
      static createFactory() {
          return () => new Firefox60();
      }
      get name() {
          return 'Firefox60';
      }
      close() {
          logger.debug('close()');
          // Close RTCPeerConnection.
          if (this._pc) {
              try {
                  this._pc.close();
              }
              catch (error) { }
          }
      }
      async getNativeRtpCapabilities() {
          logger.debug('getNativeRtpCapabilities()');
          const pc = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: 'all',
              bundlePolicy: 'max-bundle',
              rtcpMuxPolicy: 'require'
          });
          // NOTE: We need to add a real video track to get the RID extension mapping.
          const canvas = document.createElement('canvas');
          // NOTE: Otherwise Firefox fails in next line.
          canvas.getContext('2d');
          const fakeStream = canvas.captureStream();
          const fakeVideoTrack = fakeStream.getVideoTracks()[0];
          try {
              pc.addTransceiver('audio', { direction: 'sendrecv' });
              const videoTransceiver = pc.addTransceiver(fakeVideoTrack, { direction: 'sendrecv' });
              const parameters = videoTransceiver.sender.getParameters();
              const encodings = [
                  { rid: 'r0', maxBitrate: 100000 },
                  { rid: 'r1', maxBitrate: 500000 }
              ];
              parameters.encodings = encodings;
              await videoTransceiver.sender.setParameters(parameters);
              const offer = await pc.createOffer();
              try {
                  canvas.remove();
              }
              catch (error) { }
              try {
                  fakeVideoTrack.stop();
              }
              catch (error) { }
              try {
                  pc.close();
              }
              catch (error) { }
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });
              return nativeRtpCapabilities;
          }
          catch (error) {
              try {
                  canvas.remove();
              }
              catch (error2) { }
              try {
                  fakeVideoTrack.stop();
              }
              catch (error2) { }
              try {
                  pc.close();
              }
              catch (error2) { }
              throw error;
          }
      }
      async getNativeSctpCapabilities() {
          logger.debug('getNativeSctpCapabilities()');
          return {
              numStreams: SCTP_NUM_STREAMS
          };
      }
      run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger.debug('run()');
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters
          });
          this._sendingRtpParametersByKind =
              {
                  audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
                  video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
              };
          this._sendingRemoteRtpParametersByKind =
              {
                  audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
                  video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
              };
          this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require' }, additionalSettings), proprietaryConstraints);
          // Handle RTCPeerConnection connection status.
          this._pc.addEventListener('iceconnectionstatechange', () => {
              switch (this._pc.iceConnectionState) {
                  case 'checking':
                      this.emit('@connectionstatechange', 'connecting');
                      break;
                  case 'connected':
                  case 'completed':
                      this.emit('@connectionstatechange', 'connected');
                      break;
                  case 'failed':
                      this.emit('@connectionstatechange', 'failed');
                      break;
                  case 'disconnected':
                      this.emit('@connectionstatechange', 'disconnected');
                      break;
                  case 'closed':
                      this.emit('@connectionstatechange', 'closed');
                      break;
              }
          });
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async updateIceServers(iceServers) {
          // NOTE: Firefox does not implement pc.setConfiguration().
          throw new errors_1.UnsupportedError('not supported');
      }
      async restartIce(iceParameters) {
          logger.debug('restartIce()');
          // Provide the remote SDP handler with new remote ICE parameters.
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady)
              return;
          if (this._direction === 'send') {
              const offer = await this._pc.createOffer({ iceRestart: true });
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              await this._pc.setLocalDescription(offer);
              const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setRemoteDescription(answer);
          }
          else {
              const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
              await this._pc.setLocalDescription(answer);
          }
      }
      async getTransportStats() {
          return this._pc.getStats();
      }
      async send({ track, encodings, codecOptions, codec }) {
          this._assertSendDirection();
          logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
          if (encodings) {
              encodings = utils.clone(encodings, []);
              if (encodings.length > 1) {
                  encodings.forEach((encoding, idx) => {
                      encoding.rid = `r${idx}`;
                  });
                  // Clone the encodings and reverse them because Firefox likes them
                  // from high to low.
                  encodings.reverse();
              }
          }
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
          // This may throw.
          sendingRtpParameters.codecs =
              ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
          // This may throw.
          sendingRemoteRtpParameters.codecs =
              ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          // NOTE: Firefox fails sometimes to properly anticipate the closed media
          // section that it should use, so don't reuse closed media sections.
          //   https://github.com/versatica/mediasoup-client/issues/104
          //
          // const mediaSectionIdx = this._remoteSdp!.getNextMediaSectionIdx();
          const transceiver = this._pc.addTransceiver(track, { direction: 'sendonly', streams: [this._sendStream] });
          // NOTE: This is not spec compliants. Encodings should be given in addTransceiver
          // second argument, but Firefox does not support it.
          if (encodings) {
              const parameters = transceiver.sender.getParameters();
              parameters.encodings = encodings;
              await transceiver.sender.setParameters(parameters);
          }
          const offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          // In Firefox use DTLS role client even if we are the "offerer" since
          // Firefox does not respect ICE-Lite.
          if (!this._transportReady)
              await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
          logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
          await this._pc.setLocalDescription(offer);
          // We can now get the transceiver.mid.
          const localId = transceiver.mid;
          // Set MID.
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          const offerMediaObject = localSdpObject.media[localSdpObject.media.length - 1];
          // Set RTCP CNAME.
          sendingRtpParameters.rtcp.cname =
              sdpCommonUtils.getCname({ offerMediaObject });
          // Set RTP encodings by parsing the SDP offer if no encodings are given.
          if (!encodings) {
              sendingRtpParameters.encodings =
                  sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });
          }
          // Set RTP encodings by parsing the SDP offer and complete them with given
          // one if just a single encoding has been given.
          else if (encodings.length === 1) {
              const newEncodings = sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });
              Object.assign(newEncodings[0], encodings[0]);
              sendingRtpParameters.encodings = newEncodings;
          }
          // Otherwise if more than 1 encoding are given use them verbatim (but
          // reverse them back since we reversed them above to satisfy Firefox).
          else {
              sendingRtpParameters.encodings = encodings.reverse();
          }
          // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
          // each encoding.
          if (sendingRtpParameters.encodings.length > 1 &&
              (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                  sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
              for (const encoding of sendingRtpParameters.encodings) {
                  encoding.scalabilityMode = 'S1T3';
              }
          }
          this._remoteSdp.send({
              offerMediaObject,
              offerRtpParameters: sendingRtpParameters,
              answerRtpParameters: sendingRemoteRtpParameters,
              codecOptions,
              extmapAllowMixed: true
          });
          const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
          logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
          await this._pc.setRemoteDescription(answer);
          // Store in the map.
          this._mapMidTransceiver.set(localId, transceiver);
          return {
              localId,
              rtpParameters: sendingRtpParameters,
              rtpSender: transceiver.sender
          };
      }
      async stopSending(localId) {
          logger.debug('stopSending() [localId:%s]', localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated transceiver not found');
          transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          // NOTE: Cannot use closeMediaSection() due to the the note above in send()
          // method.
          // this._remoteSdp!.closeMediaSection(transceiver.mid);
          this._remoteSdp.disableMediaSection(transceiver.mid);
          const offer = await this._pc.createOffer();
          logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
          logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
          await this._pc.setRemoteDescription(answer);
      }
      async replaceTrack(localId, track) {
          this._assertSendDirection();
          if (track) {
              logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
          }
          else {
              logger.debug('replaceTrack() [localId:%s, no track]', localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          await transceiver.sender.replaceTrack(track);
      }
      async setMaxSpatialLayer(localId, spatialLayer) {
          this._assertSendDirection();
          logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated transceiver not found');
          const parameters = transceiver.sender.getParameters();
          // NOTE: We require encodings given from low to high, however Firefox
          // requires them in reverse order, so do magic here.
          spatialLayer = parameters.encodings.length - 1 - spatialLayer;
          parameters.encodings.forEach((encoding, idx) => {
              if (idx >= spatialLayer)
                  encoding.active = true;
              else
                  encoding.active = false;
          });
          await transceiver.sender.setParameters(parameters);
      }
      async setRtpEncodingParameters(localId, params) {
          this._assertSendDirection();
          logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
              parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);
          });
          await transceiver.sender.setParameters(parameters);
      }
      async getSenderStats(localId) {
          this._assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          return transceiver.sender.getStats();
      }
      async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this._assertSendDirection();
          const options = {
              negotiated: true,
              id: this._nextSendSctpStreamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol
          };
          logger.debug('sendDataChannel() [options:%o]', options);
          const dataChannel = this._pc.createDataChannel(label, options);
          // Increase next id.
          this._nextSendSctpStreamId =
              ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          // If this is the first DataChannel we need to create the SDP answer with
          // m=application section.
          if (!this._hasDataChannelMediaSection) {
              const offer = await this._pc.createOffer();
              const localSdpObject = sdpTransform.parse(offer.sdp);
              const offerMediaObject = localSdpObject.media
                  .find((m) => m.type === 'application');
              if (!this._transportReady)
                  await this._setupTransport({ localDtlsRole: 'server', localSdpObject });
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              await this._pc.setLocalDescription(offer);
              this._remoteSdp.sendSctpAssociation({ offerMediaObject });
              const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setRemoteDescription(answer);
              this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
              streamId: options.id,
              ordered: options.ordered,
              maxPacketLifeTime: options.maxPacketLifeTime,
              maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
      }
      async receive({ trackId, kind, rtpParameters }) {
          this._assertRecvDirection();
          logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
          const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
          this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: rtpParameters.rtcp.cname,
              trackId
          });
          const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
          logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          const answerMediaObject = localSdpObject.media
              .find((m) => String(m.mid) === localId);
          // May need to modify codec parameters in the answer based on codec
          // parameters in the offer.
          sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
          });
          answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady)
              await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
          logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
          await this._pc.setLocalDescription(answer);
          const transceiver = this._pc.getTransceivers()
              .find((t) => t.mid === localId);
          if (!transceiver)
              throw new Error('new RTCRtpTransceiver not found');
          // Store in the map.
          this._mapMidTransceiver.set(localId, transceiver);
          return {
              localId,
              track: transceiver.receiver.track,
              rtpReceiver: transceiver.receiver
          };
      }
      async stopReceiving(localId) {
          this._assertRecvDirection();
          logger.debug('stopReceiving() [localId:%s]', localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          this._remoteSdp.closeMediaSection(transceiver.mid);
          const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
          logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
          await this._pc.setLocalDescription(answer);
      }
      async getReceiverStats(localId) {
          this._assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          return transceiver.receiver.getStats();
      }
      async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this._assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
              negotiated: true,
              id: streamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol
          };
          logger.debug('receiveDataChannel() [options:%o]', options);
          const dataChannel = this._pc.createDataChannel(label, options);
          // If this is the first DataChannel we need to create the SDP offer with
          // m=application section.
          if (!this._hasDataChannelMediaSection) {
              this._remoteSdp.receiveSctpAssociation();
              const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              if (!this._transportReady) {
                  const localSdpObject = sdpTransform.parse(answer.sdp);
                  await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
              }
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setLocalDescription(answer);
              this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
      }
      async _setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject)
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          // Get our local DTLS parameters.
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });
          // Set our DTLS role.
          dtlsParameters.role = localDtlsRole;
          // Update the remote DTLS role in the SDP.
          this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
          // Need to tell the remote transport about our parameters.
          await this.safeEmitAsPromise('@connect', { dtlsParameters });
          this._transportReady = true;
      }
      _assertSendDirection() {
          if (this._direction !== 'send') {
              throw new Error('method can just be called for handlers with "send" direction');
          }
      }
      _assertRecvDirection() {
          if (this._direction !== 'recv') {
              throw new Error('method can just be called for handlers with "recv" direction');
          }
      }
  }
  exports.Firefox60 = Firefox60;
  
  },{"../Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Logger.js","../errors":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/errors.js","../ortc":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/ortc.js","../utils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/utils.js","./HandlerInterface":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js","./sdp/RemoteSdp":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js","./sdp/commonUtils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js","./sdp/unifiedPlanUtils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js","sdp-transform":"/home/ubuntu/umbrella-voice2/app/node_modules/sdp-transform/lib/index.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js":[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.HandlerInterface = void 0;
  const EnhancedEventEmitter_1 = require("../EnhancedEventEmitter");
  class HandlerInterface extends EnhancedEventEmitter_1.EnhancedEventEmitter {
      /**
       * @emits @connect - (
       *     { dtlsParameters: DtlsParameters },
       *     callback: Function,
       *     errback: Function
       *   )
       * @emits @connectionstatechange - (connectionState: ConnectionState)
       */
      constructor() {
          super();
      }
  }
  exports.HandlerInterface = HandlerInterface;
  
  },{"../EnhancedEventEmitter":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/EnhancedEventEmitter.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/ReactNative.js":[function(require,module,exports){
  "use strict";
  var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
      o["default"] = v;
  });
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.ReactNative = void 0;
  const sdpTransform = __importStar(require("sdp-transform"));
  const Logger_1 = require("../Logger");
  const errors_1 = require("../errors");
  const utils = __importStar(require("../utils"));
  const ortc = __importStar(require("../ortc"));
  const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
  const sdpPlanBUtils = __importStar(require("./sdp/planBUtils"));
  const HandlerInterface_1 = require("./HandlerInterface");
  const RemoteSdp_1 = require("./sdp/RemoteSdp");
  const logger = new Logger_1.Logger('ReactNative');
  const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
  class ReactNative extends HandlerInterface_1.HandlerInterface {
      constructor() {
          super();
          // Local stream for sending.
          this._sendStream = new MediaStream();
          // Map of sending MediaStreamTracks indexed by localId.
          this._mapSendLocalIdTrack = new Map();
          // Next sending localId.
          this._nextSendLocalId = 0;
          // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
          // Value is an Object with mid, rtpParameters and rtpReceiver.
          this._mapRecvLocalIdInfo = new Map();
          // Whether a DataChannel m=application section has been created.
          this._hasDataChannelMediaSection = false;
          // Sending DataChannel id value counter. Incremented for each new DataChannel.
          this._nextSendSctpStreamId = 0;
          // Got transport local and remote parameters.
          this._transportReady = false;
      }
      /**
       * Creates a factory function.
       */
      static createFactory() {
          return () => new ReactNative();
      }
      get name() {
          return 'ReactNative';
      }
      close() {
          logger.debug('close()');
          // Close RTCPeerConnection.
          if (this._pc) {
              try {
                  this._pc.close();
              }
              catch (error) { }
          }
      }
      async getNativeRtpCapabilities() {
          logger.debug('getNativeRtpCapabilities()');
          const pc = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: 'all',
              bundlePolicy: 'max-bundle',
              rtcpMuxPolicy: 'require',
              sdpSemantics: 'plan-b'
          });
          try {
              const offer = await pc.createOffer({
                  offerToReceiveAudio: true,
                  offerToReceiveVideo: true
              });
              try {
                  pc.close();
              }
              catch (error) { }
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });
              return nativeRtpCapabilities;
          }
          catch (error) {
              try {
                  pc.close();
              }
              catch (error2) { }
              throw error;
          }
      }
      async getNativeSctpCapabilities() {
          logger.debug('getNativeSctpCapabilities()');
          return {
              numStreams: SCTP_NUM_STREAMS
          };
      }
      run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger.debug('run()');
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
              planB: true
          });
          this._sendingRtpParametersByKind =
              {
                  audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
                  video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
              };
          this._sendingRemoteRtpParametersByKind =
              {
                  audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
                  video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
              };
          this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require', sdpSemantics: 'plan-b' }, additionalSettings), proprietaryConstraints);
          // Handle RTCPeerConnection connection status.
          this._pc.addEventListener('iceconnectionstatechange', () => {
              switch (this._pc.iceConnectionState) {
                  case 'checking':
                      this.emit('@connectionstatechange', 'connecting');
                      break;
                  case 'connected':
                  case 'completed':
                      this.emit('@connectionstatechange', 'connected');
                      break;
                  case 'failed':
                      this.emit('@connectionstatechange', 'failed');
                      break;
                  case 'disconnected':
                      this.emit('@connectionstatechange', 'disconnected');
                      break;
                  case 'closed':
                      this.emit('@connectionstatechange', 'closed');
                      break;
              }
          });
      }
      async updateIceServers(iceServers) {
          logger.debug('updateIceServers()');
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
      }
      async restartIce(iceParameters) {
          logger.debug('restartIce()');
          // Provide the remote SDP handler with new remote ICE parameters.
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady)
              return;
          if (this._direction === 'send') {
              const offer = await this._pc.createOffer({ iceRestart: true });
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              await this._pc.setLocalDescription(offer);
              const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setRemoteDescription(answer);
          }
          else {
              const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
              await this._pc.setLocalDescription(answer);
          }
      }
      async getTransportStats() {
          return this._pc.getStats();
      }
      async send({ track, encodings, codecOptions, codec }) {
          this._assertSendDirection();
          logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
          if (codec) {
              logger.warn('send() | codec selection is not available in %s handler', this.name);
          }
          this._sendStream.addTrack(track);
          this._pc.addStream(this._sendStream);
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
          sendingRtpParameters.codecs =
              ortc.reduceCodecs(sendingRtpParameters.codecs);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
          sendingRemoteRtpParameters.codecs =
              ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
          if (!this._transportReady)
              await this._setupTransport({ localDtlsRole: 'server', localSdpObject });
          if (track.kind === 'video' && encodings && encodings.length > 1) {
              logger.debug('send() | enabling simulcast');
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media
                  .find((m) => m.type === 'video');
              sdpPlanBUtils.addLegacySimulcast({
                  offerMediaObject,
                  track,
                  numStreams: encodings.length
              });
              offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
          }
          logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
          await this._pc.setLocalDescription(offer);
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media
              .find((m) => m.type === track.kind);
          // Set RTCP CNAME.
          sendingRtpParameters.rtcp.cname =
              sdpCommonUtils.getCname({ offerMediaObject });
          // Set RTP encodings.
          sendingRtpParameters.encodings =
              sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });
          // Complete encodings with given values.
          if (encodings) {
              for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                  if (encodings[idx])
                      Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
          }
          // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
          // each encoding.
          if (sendingRtpParameters.encodings.length > 1 &&
              (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                  sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
              for (const encoding of sendingRtpParameters.encodings) {
                  encoding.scalabilityMode = 'S1T3';
              }
          }
          this._remoteSdp.send({
              offerMediaObject,
              offerRtpParameters: sendingRtpParameters,
              answerRtpParameters: sendingRemoteRtpParameters,
              codecOptions
          });
          const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
          logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
          await this._pc.setRemoteDescription(answer);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          // Insert into the map.
          this._mapSendLocalIdTrack.set(localId, track);
          return {
              localId: localId,
              rtpParameters: sendingRtpParameters
          };
      }
      async stopSending(localId) {
          this._assertSendDirection();
          logger.debug('stopSending() [localId:%s]', localId);
          const track = this._mapSendLocalIdTrack.get(localId);
          if (!track)
              throw new Error('track not found');
          this._mapSendLocalIdTrack.delete(localId);
          this._sendStream.removeTrack(track);
          this._pc.addStream(this._sendStream);
          const offer = await this._pc.createOffer();
          logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
          try {
              await this._pc.setLocalDescription(offer);
          }
          catch (error) {
              // NOTE: If there are no sending tracks, setLocalDescription() will fail with
              // "Failed to create channels". If so, ignore it.
              if (this._sendStream.getTracks().length === 0) {
                  logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());
                  return;
              }
              throw error;
          }
          if (this._pc.signalingState === 'stable')
              return;
          const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
          logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
          await this._pc.setRemoteDescription(answer);
      }
      async replaceTrack(
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      localId, track) {
          throw new errors_1.UnsupportedError('not implemented');
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async setMaxSpatialLayer(localId, spatialLayer) {
          throw new errors_1.UnsupportedError('not implemented');
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async setRtpEncodingParameters(localId, params) {
          throw new errors_1.UnsupportedError('not implemented');
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async getSenderStats(localId) {
          throw new errors_1.UnsupportedError('not implemented');
      }
      async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this._assertSendDirection();
          const options = {
              negotiated: true,
              id: this._nextSendSctpStreamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmitTime: maxPacketLifeTime,
              maxRetransmits,
              protocol
          };
          logger.debug('sendDataChannel() [options:%o]', options);
          const dataChannel = this._pc.createDataChannel(label, options);
          // Increase next id.
          this._nextSendSctpStreamId =
              ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          // If this is the first DataChannel we need to create the SDP answer with
          // m=application section.
          if (!this._hasDataChannelMediaSection) {
              const offer = await this._pc.createOffer();
              const localSdpObject = sdpTransform.parse(offer.sdp);
              const offerMediaObject = localSdpObject.media
                  .find((m) => m.type === 'application');
              if (!this._transportReady)
                  await this._setupTransport({ localDtlsRole: 'server', localSdpObject });
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              await this._pc.setLocalDescription(offer);
              this._remoteSdp.sendSctpAssociation({ offerMediaObject });
              const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setRemoteDescription(answer);
              this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
              streamId: options.id,
              ordered: options.ordered,
              maxPacketLifeTime: options.maxPacketLifeTime,
              maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
      }
      async receive({ trackId, kind, rtpParameters }) {
          this._assertRecvDirection();
          logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
          const localId = trackId;
          const mid = kind;
          let streamId = rtpParameters.rtcp.cname;
          // NOTE: In React-Native we cannot reuse the same remote MediaStream for new
          // remote tracks. This is because react-native-webrtc does not react on new
          // tracks generated within already existing streams, so force the streamId
          // to be different.
          logger.debug('receive() | forcing a random remote streamId to avoid well known bug in react-native-webrtc');
          streamId += `-hack-${utils.generateRandomNumber()}`;
          this._remoteSdp.receive({
              mid,
              kind,
              offerRtpParameters: rtpParameters,
              streamId,
              trackId
          });
          const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
          logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          const answerMediaObject = localSdpObject.media
              .find((m) => String(m.mid) === mid);
          // May need to modify codec parameters in the answer based on codec
          // parameters in the offer.
          sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
          });
          answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady)
              await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
          logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
          await this._pc.setLocalDescription(answer);
          const stream = this._pc.getRemoteStreams()
              .find((s) => s.id === streamId);
          const track = stream.getTrackById(localId);
          if (!track)
              throw new Error('remote track not found');
          // Insert into the map.
          this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters });
          return { localId, track };
      }
      async stopReceiving(localId) {
          this._assertRecvDirection();
          logger.debug('stopReceiving() [localId:%s]', localId);
          const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};
          // Remove from the map.
          this._mapRecvLocalIdInfo.delete(localId);
          this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });
          const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
          logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
          await this._pc.setLocalDescription(answer);
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      async getReceiverStats(localId) {
          throw new errors_1.UnsupportedError('not implemented');
      }
      async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this._assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
              negotiated: true,
              id: streamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmitTime: maxPacketLifeTime,
              maxRetransmits,
              protocol
          };
          logger.debug('receiveDataChannel() [options:%o]', options);
          const dataChannel = this._pc.createDataChannel(label, options);
          // If this is the first DataChannel we need to create the SDP offer with
          // m=application section.
          if (!this._hasDataChannelMediaSection) {
              this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
              const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              if (!this._transportReady) {
                  const localSdpObject = sdpTransform.parse(answer.sdp);
                  await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
              }
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setLocalDescription(answer);
              this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
      }
      async _setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject)
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          // Get our local DTLS parameters.
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });
          // Set our DTLS role.
          dtlsParameters.role = localDtlsRole;
          // Update the remote DTLS role in the SDP.
          this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
          // Need to tell the remote transport about our parameters.
          await this.safeEmitAsPromise('@connect', { dtlsParameters });
          this._transportReady = true;
      }
      _assertSendDirection() {
          if (this._direction !== 'send') {
              throw new Error('method can just be called for handlers with "send" direction');
          }
      }
      _assertRecvDirection() {
          if (this._direction !== 'recv') {
              throw new Error('method can just be called for handlers with "recv" direction');
          }
      }
  }
  exports.ReactNative = ReactNative;
  
  },{"../Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Logger.js","../errors":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/errors.js","../ortc":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/ortc.js","../utils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/utils.js","./HandlerInterface":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js","./sdp/RemoteSdp":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js","./sdp/commonUtils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js","./sdp/planBUtils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js","sdp-transform":"/home/ubuntu/umbrella-voice2/app/node_modules/sdp-transform/lib/index.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/Safari11.js":[function(require,module,exports){
  "use strict";
  var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
      o["default"] = v;
  });
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Safari11 = void 0;
  const sdpTransform = __importStar(require("sdp-transform"));
  const Logger_1 = require("../Logger");
  const utils = __importStar(require("../utils"));
  const ortc = __importStar(require("../ortc"));
  const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
  const sdpPlanBUtils = __importStar(require("./sdp/planBUtils"));
  const HandlerInterface_1 = require("./HandlerInterface");
  const RemoteSdp_1 = require("./sdp/RemoteSdp");
  const logger = new Logger_1.Logger('Safari11');
  const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
  class Safari11 extends HandlerInterface_1.HandlerInterface {
      constructor() {
          super();
          // Local stream for sending.
          this._sendStream = new MediaStream();
          // Map of RTCRtpSender indexed by localId.
          this._mapSendLocalIdRtpSender = new Map();
          // Next sending localId.
          this._nextSendLocalId = 0;
          // Map of MID, RTP parameters and RTCRtpReceiver indexed by local id.
          // Value is an Object with mid, rtpParameters and rtpReceiver.
          this._mapRecvLocalIdInfo = new Map();
          // Whether a DataChannel m=application section has been created.
          this._hasDataChannelMediaSection = false;
          // Sending DataChannel id value counter. Incremented for each new DataChannel.
          this._nextSendSctpStreamId = 0;
          // Got transport local and remote parameters.
          this._transportReady = false;
      }
      /**
       * Creates a factory function.
       */
      static createFactory() {
          return () => new Safari11();
      }
      get name() {
          return 'Safari11';
      }
      close() {
          logger.debug('close()');
          // Close RTCPeerConnection.
          if (this._pc) {
              try {
                  this._pc.close();
              }
              catch (error) { }
          }
      }
      async getNativeRtpCapabilities() {
          logger.debug('getNativeRtpCapabilities()');
          const pc = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: 'all',
              bundlePolicy: 'max-bundle',
              rtcpMuxPolicy: 'require',
              sdpSemantics: 'plan-b'
          });
          try {
              const offer = await pc.createOffer({
                  offerToReceiveAudio: true,
                  offerToReceiveVideo: true
              });
              try {
                  pc.close();
              }
              catch (error) { }
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });
              return nativeRtpCapabilities;
          }
          catch (error) {
              try {
                  pc.close();
              }
              catch (error2) { }
              throw error;
          }
      }
      async getNativeSctpCapabilities() {
          logger.debug('getNativeSctpCapabilities()');
          return {
              numStreams: SCTP_NUM_STREAMS
          };
      }
      run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger.debug('run()');
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters,
              planB: true
          });
          this._sendingRtpParametersByKind =
              {
                  audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
                  video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
              };
          this._sendingRemoteRtpParametersByKind =
              {
                  audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
                  video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
              };
          this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require' }, additionalSettings), proprietaryConstraints);
          // Handle RTCPeerConnection connection status.
          this._pc.addEventListener('iceconnectionstatechange', () => {
              switch (this._pc.iceConnectionState) {
                  case 'checking':
                      this.emit('@connectionstatechange', 'connecting');
                      break;
                  case 'connected':
                  case 'completed':
                      this.emit('@connectionstatechange', 'connected');
                      break;
                  case 'failed':
                      this.emit('@connectionstatechange', 'failed');
                      break;
                  case 'disconnected':
                      this.emit('@connectionstatechange', 'disconnected');
                      break;
                  case 'closed':
                      this.emit('@connectionstatechange', 'closed');
                      break;
              }
          });
      }
      async updateIceServers(iceServers) {
          logger.debug('updateIceServers()');
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
      }
      async restartIce(iceParameters) {
          logger.debug('restartIce()');
          // Provide the remote SDP handler with new remote ICE parameters.
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady)
              return;
          if (this._direction === 'send') {
              const offer = await this._pc.createOffer({ iceRestart: true });
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              await this._pc.setLocalDescription(offer);
              const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setRemoteDescription(answer);
          }
          else {
              const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
              await this._pc.setLocalDescription(answer);
          }
      }
      async getTransportStats() {
          return this._pc.getStats();
      }
      async send({ track, encodings, codecOptions, codec }) {
          this._assertSendDirection();
          logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
          if (codec) {
              logger.warn('send() | codec selection is not available in %s handler', this.name);
          }
          this._sendStream.addTrack(track);
          this._pc.addTrack(track, this._sendStream);
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
          sendingRtpParameters.codecs =
              ortc.reduceCodecs(sendingRtpParameters.codecs);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
          sendingRemoteRtpParameters.codecs =
              ortc.reduceCodecs(sendingRemoteRtpParameters.codecs);
          if (!this._transportReady)
              await this._setupTransport({ localDtlsRole: 'server', localSdpObject });
          if (track.kind === 'video' && encodings && encodings.length > 1) {
              logger.debug('send() | enabling simulcast');
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media.find((m) => m.type === 'video');
              sdpPlanBUtils.addLegacySimulcast({
                  offerMediaObject,
                  track,
                  numStreams: encodings.length
              });
              offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
          }
          logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
          await this._pc.setLocalDescription(offer);
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media
              .find((m) => m.type === track.kind);
          // Set RTCP CNAME.
          sendingRtpParameters.rtcp.cname =
              sdpCommonUtils.getCname({ offerMediaObject });
          // Set RTP encodings.
          sendingRtpParameters.encodings =
              sdpPlanBUtils.getRtpEncodings({ offerMediaObject, track });
          // Complete encodings with given values.
          if (encodings) {
              for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                  if (encodings[idx])
                      Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
          }
          // If VP8 and there is effective simulcast, add scalabilityMode to each
          // encoding.
          if (sendingRtpParameters.encodings.length > 1 &&
              sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8') {
              for (const encoding of sendingRtpParameters.encodings) {
                  encoding.scalabilityMode = 'S1T3';
              }
          }
          this._remoteSdp.send({
              offerMediaObject,
              offerRtpParameters: sendingRtpParameters,
              answerRtpParameters: sendingRemoteRtpParameters,
              codecOptions
          });
          const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
          logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
          await this._pc.setRemoteDescription(answer);
          const localId = String(this._nextSendLocalId);
          this._nextSendLocalId++;
          const rtpSender = this._pc.getSenders()
              .find((s) => s.track === track);
          // Insert into the map.
          this._mapSendLocalIdRtpSender.set(localId, rtpSender);
          return {
              localId: localId,
              rtpParameters: sendingRtpParameters,
              rtpSender
          };
      }
      async stopSending(localId) {
          this._assertSendDirection();
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender)
              throw new Error('associated RTCRtpSender not found');
          if (rtpSender.track)
              this._sendStream.removeTrack(rtpSender.track);
          this._mapSendLocalIdRtpSender.delete(localId);
          const offer = await this._pc.createOffer();
          logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
          try {
              await this._pc.setLocalDescription(offer);
          }
          catch (error) {
              // NOTE: If there are no sending tracks, setLocalDescription() will fail with
              // "Failed to create channels". If so, ignore it.
              if (this._sendStream.getTracks().length === 0) {
                  logger.warn('stopSending() | ignoring expected error due no sending tracks: %s', error.toString());
                  return;
              }
              throw error;
          }
          if (this._pc.signalingState === 'stable')
              return;
          const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
          logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
          await this._pc.setRemoteDescription(answer);
      }
      async replaceTrack(localId, track) {
          this._assertSendDirection();
          if (track) {
              logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
          }
          else {
              logger.debug('replaceTrack() [localId:%s, no track]', localId);
          }
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender)
              throw new Error('associated RTCRtpSender not found');
          const oldTrack = rtpSender.track;
          await rtpSender.replaceTrack(track);
          // Remove the old track from the local stream.
          if (oldTrack)
              this._sendStream.removeTrack(oldTrack);
          // Add the new track to the local stream.
          if (track)
              this._sendStream.addTrack(track);
      }
      async setMaxSpatialLayer(localId, spatialLayer) {
          this._assertSendDirection();
          logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender)
              throw new Error('associated RTCRtpSender not found');
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
              if (idx <= spatialLayer)
                  encoding.active = true;
              else
                  encoding.active = false;
          });
          await rtpSender.setParameters(parameters);
      }
      async setRtpEncodingParameters(localId, params) {
          this._assertSendDirection();
          logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender)
              throw new Error('associated RTCRtpSender not found');
          const parameters = rtpSender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
              parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);
          });
          await rtpSender.setParameters(parameters);
      }
      async getSenderStats(localId) {
          this._assertSendDirection();
          const rtpSender = this._mapSendLocalIdRtpSender.get(localId);
          if (!rtpSender)
              throw new Error('associated RTCRtpSender not found');
          return rtpSender.getStats();
      }
      async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this._assertSendDirection();
          const options = {
              negotiated: true,
              id: this._nextSendSctpStreamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol
          };
          logger.debug('sendDataChannel() [options:%o]', options);
          const dataChannel = this._pc.createDataChannel(label, options);
          // Increase next id.
          this._nextSendSctpStreamId =
              ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          // If this is the first DataChannel we need to create the SDP answer with
          // m=application section.
          if (!this._hasDataChannelMediaSection) {
              const offer = await this._pc.createOffer();
              const localSdpObject = sdpTransform.parse(offer.sdp);
              const offerMediaObject = localSdpObject.media
                  .find((m) => m.type === 'application');
              if (!this._transportReady)
                  await this._setupTransport({ localDtlsRole: 'server', localSdpObject });
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              await this._pc.setLocalDescription(offer);
              this._remoteSdp.sendSctpAssociation({ offerMediaObject });
              const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setRemoteDescription(answer);
              this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
              streamId: options.id,
              ordered: options.ordered,
              maxPacketLifeTime: options.maxPacketLifeTime,
              maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
      }
      async receive({ trackId, kind, rtpParameters }) {
          this._assertRecvDirection();
          logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
          const localId = trackId;
          const mid = kind;
          this._remoteSdp.receive({
              mid,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: rtpParameters.rtcp.cname,
              trackId
          });
          const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
          logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          const answerMediaObject = localSdpObject.media
              .find((m) => String(m.mid) === mid);
          // May need to modify codec parameters in the answer based on codec
          // parameters in the offer.
          sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
          });
          answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady)
              await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
          logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
          await this._pc.setLocalDescription(answer);
          const rtpReceiver = this._pc.getReceivers()
              .find((r) => r.track && r.track.id === localId);
          if (!rtpReceiver)
              throw new Error('new RTCRtpReceiver not');
          // Insert into the map.
          this._mapRecvLocalIdInfo.set(localId, { mid, rtpParameters, rtpReceiver });
          return {
              localId,
              track: rtpReceiver.track,
              rtpReceiver
          };
      }
      async stopReceiving(localId) {
          this._assertRecvDirection();
          logger.debug('stopReceiving() [localId:%s]', localId);
          const { mid, rtpParameters } = this._mapRecvLocalIdInfo.get(localId) || {};
          // Remove from the map.
          this._mapRecvLocalIdInfo.delete(localId);
          this._remoteSdp.planBStopReceiving({ mid: mid, offerRtpParameters: rtpParameters });
          const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
          logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
          await this._pc.setLocalDescription(answer);
      }
      async getReceiverStats(localId) {
          this._assertRecvDirection();
          const { rtpReceiver } = this._mapRecvLocalIdInfo.get(localId) || {};
          if (!rtpReceiver)
              throw new Error('associated RTCRtpReceiver not found');
          return rtpReceiver.getStats();
      }
      async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this._assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
              negotiated: true,
              id: streamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol
          };
          logger.debug('receiveDataChannel() [options:%o]', options);
          const dataChannel = this._pc.createDataChannel(label, options);
          // If this is the first DataChannel we need to create the SDP offer with
          // m=application section.
          if (!this._hasDataChannelMediaSection) {
              this._remoteSdp.receiveSctpAssociation({ oldDataChannelSpec: true });
              const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              if (!this._transportReady) {
                  const localSdpObject = sdpTransform.parse(answer.sdp);
                  await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
              }
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setLocalDescription(answer);
              this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
      }
      async _setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject)
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          // Get our local DTLS parameters.
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });
          // Set our DTLS role.
          dtlsParameters.role = localDtlsRole;
          // Update the remote DTLS role in the SDP.
          this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
          // Need to tell the remote transport about our parameters.
          await this.safeEmitAsPromise('@connect', { dtlsParameters });
          this._transportReady = true;
      }
      _assertSendDirection() {
          if (this._direction !== 'send') {
              throw new Error('method can just be called for handlers with "send" direction');
          }
      }
      _assertRecvDirection() {
          if (this._direction !== 'recv') {
              throw new Error('method can just be called for handlers with "recv" direction');
          }
      }
  }
  exports.Safari11 = Safari11;
  
  },{"../Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Logger.js","../ortc":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/ortc.js","../utils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/utils.js","./HandlerInterface":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js","./sdp/RemoteSdp":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js","./sdp/commonUtils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js","./sdp/planBUtils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js","sdp-transform":"/home/ubuntu/umbrella-voice2/app/node_modules/sdp-transform/lib/index.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/Safari12.js":[function(require,module,exports){
  "use strict";
  var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
      o["default"] = v;
  });
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.Safari12 = void 0;
  const sdpTransform = __importStar(require("sdp-transform"));
  const Logger_1 = require("../Logger");
  const utils = __importStar(require("../utils"));
  const ortc = __importStar(require("../ortc"));
  const sdpCommonUtils = __importStar(require("./sdp/commonUtils"));
  const sdpUnifiedPlanUtils = __importStar(require("./sdp/unifiedPlanUtils"));
  const HandlerInterface_1 = require("./HandlerInterface");
  const RemoteSdp_1 = require("./sdp/RemoteSdp");
  const logger = new Logger_1.Logger('Safari12');
  const SCTP_NUM_STREAMS = { OS: 1024, MIS: 1024 };
  class Safari12 extends HandlerInterface_1.HandlerInterface {
      constructor() {
          super();
          // Map of RTCTransceivers indexed by MID.
          this._mapMidTransceiver = new Map();
          // Local stream for sending.
          this._sendStream = new MediaStream();
          // Whether a DataChannel m=application section has been created.
          this._hasDataChannelMediaSection = false;
          // Sending DataChannel id value counter. Incremented for each new DataChannel.
          this._nextSendSctpStreamId = 0;
          // Got transport local and remote parameters.
          this._transportReady = false;
      }
      /**
       * Creates a factory function.
       */
      static createFactory() {
          return () => new Safari12();
      }
      get name() {
          return 'Safari12';
      }
      close() {
          logger.debug('close()');
          // Close RTCPeerConnection.
          if (this._pc) {
              try {
                  this._pc.close();
              }
              catch (error) { }
          }
      }
      async getNativeRtpCapabilities() {
          logger.debug('getNativeRtpCapabilities()');
          const pc = new RTCPeerConnection({
              iceServers: [],
              iceTransportPolicy: 'all',
              bundlePolicy: 'max-bundle',
              rtcpMuxPolicy: 'require'
          });
          try {
              pc.addTransceiver('audio');
              pc.addTransceiver('video');
              const offer = await pc.createOffer();
              try {
                  pc.close();
              }
              catch (error) { }
              const sdpObject = sdpTransform.parse(offer.sdp);
              const nativeRtpCapabilities = sdpCommonUtils.extractRtpCapabilities({ sdpObject });
              return nativeRtpCapabilities;
          }
          catch (error) {
              try {
                  pc.close();
              }
              catch (error2) { }
              throw error;
          }
      }
      async getNativeSctpCapabilities() {
          logger.debug('getNativeSctpCapabilities()');
          return {
              numStreams: SCTP_NUM_STREAMS
          };
      }
      run({ direction, iceParameters, iceCandidates, dtlsParameters, sctpParameters, iceServers, iceTransportPolicy, additionalSettings, proprietaryConstraints, extendedRtpCapabilities }) {
          logger.debug('run()');
          this._direction = direction;
          this._remoteSdp = new RemoteSdp_1.RemoteSdp({
              iceParameters,
              iceCandidates,
              dtlsParameters,
              sctpParameters
          });
          this._sendingRtpParametersByKind =
              {
                  audio: ortc.getSendingRtpParameters('audio', extendedRtpCapabilities),
                  video: ortc.getSendingRtpParameters('video', extendedRtpCapabilities)
              };
          this._sendingRemoteRtpParametersByKind =
              {
                  audio: ortc.getSendingRemoteRtpParameters('audio', extendedRtpCapabilities),
                  video: ortc.getSendingRemoteRtpParameters('video', extendedRtpCapabilities)
              };
          this._pc = new RTCPeerConnection(Object.assign({ iceServers: iceServers || [], iceTransportPolicy: iceTransportPolicy || 'all', bundlePolicy: 'max-bundle', rtcpMuxPolicy: 'require' }, additionalSettings), proprietaryConstraints);
          // Handle RTCPeerConnection connection status.
          this._pc.addEventListener('iceconnectionstatechange', () => {
              switch (this._pc.iceConnectionState) {
                  case 'checking':
                      this.emit('@connectionstatechange', 'connecting');
                      break;
                  case 'connected':
                  case 'completed':
                      this.emit('@connectionstatechange', 'connected');
                      break;
                  case 'failed':
                      this.emit('@connectionstatechange', 'failed');
                      break;
                  case 'disconnected':
                      this.emit('@connectionstatechange', 'disconnected');
                      break;
                  case 'closed':
                      this.emit('@connectionstatechange', 'closed');
                      break;
              }
          });
      }
      async updateIceServers(iceServers) {
          logger.debug('updateIceServers()');
          const configuration = this._pc.getConfiguration();
          configuration.iceServers = iceServers;
          this._pc.setConfiguration(configuration);
      }
      async restartIce(iceParameters) {
          logger.debug('restartIce()');
          // Provide the remote SDP handler with new remote ICE parameters.
          this._remoteSdp.updateIceParameters(iceParameters);
          if (!this._transportReady)
              return;
          if (this._direction === 'send') {
              const offer = await this._pc.createOffer({ iceRestart: true });
              logger.debug('restartIce() | calling pc.setLocalDescription() [offer:%o]', offer);
              await this._pc.setLocalDescription(offer);
              const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setRemoteDescription(answer);
          }
          else {
              const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
              logger.debug('restartIce() | calling pc.setRemoteDescription() [offer:%o]', offer);
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              logger.debug('restartIce() | calling pc.setLocalDescription() [answer:%o]', answer);
              await this._pc.setLocalDescription(answer);
          }
      }
      async getTransportStats() {
          return this._pc.getStats();
      }
      async send({ track, encodings, codecOptions, codec }) {
          this._assertSendDirection();
          logger.debug('send() [kind:%s, track.id:%s]', track.kind, track.id);
          const sendingRtpParameters = utils.clone(this._sendingRtpParametersByKind[track.kind], {});
          // This may throw.
          sendingRtpParameters.codecs =
              ortc.reduceCodecs(sendingRtpParameters.codecs, codec);
          const sendingRemoteRtpParameters = utils.clone(this._sendingRemoteRtpParametersByKind[track.kind], {});
          // This may throw.
          sendingRemoteRtpParameters.codecs =
              ortc.reduceCodecs(sendingRemoteRtpParameters.codecs, codec);
          const mediaSectionIdx = this._remoteSdp.getNextMediaSectionIdx();
          const transceiver = this._pc.addTransceiver(track, { direction: 'sendonly', streams: [this._sendStream] });
          let offer = await this._pc.createOffer();
          let localSdpObject = sdpTransform.parse(offer.sdp);
          let offerMediaObject;
          if (!this._transportReady)
              await this._setupTransport({ localDtlsRole: 'server', localSdpObject });
          if (encodings && encodings.length > 1) {
              logger.debug('send() | enabling legacy simulcast');
              localSdpObject = sdpTransform.parse(offer.sdp);
              offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
              sdpUnifiedPlanUtils.addLegacySimulcast({
                  offerMediaObject,
                  numStreams: encodings.length
              });
              offer = { type: 'offer', sdp: sdpTransform.write(localSdpObject) };
          }
          logger.debug('send() | calling pc.setLocalDescription() [offer:%o]', offer);
          await this._pc.setLocalDescription(offer);
          // We can now get the transceiver.mid.
          const localId = transceiver.mid;
          // Set MID.
          sendingRtpParameters.mid = localId;
          localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          offerMediaObject = localSdpObject.media[mediaSectionIdx.idx];
          // Set RTCP CNAME.
          sendingRtpParameters.rtcp.cname =
              sdpCommonUtils.getCname({ offerMediaObject });
          // Set RTP encodings.
          sendingRtpParameters.encodings =
              sdpUnifiedPlanUtils.getRtpEncodings({ offerMediaObject });
          // Complete encodings with given values.
          if (encodings) {
              for (let idx = 0; idx < sendingRtpParameters.encodings.length; ++idx) {
                  if (encodings[idx])
                      Object.assign(sendingRtpParameters.encodings[idx], encodings[idx]);
              }
          }
          // If VP8 or H264 and there is effective simulcast, add scalabilityMode to
          // each encoding.
          if (sendingRtpParameters.encodings.length > 1 &&
              (sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/vp8' ||
                  sendingRtpParameters.codecs[0].mimeType.toLowerCase() === 'video/h264')) {
              for (const encoding of sendingRtpParameters.encodings) {
                  encoding.scalabilityMode = 'S1T3';
              }
          }
          this._remoteSdp.send({
              offerMediaObject,
              reuseMid: mediaSectionIdx.reuseMid,
              offerRtpParameters: sendingRtpParameters,
              answerRtpParameters: sendingRemoteRtpParameters,
              codecOptions
          });
          const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
          logger.debug('send() | calling pc.setRemoteDescription() [answer:%o]', answer);
          await this._pc.setRemoteDescription(answer);
          // Store in the map.
          this._mapMidTransceiver.set(localId, transceiver);
          return {
              localId,
              rtpParameters: sendingRtpParameters,
              rtpSender: transceiver.sender
          };
      }
      async stopSending(localId) {
          this._assertSendDirection();
          logger.debug('stopSending() [localId:%s]', localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          transceiver.sender.replaceTrack(null);
          this._pc.removeTrack(transceiver.sender);
          this._remoteSdp.closeMediaSection(transceiver.mid);
          const offer = await this._pc.createOffer();
          logger.debug('stopSending() | calling pc.setLocalDescription() [offer:%o]', offer);
          await this._pc.setLocalDescription(offer);
          const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
          logger.debug('stopSending() | calling pc.setRemoteDescription() [answer:%o]', answer);
          await this._pc.setRemoteDescription(answer);
      }
      async replaceTrack(localId, track) {
          this._assertSendDirection();
          if (track) {
              logger.debug('replaceTrack() [localId:%s, track.id:%s]', localId, track.id);
          }
          else {
              logger.debug('replaceTrack() [localId:%s, no track]', localId);
          }
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          await transceiver.sender.replaceTrack(track);
      }
      async setMaxSpatialLayer(localId, spatialLayer) {
          this._assertSendDirection();
          logger.debug('setMaxSpatialLayer() [localId:%s, spatialLayer:%s]', localId, spatialLayer);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
              if (idx <= spatialLayer)
                  encoding.active = true;
              else
                  encoding.active = false;
          });
          await transceiver.sender.setParameters(parameters);
      }
      async setRtpEncodingParameters(localId, params) {
          this._assertSendDirection();
          logger.debug('setRtpEncodingParameters() [localId:%s, params:%o]', localId, params);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          const parameters = transceiver.sender.getParameters();
          parameters.encodings.forEach((encoding, idx) => {
              parameters.encodings[idx] = Object.assign(Object.assign({}, encoding), params);
          });
          await transceiver.sender.setParameters(parameters);
      }
      async getSenderStats(localId) {
          this._assertSendDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          return transceiver.sender.getStats();
      }
      async sendDataChannel({ ordered, maxPacketLifeTime, maxRetransmits, label, protocol }) {
          this._assertSendDirection();
          const options = {
              negotiated: true,
              id: this._nextSendSctpStreamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol
          };
          logger.debug('sendDataChannel() [options:%o]', options);
          const dataChannel = this._pc.createDataChannel(label, options);
          // Increase next id.
          this._nextSendSctpStreamId =
              ++this._nextSendSctpStreamId % SCTP_NUM_STREAMS.MIS;
          // If this is the first DataChannel we need to create the SDP answer with
          // m=application section.
          if (!this._hasDataChannelMediaSection) {
              const offer = await this._pc.createOffer();
              const localSdpObject = sdpTransform.parse(offer.sdp);
              const offerMediaObject = localSdpObject.media
                  .find((m) => m.type === 'application');
              if (!this._transportReady)
                  await this._setupTransport({ localDtlsRole: 'server', localSdpObject });
              logger.debug('sendDataChannel() | calling pc.setLocalDescription() [offer:%o]', offer);
              await this._pc.setLocalDescription(offer);
              this._remoteSdp.sendSctpAssociation({ offerMediaObject });
              const answer = { type: 'answer', sdp: this._remoteSdp.getSdp() };
              logger.debug('sendDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setRemoteDescription(answer);
              this._hasDataChannelMediaSection = true;
          }
          const sctpStreamParameters = {
              streamId: options.id,
              ordered: options.ordered,
              maxPacketLifeTime: options.maxPacketLifeTime,
              maxRetransmits: options.maxRetransmits
          };
          return { dataChannel, sctpStreamParameters };
      }
      async receive({ trackId, kind, rtpParameters }) {
          this._assertRecvDirection();
          logger.debug('receive() [trackId:%s, kind:%s]', trackId, kind);
          const localId = rtpParameters.mid || String(this._mapMidTransceiver.size);
          this._remoteSdp.receive({
              mid: localId,
              kind,
              offerRtpParameters: rtpParameters,
              streamId: rtpParameters.rtcp.cname,
              trackId
          });
          const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
          logger.debug('receive() | calling pc.setRemoteDescription() [offer:%o]', offer);
          await this._pc.setRemoteDescription(offer);
          let answer = await this._pc.createAnswer();
          const localSdpObject = sdpTransform.parse(answer.sdp);
          const answerMediaObject = localSdpObject.media
              .find((m) => String(m.mid) === localId);
          // May need to modify codec parameters in the answer based on codec
          // parameters in the offer.
          sdpCommonUtils.applyCodecParameters({
              offerRtpParameters: rtpParameters,
              answerMediaObject
          });
          answer = { type: 'answer', sdp: sdpTransform.write(localSdpObject) };
          if (!this._transportReady)
              await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
          logger.debug('receive() | calling pc.setLocalDescription() [answer:%o]', answer);
          await this._pc.setLocalDescription(answer);
          const transceiver = this._pc.getTransceivers()
              .find((t) => t.mid === localId);
          if (!transceiver)
              throw new Error('new RTCRtpTransceiver not found');
          // Store in the map.
          this._mapMidTransceiver.set(localId, transceiver);
          return {
              localId,
              track: transceiver.receiver.track,
              rtpReceiver: transceiver.receiver
          };
      }
      async stopReceiving(localId) {
          this._assertRecvDirection();
          logger.debug('stopReceiving() [localId:%s]', localId);
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          this._remoteSdp.closeMediaSection(transceiver.mid);
          const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
          logger.debug('stopReceiving() | calling pc.setRemoteDescription() [offer:%o]', offer);
          await this._pc.setRemoteDescription(offer);
          const answer = await this._pc.createAnswer();
          logger.debug('stopReceiving() | calling pc.setLocalDescription() [answer:%o]', answer);
          await this._pc.setLocalDescription(answer);
      }
      async getReceiverStats(localId) {
          this._assertRecvDirection();
          const transceiver = this._mapMidTransceiver.get(localId);
          if (!transceiver)
              throw new Error('associated RTCRtpTransceiver not found');
          return transceiver.receiver.getStats();
      }
      async receiveDataChannel({ sctpStreamParameters, label, protocol }) {
          this._assertRecvDirection();
          const { streamId, ordered, maxPacketLifeTime, maxRetransmits } = sctpStreamParameters;
          const options = {
              negotiated: true,
              id: streamId,
              ordered,
              maxPacketLifeTime,
              maxRetransmits,
              protocol
          };
          logger.debug('receiveDataChannel() [options:%o]', options);
          const dataChannel = this._pc.createDataChannel(label, options);
          // If this is the first DataChannel we need to create the SDP offer with
          // m=application section.
          if (!this._hasDataChannelMediaSection) {
              this._remoteSdp.receiveSctpAssociation();
              const offer = { type: 'offer', sdp: this._remoteSdp.getSdp() };
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [offer:%o]', offer);
              await this._pc.setRemoteDescription(offer);
              const answer = await this._pc.createAnswer();
              if (!this._transportReady) {
                  const localSdpObject = sdpTransform.parse(answer.sdp);
                  await this._setupTransport({ localDtlsRole: 'client', localSdpObject });
              }
              logger.debug('receiveDataChannel() | calling pc.setRemoteDescription() [answer:%o]', answer);
              await this._pc.setLocalDescription(answer);
              this._hasDataChannelMediaSection = true;
          }
          return { dataChannel };
      }
      async _setupTransport({ localDtlsRole, localSdpObject }) {
          if (!localSdpObject)
              localSdpObject = sdpTransform.parse(this._pc.localDescription.sdp);
          // Get our local DTLS parameters.
          const dtlsParameters = sdpCommonUtils.extractDtlsParameters({ sdpObject: localSdpObject });
          // Set our DTLS role.
          dtlsParameters.role = localDtlsRole;
          // Update the remote DTLS role in the SDP.
          this._remoteSdp.updateDtlsRole(localDtlsRole === 'client' ? 'server' : 'client');
          // Need to tell the remote transport about our parameters.
          await this.safeEmitAsPromise('@connect', { dtlsParameters });
          this._transportReady = true;
      }
      _assertSendDirection() {
          if (this._direction !== 'send') {
              throw new Error('method can just be called for handlers with "send" direction');
          }
      }
      _assertRecvDirection() {
          if (this._direction !== 'recv') {
              throw new Error('method can just be called for handlers with "recv" direction');
          }
      }
  }
  exports.Safari12 = Safari12;
  
  },{"../Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Logger.js","../ortc":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/ortc.js","../utils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/utils.js","./HandlerInterface":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js","./sdp/RemoteSdp":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js","./sdp/commonUtils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js","./sdp/unifiedPlanUtils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js","sdp-transform":"/home/ubuntu/umbrella-voice2/app/node_modules/sdp-transform/lib/index.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/ortc/edgeUtils.js":[function(require,module,exports){
  "use strict";
  var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
      o["default"] = v;
  });
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.mangleRtpParameters = exports.getCapabilities = void 0;
  const utils = __importStar(require("../../utils"));
  /**
   * Normalize ORTC based Edge's RTCRtpReceiver.getCapabilities() to produce a full
   * compliant ORTC RTCRtpCapabilities.
   */
  function getCapabilities() {
      const nativeCaps = RTCRtpReceiver.getCapabilities();
      const caps = utils.clone(nativeCaps, {});
      for (const codec of caps.codecs) {
          // Rename numChannels to channels.
          codec.channels = codec.numChannels;
          delete codec.numChannels;
          // Add mimeType.
          codec.mimeType = codec.mimeType || `${codec.kind}/${codec.name}`;
          // NOTE: Edge sets some numeric parameters as string rather than number. Fix them.
          if (codec.parameters) {
              const parameters = codec.parameters;
              if (parameters.apt)
                  parameters.apt = Number(parameters.apt);
              if (parameters['packetization-mode'])
                  parameters['packetization-mode'] = Number(parameters['packetization-mode']);
          }
          // Delete emty parameter String in rtcpFeedback.
          for (const feedback of codec.rtcpFeedback || []) {
              if (!feedback.parameter)
                  feedback.parameter = '';
          }
      }
      return caps;
  }
  exports.getCapabilities = getCapabilities;
  /**
   * Generate RTCRtpParameters as ORTC based Edge likes.
   */
  function mangleRtpParameters(rtpParameters) {
      const params = utils.clone(rtpParameters, {});
      // Rename mid to muxId.
      if (params.mid) {
          params.muxId = params.mid;
          delete params.mid;
      }
      for (const codec of params.codecs) {
          // Rename channels to numChannels.
          if (codec.channels) {
              codec.numChannels = codec.channels;
              delete codec.channels;
          }
          // Add codec.name (requried by Edge).
          if (codec.mimeType && !codec.name)
              codec.name = codec.mimeType.split('/')[1];
          // Remove mimeType.
          delete codec.mimeType;
      }
      return params;
  }
  exports.mangleRtpParameters = mangleRtpParameters;
  
  },{"../../utils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/utils.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js":[function(require,module,exports){
  "use strict";
  var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
      o["default"] = v;
  });
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.OfferMediaSection = exports.AnswerMediaSection = exports.MediaSection = void 0;
  const utils = __importStar(require("../../utils"));
  class MediaSection {
      constructor({ iceParameters, iceCandidates, dtlsParameters, planB = false }) {
          this._mediaObject = {};
          this._planB = planB;
          if (iceParameters) {
              this.setIceParameters(iceParameters);
          }
          if (iceCandidates) {
              this._mediaObject.candidates = [];
              for (const candidate of iceCandidates) {
                  const candidateObject = {};
                  // mediasoup does mandates rtcp-mux so candidates component is always
                  // RTP (1).
                  candidateObject.component = 1;
                  candidateObject.foundation = candidate.foundation;
                  candidateObject.ip = candidate.ip;
                  candidateObject.port = candidate.port;
                  candidateObject.priority = candidate.priority;
                  candidateObject.transport = candidate.protocol;
                  candidateObject.type = candidate.type;
                  if (candidate.tcpType)
                      candidateObject.tcptype = candidate.tcpType;
                  this._mediaObject.candidates.push(candidateObject);
              }
              this._mediaObject.endOfCandidates = 'end-of-candidates';
              this._mediaObject.iceOptions = 'renomination';
          }
          if (dtlsParameters) {
              this.setDtlsRole(dtlsParameters.role);
          }
      }
      get mid() {
          return String(this._mediaObject.mid);
      }
      get closed() {
          return this._mediaObject.port === 0;
      }
      getObject() {
          return this._mediaObject;
      }
      setIceParameters(iceParameters) {
          this._mediaObject.iceUfrag = iceParameters.usernameFragment;
          this._mediaObject.icePwd = iceParameters.password;
      }
      disable() {
          this._mediaObject.direction = 'inactive';
          delete this._mediaObject.ext;
          delete this._mediaObject.ssrcs;
          delete this._mediaObject.ssrcGroups;
          delete this._mediaObject.simulcast;
          delete this._mediaObject.simulcast_03;
          delete this._mediaObject.rids;
      }
      close() {
          this._mediaObject.direction = 'inactive';
          this._mediaObject.port = 0;
          delete this._mediaObject.ext;
          delete this._mediaObject.ssrcs;
          delete this._mediaObject.ssrcGroups;
          delete this._mediaObject.simulcast;
          delete this._mediaObject.simulcast_03;
          delete this._mediaObject.rids;
          delete this._mediaObject.extmapAllowMixed;
      }
  }
  exports.MediaSection = MediaSection;
  class AnswerMediaSection extends MediaSection {
      constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, offerMediaObject, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false }) {
          super({ iceParameters, iceCandidates, dtlsParameters, planB });
          this._mediaObject.mid = String(offerMediaObject.mid);
          this._mediaObject.type = offerMediaObject.type;
          this._mediaObject.protocol = offerMediaObject.protocol;
          if (!plainRtpParameters) {
              this._mediaObject.connection = { ip: '127.0.0.1', version: 4 };
              this._mediaObject.port = 7;
          }
          else {
              this._mediaObject.connection =
                  {
                      ip: plainRtpParameters.ip,
                      version: plainRtpParameters.ipVersion
                  };
              this._mediaObject.port = plainRtpParameters.port;
          }
          switch (offerMediaObject.type) {
              case 'audio':
              case 'video':
                  {
                      this._mediaObject.direction = 'recvonly';
                      this._mediaObject.rtp = [];
                      this._mediaObject.rtcpFb = [];
                      this._mediaObject.fmtp = [];
                      for (const codec of answerRtpParameters.codecs) {
                          const rtp = {
                              payload: codec.payloadType,
                              codec: getCodecName(codec),
                              rate: codec.clockRate
                          };
                          if (codec.channels > 1)
                              rtp.encoding = codec.channels;
                          this._mediaObject.rtp.push(rtp);
                          const codecParameters = utils.clone(codec.parameters, {});
                          if (codecOptions) {
                              const { opusStereo, opusFec, opusDtx, opusMaxPlaybackRate, opusMaxAverageBitrate, opusPtime, videoGoogleStartBitrate, videoGoogleMaxBitrate, videoGoogleMinBitrate } = codecOptions;
                              const offerCodec = offerRtpParameters.codecs
                                  .find((c) => (c.payloadType === codec.payloadType));
                              switch (codec.mimeType.toLowerCase()) {
                                  case 'audio/opus':
                                      {
                                          if (opusStereo !== undefined) {
                                              offerCodec.parameters['sprop-stereo'] = opusStereo ? 1 : 0;
                                              codecParameters.stereo = opusStereo ? 1 : 0;
                                          }
                                          if (opusFec !== undefined) {
                                              offerCodec.parameters.useinbandfec = opusFec ? 1 : 0;
                                              codecParameters.useinbandfec = opusFec ? 1 : 0;
                                          }
                                          if (opusDtx !== undefined) {
                                              offerCodec.parameters.usedtx = opusDtx ? 1 : 0;
                                              codecParameters.usedtx = opusDtx ? 1 : 0;
                                          }
                                          if (opusMaxPlaybackRate !== undefined) {
                                              codecParameters.maxplaybackrate = opusMaxPlaybackRate;
                                          }
                                          if (opusMaxAverageBitrate !== undefined) {
                                              codecParameters.maxaveragebitrate = opusMaxAverageBitrate;
                                          }
                                          if (opusPtime !== undefined) {
                                              offerCodec.parameters.ptime = opusPtime;
                                              codecParameters.ptime = opusPtime;
                                          }
                                          break;
                                      }
                                  case 'video/vp8':
                                  case 'video/vp9':
                                  case 'video/h264':
                                  case 'video/h265':
                                      {
                                          if (videoGoogleStartBitrate !== undefined)
                                              codecParameters['x-google-start-bitrate'] = videoGoogleStartBitrate;
                                          if (videoGoogleMaxBitrate !== undefined)
                                              codecParameters['x-google-max-bitrate'] = videoGoogleMaxBitrate;
                                          if (videoGoogleMinBitrate !== undefined)
                                              codecParameters['x-google-min-bitrate'] = videoGoogleMinBitrate;
                                          break;
                                      }
                              }
                          }
                          const fmtp = {
                              payload: codec.payloadType,
                              config: ''
                          };
                          for (const key of Object.keys(codecParameters)) {
                              if (fmtp.config)
                                  fmtp.config += ';';
                              fmtp.config += `${key}=${codecParameters[key]}`;
                          }
                          if (fmtp.config)
                              this._mediaObject.fmtp.push(fmtp);
                          for (const fb of codec.rtcpFeedback) {
                              this._mediaObject.rtcpFb.push({
                                  payload: codec.payloadType,
                                  type: fb.type,
                                  subtype: fb.parameter
                              });
                          }
                      }
                      this._mediaObject.payloads = answerRtpParameters.codecs
                          .map((codec) => codec.payloadType)
                          .join(' ');
                      this._mediaObject.ext = [];
                      for (const ext of answerRtpParameters.headerExtensions) {
                          // Don't add a header extension if not present in the offer.
                          const found = (offerMediaObject.ext || [])
                              .some((localExt) => localExt.uri === ext.uri);
                          if (!found)
                              continue;
                          this._mediaObject.ext.push({
                              uri: ext.uri,
                              value: ext.id
                          });
                      }
                      // Allow both 1 byte and 2 bytes length header extensions.
                      if (extmapAllowMixed &&
                          offerMediaObject.extmapAllowMixed === 'extmap-allow-mixed') {
                          this._mediaObject.extmapAllowMixed = 'extmap-allow-mixed';
                      }
                      // Simulcast.
                      if (offerMediaObject.simulcast) {
                          this._mediaObject.simulcast =
                              {
                                  dir1: 'recv',
                                  list1: offerMediaObject.simulcast.list1
                              };
                          this._mediaObject.rids = [];
                          for (const rid of offerMediaObject.rids || []) {
                              if (rid.direction !== 'send')
                                  continue;
                              this._mediaObject.rids.push({
                                  id: rid.id,
                                  direction: 'recv'
                              });
                          }
                      }
                      // Simulcast (draft version 03).
                      else if (offerMediaObject.simulcast_03) {
                          // eslint-disable-next-line camelcase
                          this._mediaObject.simulcast_03 =
                              {
                                  value: offerMediaObject.simulcast_03.value.replace(/send/g, 'recv')
                              };
                          this._mediaObject.rids = [];
                          for (const rid of offerMediaObject.rids || []) {
                              if (rid.direction !== 'send')
                                  continue;
                              this._mediaObject.rids.push({
                                  id: rid.id,
                                  direction: 'recv'
                              });
                          }
                      }
                      this._mediaObject.rtcpMux = 'rtcp-mux';
                      this._mediaObject.rtcpRsize = 'rtcp-rsize';
                      if (this._planB && this._mediaObject.type === 'video')
                          this._mediaObject.xGoogleFlag = 'conference';
                      break;
                  }
              case 'application':
                  {
                      // New spec.
                      if (typeof offerMediaObject.sctpPort === 'number') {
                          this._mediaObject.payloads = 'webrtc-datachannel';
                          this._mediaObject.sctpPort = sctpParameters.port;
                          this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
                      }
                      // Old spec.
                      else if (offerMediaObject.sctpmap) {
                          this._mediaObject.payloads = sctpParameters.port;
                          this._mediaObject.sctpmap =
                              {
                                  app: 'webrtc-datachannel',
                                  sctpmapNumber: sctpParameters.port,
                                  maxMessageSize: sctpParameters.maxMessageSize
                              };
                      }
                      break;
                  }
          }
      }
      setDtlsRole(role) {
          switch (role) {
              case 'client':
                  this._mediaObject.setup = 'active';
                  break;
              case 'server':
                  this._mediaObject.setup = 'passive';
                  break;
              case 'auto':
                  this._mediaObject.setup = 'actpass';
                  break;
          }
      }
  }
  exports.AnswerMediaSection = AnswerMediaSection;
  class OfferMediaSection extends MediaSection {
      constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false, mid, kind, offerRtpParameters, streamId, trackId, oldDataChannelSpec = false }) {
          super({ iceParameters, iceCandidates, dtlsParameters, planB });
          this._mediaObject.mid = String(mid);
          this._mediaObject.type = kind;
          if (!plainRtpParameters) {
              this._mediaObject.connection = { ip: '127.0.0.1', version: 4 };
              if (!sctpParameters)
                  this._mediaObject.protocol = 'UDP/TLS/RTP/SAVPF';
              else
                  this._mediaObject.protocol = 'UDP/DTLS/SCTP';
              this._mediaObject.port = 7;
          }
          else {
              this._mediaObject.connection =
                  {
                      ip: plainRtpParameters.ip,
                      version: plainRtpParameters.ipVersion
                  };
              this._mediaObject.protocol = 'RTP/AVP';
              this._mediaObject.port = plainRtpParameters.port;
          }
          switch (kind) {
              case 'audio':
              case 'video':
                  {
                      this._mediaObject.direction = 'sendonly';
                      this._mediaObject.rtp = [];
                      this._mediaObject.rtcpFb = [];
                      this._mediaObject.fmtp = [];
                      if (!this._planB)
                          this._mediaObject.msid = `${streamId || '-'} ${trackId}`;
                      for (const codec of offerRtpParameters.codecs) {
                          const rtp = {
                              payload: codec.payloadType,
                              codec: getCodecName(codec),
                              rate: codec.clockRate
                          };
                          if (codec.channels > 1)
                              rtp.encoding = codec.channels;
                          this._mediaObject.rtp.push(rtp);
                          const fmtp = {
                              payload: codec.payloadType,
                              config: ''
                          };
                          for (const key of Object.keys(codec.parameters)) {
                              if (fmtp.config)
                                  fmtp.config += ';';
                              fmtp.config += `${key}=${codec.parameters[key]}`;
                          }
                          if (fmtp.config)
                              this._mediaObject.fmtp.push(fmtp);
                          for (const fb of codec.rtcpFeedback) {
                              this._mediaObject.rtcpFb.push({
                                  payload: codec.payloadType,
                                  type: fb.type,
                                  subtype: fb.parameter
                              });
                          }
                      }
                      this._mediaObject.payloads = offerRtpParameters.codecs
                          .map((codec) => codec.payloadType)
                          .join(' ');
                      this._mediaObject.ext = [];
                      for (const ext of offerRtpParameters.headerExtensions) {
                          this._mediaObject.ext.push({
                              uri: ext.uri,
                              value: ext.id
                          });
                      }
                      this._mediaObject.rtcpMux = 'rtcp-mux';
                      this._mediaObject.rtcpRsize = 'rtcp-rsize';
                      const encoding = offerRtpParameters.encodings[0];
                      const ssrc = encoding.ssrc;
                      const rtxSsrc = (encoding.rtx && encoding.rtx.ssrc)
                          ? encoding.rtx.ssrc
                          : undefined;
                      this._mediaObject.ssrcs = [];
                      this._mediaObject.ssrcGroups = [];
                      if (offerRtpParameters.rtcp.cname) {
                          this._mediaObject.ssrcs.push({
                              id: ssrc,
                              attribute: 'cname',
                              value: offerRtpParameters.rtcp.cname
                          });
                      }
                      if (this._planB) {
                          this._mediaObject.ssrcs.push({
                              id: ssrc,
                              attribute: 'msid',
                              value: `${streamId || '-'} ${trackId}`
                          });
                      }
                      if (rtxSsrc) {
                          if (offerRtpParameters.rtcp.cname) {
                              this._mediaObject.ssrcs.push({
                                  id: rtxSsrc,
                                  attribute: 'cname',
                                  value: offerRtpParameters.rtcp.cname
                              });
                          }
                          if (this._planB) {
                              this._mediaObject.ssrcs.push({
                                  id: rtxSsrc,
                                  attribute: 'msid',
                                  value: `${streamId || '-'} ${trackId}`
                              });
                          }
                          // Associate original and retransmission SSRCs.
                          this._mediaObject.ssrcGroups.push({
                              semantics: 'FID',
                              ssrcs: `${ssrc} ${rtxSsrc}`
                          });
                      }
                      break;
                  }
              case 'application':
                  {
                      // New spec.
                      if (!oldDataChannelSpec) {
                          this._mediaObject.payloads = 'webrtc-datachannel';
                          this._mediaObject.sctpPort = sctpParameters.port;
                          this._mediaObject.maxMessageSize = sctpParameters.maxMessageSize;
                      }
                      // Old spec.
                      else {
                          this._mediaObject.payloads = sctpParameters.port;
                          this._mediaObject.sctpmap =
                              {
                                  app: 'webrtc-datachannel',
                                  sctpmapNumber: sctpParameters.port,
                                  maxMessageSize: sctpParameters.maxMessageSize
                              };
                      }
                      break;
                  }
          }
      }
      // eslint-disable-next-line @typescript-eslint/no-unused-vars
      setDtlsRole(role) {
          // Always 'actpass'.
          this._mediaObject.setup = 'actpass';
      }
      planBReceive({ offerRtpParameters, streamId, trackId }) {
          const encoding = offerRtpParameters.encodings[0];
          const ssrc = encoding.ssrc;
          const rtxSsrc = (encoding.rtx && encoding.rtx.ssrc)
              ? encoding.rtx.ssrc
              : undefined;
          for (const codec of offerRtpParameters.codecs) {
              const rtp = {
                  payload: codec.payloadType,
                  codec: getCodecName(codec),
                  rate: codec.clockRate
              };
              if (codec.channels > 1)
                  rtp.encoding = codec.channels;
              this._mediaObject.rtp.push(rtp);
              const fmtp = {
                  payload: codec.payloadType,
                  config: ''
              };
              for (const key of Object.keys(codec.parameters)) {
                  if (fmtp.config)
                      fmtp.config += ';';
                  fmtp.config += `${key}=${codec.parameters[key]}`;
              }
              if (fmtp.config)
                  this._mediaObject.fmtp.push(fmtp);
              for (const fb of codec.rtcpFeedback) {
                  this._mediaObject.rtcpFb.push({
                      payload: codec.payloadType,
                      type: fb.type,
                      subtype: fb.parameter
                  });
              }
          }
          this._mediaObject.payloads += ` ${offerRtpParameters
              .codecs
              .map((codec) => codec.payloadType)
              .join(' ')}`;
          if (offerRtpParameters.rtcp.cname) {
              this._mediaObject.ssrcs.push({
                  id: ssrc,
                  attribute: 'cname',
                  value: offerRtpParameters.rtcp.cname
              });
          }
          this._mediaObject.ssrcs.push({
              id: ssrc,
              attribute: 'msid',
              value: `${streamId || '-'} ${trackId}`
          });
          if (rtxSsrc) {
              if (offerRtpParameters.rtcp.cname) {
                  this._mediaObject.ssrcs.push({
                      id: rtxSsrc,
                      attribute: 'cname',
                      value: offerRtpParameters.rtcp.cname
                  });
              }
              this._mediaObject.ssrcs.push({
                  id: rtxSsrc,
                  attribute: 'msid',
                  value: `${streamId || '-'} ${trackId}`
              });
              // Associate original and retransmission SSRCs.
              this._mediaObject.ssrcGroups.push({
                  semantics: 'FID',
                  ssrcs: `${ssrc} ${rtxSsrc}`
              });
          }
      }
      planBStopReceiving({ offerRtpParameters }) {
          const encoding = offerRtpParameters.encodings[0];
          const ssrc = encoding.ssrc;
          const rtxSsrc = (encoding.rtx && encoding.rtx.ssrc)
              ? encoding.rtx.ssrc
              : undefined;
          const payloads = offerRtpParameters.codecs
              .map((codec) => codec.payloadType);
          this._mediaObject.payloads = this._mediaObject.payloads.split(' ')
              .filter((payload) => !payloads.includes(Number(payload)))
              .join(' ');
          this._mediaObject.rtp = this._mediaObject.rtp
              .filter((rtp) => !payloads.includes(rtp.payload));
          this._mediaObject.rtcpFb = this._mediaObject.rtcpFb
              .filter((rtcpFb) => !payloads.includes(rtcpFb.payload));
          this._mediaObject.fmtp = this._mediaObject.fmtp
              .filter((fmtp) => !payloads.includes(fmtp.payload));
          this._mediaObject.ssrcs = this._mediaObject.ssrcs
              .filter((s) => s.id !== ssrc && s.id !== rtxSsrc);
          if (rtxSsrc) {
              this._mediaObject.ssrcGroups = this._mediaObject.ssrcGroups
                  .filter((group) => group.ssrcs !== `${ssrc} ${rtxSsrc}`);
          }
      }
  }
  exports.OfferMediaSection = OfferMediaSection;
  function getCodecName(codec) {
      const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
      const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
      if (!mimeTypeMatch)
          throw new TypeError('invalid codec.mimeType');
      return mimeTypeMatch[2];
  }
  
  },{"../../utils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/utils.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/RemoteSdp.js":[function(require,module,exports){
  "use strict";
  var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
      o["default"] = v;
  });
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.RemoteSdp = void 0;
  const sdpTransform = __importStar(require("sdp-transform"));
  const Logger_1 = require("../../Logger");
  const MediaSection_1 = require("./MediaSection");
  const logger = new Logger_1.Logger('RemoteSdp');
  class RemoteSdp {
      constructor({ iceParameters, iceCandidates, dtlsParameters, sctpParameters, plainRtpParameters, planB = false }) {
          // MediaSection instances with same order as in the SDP.
          this._mediaSections = [];
          // MediaSection indices indexed by MID.
          this._midToIndex = new Map();
          this._iceParameters = iceParameters;
          this._iceCandidates = iceCandidates;
          this._dtlsParameters = dtlsParameters;
          this._sctpParameters = sctpParameters;
          this._plainRtpParameters = plainRtpParameters;
          this._planB = planB;
          this._sdpObject =
              {
                  version: 0,
                  origin: {
                      address: '0.0.0.0',
                      ipVer: 4,
                      netType: 'IN',
                      sessionId: 10000,
                      sessionVersion: 0,
                      username: 'mediasoup-client'
                  },
                  name: '-',
                  timing: { start: 0, stop: 0 },
                  media: []
              };
          // If ICE parameters are given, add ICE-Lite indicator.
          if (iceParameters && iceParameters.iceLite) {
              this._sdpObject.icelite = 'ice-lite';
          }
          // If DTLS parameters are given, assume WebRTC and BUNDLE.
          if (dtlsParameters) {
              this._sdpObject.msidSemantic = { semantic: 'WMS', token: '*' };
              // NOTE: We take the latest fingerprint.
              const numFingerprints = this._dtlsParameters.fingerprints.length;
              this._sdpObject.fingerprint =
                  {
                      type: dtlsParameters.fingerprints[numFingerprints - 1].algorithm,
                      hash: dtlsParameters.fingerprints[numFingerprints - 1].value
                  };
              this._sdpObject.groups = [{ type: 'BUNDLE', mids: '' }];
          }
          // If there are plain RPT parameters, override SDP origin.
          if (plainRtpParameters) {
              this._sdpObject.origin.address = plainRtpParameters.ip;
              this._sdpObject.origin.ipVer = plainRtpParameters.ipVersion;
          }
      }
      updateIceParameters(iceParameters) {
          logger.debug('updateIceParameters() [iceParameters:%o]', iceParameters);
          this._iceParameters = iceParameters;
          this._sdpObject.icelite = iceParameters.iceLite ? 'ice-lite' : undefined;
          for (const mediaSection of this._mediaSections) {
              mediaSection.setIceParameters(iceParameters);
          }
      }
      updateDtlsRole(role) {
          logger.debug('updateDtlsRole() [role:%s]', role);
          this._dtlsParameters.role = role;
          for (const mediaSection of this._mediaSections) {
              mediaSection.setDtlsRole(role);
          }
      }
      getNextMediaSectionIdx() {
          // If a closed media section is found, return its index.
          for (let idx = 0; idx < this._mediaSections.length; ++idx) {
              const mediaSection = this._mediaSections[idx];
              if (mediaSection.closed)
                  return { idx, reuseMid: mediaSection.mid };
          }
          // If no closed media section is found, return next one.
          return { idx: this._mediaSections.length };
      }
      send({ offerMediaObject, reuseMid, offerRtpParameters, answerRtpParameters, codecOptions, extmapAllowMixed = false }) {
          const mediaSection = new MediaSection_1.AnswerMediaSection({
              iceParameters: this._iceParameters,
              iceCandidates: this._iceCandidates,
              dtlsParameters: this._dtlsParameters,
              plainRtpParameters: this._plainRtpParameters,
              planB: this._planB,
              offerMediaObject,
              offerRtpParameters,
              answerRtpParameters,
              codecOptions,
              extmapAllowMixed
          });
          // Unified-Plan with closed media section replacement.
          if (reuseMid) {
              this._replaceMediaSection(mediaSection, reuseMid);
          }
          // Unified-Plan or Plan-B with different media kind.
          else if (!this._midToIndex.has(mediaSection.mid)) {
              this._addMediaSection(mediaSection);
          }
          // Plan-B with same media kind.
          else {
              this._replaceMediaSection(mediaSection);
          }
      }
      receive({ mid, kind, offerRtpParameters, streamId, trackId }) {
          const idx = this._midToIndex.get(mid);
          let mediaSection;
          if (idx !== undefined)
              mediaSection = this._mediaSections[idx];
          // Unified-Plan or different media kind.
          if (!mediaSection) {
              mediaSection = new MediaSection_1.OfferMediaSection({
                  iceParameters: this._iceParameters,
                  iceCandidates: this._iceCandidates,
                  dtlsParameters: this._dtlsParameters,
                  plainRtpParameters: this._plainRtpParameters,
                  planB: this._planB,
                  mid,
                  kind,
                  offerRtpParameters,
                  streamId,
                  trackId
              });
              // Let's try to recycle a closed media section (if any).
              // NOTE: Yes, we can recycle a closed m=audio section with a new m=video.
              const oldMediaSection = this._mediaSections.find((m) => (m.closed));
              if (oldMediaSection) {
                  this._replaceMediaSection(mediaSection, oldMediaSection.mid);
              }
              else {
                  this._addMediaSection(mediaSection);
              }
          }
          // Plan-B.
          else {
              mediaSection.planBReceive({ offerRtpParameters, streamId, trackId });
              this._replaceMediaSection(mediaSection);
          }
      }
      disableMediaSection(mid) {
          const idx = this._midToIndex.get(mid);
          if (idx === undefined) {
              throw new Error(`no media section found with mid '${mid}'`);
          }
          const mediaSection = this._mediaSections[idx];
          mediaSection.disable();
      }
      closeMediaSection(mid) {
          const idx = this._midToIndex.get(mid);
          if (idx === undefined) {
              throw new Error(`no media section found with mid '${mid}'`);
          }
          const mediaSection = this._mediaSections[idx];
          // NOTE: Closing the first m section is a pain since it invalidates the
          // bundled transport, so let's avoid it.
          if (mid === this._firstMid) {
              logger.debug('closeMediaSection() | cannot close first media section, disabling it instead [mid:%s]', mid);
              this.disableMediaSection(mid);
              return;
          }
          mediaSection.close();
          // Regenerate BUNDLE mids.
          this._regenerateBundleMids();
      }
      planBStopReceiving({ mid, offerRtpParameters }) {
          const idx = this._midToIndex.get(mid);
          if (idx === undefined) {
              throw new Error(`no media section found with mid '${mid}'`);
          }
          const mediaSection = this._mediaSections[idx];
          mediaSection.planBStopReceiving({ offerRtpParameters });
          this._replaceMediaSection(mediaSection);
      }
      sendSctpAssociation({ offerMediaObject }) {
          const mediaSection = new MediaSection_1.AnswerMediaSection({
              iceParameters: this._iceParameters,
              iceCandidates: this._iceCandidates,
              dtlsParameters: this._dtlsParameters,
              sctpParameters: this._sctpParameters,
              plainRtpParameters: this._plainRtpParameters,
              offerMediaObject
          });
          this._addMediaSection(mediaSection);
      }
      receiveSctpAssociation({ oldDataChannelSpec = false } = {}) {
          const mediaSection = new MediaSection_1.OfferMediaSection({
              iceParameters: this._iceParameters,
              iceCandidates: this._iceCandidates,
              dtlsParameters: this._dtlsParameters,
              sctpParameters: this._sctpParameters,
              plainRtpParameters: this._plainRtpParameters,
              mid: 'datachannel',
              kind: 'application',
              oldDataChannelSpec
          });
          this._addMediaSection(mediaSection);
      }
      getSdp() {
          // Increase SDP version.
          this._sdpObject.origin.sessionVersion++;
          return sdpTransform.write(this._sdpObject);
      }
      _addMediaSection(newMediaSection) {
          if (!this._firstMid)
              this._firstMid = newMediaSection.mid;
          // Add to the vector.
          this._mediaSections.push(newMediaSection);
          // Add to the map.
          this._midToIndex.set(newMediaSection.mid, this._mediaSections.length - 1);
          // Add to the SDP object.
          this._sdpObject.media.push(newMediaSection.getObject());
          // Regenerate BUNDLE mids.
          this._regenerateBundleMids();
      }
      _replaceMediaSection(newMediaSection, reuseMid) {
          // Store it in the map.
          if (typeof reuseMid === 'string') {
              const idx = this._midToIndex.get(reuseMid);
              if (idx === undefined) {
                  throw new Error(`no media section found for reuseMid '${reuseMid}'`);
              }
              const oldMediaSection = this._mediaSections[idx];
              // Replace the index in the vector with the new media section.
              this._mediaSections[idx] = newMediaSection;
              // Update the map.
              this._midToIndex.delete(oldMediaSection.mid);
              this._midToIndex.set(newMediaSection.mid, idx);
              // Update the SDP object.
              this._sdpObject.media[idx] = newMediaSection.getObject();
              // Regenerate BUNDLE mids.
              this._regenerateBundleMids();
          }
          else {
              const idx = this._midToIndex.get(newMediaSection.mid);
              if (idx === undefined) {
                  throw new Error(`no media section found with mid '${newMediaSection.mid}'`);
              }
              // Replace the index in the vector with the new media section.
              this._mediaSections[idx] = newMediaSection;
              // Update the SDP object.
              this._sdpObject.media[idx] = newMediaSection.getObject();
          }
      }
      _regenerateBundleMids() {
          if (!this._dtlsParameters)
              return;
          this._sdpObject.groups[0].mids = this._mediaSections
              .filter((mediaSection) => !mediaSection.closed)
              .map((mediaSection) => mediaSection.mid)
              .join(' ');
      }
  }
  exports.RemoteSdp = RemoteSdp;
  
  },{"../../Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Logger.js","./MediaSection":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/MediaSection.js","sdp-transform":"/home/ubuntu/umbrella-voice2/app/node_modules/sdp-transform/lib/index.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/commonUtils.js":[function(require,module,exports){
  "use strict";
  var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
      o["default"] = v;
  });
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.applyCodecParameters = exports.getCname = exports.extractDtlsParameters = exports.extractRtpCapabilities = void 0;
  const sdpTransform = __importStar(require("sdp-transform"));
  function extractRtpCapabilities({ sdpObject }) {
      // Map of RtpCodecParameters indexed by payload type.
      const codecsMap = new Map();
      // Array of RtpHeaderExtensions.
      const headerExtensions = [];
      // Whether a m=audio/video section has been already found.
      let gotAudio = false;
      let gotVideo = false;
      for (const m of sdpObject.media) {
          const kind = m.type;
          switch (kind) {
              case 'audio':
                  {
                      if (gotAudio)
                          continue;
                      gotAudio = true;
                      break;
                  }
              case 'video':
                  {
                      if (gotVideo)
                          continue;
                      gotVideo = true;
                      break;
                  }
              default:
                  {
                      continue;
                  }
          }
          // Get codecs.
          for (const rtp of m.rtp) {
              const codec = {
                  kind: kind,
                  mimeType: `${kind}/${rtp.codec}`,
                  preferredPayloadType: rtp.payload,
                  clockRate: rtp.rate,
                  channels: rtp.encoding,
                  parameters: {},
                  rtcpFeedback: []
              };
              codecsMap.set(codec.preferredPayloadType, codec);
          }
          // Get codec parameters.
          for (const fmtp of m.fmtp || []) {
              const parameters = sdpTransform.parseParams(fmtp.config);
              const codec = codecsMap.get(fmtp.payload);
              if (!codec)
                  continue;
              // Specials case to convert parameter value to string.
              if (parameters && parameters.hasOwnProperty('profile-level-id'))
                  parameters['profile-level-id'] = String(parameters['profile-level-id']);
              codec.parameters = parameters;
          }
          // Get RTCP feedback for each codec.
          for (const fb of m.rtcpFb || []) {
              const codec = codecsMap.get(fb.payload);
              if (!codec)
                  continue;
              const feedback = {
                  type: fb.type,
                  parameter: fb.subtype
              };
              if (!feedback.parameter)
                  delete feedback.parameter;
              codec.rtcpFeedback.push(feedback);
          }
          // Get RTP header extensions.
          for (const ext of m.ext || []) {
              // Ignore encrypted extensions (not yet supported in mediasoup).
              if (ext['encrypt-uri'])
                  continue;
              const headerExtension = {
                  kind: kind,
                  uri: ext.uri,
                  preferredId: ext.value
              };
              headerExtensions.push(headerExtension);
          }
      }
      const rtpCapabilities = {
          codecs: Array.from(codecsMap.values()),
          headerExtensions: headerExtensions
      };
      return rtpCapabilities;
  }
  exports.extractRtpCapabilities = extractRtpCapabilities;
  function extractDtlsParameters({ sdpObject }) {
      const mediaObject = (sdpObject.media || [])
          .find((m) => (m.iceUfrag && m.port !== 0));
      if (!mediaObject)
          throw new Error('no active media section found');
      const fingerprint = mediaObject.fingerprint || sdpObject.fingerprint;
      let role;
      switch (mediaObject.setup) {
          case 'active':
              role = 'client';
              break;
          case 'passive':
              role = 'server';
              break;
          case 'actpass':
              role = 'auto';
              break;
      }
      const dtlsParameters = {
          role,
          fingerprints: [
              {
                  algorithm: fingerprint.type,
                  value: fingerprint.hash
              }
          ]
      };
      return dtlsParameters;
  }
  exports.extractDtlsParameters = extractDtlsParameters;
  function getCname({ offerMediaObject }) {
      const ssrcCnameLine = (offerMediaObject.ssrcs || [])
          .find((line) => line.attribute === 'cname');
      if (!ssrcCnameLine)
          return '';
      return ssrcCnameLine.value;
  }
  exports.getCname = getCname;
  /**
   * Apply codec parameters in the given SDP m= section answer based on the
   * given RTP parameters of an offer.
   */
  function applyCodecParameters({ offerRtpParameters, answerMediaObject }) {
      for (const codec of offerRtpParameters.codecs) {
          const mimeType = codec.mimeType.toLowerCase();
          // Avoid parsing codec parameters for unhandled codecs.
          if (mimeType !== 'audio/opus')
              continue;
          const rtp = (answerMediaObject.rtp || [])
              .find((r) => r.payload === codec.payloadType);
          if (!rtp)
              continue;
          // Just in case.
          answerMediaObject.fmtp = answerMediaObject.fmtp || [];
          let fmtp = answerMediaObject.fmtp
              .find((f) => f.payload === codec.payloadType);
          if (!fmtp) {
              fmtp = { payload: codec.payloadType, config: '' };
              answerMediaObject.fmtp.push(fmtp);
          }
          const parameters = sdpTransform.parseParams(fmtp.config);
          switch (mimeType) {
              case 'audio/opus':
                  {
                      const spropStereo = codec.parameters['sprop-stereo'];
                      if (spropStereo !== undefined)
                          parameters.stereo = spropStereo ? 1 : 0;
                      break;
                  }
          }
          // Write the codec fmtp.config back.
          fmtp.config = '';
          for (const key of Object.keys(parameters)) {
              if (fmtp.config)
                  fmtp.config += ';';
              fmtp.config += `${key}=${parameters[key]}`;
          }
      }
  }
  exports.applyCodecParameters = applyCodecParameters;
  
  },{"sdp-transform":"/home/ubuntu/umbrella-voice2/app/node_modules/sdp-transform/lib/index.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/planBUtils.js":[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.addLegacySimulcast = exports.getRtpEncodings = void 0;
  function getRtpEncodings({ offerMediaObject, track }) {
      // First media SSRC (or the only one).
      let firstSsrc;
      const ssrcs = new Set();
      for (const line of offerMediaObject.ssrcs || []) {
          if (line.attribute !== 'msid')
              continue;
          const trackId = line.value.split(' ')[1];
          if (trackId === track.id) {
              const ssrc = line.id;
              ssrcs.add(ssrc);
              if (!firstSsrc)
                  firstSsrc = ssrc;
          }
      }
      if (ssrcs.size === 0)
          throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);
      const ssrcToRtxSsrc = new Map();
      // First assume RTX is used.
      for (const line of offerMediaObject.ssrcGroups || []) {
          if (line.semantics !== 'FID')
              continue;
          let [ssrc, rtxSsrc] = line.ssrcs.split(/\s+/);
          ssrc = Number(ssrc);
          rtxSsrc = Number(rtxSsrc);
          if (ssrcs.has(ssrc)) {
              // Remove both the SSRC and RTX SSRC from the set so later we know that they
              // are already handled.
              ssrcs.delete(ssrc);
              ssrcs.delete(rtxSsrc);
              // Add to the map.
              ssrcToRtxSsrc.set(ssrc, rtxSsrc);
          }
      }
      // If the set of SSRCs is not empty it means that RTX is not being used, so take
      // media SSRCs from there.
      for (const ssrc of ssrcs) {
          // Add to the map.
          ssrcToRtxSsrc.set(ssrc, null);
      }
      const encodings = [];
      for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
          const encoding = { ssrc };
          if (rtxSsrc)
              encoding.rtx = { ssrc: rtxSsrc };
          encodings.push(encoding);
      }
      return encodings;
  }
  exports.getRtpEncodings = getRtpEncodings;
  /**
   * Adds multi-ssrc based simulcast into the given SDP media section offer.
   */
  function addLegacySimulcast({ offerMediaObject, track, numStreams }) {
      if (numStreams <= 1)
          throw new TypeError('numStreams must be greater than 1');
      let firstSsrc;
      let firstRtxSsrc;
      let streamId;
      // Get the SSRC.
      const ssrcMsidLine = (offerMediaObject.ssrcs || [])
          .find((line) => {
          if (line.attribute !== 'msid')
              return false;
          const trackId = line.value.split(' ')[1];
          if (trackId === track.id) {
              firstSsrc = line.id;
              streamId = line.value.split(' ')[0];
              return true;
          }
          else {
              return false;
          }
      });
      if (!ssrcMsidLine)
          throw new Error(`a=ssrc line with msid information not found [track.id:${track.id}]`);
      // Get the SSRC for RTX.
      (offerMediaObject.ssrcGroups || [])
          .some((line) => {
          if (line.semantics !== 'FID')
              return false;
          const ssrcs = line.ssrcs.split(/\s+/);
          if (Number(ssrcs[0]) === firstSsrc) {
              firstRtxSsrc = Number(ssrcs[1]);
              return true;
          }
          else {
              return false;
          }
      });
      const ssrcCnameLine = offerMediaObject.ssrcs
          .find((line) => (line.attribute === 'cname' && line.id === firstSsrc));
      if (!ssrcCnameLine)
          throw new Error(`a=ssrc line with cname information not found [track.id:${track.id}]`);
      const cname = ssrcCnameLine.value;
      const ssrcs = [];
      const rtxSsrcs = [];
      for (let i = 0; i < numStreams; ++i) {
          ssrcs.push(firstSsrc + i);
          if (firstRtxSsrc)
              rtxSsrcs.push(firstRtxSsrc + i);
      }
      offerMediaObject.ssrcGroups = offerMediaObject.ssrcGroups || [];
      offerMediaObject.ssrcs = offerMediaObject.ssrcs || [];
      offerMediaObject.ssrcGroups.push({
          semantics: 'SIM',
          ssrcs: ssrcs.join(' ')
      });
      for (let i = 0; i < ssrcs.length; ++i) {
          const ssrc = ssrcs[i];
          offerMediaObject.ssrcs.push({
              id: ssrc,
              attribute: 'cname',
              value: cname
          });
          offerMediaObject.ssrcs.push({
              id: ssrc,
              attribute: 'msid',
              value: `${streamId} ${track.id}`
          });
      }
      for (let i = 0; i < rtxSsrcs.length; ++i) {
          const ssrc = ssrcs[i];
          const rtxSsrc = rtxSsrcs[i];
          offerMediaObject.ssrcs.push({
              id: rtxSsrc,
              attribute: 'cname',
              value: cname
          });
          offerMediaObject.ssrcs.push({
              id: rtxSsrc,
              attribute: 'msid',
              value: `${streamId} ${track.id}`
          });
          offerMediaObject.ssrcGroups.push({
              semantics: 'FID',
              ssrcs: `${ssrc} ${rtxSsrc}`
          });
      }
  }
  exports.addLegacySimulcast = addLegacySimulcast;
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/sdp/unifiedPlanUtils.js":[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.addLegacySimulcast = exports.getRtpEncodings = void 0;
  function getRtpEncodings({ offerMediaObject }) {
      const ssrcs = new Set();
      for (const line of offerMediaObject.ssrcs || []) {
          const ssrc = line.id;
          ssrcs.add(ssrc);
      }
      if (ssrcs.size === 0)
          throw new Error('no a=ssrc lines found');
      const ssrcToRtxSsrc = new Map();
      // First assume RTX is used.
      for (const line of offerMediaObject.ssrcGroups || []) {
          if (line.semantics !== 'FID')
              continue;
          let [ssrc, rtxSsrc] = line.ssrcs.split(/\s+/);
          ssrc = Number(ssrc);
          rtxSsrc = Number(rtxSsrc);
          if (ssrcs.has(ssrc)) {
              // Remove both the SSRC and RTX SSRC from the set so later we know that they
              // are already handled.
              ssrcs.delete(ssrc);
              ssrcs.delete(rtxSsrc);
              // Add to the map.
              ssrcToRtxSsrc.set(ssrc, rtxSsrc);
          }
      }
      // If the set of SSRCs is not empty it means that RTX is not being used, so take
      // media SSRCs from there.
      for (const ssrc of ssrcs) {
          // Add to the map.
          ssrcToRtxSsrc.set(ssrc, null);
      }
      const encodings = [];
      for (const [ssrc, rtxSsrc] of ssrcToRtxSsrc) {
          const encoding = { ssrc };
          if (rtxSsrc)
              encoding.rtx = { ssrc: rtxSsrc };
          encodings.push(encoding);
      }
      return encodings;
  }
  exports.getRtpEncodings = getRtpEncodings;
  /**
   * Adds multi-ssrc based simulcast into the given SDP media section offer.
   */
  function addLegacySimulcast({ offerMediaObject, numStreams }) {
      if (numStreams <= 1)
          throw new TypeError('numStreams must be greater than 1');
      // Get the SSRC.
      const ssrcMsidLine = (offerMediaObject.ssrcs || [])
          .find((line) => line.attribute === 'msid');
      if (!ssrcMsidLine)
          throw new Error('a=ssrc line with msid information not found');
      const [streamId, trackId] = ssrcMsidLine.value.split(' ');
      const firstSsrc = ssrcMsidLine.id;
      let firstRtxSsrc;
      // Get the SSRC for RTX.
      (offerMediaObject.ssrcGroups || [])
          .some((line) => {
          if (line.semantics !== 'FID')
              return false;
          const ssrcs = line.ssrcs.split(/\s+/);
          if (Number(ssrcs[0]) === firstSsrc) {
              firstRtxSsrc = Number(ssrcs[1]);
              return true;
          }
          else {
              return false;
          }
      });
      const ssrcCnameLine = offerMediaObject.ssrcs
          .find((line) => line.attribute === 'cname');
      if (!ssrcCnameLine)
          throw new Error('a=ssrc line with cname information not found');
      const cname = ssrcCnameLine.value;
      const ssrcs = [];
      const rtxSsrcs = [];
      for (let i = 0; i < numStreams; ++i) {
          ssrcs.push(firstSsrc + i);
          if (firstRtxSsrc)
              rtxSsrcs.push(firstRtxSsrc + i);
      }
      offerMediaObject.ssrcGroups = [];
      offerMediaObject.ssrcs = [];
      offerMediaObject.ssrcGroups.push({
          semantics: 'SIM',
          ssrcs: ssrcs.join(' ')
      });
      for (let i = 0; i < ssrcs.length; ++i) {
          const ssrc = ssrcs[i];
          offerMediaObject.ssrcs.push({
              id: ssrc,
              attribute: 'cname',
              value: cname
          });
          offerMediaObject.ssrcs.push({
              id: ssrc,
              attribute: 'msid',
              value: `${streamId} ${trackId}`
          });
      }
      for (let i = 0; i < rtxSsrcs.length; ++i) {
          const ssrc = ssrcs[i];
          const rtxSsrc = rtxSsrcs[i];
          offerMediaObject.ssrcs.push({
              id: rtxSsrc,
              attribute: 'cname',
              value: cname
          });
          offerMediaObject.ssrcs.push({
              id: rtxSsrc,
              attribute: 'msid',
              value: `${streamId} ${trackId}`
          });
          offerMediaObject.ssrcGroups.push({
              semantics: 'FID',
              ssrcs: `${ssrc} ${rtxSsrc}`
          });
      }
  }
  exports.addLegacySimulcast = addLegacySimulcast;
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/index.js":[function(require,module,exports){
  "use strict";
  var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
      o["default"] = v;
  });
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.detectDevice = exports.Device = exports.version = exports.types = void 0;
  const Device_1 = require("./Device");
  Object.defineProperty(exports, "Device", { enumerable: true, get: function () { return Device_1.Device; } });
  Object.defineProperty(exports, "detectDevice", { enumerable: true, get: function () { return Device_1.detectDevice; } });
  const types = __importStar(require("./types"));
  exports.types = types;
  /**
   * Expose mediasoup-client version.
   */
  exports.version = '3.6.34';
  /**
   * Expose parseScalabilityMode() function.
   */
  var scalabilityModes_1 = require("./scalabilityModes");
  Object.defineProperty(exports, "parseScalabilityMode", { enumerable: true, get: function () { return scalabilityModes_1.parse; } });
  
  },{"./Device":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Device.js","./scalabilityModes":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/scalabilityModes.js","./types":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/types.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/ortc.js":[function(require,module,exports){
  "use strict";
  var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
  }) : function(o, v) {
      o["default"] = v;
  });
  var __importStar = (this && this.__importStar) || function (mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      __setModuleDefault(result, mod);
      return result;
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.canReceive = exports.canSend = exports.generateProbatorRtpParameters = exports.reduceCodecs = exports.getSendingRemoteRtpParameters = exports.getSendingRtpParameters = exports.getRecvRtpCapabilities = exports.getExtendedRtpCapabilities = exports.validateSctpStreamParameters = exports.validateSctpParameters = exports.validateNumSctpStreams = exports.validateSctpCapabilities = exports.validateRtcpParameters = exports.validateRtpEncodingParameters = exports.validateRtpHeaderExtensionParameters = exports.validateRtpCodecParameters = exports.validateRtpParameters = exports.validateRtpHeaderExtension = exports.validateRtcpFeedback = exports.validateRtpCodecCapability = exports.validateRtpCapabilities = void 0;
  const h264 = __importStar(require("h264-profile-level-id"));
  const utils = __importStar(require("./utils"));
  const RTP_PROBATOR_MID = 'probator';
  const RTP_PROBATOR_SSRC = 1234;
  const RTP_PROBATOR_CODEC_PAYLOAD_TYPE = 127;
  /**
   * Validates RtpCapabilities. It may modify given data by adding missing
   * fields with default values.
   * It throws if invalid.
   */
  function validateRtpCapabilities(caps) {
      if (typeof caps !== 'object')
          throw new TypeError('caps is not an object');
      // codecs is optional. If unset, fill with an empty array.
      if (caps.codecs && !Array.isArray(caps.codecs))
          throw new TypeError('caps.codecs is not an array');
      else if (!caps.codecs)
          caps.codecs = [];
      for (const codec of caps.codecs) {
          validateRtpCodecCapability(codec);
      }
      // headerExtensions is optional. If unset, fill with an empty array.
      if (caps.headerExtensions && !Array.isArray(caps.headerExtensions))
          throw new TypeError('caps.headerExtensions is not an array');
      else if (!caps.headerExtensions)
          caps.headerExtensions = [];
      for (const ext of caps.headerExtensions) {
          validateRtpHeaderExtension(ext);
      }
  }
  exports.validateRtpCapabilities = validateRtpCapabilities;
  /**
   * Validates RtpCodecCapability. It may modify given data by adding missing
   * fields with default values.
   * It throws if invalid.
   */
  function validateRtpCodecCapability(codec) {
      const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
      if (typeof codec !== 'object')
          throw new TypeError('codec is not an object');
      // mimeType is mandatory.
      if (!codec.mimeType || typeof codec.mimeType !== 'string')
          throw new TypeError('missing codec.mimeType');
      const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
      if (!mimeTypeMatch)
          throw new TypeError('invalid codec.mimeType');
      // Just override kind with media component of mimeType.
      codec.kind = mimeTypeMatch[1].toLowerCase();
      // preferredPayloadType is optional.
      if (codec.preferredPayloadType && typeof codec.preferredPayloadType !== 'number')
          throw new TypeError('invalid codec.preferredPayloadType');
      // clockRate is mandatory.
      if (typeof codec.clockRate !== 'number')
          throw new TypeError('missing codec.clockRate');
      // channels is optional. If unset, set it to 1 (just if audio).
      if (codec.kind === 'audio') {
          if (typeof codec.channels !== 'number')
              codec.channels = 1;
      }
      else {
          delete codec.channels;
      }
      // parameters is optional. If unset, set it to an empty object.
      if (!codec.parameters || typeof codec.parameters !== 'object')
          codec.parameters = {};
      for (const key of Object.keys(codec.parameters)) {
          let value = codec.parameters[key];
          if (value === undefined) {
              codec.parameters[key] = '';
              value = '';
          }
          if (typeof value !== 'string' && typeof value !== 'number') {
              throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
          }
          // Specific parameters validation.
          if (key === 'apt') {
              if (typeof value !== 'number')
                  throw new TypeError('invalid codec apt parameter');
          }
      }
      // rtcpFeedback is optional. If unset, set it to an empty array.
      if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback))
          codec.rtcpFeedback = [];
      for (const fb of codec.rtcpFeedback) {
          validateRtcpFeedback(fb);
      }
  }
  exports.validateRtpCodecCapability = validateRtpCodecCapability;
  /**
   * Validates RtcpFeedback. It may modify given data by adding missing
   * fields with default values.
   * It throws if invalid.
   */
  function validateRtcpFeedback(fb) {
      if (typeof fb !== 'object')
          throw new TypeError('fb is not an object');
      // type is mandatory.
      if (!fb.type || typeof fb.type !== 'string')
          throw new TypeError('missing fb.type');
      // parameter is optional. If unset set it to an empty string.
      if (!fb.parameter || typeof fb.parameter !== 'string')
          fb.parameter = '';
  }
  exports.validateRtcpFeedback = validateRtcpFeedback;
  /**
   * Validates RtpHeaderExtension. It may modify given data by adding missing
   * fields with default values.
   * It throws if invalid.
   */
  function validateRtpHeaderExtension(ext) {
      if (typeof ext !== 'object')
          throw new TypeError('ext is not an object');
      // kind is mandatory.
      if (ext.kind !== 'audio' && ext.kind !== 'video')
          throw new TypeError('invalid ext.kind');
      // uri is mandatory.
      if (!ext.uri || typeof ext.uri !== 'string')
          throw new TypeError('missing ext.uri');
      // preferredId is mandatory.
      if (typeof ext.preferredId !== 'number')
          throw new TypeError('missing ext.preferredId');
      // preferredEncrypt is optional. If unset set it to false.
      if (ext.preferredEncrypt && typeof ext.preferredEncrypt !== 'boolean')
          throw new TypeError('invalid ext.preferredEncrypt');
      else if (!ext.preferredEncrypt)
          ext.preferredEncrypt = false;
      // direction is optional. If unset set it to sendrecv.
      if (ext.direction && typeof ext.direction !== 'string')
          throw new TypeError('invalid ext.direction');
      else if (!ext.direction)
          ext.direction = 'sendrecv';
  }
  exports.validateRtpHeaderExtension = validateRtpHeaderExtension;
  /**
   * Validates RtpParameters. It may modify given data by adding missing
   * fields with default values.
   * It throws if invalid.
   */
  function validateRtpParameters(params) {
      if (typeof params !== 'object')
          throw new TypeError('params is not an object');
      // mid is optional.
      if (params.mid && typeof params.mid !== 'string')
          throw new TypeError('params.mid is not a string');
      // codecs is mandatory.
      if (!Array.isArray(params.codecs))
          throw new TypeError('missing params.codecs');
      for (const codec of params.codecs) {
          validateRtpCodecParameters(codec);
      }
      // headerExtensions is optional. If unset, fill with an empty array.
      if (params.headerExtensions && !Array.isArray(params.headerExtensions))
          throw new TypeError('params.headerExtensions is not an array');
      else if (!params.headerExtensions)
          params.headerExtensions = [];
      for (const ext of params.headerExtensions) {
          validateRtpHeaderExtensionParameters(ext);
      }
      // encodings is optional. If unset, fill with an empty array.
      if (params.encodings && !Array.isArray(params.encodings))
          throw new TypeError('params.encodings is not an array');
      else if (!params.encodings)
          params.encodings = [];
      for (const encoding of params.encodings) {
          validateRtpEncodingParameters(encoding);
      }
      // rtcp is optional. If unset, fill with an empty object.
      if (params.rtcp && typeof params.rtcp !== 'object')
          throw new TypeError('params.rtcp is not an object');
      else if (!params.rtcp)
          params.rtcp = {};
      validateRtcpParameters(params.rtcp);
  }
  exports.validateRtpParameters = validateRtpParameters;
  /**
   * Validates RtpCodecParameters. It may modify given data by adding missing
   * fields with default values.
   * It throws if invalid.
   */
  function validateRtpCodecParameters(codec) {
      const MimeTypeRegex = new RegExp('^(audio|video)/(.+)', 'i');
      if (typeof codec !== 'object')
          throw new TypeError('codec is not an object');
      // mimeType is mandatory.
      if (!codec.mimeType || typeof codec.mimeType !== 'string')
          throw new TypeError('missing codec.mimeType');
      const mimeTypeMatch = MimeTypeRegex.exec(codec.mimeType);
      if (!mimeTypeMatch)
          throw new TypeError('invalid codec.mimeType');
      // payloadType is mandatory.
      if (typeof codec.payloadType !== 'number')
          throw new TypeError('missing codec.payloadType');
      // clockRate is mandatory.
      if (typeof codec.clockRate !== 'number')
          throw new TypeError('missing codec.clockRate');
      const kind = mimeTypeMatch[1].toLowerCase();
      // channels is optional. If unset, set it to 1 (just if audio).
      if (kind === 'audio') {
          if (typeof codec.channels !== 'number')
              codec.channels = 1;
      }
      else {
          delete codec.channels;
      }
      // parameters is optional. If unset, set it to an empty object.
      if (!codec.parameters || typeof codec.parameters !== 'object')
          codec.parameters = {};
      for (const key of Object.keys(codec.parameters)) {
          let value = codec.parameters[key];
          if (value === undefined) {
              codec.parameters[key] = '';
              value = '';
          }
          if (typeof value !== 'string' && typeof value !== 'number') {
              throw new TypeError(`invalid codec parameter [key:${key}s, value:${value}]`);
          }
          // Specific parameters validation.
          if (key === 'apt') {
              if (typeof value !== 'number')
                  throw new TypeError('invalid codec apt parameter');
          }
      }
      // rtcpFeedback is optional. If unset, set it to an empty array.
      if (!codec.rtcpFeedback || !Array.isArray(codec.rtcpFeedback))
          codec.rtcpFeedback = [];
      for (const fb of codec.rtcpFeedback) {
          validateRtcpFeedback(fb);
      }
  }
  exports.validateRtpCodecParameters = validateRtpCodecParameters;
  /**
   * Validates RtpHeaderExtensionParameteters. It may modify given data by adding missing
   * fields with default values.
   * It throws if invalid.
   */
  function validateRtpHeaderExtensionParameters(ext) {
      if (typeof ext !== 'object')
          throw new TypeError('ext is not an object');
      // uri is mandatory.
      if (!ext.uri || typeof ext.uri !== 'string')
          throw new TypeError('missing ext.uri');
      // id is mandatory.
      if (typeof ext.id !== 'number')
          throw new TypeError('missing ext.id');
      // encrypt is optional. If unset set it to false.
      if (ext.encrypt && typeof ext.encrypt !== 'boolean')
          throw new TypeError('invalid ext.encrypt');
      else if (!ext.encrypt)
          ext.encrypt = false;
      // parameters is optional. If unset, set it to an empty object.
      if (!ext.parameters || typeof ext.parameters !== 'object')
          ext.parameters = {};
      for (const key of Object.keys(ext.parameters)) {
          let value = ext.parameters[key];
          if (value === undefined) {
              ext.parameters[key] = '';
              value = '';
          }
          if (typeof value !== 'string' && typeof value !== 'number')
              throw new TypeError('invalid header extension parameter');
      }
  }
  exports.validateRtpHeaderExtensionParameters = validateRtpHeaderExtensionParameters;
  /**
   * Validates RtpEncodingParameters. It may modify given data by adding missing
   * fields with default values.
   * It throws if invalid.
   */
  function validateRtpEncodingParameters(encoding) {
      if (typeof encoding !== 'object')
          throw new TypeError('encoding is not an object');
      // ssrc is optional.
      if (encoding.ssrc && typeof encoding.ssrc !== 'number')
          throw new TypeError('invalid encoding.ssrc');
      // rid is optional.
      if (encoding.rid && typeof encoding.rid !== 'string')
          throw new TypeError('invalid encoding.rid');
      // rtx is optional.
      if (encoding.rtx && typeof encoding.rtx !== 'object') {
          throw new TypeError('invalid encoding.rtx');
      }
      else if (encoding.rtx) {
          // RTX ssrc is mandatory if rtx is present.
          if (typeof encoding.rtx.ssrc !== 'number')
              throw new TypeError('missing encoding.rtx.ssrc');
      }
      // dtx is optional. If unset set it to false.
      if (!encoding.dtx || typeof encoding.dtx !== 'boolean')
          encoding.dtx = false;
      // scalabilityMode is optional.
      if (encoding.scalabilityMode && typeof encoding.scalabilityMode !== 'string')
          throw new TypeError('invalid encoding.scalabilityMode');
  }
  exports.validateRtpEncodingParameters = validateRtpEncodingParameters;
  /**
   * Validates RtcpParameters. It may modify given data by adding missing
   * fields with default values.
   * It throws if invalid.
   */
  function validateRtcpParameters(rtcp) {
      if (typeof rtcp !== 'object')
          throw new TypeError('rtcp is not an object');
      // cname is optional.
      if (rtcp.cname && typeof rtcp.cname !== 'string')
          throw new TypeError('invalid rtcp.cname');
      // reducedSize is optional. If unset set it to true.
      if (!rtcp.reducedSize || typeof rtcp.reducedSize !== 'boolean')
          rtcp.reducedSize = true;
  }
  exports.validateRtcpParameters = validateRtcpParameters;
  /**
   * Validates SctpCapabilities. It may modify given data by adding missing
   * fields with default values.
   * It throws if invalid.
   */
  function validateSctpCapabilities(caps) {
      if (typeof caps !== 'object')
          throw new TypeError('caps is not an object');
      // numStreams is mandatory.
      if (!caps.numStreams || typeof caps.numStreams !== 'object')
          throw new TypeError('missing caps.numStreams');
      validateNumSctpStreams(caps.numStreams);
  }
  exports.validateSctpCapabilities = validateSctpCapabilities;
  /**
   * Validates NumSctpStreams. It may modify given data by adding missing
   * fields with default values.
   * It throws if invalid.
   */
  function validateNumSctpStreams(numStreams) {
      if (typeof numStreams !== 'object')
          throw new TypeError('numStreams is not an object');
      // OS is mandatory.
      if (typeof numStreams.OS !== 'number')
          throw new TypeError('missing numStreams.OS');
      // MIS is mandatory.
      if (typeof numStreams.MIS !== 'number')
          throw new TypeError('missing numStreams.MIS');
  }
  exports.validateNumSctpStreams = validateNumSctpStreams;
  /**
   * Validates SctpParameters. It may modify given data by adding missing
   * fields with default values.
   * It throws if invalid.
   */
  function validateSctpParameters(params) {
      if (typeof params !== 'object')
          throw new TypeError('params is not an object');
      // port is mandatory.
      if (typeof params.port !== 'number')
          throw new TypeError('missing params.port');
      // OS is mandatory.
      if (typeof params.OS !== 'number')
          throw new TypeError('missing params.OS');
      // MIS is mandatory.
      if (typeof params.MIS !== 'number')
          throw new TypeError('missing params.MIS');
      // maxMessageSize is mandatory.
      if (typeof params.maxMessageSize !== 'number')
          throw new TypeError('missing params.maxMessageSize');
  }
  exports.validateSctpParameters = validateSctpParameters;
  /**
   * Validates SctpStreamParameters. It may modify given data by adding missing
   * fields with default values.
   * It throws if invalid.
   */
  function validateSctpStreamParameters(params) {
      if (typeof params !== 'object')
          throw new TypeError('params is not an object');
      // streamId is mandatory.
      if (typeof params.streamId !== 'number')
          throw new TypeError('missing params.streamId');
      // ordered is optional.
      let orderedGiven = false;
      if (typeof params.ordered === 'boolean')
          orderedGiven = true;
      else
          params.ordered = true;
      // maxPacketLifeTime is optional.
      if (params.maxPacketLifeTime && typeof params.maxPacketLifeTime !== 'number')
          throw new TypeError('invalid params.maxPacketLifeTime');
      // maxRetransmits is optional.
      if (params.maxRetransmits && typeof params.maxRetransmits !== 'number')
          throw new TypeError('invalid params.maxRetransmits');
      if (params.maxPacketLifeTime && params.maxRetransmits)
          throw new TypeError('cannot provide both maxPacketLifeTime and maxRetransmits');
      if (orderedGiven &&
          params.ordered &&
          (params.maxPacketLifeTime || params.maxRetransmits)) {
          throw new TypeError('cannot be ordered with maxPacketLifeTime or maxRetransmits');
      }
      else if (!orderedGiven && (params.maxPacketLifeTime || params.maxRetransmits)) {
          params.ordered = false;
      }
      // label is optional.
      if (params.label && typeof params.label !== 'string')
          throw new TypeError('invalid params.label');
      // protocol is optional.
      if (params.protocol && typeof params.protocol !== 'string')
          throw new TypeError('invalid params.protocol');
  }
  exports.validateSctpStreamParameters = validateSctpStreamParameters;
  /**
   * Generate extended RTP capabilities for sending and receiving.
   */
  function getExtendedRtpCapabilities(localCaps, remoteCaps) {
      const extendedRtpCapabilities = {
          codecs: [],
          headerExtensions: []
      };
      // Match media codecs and keep the order preferred by remoteCaps.
      for (const remoteCodec of remoteCaps.codecs || []) {
          if (isRtxCodec(remoteCodec))
              continue;
          const matchingLocalCodec = (localCaps.codecs || [])
              .find((localCodec) => (matchCodecs(localCodec, remoteCodec, { strict: true, modify: true })));
          if (!matchingLocalCodec)
              continue;
          const extendedCodec = {
              mimeType: matchingLocalCodec.mimeType,
              kind: matchingLocalCodec.kind,
              clockRate: matchingLocalCodec.clockRate,
              channels: matchingLocalCodec.channels,
              localPayloadType: matchingLocalCodec.preferredPayloadType,
              localRtxPayloadType: undefined,
              remotePayloadType: remoteCodec.preferredPayloadType,
              remoteRtxPayloadType: undefined,
              localParameters: matchingLocalCodec.parameters,
              remoteParameters: remoteCodec.parameters,
              rtcpFeedback: reduceRtcpFeedback(matchingLocalCodec, remoteCodec)
          };
          extendedRtpCapabilities.codecs.push(extendedCodec);
      }
      // Match RTX codecs.
      for (const extendedCodec of extendedRtpCapabilities.codecs) {
          const matchingLocalRtxCodec = localCaps.codecs
              .find((localCodec) => (isRtxCodec(localCodec) &&
              localCodec.parameters.apt === extendedCodec.localPayloadType));
          const matchingRemoteRtxCodec = remoteCaps.codecs
              .find((remoteCodec) => (isRtxCodec(remoteCodec) &&
              remoteCodec.parameters.apt === extendedCodec.remotePayloadType));
          if (matchingLocalRtxCodec && matchingRemoteRtxCodec) {
              extendedCodec.localRtxPayloadType = matchingLocalRtxCodec.preferredPayloadType;
              extendedCodec.remoteRtxPayloadType = matchingRemoteRtxCodec.preferredPayloadType;
          }
      }
      // Match header extensions.
      for (const remoteExt of remoteCaps.headerExtensions) {
          const matchingLocalExt = localCaps.headerExtensions
              .find((localExt) => (matchHeaderExtensions(localExt, remoteExt)));
          if (!matchingLocalExt)
              continue;
          const extendedExt = {
              kind: remoteExt.kind,
              uri: remoteExt.uri,
              sendId: matchingLocalExt.preferredId,
              recvId: remoteExt.preferredId,
              encrypt: matchingLocalExt.preferredEncrypt,
              direction: 'sendrecv'
          };
          switch (remoteExt.direction) {
              case 'sendrecv':
                  extendedExt.direction = 'sendrecv';
                  break;
              case 'recvonly':
                  extendedExt.direction = 'sendonly';
                  break;
              case 'sendonly':
                  extendedExt.direction = 'recvonly';
                  break;
              case 'inactive':
                  extendedExt.direction = 'inactive';
                  break;
          }
          extendedRtpCapabilities.headerExtensions.push(extendedExt);
      }
      return extendedRtpCapabilities;
  }
  exports.getExtendedRtpCapabilities = getExtendedRtpCapabilities;
  /**
   * Generate RTP capabilities for receiving media based on the given extended
   * RTP capabilities.
   */
  function getRecvRtpCapabilities(extendedRtpCapabilities) {
      const rtpCapabilities = {
          codecs: [],
          headerExtensions: []
      };
      for (const extendedCodec of extendedRtpCapabilities.codecs) {
          const codec = {
              mimeType: extendedCodec.mimeType,
              kind: extendedCodec.kind,
              preferredPayloadType: extendedCodec.remotePayloadType,
              clockRate: extendedCodec.clockRate,
              channels: extendedCodec.channels,
              parameters: extendedCodec.localParameters,
              rtcpFeedback: extendedCodec.rtcpFeedback
          };
          rtpCapabilities.codecs.push(codec);
          // Add RTX codec.
          if (!extendedCodec.remoteRtxPayloadType)
              continue;
          const rtxCodec = {
              mimeType: `${extendedCodec.kind}/rtx`,
              kind: extendedCodec.kind,
              preferredPayloadType: extendedCodec.remoteRtxPayloadType,
              clockRate: extendedCodec.clockRate,
              parameters: {
                  apt: extendedCodec.remotePayloadType
              },
              rtcpFeedback: []
          };
          rtpCapabilities.codecs.push(rtxCodec);
          // TODO: In the future, we need to add FEC, CN, etc, codecs.
      }
      for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
          // Ignore RTP extensions not valid for receiving.
          if (extendedExtension.direction !== 'sendrecv' &&
              extendedExtension.direction !== 'recvonly') {
              continue;
          }
          const ext = {
              kind: extendedExtension.kind,
              uri: extendedExtension.uri,
              preferredId: extendedExtension.recvId,
              preferredEncrypt: extendedExtension.encrypt,
              direction: extendedExtension.direction
          };
          rtpCapabilities.headerExtensions.push(ext);
      }
      return rtpCapabilities;
  }
  exports.getRecvRtpCapabilities = getRecvRtpCapabilities;
  /**
   * Generate RTP parameters of the given kind for sending media.
   * NOTE: mid, encodings and rtcp fields are left empty.
   */
  function getSendingRtpParameters(kind, extendedRtpCapabilities) {
      const rtpParameters = {
          mid: undefined,
          codecs: [],
          headerExtensions: [],
          encodings: [],
          rtcp: {}
      };
      for (const extendedCodec of extendedRtpCapabilities.codecs) {
          if (extendedCodec.kind !== kind)
              continue;
          const codec = {
              mimeType: extendedCodec.mimeType,
              payloadType: extendedCodec.localPayloadType,
              clockRate: extendedCodec.clockRate,
              channels: extendedCodec.channels,
              parameters: extendedCodec.localParameters,
              rtcpFeedback: extendedCodec.rtcpFeedback
          };
          rtpParameters.codecs.push(codec);
          // Add RTX codec.
          if (extendedCodec.localRtxPayloadType) {
              const rtxCodec = {
                  mimeType: `${extendedCodec.kind}/rtx`,
                  payloadType: extendedCodec.localRtxPayloadType,
                  clockRate: extendedCodec.clockRate,
                  parameters: {
                      apt: extendedCodec.localPayloadType
                  },
                  rtcpFeedback: []
              };
              rtpParameters.codecs.push(rtxCodec);
          }
      }
      for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
          // Ignore RTP extensions of a different kind and those not valid for sending.
          if ((extendedExtension.kind && extendedExtension.kind !== kind) ||
              (extendedExtension.direction !== 'sendrecv' &&
                  extendedExtension.direction !== 'sendonly')) {
              continue;
          }
          const ext = {
              uri: extendedExtension.uri,
              id: extendedExtension.sendId,
              encrypt: extendedExtension.encrypt,
              parameters: {}
          };
          rtpParameters.headerExtensions.push(ext);
      }
      return rtpParameters;
  }
  exports.getSendingRtpParameters = getSendingRtpParameters;
  /**
   * Generate RTP parameters of the given kind suitable for the remote SDP answer.
   */
  function getSendingRemoteRtpParameters(kind, extendedRtpCapabilities) {
      const rtpParameters = {
          mid: undefined,
          codecs: [],
          headerExtensions: [],
          encodings: [],
          rtcp: {}
      };
      for (const extendedCodec of extendedRtpCapabilities.codecs) {
          if (extendedCodec.kind !== kind)
              continue;
          const codec = {
              mimeType: extendedCodec.mimeType,
              payloadType: extendedCodec.localPayloadType,
              clockRate: extendedCodec.clockRate,
              channels: extendedCodec.channels,
              parameters: extendedCodec.remoteParameters,
              rtcpFeedback: extendedCodec.rtcpFeedback
          };
          rtpParameters.codecs.push(codec);
          // Add RTX codec.
          if (extendedCodec.localRtxPayloadType) {
              const rtxCodec = {
                  mimeType: `${extendedCodec.kind}/rtx`,
                  payloadType: extendedCodec.localRtxPayloadType,
                  clockRate: extendedCodec.clockRate,
                  parameters: {
                      apt: extendedCodec.localPayloadType
                  },
                  rtcpFeedback: []
              };
              rtpParameters.codecs.push(rtxCodec);
          }
      }
      for (const extendedExtension of extendedRtpCapabilities.headerExtensions) {
          // Ignore RTP extensions of a different kind and those not valid for sending.
          if ((extendedExtension.kind && extendedExtension.kind !== kind) ||
              (extendedExtension.direction !== 'sendrecv' &&
                  extendedExtension.direction !== 'sendonly')) {
              continue;
          }
          const ext = {
              uri: extendedExtension.uri,
              id: extendedExtension.sendId,
              encrypt: extendedExtension.encrypt,
              parameters: {}
          };
          rtpParameters.headerExtensions.push(ext);
      }
      // Reduce codecs' RTCP feedback. Use Transport-CC if available, REMB otherwise.
      if (rtpParameters.headerExtensions.some((ext) => (ext.uri === 'http://www.ietf.org/id/draft-holmer-rmcat-transport-wide-cc-extensions-01'))) {
          for (const codec of rtpParameters.codecs) {
              codec.rtcpFeedback = (codec.rtcpFeedback || [])
                  .filter((fb) => fb.type !== 'goog-remb');
          }
      }
      else if (rtpParameters.headerExtensions.some((ext) => (ext.uri === 'http://www.webrtc.org/experiments/rtp-hdrext/abs-send-time'))) {
          for (const codec of rtpParameters.codecs) {
              codec.rtcpFeedback = (codec.rtcpFeedback || [])
                  .filter((fb) => fb.type !== 'transport-cc');
          }
      }
      else {
          for (const codec of rtpParameters.codecs) {
              codec.rtcpFeedback = (codec.rtcpFeedback || [])
                  .filter((fb) => (fb.type !== 'transport-cc' &&
                  fb.type !== 'goog-remb'));
          }
      }
      return rtpParameters;
  }
  exports.getSendingRemoteRtpParameters = getSendingRemoteRtpParameters;
  /**
   * Reduce given codecs by returning an array of codecs "compatible" with the
   * given capability codec. If no capability codec is given, take the first
   * one(s).
   *
   * Given codecs must be generated by ortc.getSendingRtpParameters() or
   * ortc.getSendingRemoteRtpParameters().
   *
   * The returned array of codecs also include a RTX codec if available.
   */
  function reduceCodecs(codecs, capCodec) {
      const filteredCodecs = [];
      // If no capability codec is given, take the first one (and RTX).
      if (!capCodec) {
          filteredCodecs.push(codecs[0]);
          if (isRtxCodec(codecs[1]))
              filteredCodecs.push(codecs[1]);
      }
      // Otherwise look for a compatible set of codecs.
      else {
          for (let idx = 0; idx < codecs.length; ++idx) {
              if (matchCodecs(codecs[idx], capCodec)) {
                  filteredCodecs.push(codecs[idx]);
                  if (isRtxCodec(codecs[idx + 1]))
                      filteredCodecs.push(codecs[idx + 1]);
                  break;
              }
          }
          if (filteredCodecs.length === 0)
              throw new TypeError('no matching codec found');
      }
      return filteredCodecs;
  }
  exports.reduceCodecs = reduceCodecs;
  /**
   * Create RTP parameters for a Consumer for the RTP probator.
   */
  function generateProbatorRtpParameters(videoRtpParameters) {
      // Clone given reference video RTP parameters.
      videoRtpParameters = utils.clone(videoRtpParameters, {});
      // This may throw.
      validateRtpParameters(videoRtpParameters);
      const rtpParameters = {
          mid: RTP_PROBATOR_MID,
          codecs: [],
          headerExtensions: [],
          encodings: [{ ssrc: RTP_PROBATOR_SSRC }],
          rtcp: { cname: 'probator' }
      };
      rtpParameters.codecs.push(videoRtpParameters.codecs[0]);
      rtpParameters.codecs[0].payloadType = RTP_PROBATOR_CODEC_PAYLOAD_TYPE;
      rtpParameters.headerExtensions = videoRtpParameters.headerExtensions;
      return rtpParameters;
  }
  exports.generateProbatorRtpParameters = generateProbatorRtpParameters;
  /**
   * Whether media can be sent based on the given RTP capabilities.
   */
  function canSend(kind, extendedRtpCapabilities) {
      return extendedRtpCapabilities.codecs.
          some((codec) => codec.kind === kind);
  }
  exports.canSend = canSend;
  /**
   * Whether the given RTP parameters can be received with the given RTP
   * capabilities.
   */
  function canReceive(rtpParameters, extendedRtpCapabilities) {
      // This may throw.
      validateRtpParameters(rtpParameters);
      if (rtpParameters.codecs.length === 0)
          return false;
      const firstMediaCodec = rtpParameters.codecs[0];
      return extendedRtpCapabilities.codecs
          .some((codec) => codec.remotePayloadType === firstMediaCodec.payloadType);
  }
  exports.canReceive = canReceive;
  function isRtxCodec(codec) {
      if (!codec)
          return false;
      return /.+\/rtx$/i.test(codec.mimeType);
  }
  function matchCodecs(aCodec, bCodec, { strict = false, modify = false } = {}) {
      const aMimeType = aCodec.mimeType.toLowerCase();
      const bMimeType = bCodec.mimeType.toLowerCase();
      if (aMimeType !== bMimeType)
          return false;
      if (aCodec.clockRate !== bCodec.clockRate)
          return false;
      if (aCodec.channels !== bCodec.channels)
          return false;
      // Per codec special checks.
      switch (aMimeType) {
          case 'video/h264':
              {
                  const aPacketizationMode = aCodec.parameters['packetization-mode'] || 0;
                  const bPacketizationMode = bCodec.parameters['packetization-mode'] || 0;
                  if (aPacketizationMode !== bPacketizationMode)
                      return false;
                  // If strict matching check profile-level-id.
                  if (strict) {
                      if (!h264.isSameProfile(aCodec.parameters, bCodec.parameters))
                          return false;
                      let selectedProfileLevelId;
                      try {
                          selectedProfileLevelId =
                              h264.generateProfileLevelIdForAnswer(aCodec.parameters, bCodec.parameters);
                      }
                      catch (error) {
                          return false;
                      }
                      if (modify) {
                          if (selectedProfileLevelId) {
                              aCodec.parameters['profile-level-id'] = selectedProfileLevelId;
                              bCodec.parameters['profile-level-id'] = selectedProfileLevelId;
                          }
                          else {
                              delete aCodec.parameters['profile-level-id'];
                              delete bCodec.parameters['profile-level-id'];
                          }
                      }
                  }
                  break;
              }
          case 'video/vp9':
              {
                  // If strict matching check profile-id.
                  if (strict) {
                      const aProfileId = aCodec.parameters['profile-id'] || 0;
                      const bProfileId = bCodec.parameters['profile-id'] || 0;
                      if (aProfileId !== bProfileId)
                          return false;
                  }
                  break;
              }
      }
      return true;
  }
  function matchHeaderExtensions(aExt, bExt) {
      if (aExt.kind && bExt.kind && aExt.kind !== bExt.kind)
          return false;
      if (aExt.uri !== bExt.uri)
          return false;
      return true;
  }
  function reduceRtcpFeedback(codecA, codecB) {
      const reducedRtcpFeedback = [];
      for (const aFb of codecA.rtcpFeedback || []) {
          const matchingBFb = (codecB.rtcpFeedback || [])
              .find((bFb) => (bFb.type === aFb.type &&
              (bFb.parameter === aFb.parameter || (!bFb.parameter && !aFb.parameter))));
          if (matchingBFb)
              reducedRtcpFeedback.push(matchingBFb);
      }
      return reducedRtcpFeedback;
  }
  
  },{"./utils":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/utils.js","h264-profile-level-id":"/home/ubuntu/umbrella-voice2/app/node_modules/h264-profile-level-id/index.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/scalabilityModes.js":[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.parse = void 0;
  const ScalabilityModeRegex = new RegExp('^[LS]([1-9]\\d{0,1})T([1-9]\\d{0,1})');
  function parse(scalabilityMode) {
      const match = ScalabilityModeRegex.exec(scalabilityMode || '');
      if (match) {
          return {
              spatialLayers: Number(match[1]),
              temporalLayers: Number(match[2])
          };
      }
      else {
          return {
              spatialLayers: 1,
              temporalLayers: 1
          };
      }
  }
  exports.parse = parse;
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/types.js":[function(require,module,exports){
  "use strict";
  var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
  }) : (function(o, m, k, k2) {
      if (k2 === undefined) k2 = k;
      o[k2] = m[k];
  }));
  var __exportStar = (this && this.__exportStar) || function(m, exports) {
      for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
  };
  Object.defineProperty(exports, "__esModule", { value: true });
  __exportStar(require("./Device"), exports);
  __exportStar(require("./Transport"), exports);
  __exportStar(require("./Producer"), exports);
  __exportStar(require("./Consumer"), exports);
  __exportStar(require("./DataProducer"), exports);
  __exportStar(require("./DataConsumer"), exports);
  __exportStar(require("./RtpParameters"), exports);
  __exportStar(require("./SctpParameters"), exports);
  __exportStar(require("./handlers/HandlerInterface"), exports);
  __exportStar(require("./errors"), exports);
  
  },{"./Consumer":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Consumer.js","./DataConsumer":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/DataConsumer.js","./DataProducer":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/DataProducer.js","./Device":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Device.js","./Producer":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Producer.js","./RtpParameters":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/RtpParameters.js","./SctpParameters":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/SctpParameters.js","./Transport":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/Transport.js","./errors":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/errors.js","./handlers/HandlerInterface":"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/handlers/HandlerInterface.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/mediasoup-client/lib/utils.js":[function(require,module,exports){
  "use strict";
  Object.defineProperty(exports, "__esModule", { value: true });
  exports.generateRandomNumber = exports.clone = void 0;
  /**
   * Clones the given data.
   */
  function clone(data, defaultValue) {
      if (typeof data === 'undefined')
          return defaultValue;
      return JSON.parse(JSON.stringify(data));
  }
  exports.clone = clone;
  /**
   * Generates a random positive integer.
   */
  function generateRandomNumber() {
      return Math.round(Math.random() * 10000000);
  }
  exports.generateRandomNumber = generateRandomNumber;
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/ms/index.js":[function(require,module,exports){
  /**
   * Helpers.
   */
  
  var s = 1000;
  var m = s * 60;
  var h = m * 60;
  var d = h * 24;
  var w = d * 7;
  var y = d * 365.25;
  
  /**
   * Parse or format the given `val`.
   *
   * Options:
   *
   *  - `long` verbose formatting [false]
   *
   * @param {String|Number} val
   * @param {Object} [options]
   * @throws {Error} throw an error if val is not a non-empty string or a number
   * @return {String|Number}
   * @api public
   */
  
  module.exports = function(val, options) {
    options = options || {};
    var type = typeof val;
    if (type === 'string' && val.length > 0) {
      return parse(val);
    } else if (type === 'number' && isFinite(val)) {
      return options.long ? fmtLong(val) : fmtShort(val);
    }
    throw new Error(
      'val is not a non-empty string or a valid number. val=' +
        JSON.stringify(val)
    );
  };
  
  /**
   * Parse the given `str` and return milliseconds.
   *
   * @param {String} str
   * @return {Number}
   * @api private
   */
  
  function parse(str) {
    str = String(str);
    if (str.length > 100) {
      return;
    }
    var match = /^(-?(?:\d+)?\.?\d+) *(milliseconds?|msecs?|ms|seconds?|secs?|s|minutes?|mins?|m|hours?|hrs?|h|days?|d|weeks?|w|years?|yrs?|y)?$/i.exec(
      str
    );
    if (!match) {
      return;
    }
    var n = parseFloat(match[1]);
    var type = (match[2] || 'ms').toLowerCase();
    switch (type) {
      case 'years':
      case 'year':
      case 'yrs':
      case 'yr':
      case 'y':
        return n * y;
      case 'weeks':
      case 'week':
      case 'w':
        return n * w;
      case 'days':
      case 'day':
      case 'd':
        return n * d;
      case 'hours':
      case 'hour':
      case 'hrs':
      case 'hr':
      case 'h':
        return n * h;
      case 'minutes':
      case 'minute':
      case 'mins':
      case 'min':
      case 'm':
        return n * m;
      case 'seconds':
      case 'second':
      case 'secs':
      case 'sec':
      case 's':
        return n * s;
      case 'milliseconds':
      case 'millisecond':
      case 'msecs':
      case 'msec':
      case 'ms':
        return n;
      default:
        return undefined;
    }
  }
  
  /**
   * Short format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */
  
  function fmtShort(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return Math.round(ms / d) + 'd';
    }
    if (msAbs >= h) {
      return Math.round(ms / h) + 'h';
    }
    if (msAbs >= m) {
      return Math.round(ms / m) + 'm';
    }
    if (msAbs >= s) {
      return Math.round(ms / s) + 's';
    }
    return ms + 'ms';
  }
  
  /**
   * Long format for `ms`.
   *
   * @param {Number} ms
   * @return {String}
   * @api private
   */
  
  function fmtLong(ms) {
    var msAbs = Math.abs(ms);
    if (msAbs >= d) {
      return plural(ms, msAbs, d, 'day');
    }
    if (msAbs >= h) {
      return plural(ms, msAbs, h, 'hour');
    }
    if (msAbs >= m) {
      return plural(ms, msAbs, m, 'minute');
    }
    if (msAbs >= s) {
      return plural(ms, msAbs, s, 'second');
    }
    return ms + ' ms';
  }
  
  /**
   * Pluralization helper.
   */
  
  function plural(ms, msAbs, n, name) {
    var isPlural = msAbs >= n * 1.5;
    return Math.round(ms / n) + ' ' + name + (isPlural ? 's' : '');
  }
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/process/browser.js":[function(require,module,exports){
  // shim for using process in browser
  var process = module.exports = {};
  
  // cached from whatever global is present so that test runners that stub it
  // don't break things.  But we need to wrap it in a try catch in case it is
  // wrapped in strict mode code which doesn't define any globals.  It's inside a
  // function because try/catches deoptimize in certain engines.
  
  var cachedSetTimeout;
  var cachedClearTimeout;
  
  function defaultSetTimout() {
      throw new Error('setTimeout has not been defined');
  }
  function defaultClearTimeout () {
      throw new Error('clearTimeout has not been defined');
  }
  (function () {
      try {
          if (typeof setTimeout === 'function') {
              cachedSetTimeout = setTimeout;
          } else {
              cachedSetTimeout = defaultSetTimout;
          }
      } catch (e) {
          cachedSetTimeout = defaultSetTimout;
      }
      try {
          if (typeof clearTimeout === 'function') {
              cachedClearTimeout = clearTimeout;
          } else {
              cachedClearTimeout = defaultClearTimeout;
          }
      } catch (e) {
          cachedClearTimeout = defaultClearTimeout;
      }
  } ())
  function runTimeout(fun) {
      if (cachedSetTimeout === setTimeout) {
          //normal enviroments in sane situations
          return setTimeout(fun, 0);
      }
      // if setTimeout wasn't available but was latter defined
      if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
          cachedSetTimeout = setTimeout;
          return setTimeout(fun, 0);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedSetTimeout(fun, 0);
      } catch(e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
              return cachedSetTimeout.call(null, fun, 0);
          } catch(e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
              return cachedSetTimeout.call(this, fun, 0);
          }
      }
  
  
  }
  function runClearTimeout(marker) {
      if (cachedClearTimeout === clearTimeout) {
          //normal enviroments in sane situations
          return clearTimeout(marker);
      }
      // if clearTimeout wasn't available but was latter defined
      if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
          cachedClearTimeout = clearTimeout;
          return clearTimeout(marker);
      }
      try {
          // when when somebody has screwed with setTimeout but no I.E. maddness
          return cachedClearTimeout(marker);
      } catch (e){
          try {
              // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
              return cachedClearTimeout.call(null, marker);
          } catch (e){
              // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
              // Some versions of I.E. have different rules for clearTimeout vs setTimeout
              return cachedClearTimeout.call(this, marker);
          }
      }
  
  
  
  }
  var queue = [];
  var draining = false;
  var currentQueue;
  var queueIndex = -1;
  
  function cleanUpNextTick() {
      if (!draining || !currentQueue) {
          return;
      }
      draining = false;
      if (currentQueue.length) {
          queue = currentQueue.concat(queue);
      } else {
          queueIndex = -1;
      }
      if (queue.length) {
          drainQueue();
      }
  }
  
  function drainQueue() {
      if (draining) {
          return;
      }
      var timeout = runTimeout(cleanUpNextTick);
      draining = true;
  
      var len = queue.length;
      while(len) {
          currentQueue = queue;
          queue = [];
          while (++queueIndex < len) {
              if (currentQueue) {
                  currentQueue[queueIndex].run();
              }
          }
          queueIndex = -1;
          len = queue.length;
      }
      currentQueue = null;
      draining = false;
      runClearTimeout(timeout);
  }
  
  process.nextTick = function (fun) {
      var args = new Array(arguments.length - 1);
      if (arguments.length > 1) {
          for (var i = 1; i < arguments.length; i++) {
              args[i - 1] = arguments[i];
          }
      }
      queue.push(new Item(fun, args));
      if (queue.length === 1 && !draining) {
          runTimeout(drainQueue);
      }
  };
  
  // v8 likes predictible objects
  function Item(fun, array) {
      this.fun = fun;
      this.array = array;
  }
  Item.prototype.run = function () {
      this.fun.apply(null, this.array);
  };
  process.title = 'browser';
  process.browser = true;
  process.env = {};
  process.argv = [];
  process.version = ''; // empty string to avoid regexp issues
  process.versions = {};
  
  function noop() {}
  
  process.on = noop;
  process.addListener = noop;
  process.once = noop;
  process.off = noop;
  process.removeListener = noop;
  process.removeAllListeners = noop;
  process.emit = noop;
  process.prependListener = noop;
  process.prependOnceListener = noop;
  
  process.listeners = function (name) { return [] }
  
  process.binding = function (name) {
      throw new Error('process.binding is not supported');
  };
  
  process.cwd = function () { return '/' };
  process.chdir = function (dir) {
      throw new Error('process.chdir is not supported');
  };
  process.umask = function() { return 0; };
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/lib/EnhancedEventEmitter.js":[function(require,module,exports){
  const { EventEmitter } = require('events');
  const Logger = require('./Logger');
  
  class EnhancedEventEmitter extends EventEmitter
  {
    constructor(logger)
    {
      super();
      this.setMaxListeners(Infinity);
  
      this._logger = logger || new Logger('EnhancedEventEmitter');
    }
  
    safeEmit(event, ...args)
    {
      try
      {
        this.emit(event, ...args);
      }
      catch (error)
      {
        this._logger.error(
          'safeEmit() | event listener threw an error [event:%s]:%o',
          event, error);
      }
    }
  
    async safeEmitAsPromise(event, ...args)
    {
      return new Promise((resolve, reject) =>
      {
        this.safeEmit(event, ...args, resolve, reject);
      });
    }
  }
  
  module.exports = EnhancedEventEmitter;
  
  },{"./Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/lib/Logger.js","events":"/home/ubuntu/umbrella-voice2/app/node_modules/browserify/node_modules/events/events.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/lib/Logger.js":[function(require,module,exports){
  const debug = require('debug');
  
  const APP_NAME = 'protoo-client';
  
  class Logger
  {
    constructor(prefix)
    {
      if (prefix)
      {
        this._debug = debug(`${APP_NAME}:${prefix}`);
        this._warn = debug(`${APP_NAME}:WARN:${prefix}`);
        this._error = debug(`${APP_NAME}:ERROR:${prefix}`);
      }
      else
      {
        this._debug = debug(APP_NAME);
        this._warn = debug(`${APP_NAME}:WARN`);
        this._error = debug(`${APP_NAME}:ERROR`);
      }
  
      /* eslint-disable no-console */
      this._debug.log = console.info.bind(console);
      this._warn.log = console.warn.bind(console);
      this._error.log = console.error.bind(console);
      /* eslint-enable no-console */
    }
  
    get debug()
    {
      return this._debug;
    }
  
    get warn()
    {
      return this._warn;
    }
  
    get error()
    {
      return this._error;
    }
  }
  
  module.exports = Logger;
  
  },{"debug":"/home/ubuntu/umbrella-voice2/app/node_modules/debug/src/browser.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/lib/Message.js":[function(require,module,exports){
  const Logger = require('./Logger');
  const { generateRandomNumber } = require('./utils');
  
  const logger = new Logger('Message');
  
  class Message
  {
    static parse(raw)
    {
      let object;
      const message = {};
  
      try
      {
        object = JSON.parse(raw);
      }
      catch (error)
      {
        logger.error('parse() | invalid JSON: %s', error);
  
        return;
      }
  
      if (typeof object !== 'object' || Array.isArray(object))
      {
        logger.error('parse() | not an object');
  
        return;
      }
  
      // Request.
      if (object.request)
      {
        message.request = true;
  
        if (typeof object.method !== 'string')
        {
          logger.error('parse() | missing/invalid method field');
  
          return;
        }
  
        if (typeof object.id !== 'number')
        {
          logger.error('parse() | missing/invalid id field');
  
          return;
        }
  
        message.id = object.id;
        message.method = object.method;
        message.data = object.data || {};
      }
      // Response.
      else if (object.response)
      {
        message.response = true;
  
        if (typeof object.id !== 'number')
        {
          logger.error('parse() | missing/invalid id field');
  
          return;
        }
  
        message.id = object.id;
  
        // Success.
        if (object.ok)
        {
          message.ok = true;
          message.data = object.data || {};
        }
        // Error.
        else
        {
          message.ok = false;
          message.errorCode = object.errorCode;
          message.errorReason = object.errorReason;
        }
      }
      // Notification.
      else if (object.notification)
      {
        message.notification = true;
  
        if (typeof object.method !== 'string')
        {
          logger.error('parse() | missing/invalid method field');
  
          return;
        }
  
        message.method = object.method;
        message.data = object.data || {};
      }
      // Invalid.
      else
      {
        logger.error('parse() | missing request/response field');
  
        return;
      }
  
      return message;
    }
  
    static createRequest(method, data)
    {
      const request =
      {
        request : true,
        id      : generateRandomNumber(),
        method  : method,
        data    : data || {}
      };
  
      return request;
    }
  
    static createSuccessResponse(request, data)
    {
      const response =
      {
        response : true,
        id       : request.id,
        ok       : true,
        data     : data || {}
      };
  
      return response;
    }
  
    static createErrorResponse(request, errorCode, errorReason)
    {
      const response =
      {
        response    : true,
        id          : request.id,
        ok          : false,
        errorCode   : errorCode,
        errorReason : errorReason
      };
  
      return response;
    }
  
    static createNotification(method, data)
    {
      const notification =
      {
        notification : true,
        method       : method,
        data         : data || {}
      };
  
      return notification;
    }
  }
  
  module.exports = Message;
  
  },{"./Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/lib/Logger.js","./utils":"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/lib/utils.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/lib/Peer.js":[function(require,module,exports){
  const Logger = require('./Logger');
  const EnhancedEventEmitter = require('./EnhancedEventEmitter');
  const Message = require('./Message');
  
  const logger = new Logger('Peer');
  
  class Peer extends EnhancedEventEmitter
  {
    /**
     * @param {protoo.Transport} transport
     *
     * @emits open
     * @emits {currentAttempt: Number} failed
     * @emits disconnected
     * @emits close
     * @emits {request: protoo.Request, accept: Function, reject: Function} request
     * @emits {notification: protoo.Notification} notification
     */
    constructor(transport)
    {
      super(logger);
  
      logger.debug('constructor()');
  
      // Closed flag.
      // @type {Boolean}
      this._closed = false;
  
      // Transport.
      // @type {protoo.Transport}
      this._transport = transport;
  
      // Connected flag.
      // @type {Boolean}
      this._connected = false;
  
      // Custom data object.
      // @type {Object}
      this._data = {};
  
      // Map of pending sent request objects indexed by request id.
      // @type {Map<Number, Object>}
      this._sents = new Map();
  
      // Handle transport.
      this._handleTransport();
    }
  
    /**
     * Whether the Peer is closed.
     *
     * @returns {Boolean}
     */
    get closed()
    {
      return this._closed;
    }
  
    /**
     * Whether the Peer is connected.
     *
     * @returns {Boolean}
     */
    get connected()
    {
      return this._connected;
    }
  
    /**
     * App custom data.
     *
     * @returns {Object}
     */
    get data()
    {
      return this._data;
    }
  
    /**
     * Invalid setter.
     */
    set data(data) // eslint-disable-line no-unused-vars
    {
      throw new Error('cannot override data object');
    }
  
    /**
     * Close this Peer and its Transport.
     */
    close()
    {
      if (this._closed)
        return;
  
      logger.debug('close()');
  
      this._closed = true;
      this._connected = false;
  
      // Close Transport.
      this._transport.close();
  
      // Close every pending sent.
      for (const sent of this._sents.values())
      {
        sent.close();
      }
  
      // Emit 'close' event.
      this.safeEmit('close');
    }
  
    /**
     * Send a protoo request to the server-side Room.
     *
     * @param {String} method
     * @param {Object} [data]
     *
     * @async
     * @returns {Object} The response data Object if a success response is received.
     */
    async request(method, data = undefined)
    {
      const request = Message.createRequest(method, data);
  
      this._logger.debug('request() [method:%s, id:%s]', method, request.id);
  
      // This may throw.
      await this._transport.send(request);
  
      return new Promise((pResolve, pReject) =>
      {
        const timeout = 1500 * (15 + (0.1 * this._sents.size));
        const sent =
        {
          id      : request.id,
          method  : request.method,
          resolve : (data2) =>
          {
            if (!this._sents.delete(request.id))
              return;
  
            clearTimeout(sent.timer);
            pResolve(data2);
          },
          reject : (error) =>
          {
            if (!this._sents.delete(request.id))
              return;
  
            clearTimeout(sent.timer);
            pReject(error);
          },
          timer : setTimeout(() =>
          {
            if (!this._sents.delete(request.id))
              return;
  
            pReject(new Error('request timeout'));
          }, timeout),
          close : () =>
          {
            clearTimeout(sent.timer);
            pReject(new Error('peer closed'));
          }
        };
  
        // Add sent stuff to the map.
        this._sents.set(request.id, sent);
      });
    }
  
    /**
     * Send a protoo notification to the server-side Room.
     *
     * @param {String} method
     * @param {Object} [data]
     *
     * @async
     */
    async notify(method, data = undefined)
    {
      const notification = Message.createNotification(method, data);
  
      this._logger.debug('notify() [method:%s]', method);
  
      // This may throw.
      await this._transport.send(notification);
    }
  
    _handleTransport()
    {
      if (this._transport.closed)
      {
        this._closed = true;
  
        setTimeout(() =>
        {
          if (this._closed)
            return;
  
          this._connected = false;
  
          this.safeEmit('close');
        });
  
        return;
      }
  
      this._transport.on('open', () =>
      {
        if (this._closed)
          return;
  
        logger.debug('emit "open"');
  
        this._connected = true;
  
        this.safeEmit('open');
      });
  
      this._transport.on('disconnected', () =>
      {
        if (this._closed)
          return;
  
        logger.debug('emit "disconnected"');
  
        this._connected = false;
  
        this.safeEmit('disconnected');
      });
  
      this._transport.on('failed', (currentAttempt) =>
      {
        if (this._closed)
          return;
  
        logger.debug('emit "failed" [currentAttempt:%s]', currentAttempt);
  
        this._connected = false;
  
        this.safeEmit('failed', currentAttempt);
      });
  
      this._transport.on('close', () =>
      {
        if (this._closed)
          return;
  
        this._closed = true;
  
        logger.debug('emit "close"');
  
        this._connected = false;
  
        this.safeEmit('close');
      });
  
      this._transport.on('message', (message) =>
      {
        if (message.request)
          this._handleRequest(message);
        else if (message.response)
          this._handleResponse(message);
        else if (message.notification)
          this._handleNotification(message);
      });
    }
  
    _handleRequest(request)
    {
      try
      {
        this.emit('request',
          // Request.
          request,
          // accept() function.
          (data) =>
          {
            const response = Message.createSuccessResponse(request, data);
  
            this._transport.send(response)
              .catch(() => {});
          },
          // reject() function.
          (errorCode, errorReason) =>
          {
            if (errorCode instanceof Error)
            {
              errorReason = errorCode.message;
              errorCode = 500;
            }
            else if (typeof errorCode === 'number' && errorReason instanceof Error)
            {
              errorReason = errorReason.message;
            }
  
            const response =
              Message.createErrorResponse(request, errorCode, errorReason);
  
            this._transport.send(response)
              .catch(() => {});
          });
      }
      catch (error)
      {
        const response = Message.createErrorResponse(request, 500, String(error));
  
        this._transport.send(response)
          .catch(() => {});
      }
    }
  
    _handleResponse(response)
    {
      const sent = this._sents.get(response.id);
  
      if (!sent)
      {
        logger.error(
          'received response does not match any sent request [id:%s]', response.id);
  
        return;
      }
  
      if (response.ok)
      {
        sent.resolve(response.data);
      }
      else
      {
        const error = new Error(response.errorReason);
  
        error.code = response.errorCode;
        sent.reject(error);
      }
    }
  
    _handleNotification(notification)
    {
      this.safeEmit('notification', notification);
    }
  }
  
  module.exports = Peer;
  
  },{"./EnhancedEventEmitter":"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/lib/EnhancedEventEmitter.js","./Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/lib/Logger.js","./Message":"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/lib/Message.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/lib/index.js":[function(require,module,exports){
  const { version } = require('../package.json');
  const Peer = require('./Peer');
  const WebSocketTransport = require('./transports/WebSocketTransport');
  
  /**
   * Expose mediasoup-client version.
   *
   * @type {String}
   */
  exports.version = version;
  
  /**
   * Expose Peer class.
   *
   * @type {Class}
   */
  exports.Peer = Peer;
  
  /**
   * Expose WebSocketTransport class.
   *
   * @type {Class}
   */
  exports.WebSocketTransport = WebSocketTransport;
  
  },{"../package.json":"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/package.json","./Peer":"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/lib/Peer.js","./transports/WebSocketTransport":"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/lib/transports/WebSocketTransport.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/lib/transports/WebSocketTransport.js":[function(require,module,exports){
  const W3CWebSocket = require('websocket').w3cwebsocket;
  const retry = require('retry');
  const Logger = require('../Logger');
  const EnhancedEventEmitter = require('../EnhancedEventEmitter');
  const Message = require('../Message');
  
  const WS_SUBPROTOCOL = 'protoo';
  const DEFAULT_RETRY_OPTIONS =
  {
    retries    : 10,
    factor     : 2,
    minTimeout : 1 * 1000,
    maxTimeout : 8 * 1000
  };
  
  const logger = new Logger('WebSocketTransport');
  
  class WebSocketTransport extends EnhancedEventEmitter
  {
    /**
     * @param {String} url - WebSocket URL.
     * @param {Object} [options] - Options for WebSocket-Node.W3CWebSocket and retry.
     */
    constructor(url, options)
    {
      super(logger);
  
      logger.debug('constructor() [url:%s, options:%o]', url, options);
  
      // Closed flag.
      // @type {Boolean}
      this._closed = false;
  
      // WebSocket URL.
      // @type {String}
      this._url = url;
  
      // Options.
      // @type {Object}
      this._options = options || {};
  
      // WebSocket instance.
      // @type {WebSocket}
      this._ws = null;
  
      // Run the WebSocket.
      this._runWebSocket();
    }
  
    get closed()
    {
      return this._closed;
    }
  
    close()
    {
      if (this._closed)
        return;
  
      logger.debug('close()');
  
      // Don't wait for the WebSocket 'close' event, do it now.
      this._closed = true;
      this.safeEmit('close');
  
      try
      {
        this._ws.onopen = null;
        this._ws.onclose = null;
        this._ws.onerror = null;
        this._ws.onmessage = null;
        this._ws.close();
      }
      catch (error)
      {
        logger.error('close() | error closing the WebSocket: %o', error);
      }
    }
  
    async send(message)
    {
      if (this._closed)
        throw new Error('transport closed');
  
      try
      {
        this._ws.send(JSON.stringify(message));
      }
      catch (error)
      {
        logger.warn('send() failed:%o', error);
  
        throw error;
      }
    }
  
    _runWebSocket()
    {
      const operation =
        retry.operation(this._options.retry || DEFAULT_RETRY_OPTIONS);
  
      let wasConnected = false;
  
      operation.attempt((currentAttempt) =>
      {
        if (this._closed)
        {
          operation.stop();
  
          return;
        }
  
        logger.debug('_runWebSocket() [currentAttempt:%s]', currentAttempt);
  
        this._ws = new W3CWebSocket(
          this._url,
          WS_SUBPROTOCOL,
          this._options.origin,
          this._options.headers,
          this._options.requestOptions,
          this._options.clientConfig);
  
        this._ws.onopen = () =>
        {
          if (this._closed)
            return;
  
          wasConnected = true;
  
          // Emit 'open' event.
          this.safeEmit('open');
        };
  
        this._ws.onclose = (event) =>
        {
          if (this._closed)
            return;
  
          logger.warn(
            'WebSocket "close" event [wasClean:%s, code:%s, reason:"%s"]',
            event.wasClean, event.code, event.reason);
  
          // Don't retry if code is 4000 (closed by the server).
          if (event.code !== 4000)
          {
            // If it was not connected, try again.
            if (!wasConnected)
            {
              this.safeEmit('failed', currentAttempt);
  
              if (this._closed)
                return;
  
              if (operation.retry(true))
                return;
            }
            // If it was connected, start from scratch.
            else
            {
              operation.stop();
  
              this.safeEmit('disconnected');
  
              if (this._closed)
                return;
  
              this._runWebSocket();
  
              return;
            }
          }
  
          this._closed = true;
  
          // Emit 'close' event.
          this.safeEmit('close');
        };
  
        this._ws.onerror = () =>
        {
          if (this._closed)
            return;
  
          logger.error('WebSocket "error" event');
        };
  
        this._ws.onmessage = (event) =>
        {
          if (this._closed)
            return;
  
          const message = Message.parse(event.data);
  
          if (!message)
            return;
  
          if (this.listenerCount('message') === 0)
          {
            logger.error(
              'no listeners for WebSocket "message" event, ignoring received message');
  
            return;
          }
  
          // Emit 'message' event.
          this.safeEmit('message', message);
        };
      });
    }
  }
  
  module.exports = WebSocketTransport;
  
  },{"../EnhancedEventEmitter":"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/lib/EnhancedEventEmitter.js","../Logger":"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/lib/Logger.js","../Message":"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/lib/Message.js","retry":"/home/ubuntu/umbrella-voice2/app/node_modules/retry/index.js","websocket":"/home/ubuntu/umbrella-voice2/app/node_modules/websocket/lib/browser.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/lib/utils.js":[function(require,module,exports){
  /**
   * Generates a random positive integer.
   *
   * @returns {Number}
   */
  exports.generateRandomNumber = function()
  {
    return Math.round(Math.random() * 10000000);
  };
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/protoo-client/package.json":[function(require,module,exports){
  module.exports={
    "_from": "protoo-client@^4.0.4",
    "_id": "protoo-client@4.0.6",
    "_inBundle": false,
    "_integrity": "sha512-ZqImkKHpeJhSlgvyI6QAfZNc/aXcCgmmocMx4S1w2lAaxXtckxxeDtcVNtkOISUWm/mbC+BrmYPXoGMkfhkKOQ==",
    "_location": "/protoo-client",
    "_phantomChildren": {},
    "_requested": {
      "type": "range",
      "registry": true,
      "raw": "protoo-client@^4.0.4",
      "name": "protoo-client",
      "escapedName": "protoo-client",
      "rawSpec": "^4.0.4",
      "saveSpec": null,
      "fetchSpec": "^4.0.4"
    },
    "_requiredBy": [
      "/"
    ],
    "_resolved": "https://registry.npmjs.org/protoo-client/-/protoo-client-4.0.6.tgz",
    "_shasum": "02a89f997ee5a4f385dab7be938dda1a2c5158e4",
    "_spec": "protoo-client@^4.0.4",
    "_where": "/home/ubuntu/umbrella-voice/app",
    "author": {
      "name": "Iñaki Baz Castillo",
      "email": "ibc@aliax.net"
    },
    "bugs": {
      "url": "https://github.com/ibc/protoo/issues"
    },
    "bundleDependencies": false,
    "dependencies": {
      "debug": "^4.3.1",
      "events": "^3.2.0",
      "retry": "^0.12.0",
      "websocket": "^1.0.33"
    },
    "deprecated": false,
    "description": "protoo JavaScript client module",
    "devDependencies": {
      "eslint": "^5.16.0"
    },
    "engines": {
      "node": ">=8.0.0"
    },
    "homepage": "https://protoo.versatica.com",
    "keywords": [
      "nodejs",
      "browser",
      "websocket"
    ],
    "license": "MIT",
    "main": "lib/index.js",
    "name": "protoo-client",
    "optionalDependencies": {
      "websocket": "^1.0.33"
    },
    "repository": {
      "type": "git",
      "url": "git+https://github.com/ibc/protoo.git"
    },
    "scripts": {
      "lint": "eslint -c .eslintrc.js lib"
    },
    "version": "4.0.6"
  }
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/querystringify/index.js":[function(require,module,exports){
  'use strict';
  
  var has = Object.prototype.hasOwnProperty
    , undef;
  
  /**
   * Decode a URI encoded string.
   *
   * @param {String} input The URI encoded string.
   * @returns {String|Null} The decoded string.
   * @api private
   */
  function decode(input) {
    try {
      return decodeURIComponent(input.replace(/\+/g, ' '));
    } catch (e) {
      return null;
    }
  }
  
  /**
   * Attempts to encode a given input.
   *
   * @param {String} input The string that needs to be encoded.
   * @returns {String|Null} The encoded string.
   * @api private
   */
  function encode(input) {
    try {
      return encodeURIComponent(input);
    } catch (e) {
      return null;
    }
  }
  
  /**
   * Simple query string parser.
   *
   * @param {String} query The query string that needs to be parsed.
   * @returns {Object}
   * @api public
   */
  function querystring(query) {
    var parser = /([^=?#&]+)=?([^&]*)/g
      , result = {}
      , part;
  
    while (part = parser.exec(query)) {
      var key = decode(part[1])
        , value = decode(part[2]);
  
      //
      // Prevent overriding of existing properties. This ensures that build-in
      // methods like `toString` or __proto__ are not overriden by malicious
      // querystrings.
      //
      // In the case if failed decoding, we want to omit the key/value pairs
      // from the result.
      //
      if (key === null || value === null || key in result) continue;
      result[key] = value;
    }
  
    return result;
  }
  
  /**
   * Transform a query string to an object.
   *
   * @param {Object} obj Object that should be transformed.
   * @param {String} prefix Optional prefix.
   * @returns {String}
   * @api public
   */
  function querystringify(obj, prefix) {
    prefix = prefix || '';
  
    var pairs = []
      , value
      , key;
  
    //
    // Optionally prefix with a '?' if needed
    //
    if ('string' !== typeof prefix) prefix = '?';
  
    for (key in obj) {
      if (has.call(obj, key)) {
        value = obj[key];
  
        //
        // Edge cases where we actually want to encode the value to an empty
        // string instead of the stringified value.
        //
        if (!value && (value === null || value === undef || isNaN(value))) {
          value = '';
        }
  
        key = encode(key);
        value = encode(value);
  
        //
        // If we failed to encode the strings, we should bail out as we don't
        // want to add invalid strings to the query.
        //
        if (key === null || value === null) continue;
        pairs.push(key +'='+ value);
      }
    }
  
    return pairs.length ? prefix + pairs.join('&') : '';
  }
  
  //
  // Expose the module.
  //
  exports.stringify = querystringify;
  exports.parse = querystring;
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/regenerator-runtime/runtime.js":[function(require,module,exports){
  /**
   * Copyright (c) 2014-present, Facebook, Inc.
   *
   * This source code is licensed under the MIT license found in the
   * LICENSE file in the root directory of this source tree.
   */
  
  var runtime = (function (exports) {
    "use strict";
  
    var Op = Object.prototype;
    var hasOwn = Op.hasOwnProperty;
    var undefined; // More compressible than void 0.
    var $Symbol = typeof Symbol === "function" ? Symbol : {};
    var iteratorSymbol = $Symbol.iterator || "@@iterator";
    var asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator";
    var toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
  
    function define(obj, key, value) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
      return obj[key];
    }
    try {
      // IE 8 has a broken Object.defineProperty that only works on DOM objects.
      define({}, "");
    } catch (err) {
      define = function(obj, key, value) {
        return obj[key] = value;
      };
    }
  
    function wrap(innerFn, outerFn, self, tryLocsList) {
      // If outerFn provided and outerFn.prototype is a Generator, then outerFn.prototype instanceof Generator.
      var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator;
      var generator = Object.create(protoGenerator.prototype);
      var context = new Context(tryLocsList || []);
  
      // The ._invoke method unifies the implementations of the .next,
      // .throw, and .return methods.
      generator._invoke = makeInvokeMethod(innerFn, self, context);
  
      return generator;
    }
    exports.wrap = wrap;
  
    // Try/catch helper to minimize deoptimizations. Returns a completion
    // record like context.tryEntries[i].completion. This interface could
    // have been (and was previously) designed to take a closure to be
    // invoked without arguments, but in all the cases we care about we
    // already have an existing method we want to call, so there's no need
    // to create a new function object. We can even get away with assuming
    // the method takes exactly one argument, since that happens to be true
    // in every case, so we don't have to touch the arguments object. The
    // only additional allocation required is the completion record, which
    // has a stable shape and so hopefully should be cheap to allocate.
    function tryCatch(fn, obj, arg) {
      try {
        return { type: "normal", arg: fn.call(obj, arg) };
      } catch (err) {
        return { type: "throw", arg: err };
      }
    }
  
    var GenStateSuspendedStart = "suspendedStart";
    var GenStateSuspendedYield = "suspendedYield";
    var GenStateExecuting = "executing";
    var GenStateCompleted = "completed";
  
    // Returning this object from the innerFn has the same effect as
    // breaking out of the dispatch switch statement.
    var ContinueSentinel = {};
  
    // Dummy constructor functions that we use as the .constructor and
    // .constructor.prototype properties for functions that return Generator
    // objects. For full spec compliance, you may wish to configure your
    // minifier not to mangle the names of these two functions.
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
  
    // This is a polyfill for %IteratorPrototype% for environments that
    // don't natively support it.
    var IteratorPrototype = {};
    IteratorPrototype[iteratorSymbol] = function () {
      return this;
    };
  
    var getProto = Object.getPrototypeOf;
    var NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    if (NativeIteratorPrototype &&
        NativeIteratorPrototype !== Op &&
        hasOwn.call(NativeIteratorPrototype, iteratorSymbol)) {
      // This environment has a native %IteratorPrototype%; use it instead
      // of the polyfill.
      IteratorPrototype = NativeIteratorPrototype;
    }
  
    var Gp = GeneratorFunctionPrototype.prototype =
      Generator.prototype = Object.create(IteratorPrototype);
    GeneratorFunction.prototype = Gp.constructor = GeneratorFunctionPrototype;
    GeneratorFunctionPrototype.constructor = GeneratorFunction;
    GeneratorFunction.displayName = define(
      GeneratorFunctionPrototype,
      toStringTagSymbol,
      "GeneratorFunction"
    );
  
    // Helper for defining the .next, .throw, and .return methods of the
    // Iterator interface in terms of a single ._invoke method.
    function defineIteratorMethods(prototype) {
      ["next", "throw", "return"].forEach(function(method) {
        define(prototype, method, function(arg) {
          return this._invoke(method, arg);
        });
      });
    }
  
    exports.isGeneratorFunction = function(genFun) {
      var ctor = typeof genFun === "function" && genFun.constructor;
      return ctor
        ? ctor === GeneratorFunction ||
          // For the native GeneratorFunction constructor, the best we can
          // do is to check its .name property.
          (ctor.displayName || ctor.name) === "GeneratorFunction"
        : false;
    };
  
    exports.mark = function(genFun) {
      if (Object.setPrototypeOf) {
        Object.setPrototypeOf(genFun, GeneratorFunctionPrototype);
      } else {
        genFun.__proto__ = GeneratorFunctionPrototype;
        define(genFun, toStringTagSymbol, "GeneratorFunction");
      }
      genFun.prototype = Object.create(Gp);
      return genFun;
    };
  
    // Within the body of any async function, `await x` is transformed to
    // `yield regeneratorRuntime.awrap(x)`, so that the runtime can test
    // `hasOwn.call(value, "__await")` to determine if the yielded value is
    // meant to be awaited.
    exports.awrap = function(arg) {
      return { __await: arg };
    };
  
    function AsyncIterator(generator, PromiseImpl) {
      function invoke(method, arg, resolve, reject) {
        var record = tryCatch(generator[method], generator, arg);
        if (record.type === "throw") {
          reject(record.arg);
        } else {
          var result = record.arg;
          var value = result.value;
          if (value &&
              typeof value === "object" &&
              hasOwn.call(value, "__await")) {
            return PromiseImpl.resolve(value.__await).then(function(value) {
              invoke("next", value, resolve, reject);
            }, function(err) {
              invoke("throw", err, resolve, reject);
            });
          }
  
          return PromiseImpl.resolve(value).then(function(unwrapped) {
            // When a yielded Promise is resolved, its final value becomes
            // the .value of the Promise<{value,done}> result for the
            // current iteration.
            result.value = unwrapped;
            resolve(result);
          }, function(error) {
            // If a rejected Promise was yielded, throw the rejection back
            // into the async generator function so it can be handled there.
            return invoke("throw", error, resolve, reject);
          });
        }
      }
  
      var previousPromise;
  
      function enqueue(method, arg) {
        function callInvokeWithMethodAndArg() {
          return new PromiseImpl(function(resolve, reject) {
            invoke(method, arg, resolve, reject);
          });
        }
  
        return previousPromise =
          // If enqueue has been called before, then we want to wait until
          // all previous Promises have been resolved before calling invoke,
          // so that results are always delivered in the correct order. If
          // enqueue has not been called before, then it is important to
          // call invoke immediately, without waiting on a callback to fire,
          // so that the async generator function has the opportunity to do
          // any necessary setup in a predictable way. This predictability
          // is why the Promise constructor synchronously invokes its
          // executor callback, and why async functions synchronously
          // execute code before the first await. Since we implement simple
          // async functions in terms of async generators, it is especially
          // important to get this right, even though it requires care.
          previousPromise ? previousPromise.then(
            callInvokeWithMethodAndArg,
            // Avoid propagating failures to Promises returned by later
            // invocations of the iterator.
            callInvokeWithMethodAndArg
          ) : callInvokeWithMethodAndArg();
      }
  
      // Define the unified helper method that is used to implement .next,
      // .throw, and .return (see defineIteratorMethods).
      this._invoke = enqueue;
    }
  
    defineIteratorMethods(AsyncIterator.prototype);
    AsyncIterator.prototype[asyncIteratorSymbol] = function () {
      return this;
    };
    exports.AsyncIterator = AsyncIterator;
  
    // Note that simple async functions are implemented on top of
    // AsyncIterator objects; they just return a Promise for the value of
    // the final result produced by the iterator.
    exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
      if (PromiseImpl === void 0) PromiseImpl = Promise;
  
      var iter = new AsyncIterator(
        wrap(innerFn, outerFn, self, tryLocsList),
        PromiseImpl
      );
  
      return exports.isGeneratorFunction(outerFn)
        ? iter // If outerFn is a generator, return the full iterator.
        : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
          });
    };
  
    function makeInvokeMethod(innerFn, self, context) {
      var state = GenStateSuspendedStart;
  
      return function invoke(method, arg) {
        if (state === GenStateExecuting) {
          throw new Error("Generator is already running");
        }
  
        if (state === GenStateCompleted) {
          if (method === "throw") {
            throw arg;
          }
  
          // Be forgiving, per 25.3.3.3.3 of the spec:
          // https://people.mozilla.org/~jorendorff/es6-draft.html#sec-generatorresume
          return doneResult();
        }
  
        context.method = method;
        context.arg = arg;
  
        while (true) {
          var delegate = context.delegate;
          if (delegate) {
            var delegateResult = maybeInvokeDelegate(delegate, context);
            if (delegateResult) {
              if (delegateResult === ContinueSentinel) continue;
              return delegateResult;
            }
          }
  
          if (context.method === "next") {
            // Setting context._sent for legacy support of Babel's
            // function.sent implementation.
            context.sent = context._sent = context.arg;
  
          } else if (context.method === "throw") {
            if (state === GenStateSuspendedStart) {
              state = GenStateCompleted;
              throw context.arg;
            }
  
            context.dispatchException(context.arg);
  
          } else if (context.method === "return") {
            context.abrupt("return", context.arg);
          }
  
          state = GenStateExecuting;
  
          var record = tryCatch(innerFn, self, context);
          if (record.type === "normal") {
            // If an exception is thrown from innerFn, we leave state ===
            // GenStateExecuting and loop back for another invocation.
            state = context.done
              ? GenStateCompleted
              : GenStateSuspendedYield;
  
            if (record.arg === ContinueSentinel) {
              continue;
            }
  
            return {
              value: record.arg,
              done: context.done
            };
  
          } else if (record.type === "throw") {
            state = GenStateCompleted;
            // Dispatch the exception by looping back around to the
            // context.dispatchException(context.arg) call above.
            context.method = "throw";
            context.arg = record.arg;
          }
        }
      };
    }
  
    // Call delegate.iterator[context.method](context.arg) and handle the
    // result, either by returning a { value, done } result from the
    // delegate iterator, or by modifying context.method and context.arg,
    // setting context.delegate to null, and returning the ContinueSentinel.
    function maybeInvokeDelegate(delegate, context) {
      var method = delegate.iterator[context.method];
      if (method === undefined) {
        // A .throw or .return when the delegate iterator has no .throw
        // method always terminates the yield* loop.
        context.delegate = null;
  
        if (context.method === "throw") {
          // Note: ["return"] must be used for ES3 parsing compatibility.
          if (delegate.iterator["return"]) {
            // If the delegate iterator has a return method, give it a
            // chance to clean up.
            context.method = "return";
            context.arg = undefined;
            maybeInvokeDelegate(delegate, context);
  
            if (context.method === "throw") {
              // If maybeInvokeDelegate(context) changed context.method from
              // "return" to "throw", let that override the TypeError below.
              return ContinueSentinel;
            }
          }
  
          context.method = "throw";
          context.arg = new TypeError(
            "The iterator does not provide a 'throw' method");
        }
  
        return ContinueSentinel;
      }
  
      var record = tryCatch(method, delegate.iterator, context.arg);
  
      if (record.type === "throw") {
        context.method = "throw";
        context.arg = record.arg;
        context.delegate = null;
        return ContinueSentinel;
      }
  
      var info = record.arg;
  
      if (! info) {
        context.method = "throw";
        context.arg = new TypeError("iterator result is not an object");
        context.delegate = null;
        return ContinueSentinel;
      }
  
      if (info.done) {
        // Assign the result of the finished delegate to the temporary
        // variable specified by delegate.resultName (see delegateYield).
        context[delegate.resultName] = info.value;
  
        // Resume execution at the desired location (see delegateYield).
        context.next = delegate.nextLoc;
  
        // If context.method was "throw" but the delegate handled the
        // exception, let the outer generator proceed normally. If
        // context.method was "next", forget context.arg since it has been
        // "consumed" by the delegate iterator. If context.method was
        // "return", allow the original .return call to continue in the
        // outer generator.
        if (context.method !== "return") {
          context.method = "next";
          context.arg = undefined;
        }
  
      } else {
        // Re-yield the result returned by the delegate method.
        return info;
      }
  
      // The delegate iterator is finished, so forget it and continue with
      // the outer generator.
      context.delegate = null;
      return ContinueSentinel;
    }
  
    // Define Generator.prototype.{next,throw,return} in terms of the
    // unified ._invoke helper method.
    defineIteratorMethods(Gp);
  
    define(Gp, toStringTagSymbol, "Generator");
  
    // A Generator should always return itself as the iterator object when the
    // @@iterator function is called on it. Some browsers' implementations of the
    // iterator prototype chain incorrectly implement this, causing the Generator
    // object to not be returned from this call. This ensures that doesn't happen.
    // See https://github.com/facebook/regenerator/issues/274 for more details.
    Gp[iteratorSymbol] = function() {
      return this;
    };
  
    Gp.toString = function() {
      return "[object Generator]";
    };
  
    function pushTryEntry(locs) {
      var entry = { tryLoc: locs[0] };
  
      if (1 in locs) {
        entry.catchLoc = locs[1];
      }
  
      if (2 in locs) {
        entry.finallyLoc = locs[2];
        entry.afterLoc = locs[3];
      }
  
      this.tryEntries.push(entry);
    }
  
    function resetTryEntry(entry) {
      var record = entry.completion || {};
      record.type = "normal";
      delete record.arg;
      entry.completion = record;
    }
  
    function Context(tryLocsList) {
      // The root entry object (effectively a try statement without a catch
      // or a finally block) gives us a place to store values thrown from
      // locations where there is no enclosing try statement.
      this.tryEntries = [{ tryLoc: "root" }];
      tryLocsList.forEach(pushTryEntry, this);
      this.reset(true);
    }
  
    exports.keys = function(object) {
      var keys = [];
      for (var key in object) {
        keys.push(key);
      }
      keys.reverse();
  
      // Rather than returning an object with a next method, we keep
      // things simple and return the next function itself.
      return function next() {
        while (keys.length) {
          var key = keys.pop();
          if (key in object) {
            next.value = key;
            next.done = false;
            return next;
          }
        }
  
        // To avoid creating an additional object, we just hang the .value
        // and .done properties off the next function object itself. This
        // also ensures that the minifier will not anonymize the function.
        next.done = true;
        return next;
      };
    };
  
    function values(iterable) {
      if (iterable) {
        var iteratorMethod = iterable[iteratorSymbol];
        if (iteratorMethod) {
          return iteratorMethod.call(iterable);
        }
  
        if (typeof iterable.next === "function") {
          return iterable;
        }
  
        if (!isNaN(iterable.length)) {
          var i = -1, next = function next() {
            while (++i < iterable.length) {
              if (hasOwn.call(iterable, i)) {
                next.value = iterable[i];
                next.done = false;
                return next;
              }
            }
  
            next.value = undefined;
            next.done = true;
  
            return next;
          };
  
          return next.next = next;
        }
      }
  
      // Return an iterator with no values.
      return { next: doneResult };
    }
    exports.values = values;
  
    function doneResult() {
      return { value: undefined, done: true };
    }
  
    Context.prototype = {
      constructor: Context,
  
      reset: function(skipTempReset) {
        this.prev = 0;
        this.next = 0;
        // Resetting context._sent for legacy support of Babel's
        // function.sent implementation.
        this.sent = this._sent = undefined;
        this.done = false;
        this.delegate = null;
  
        this.method = "next";
        this.arg = undefined;
  
        this.tryEntries.forEach(resetTryEntry);
  
        if (!skipTempReset) {
          for (var name in this) {
            // Not sure about the optimal order of these conditions:
            if (name.charAt(0) === "t" &&
                hasOwn.call(this, name) &&
                !isNaN(+name.slice(1))) {
              this[name] = undefined;
            }
          }
        }
      },
  
      stop: function() {
        this.done = true;
  
        var rootEntry = this.tryEntries[0];
        var rootRecord = rootEntry.completion;
        if (rootRecord.type === "throw") {
          throw rootRecord.arg;
        }
  
        return this.rval;
      },
  
      dispatchException: function(exception) {
        if (this.done) {
          throw exception;
        }
  
        var context = this;
        function handle(loc, caught) {
          record.type = "throw";
          record.arg = exception;
          context.next = loc;
  
          if (caught) {
            // If the dispatched exception was caught by a catch block,
            // then let that catch block handle the exception normally.
            context.method = "next";
            context.arg = undefined;
          }
  
          return !! caught;
        }
  
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          var record = entry.completion;
  
          if (entry.tryLoc === "root") {
            // Exception thrown outside of any try block that could handle
            // it, so set the completion value of the entire function to
            // throw the exception.
            return handle("end");
          }
  
          if (entry.tryLoc <= this.prev) {
            var hasCatch = hasOwn.call(entry, "catchLoc");
            var hasFinally = hasOwn.call(entry, "finallyLoc");
  
            if (hasCatch && hasFinally) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              } else if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
  
            } else if (hasCatch) {
              if (this.prev < entry.catchLoc) {
                return handle(entry.catchLoc, true);
              }
  
            } else if (hasFinally) {
              if (this.prev < entry.finallyLoc) {
                return handle(entry.finallyLoc);
              }
  
            } else {
              throw new Error("try statement without catch or finally");
            }
          }
        }
      },
  
      abrupt: function(type, arg) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc <= this.prev &&
              hasOwn.call(entry, "finallyLoc") &&
              this.prev < entry.finallyLoc) {
            var finallyEntry = entry;
            break;
          }
        }
  
        if (finallyEntry &&
            (type === "break" ||
             type === "continue") &&
            finallyEntry.tryLoc <= arg &&
            arg <= finallyEntry.finallyLoc) {
          // Ignore the finally entry if control is not jumping to a
          // location outside the try/catch block.
          finallyEntry = null;
        }
  
        var record = finallyEntry ? finallyEntry.completion : {};
        record.type = type;
        record.arg = arg;
  
        if (finallyEntry) {
          this.method = "next";
          this.next = finallyEntry.finallyLoc;
          return ContinueSentinel;
        }
  
        return this.complete(record);
      },
  
      complete: function(record, afterLoc) {
        if (record.type === "throw") {
          throw record.arg;
        }
  
        if (record.type === "break" ||
            record.type === "continue") {
          this.next = record.arg;
        } else if (record.type === "return") {
          this.rval = this.arg = record.arg;
          this.method = "return";
          this.next = "end";
        } else if (record.type === "normal" && afterLoc) {
          this.next = afterLoc;
        }
  
        return ContinueSentinel;
      },
  
      finish: function(finallyLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.finallyLoc === finallyLoc) {
            this.complete(entry.completion, entry.afterLoc);
            resetTryEntry(entry);
            return ContinueSentinel;
          }
        }
      },
  
      "catch": function(tryLoc) {
        for (var i = this.tryEntries.length - 1; i >= 0; --i) {
          var entry = this.tryEntries[i];
          if (entry.tryLoc === tryLoc) {
            var record = entry.completion;
            if (record.type === "throw") {
              var thrown = record.arg;
              resetTryEntry(entry);
            }
            return thrown;
          }
        }
  
        // The context.catch method must only be called with a location
        // argument that corresponds to a known catch block.
        throw new Error("illegal catch attempt");
      },
  
      delegateYield: function(iterable, resultName, nextLoc) {
        this.delegate = {
          iterator: values(iterable),
          resultName: resultName,
          nextLoc: nextLoc
        };
  
        if (this.method === "next") {
          // Deliberately forget the last sent value so that we don't
          // accidentally pass it on to the delegate.
          this.arg = undefined;
        }
  
        return ContinueSentinel;
      }
    };
  
    // Regardless of whether this script is executing as a CommonJS module
    // or not, return the runtime object so that we can declare the variable
    // regeneratorRuntime in the outer scope, which allows this module to be
    // injected easily by `bin/regenerator --include-runtime script.js`.
    return exports;
  
  }(
    // If this script is executing as a CommonJS module, use module.exports
    // as the regeneratorRuntime namespace. Otherwise create a new empty
    // object. Either way, the resulting object will be used to initialize
    // the regeneratorRuntime variable at the top of this file.
    typeof module === "object" ? module.exports : {}
  ));
  
  try {
    regeneratorRuntime = runtime;
  } catch (accidentalStrictMode) {
    // This module should not be running in strict mode, so the above
    // assignment should always work unless something is misconfigured. Just
    // in case runtime.js accidentally runs in strict mode, we can escape
    // strict mode using a global Function call. This could conceivably fail
    // if a Content Security Policy forbids using Function, but in that case
    // the proper solution is to fix the accidental strict mode problem. If
    // you've misconfigured your bundler to force strict mode and applied a
    // CSP to forbid Function, and you're not willing to fix either of those
    // problems, please detail your unique predicament in a GitHub issue.
    Function("r", "regeneratorRuntime = r")(runtime);
  }
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/requires-port/index.js":[function(require,module,exports){
  'use strict';
  
  /**
   * Check if we're required to add a port number.
   *
   * @see https://url.spec.whatwg.org/#default-port
   * @param {Number|String} port Port number we need to check
   * @param {String} protocol Protocol we need to check against.
   * @returns {Boolean} Is it a default port for the given protocol
   * @api private
   */
  module.exports = function required(port, protocol) {
    protocol = protocol.split(':')[0];
    port = +port;
  
    if (!port) return false;
  
    switch (protocol) {
      case 'http':
      case 'ws':
      return port !== 80;
  
      case 'https':
      case 'wss':
      return port !== 443;
  
      case 'ftp':
      return port !== 21;
  
      case 'gopher':
      return port !== 70;
  
      case 'file':
      return false;
    }
  
    return port !== 0;
  };
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/retry/index.js":[function(require,module,exports){
  module.exports = require('./lib/retry');
  },{"./lib/retry":"/home/ubuntu/umbrella-voice2/app/node_modules/retry/lib/retry.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/retry/lib/retry.js":[function(require,module,exports){
  var RetryOperation = require('./retry_operation');
  
  exports.operation = function(options) {
    var timeouts = exports.timeouts(options);
    return new RetryOperation(timeouts, {
        forever: options && options.forever,
        unref: options && options.unref,
        maxRetryTime: options && options.maxRetryTime
    });
  };
  
  exports.timeouts = function(options) {
    if (options instanceof Array) {
      return [].concat(options);
    }
  
    var opts = {
      retries: 10,
      factor: 2,
      minTimeout: 1 * 1000,
      maxTimeout: Infinity,
      randomize: false
    };
    for (var key in options) {
      opts[key] = options[key];
    }
  
    if (opts.minTimeout > opts.maxTimeout) {
      throw new Error('minTimeout is greater than maxTimeout');
    }
  
    var timeouts = [];
    for (var i = 0; i < opts.retries; i++) {
      timeouts.push(this.createTimeout(i, opts));
    }
  
    if (options && options.forever && !timeouts.length) {
      timeouts.push(this.createTimeout(i, opts));
    }
  
    // sort the array numerically ascending
    timeouts.sort(function(a,b) {
      return a - b;
    });
  
    return timeouts;
  };
  
  exports.createTimeout = function(attempt, opts) {
    var random = (opts.randomize)
      ? (Math.random() + 1)
      : 1;
  
    var timeout = Math.round(random * opts.minTimeout * Math.pow(opts.factor, attempt));
    timeout = Math.min(timeout, opts.maxTimeout);
  
    return timeout;
  };
  
  exports.wrap = function(obj, options, methods) {
    if (options instanceof Array) {
      methods = options;
      options = null;
    }
  
    if (!methods) {
      methods = [];
      for (var key in obj) {
        if (typeof obj[key] === 'function') {
          methods.push(key);
        }
      }
    }
  
    for (var i = 0; i < methods.length; i++) {
      var method   = methods[i];
      var original = obj[method];
  
      obj[method] = function retryWrapper(original) {
        var op       = exports.operation(options);
        var args     = Array.prototype.slice.call(arguments, 1);
        var callback = args.pop();
  
        args.push(function(err) {
          if (op.retry(err)) {
            return;
          }
          if (err) {
            arguments[0] = op.mainError();
          }
          callback.apply(this, arguments);
        });
  
        op.attempt(function() {
          original.apply(obj, args);
        });
      }.bind(obj, original);
      obj[method].options = options;
    }
  };
  
  },{"./retry_operation":"/home/ubuntu/umbrella-voice2/app/node_modules/retry/lib/retry_operation.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/retry/lib/retry_operation.js":[function(require,module,exports){
  function RetryOperation(timeouts, options) {
    // Compatibility for the old (timeouts, retryForever) signature
    if (typeof options === 'boolean') {
      options = { forever: options };
    }
  
    this._originalTimeouts = JSON.parse(JSON.stringify(timeouts));
    this._timeouts = timeouts;
    this._options = options || {};
    this._maxRetryTime = options && options.maxRetryTime || Infinity;
    this._fn = null;
    this._errors = [];
    this._attempts = 1;
    this._operationTimeout = null;
    this._operationTimeoutCb = null;
    this._timeout = null;
    this._operationStart = null;
  
    if (this._options.forever) {
      this._cachedTimeouts = this._timeouts.slice(0);
    }
  }
  module.exports = RetryOperation;
  
  RetryOperation.prototype.reset = function() {
    this._attempts = 1;
    this._timeouts = this._originalTimeouts;
  }
  
  RetryOperation.prototype.stop = function() {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
  
    this._timeouts       = [];
    this._cachedTimeouts = null;
  };
  
  RetryOperation.prototype.retry = function(err) {
    if (this._timeout) {
      clearTimeout(this._timeout);
    }
  
    if (!err) {
      return false;
    }
    var currentTime = new Date().getTime();
    if (err && currentTime - this._operationStart >= this._maxRetryTime) {
      this._errors.unshift(new Error('RetryOperation timeout occurred'));
      return false;
    }
  
    this._errors.push(err);
  
    var timeout = this._timeouts.shift();
    if (timeout === undefined) {
      if (this._cachedTimeouts) {
        // retry forever, only keep last error
        this._errors.splice(this._errors.length - 1, this._errors.length);
        this._timeouts = this._cachedTimeouts.slice(0);
        timeout = this._timeouts.shift();
      } else {
        return false;
      }
    }
  
    var self = this;
    var timer = setTimeout(function() {
      self._attempts++;
  
      if (self._operationTimeoutCb) {
        self._timeout = setTimeout(function() {
          self._operationTimeoutCb(self._attempts);
        }, self._operationTimeout);
  
        if (self._options.unref) {
            self._timeout.unref();
        }
      }
  
      self._fn(self._attempts);
    }, timeout);
  
    if (this._options.unref) {
        timer.unref();
    }
  
    return true;
  };
  
  RetryOperation.prototype.attempt = function(fn, timeoutOps) {
    this._fn = fn;
  
    if (timeoutOps) {
      if (timeoutOps.timeout) {
        this._operationTimeout = timeoutOps.timeout;
      }
      if (timeoutOps.cb) {
        this._operationTimeoutCb = timeoutOps.cb;
      }
    }
  
    var self = this;
    if (this._operationTimeoutCb) {
      this._timeout = setTimeout(function() {
        self._operationTimeoutCb();
      }, self._operationTimeout);
    }
  
    this._operationStart = new Date().getTime();
  
    this._fn(this._attempts);
  };
  
  RetryOperation.prototype.try = function(fn) {
    console.log('Using RetryOperation.try() is deprecated');
    this.attempt(fn);
  };
  
  RetryOperation.prototype.start = function(fn) {
    console.log('Using RetryOperation.start() is deprecated');
    this.attempt(fn);
  };
  
  RetryOperation.prototype.start = RetryOperation.prototype.try;
  
  RetryOperation.prototype.errors = function() {
    return this._errors;
  };
  
  RetryOperation.prototype.attempts = function() {
    return this._attempts;
  };
  
  RetryOperation.prototype.mainError = function() {
    if (this._errors.length === 0) {
      return null;
    }
  
    var counts = {};
    var mainError = null;
    var mainErrorCount = 0;
  
    for (var i = 0; i < this._errors.length; i++) {
      var error = this._errors[i];
      var message = error.message;
      var count = (counts[message] || 0) + 1;
  
      counts[message] = count;
  
      if (count >= mainErrorCount) {
        mainError = error;
        mainErrorCount = count;
      }
    }
  
    return mainError;
  };
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/sdp-transform/lib/grammar.js":[function(require,module,exports){
  var grammar = module.exports = {
    v: [{
      name: 'version',
      reg: /^(\d*)$/
    }],
    o: [{
      // o=- 20518 0 IN IP4 203.0.113.1
      // NB: sessionId will be a String in most cases because it is huge
      name: 'origin',
      reg: /^(\S*) (\d*) (\d*) (\S*) IP(\d) (\S*)/,
      names: ['username', 'sessionId', 'sessionVersion', 'netType', 'ipVer', 'address'],
      format: '%s %s %d %s IP%d %s'
    }],
    // default parsing of these only (though some of these feel outdated)
    s: [{ name: 'name' }],
    i: [{ name: 'description' }],
    u: [{ name: 'uri' }],
    e: [{ name: 'email' }],
    p: [{ name: 'phone' }],
    z: [{ name: 'timezones' }], // TODO: this one can actually be parsed properly...
    r: [{ name: 'repeats' }],   // TODO: this one can also be parsed properly
    // k: [{}], // outdated thing ignored
    t: [{
      // t=0 0
      name: 'timing',
      reg: /^(\d*) (\d*)/,
      names: ['start', 'stop'],
      format: '%d %d'
    }],
    c: [{
      // c=IN IP4 10.47.197.26
      name: 'connection',
      reg: /^IN IP(\d) (\S*)/,
      names: ['version', 'ip'],
      format: 'IN IP%d %s'
    }],
    b: [{
      // b=AS:4000
      push: 'bandwidth',
      reg: /^(TIAS|AS|CT|RR|RS):(\d*)/,
      names: ['type', 'limit'],
      format: '%s:%s'
    }],
    m: [{
      // m=video 51744 RTP/AVP 126 97 98 34 31
      // NB: special - pushes to session
      // TODO: rtp/fmtp should be filtered by the payloads found here?
      reg: /^(\w*) (\d*) ([\w/]*)(?: (.*))?/,
      names: ['type', 'port', 'protocol', 'payloads'],
      format: '%s %d %s %s'
    }],
    a: [
      {
        // a=rtpmap:110 opus/48000/2
        push: 'rtp',
        reg: /^rtpmap:(\d*) ([\w\-.]*)(?:\s*\/(\d*)(?:\s*\/(\S*))?)?/,
        names: ['payload', 'codec', 'rate', 'encoding'],
        format: function (o) {
          return (o.encoding)
            ? 'rtpmap:%d %s/%s/%s'
            : o.rate
              ? 'rtpmap:%d %s/%s'
              : 'rtpmap:%d %s';
        }
      },
      {
        // a=fmtp:108 profile-level-id=24;object=23;bitrate=64000
        // a=fmtp:111 minptime=10; useinbandfec=1
        push: 'fmtp',
        reg: /^fmtp:(\d*) ([\S| ]*)/,
        names: ['payload', 'config'],
        format: 'fmtp:%d %s'
      },
      {
        // a=control:streamid=0
        name: 'control',
        reg: /^control:(.*)/,
        format: 'control:%s'
      },
      {
        // a=rtcp:65179 IN IP4 193.84.77.194
        name: 'rtcp',
        reg: /^rtcp:(\d*)(?: (\S*) IP(\d) (\S*))?/,
        names: ['port', 'netType', 'ipVer', 'address'],
        format: function (o) {
          return (o.address != null)
            ? 'rtcp:%d %s IP%d %s'
            : 'rtcp:%d';
        }
      },
      {
        // a=rtcp-fb:98 trr-int 100
        push: 'rtcpFbTrrInt',
        reg: /^rtcp-fb:(\*|\d*) trr-int (\d*)/,
        names: ['payload', 'value'],
        format: 'rtcp-fb:%s trr-int %d'
      },
      {
        // a=rtcp-fb:98 nack rpsi
        push: 'rtcpFb',
        reg: /^rtcp-fb:(\*|\d*) ([\w-_]*)(?: ([\w-_]*))?/,
        names: ['payload', 'type', 'subtype'],
        format: function (o) {
          return (o.subtype != null)
            ? 'rtcp-fb:%s %s %s'
            : 'rtcp-fb:%s %s';
        }
      },
      {
        // a=extmap:2 urn:ietf:params:rtp-hdrext:toffset
        // a=extmap:1/recvonly URI-gps-string
        // a=extmap:3 urn:ietf:params:rtp-hdrext:encrypt urn:ietf:params:rtp-hdrext:smpte-tc 25@600/24
        push: 'ext',
        reg: /^extmap:(\d+)(?:\/(\w+))?(?: (urn:ietf:params:rtp-hdrext:encrypt))? (\S*)(?: (\S*))?/,
        names: ['value', 'direction', 'encrypt-uri', 'uri', 'config'],
        format: function (o) {
          return (
            'extmap:%d' +
            (o.direction ? '/%s' : '%v') +
            (o['encrypt-uri'] ? ' %s' : '%v') +
            ' %s' +
            (o.config ? ' %s' : '')
          );
        }
      },
      {
        // a=extmap-allow-mixed
        name: 'extmapAllowMixed',
        reg: /^(extmap-allow-mixed)/
      },
      {
        // a=crypto:1 AES_CM_128_HMAC_SHA1_80 inline:PS1uQCVeeCFCanVmcjkpPywjNWhcYD0mXXtxaVBR|2^20|1:32
        push: 'crypto',
        reg: /^crypto:(\d*) ([\w_]*) (\S*)(?: (\S*))?/,
        names: ['id', 'suite', 'config', 'sessionConfig'],
        format: function (o) {
          return (o.sessionConfig != null)
            ? 'crypto:%d %s %s %s'
            : 'crypto:%d %s %s';
        }
      },
      {
        // a=setup:actpass
        name: 'setup',
        reg: /^setup:(\w*)/,
        format: 'setup:%s'
      },
      {
        // a=connection:new
        name: 'connectionType',
        reg: /^connection:(new|existing)/,
        format: 'connection:%s'
      },
      {
        // a=mid:1
        name: 'mid',
        reg: /^mid:([^\s]*)/,
        format: 'mid:%s'
      },
      {
        // a=msid:0c8b064d-d807-43b4-b434-f92a889d8587 98178685-d409-46e0-8e16-7ef0db0db64a
        name: 'msid',
        reg: /^msid:(.*)/,
        format: 'msid:%s'
      },
      {
        // a=ptime:20
        name: 'ptime',
        reg: /^ptime:(\d*(?:\.\d*)*)/,
        format: 'ptime:%d'
      },
      {
        // a=maxptime:60
        name: 'maxptime',
        reg: /^maxptime:(\d*(?:\.\d*)*)/,
        format: 'maxptime:%d'
      },
      {
        // a=sendrecv
        name: 'direction',
        reg: /^(sendrecv|recvonly|sendonly|inactive)/
      },
      {
        // a=ice-lite
        name: 'icelite',
        reg: /^(ice-lite)/
      },
      {
        // a=ice-ufrag:F7gI
        name: 'iceUfrag',
        reg: /^ice-ufrag:(\S*)/,
        format: 'ice-ufrag:%s'
      },
      {
        // a=ice-pwd:x9cml/YzichV2+XlhiMu8g
        name: 'icePwd',
        reg: /^ice-pwd:(\S*)/,
        format: 'ice-pwd:%s'
      },
      {
        // a=fingerprint:SHA-1 00:11:22:33:44:55:66:77:88:99:AA:BB:CC:DD:EE:FF:00:11:22:33
        name: 'fingerprint',
        reg: /^fingerprint:(\S*) (\S*)/,
        names: ['type', 'hash'],
        format: 'fingerprint:%s %s'
      },
      {
        // a=candidate:0 1 UDP 2113667327 203.0.113.1 54400 typ host
        // a=candidate:1162875081 1 udp 2113937151 192.168.34.75 60017 typ host generation 0 network-id 3 network-cost 10
        // a=candidate:3289912957 2 udp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 generation 0 network-id 3 network-cost 10
        // a=candidate:229815620 1 tcp 1518280447 192.168.150.19 60017 typ host tcptype active generation 0 network-id 3 network-cost 10
        // a=candidate:3289912957 2 tcp 1845501695 193.84.77.194 60017 typ srflx raddr 192.168.34.75 rport 60017 tcptype passive generation 0 network-id 3 network-cost 10
        push:'candidates',
        reg: /^candidate:(\S*) (\d*) (\S*) (\d*) (\S*) (\d*) typ (\S*)(?: raddr (\S*) rport (\d*))?(?: tcptype (\S*))?(?: generation (\d*))?(?: network-id (\d*))?(?: network-cost (\d*))?/,
        names: ['foundation', 'component', 'transport', 'priority', 'ip', 'port', 'type', 'raddr', 'rport', 'tcptype', 'generation', 'network-id', 'network-cost'],
        format: function (o) {
          var str = 'candidate:%s %d %s %d %s %d typ %s';
  
          str += (o.raddr != null) ? ' raddr %s rport %d' : '%v%v';
  
          // NB: candidate has three optional chunks, so %void middles one if it's missing
          str += (o.tcptype != null) ? ' tcptype %s' : '%v';
  
          if (o.generation != null) {
            str += ' generation %d';
          }
  
          str += (o['network-id'] != null) ? ' network-id %d' : '%v';
          str += (o['network-cost'] != null) ? ' network-cost %d' : '%v';
          return str;
        }
      },
      {
        // a=end-of-candidates (keep after the candidates line for readability)
        name: 'endOfCandidates',
        reg: /^(end-of-candidates)/
      },
      {
        // a=remote-candidates:1 203.0.113.1 54400 2 203.0.113.1 54401 ...
        name: 'remoteCandidates',
        reg: /^remote-candidates:(.*)/,
        format: 'remote-candidates:%s'
      },
      {
        // a=ice-options:google-ice
        name: 'iceOptions',
        reg: /^ice-options:(\S*)/,
        format: 'ice-options:%s'
      },
      {
        // a=ssrc:2566107569 cname:t9YU8M1UxTF8Y1A1
        push: 'ssrcs',
        reg: /^ssrc:(\d*) ([\w_-]*)(?::(.*))?/,
        names: ['id', 'attribute', 'value'],
        format: function (o) {
          var str = 'ssrc:%d';
          if (o.attribute != null) {
            str += ' %s';
            if (o.value != null) {
              str += ':%s';
            }
          }
          return str;
        }
      },
      {
        // a=ssrc-group:FEC 1 2
        // a=ssrc-group:FEC-FR 3004364195 1080772241
        push: 'ssrcGroups',
        // token-char = %x21 / %x23-27 / %x2A-2B / %x2D-2E / %x30-39 / %x41-5A / %x5E-7E
        reg: /^ssrc-group:([\x21\x23\x24\x25\x26\x27\x2A\x2B\x2D\x2E\w]*) (.*)/,
        names: ['semantics', 'ssrcs'],
        format: 'ssrc-group:%s %s'
      },
      {
        // a=msid-semantic: WMS Jvlam5X3SX1OP6pn20zWogvaKJz5Hjf9OnlV
        name: 'msidSemantic',
        reg: /^msid-semantic:\s?(\w*) (\S*)/,
        names: ['semantic', 'token'],
        format: 'msid-semantic: %s %s' // space after ':' is not accidental
      },
      {
        // a=group:BUNDLE audio video
        push: 'groups',
        reg: /^group:(\w*) (.*)/,
        names: ['type', 'mids'],
        format: 'group:%s %s'
      },
      {
        // a=rtcp-mux
        name: 'rtcpMux',
        reg: /^(rtcp-mux)/
      },
      {
        // a=rtcp-rsize
        name: 'rtcpRsize',
        reg: /^(rtcp-rsize)/
      },
      {
        // a=sctpmap:5000 webrtc-datachannel 1024
        name: 'sctpmap',
        reg: /^sctpmap:([\w_/]*) (\S*)(?: (\S*))?/,
        names: ['sctpmapNumber', 'app', 'maxMessageSize'],
        format: function (o) {
          return (o.maxMessageSize != null)
            ? 'sctpmap:%s %s %s'
            : 'sctpmap:%s %s';
        }
      },
      {
        // a=x-google-flag:conference
        name: 'xGoogleFlag',
        reg: /^x-google-flag:([^\s]*)/,
        format: 'x-google-flag:%s'
      },
      {
        // a=rid:1 send max-width=1280;max-height=720;max-fps=30;depend=0
        push: 'rids',
        reg: /^rid:([\d\w]+) (\w+)(?: ([\S| ]*))?/,
        names: ['id', 'direction', 'params'],
        format: function (o) {
          return (o.params) ? 'rid:%s %s %s' : 'rid:%s %s';
        }
      },
      {
        // a=imageattr:97 send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320] recv [x=330,y=250]
        // a=imageattr:* send [x=800,y=640] recv *
        // a=imageattr:100 recv [x=320,y=240]
        push: 'imageattrs',
        reg: new RegExp(
          // a=imageattr:97
          '^imageattr:(\\d+|\\*)' +
          // send [x=800,y=640,sar=1.1,q=0.6] [x=480,y=320]
          '[\\s\\t]+(send|recv)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*)' +
          // recv [x=330,y=250]
          '(?:[\\s\\t]+(recv|send)[\\s\\t]+(\\*|\\[\\S+\\](?:[\\s\\t]+\\[\\S+\\])*))?'
        ),
        names: ['pt', 'dir1', 'attrs1', 'dir2', 'attrs2'],
        format: function (o) {
          return 'imageattr:%s %s %s' + (o.dir2 ? ' %s %s' : '');
        }
      },
      {
        // a=simulcast:send 1,2,3;~4,~5 recv 6;~7,~8
        // a=simulcast:recv 1;4,5 send 6;7
        name: 'simulcast',
        reg: new RegExp(
          // a=simulcast:
          '^simulcast:' +
          // send 1,2,3;~4,~5
          '(send|recv) ([a-zA-Z0-9\\-_~;,]+)' +
          // space + recv 6;~7,~8
          '(?:\\s?(send|recv) ([a-zA-Z0-9\\-_~;,]+))?' +
          // end
          '$'
        ),
        names: ['dir1', 'list1', 'dir2', 'list2'],
        format: function (o) {
          return 'simulcast:%s %s' + (o.dir2 ? ' %s %s' : '');
        }
      },
      {
        // old simulcast draft 03 (implemented by Firefox)
        //   https://tools.ietf.org/html/draft-ietf-mmusic-sdp-simulcast-03
        // a=simulcast: recv pt=97;98 send pt=97
        // a=simulcast: send rid=5;6;7 paused=6,7
        name: 'simulcast_03',
        reg: /^simulcast:[\s\t]+([\S+\s\t]+)$/,
        names: ['value'],
        format: 'simulcast: %s'
      },
      {
        // a=framerate:25
        // a=framerate:29.97
        name: 'framerate',
        reg: /^framerate:(\d+(?:$|\.\d+))/,
        format: 'framerate:%s'
      },
      {
        // RFC4570
        // a=source-filter: incl IN IP4 239.5.2.31 10.1.15.5
        name: 'sourceFilter',
        reg: /^source-filter: *(excl|incl) (\S*) (IP4|IP6|\*) (\S*) (.*)/,
        names: ['filterMode', 'netType', 'addressTypes', 'destAddress', 'srcList'],
        format: 'source-filter: %s %s %s %s %s'
      },
      {
        // a=bundle-only
        name: 'bundleOnly',
        reg: /^(bundle-only)/
      },
      {
        // a=label:1
        name: 'label',
        reg: /^label:(.+)/,
        format: 'label:%s'
      },
      {
        // RFC version 26 for SCTP over DTLS
        // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-5
        name: 'sctpPort',
        reg: /^sctp-port:(\d+)$/,
        format: 'sctp-port:%s'
      },
      {
        // RFC version 26 for SCTP over DTLS
        // https://tools.ietf.org/html/draft-ietf-mmusic-sctp-sdp-26#section-6
        name: 'maxMessageSize',
        reg: /^max-message-size:(\d+)$/,
        format: 'max-message-size:%s'
      },
      {
        // RFC7273
        // a=ts-refclk:ptp=IEEE1588-2008:39-A7-94-FF-FE-07-CB-D0:37
        push:'tsRefClocks',
        reg: /^ts-refclk:([^\s=]*)(?:=(\S*))?/,
        names: ['clksrc', 'clksrcExt'],
        format: function (o) {
          return 'ts-refclk:%s' + (o.clksrcExt != null ? '=%s' : '');
        }
      },
      {
        // RFC7273
        // a=mediaclk:direct=963214424
        name:'mediaClk',
        reg: /^mediaclk:(?:id=(\S*))? *([^\s=]*)(?:=(\S*))?(?: *rate=(\d+)\/(\d+))?/,
        names: ['id', 'mediaClockName', 'mediaClockValue', 'rateNumerator', 'rateDenominator'],
        format: function (o) {
          var str = 'mediaclk:';
          str += (o.id != null ? 'id=%s %s' : '%v%s');
          str += (o.mediaClockValue != null ? '=%s' : '');
          str += (o.rateNumerator != null ? ' rate=%s' : '');
          str += (o.rateDenominator != null ? '/%s' : '');
          return str;
        }
      },
      {
        // a=keywds:keywords
        name: 'keywords',
        reg: /^keywds:(.+)$/,
        format: 'keywds:%s'
      },
      {
        // a=content:main
        name: 'content',
        reg: /^content:(.+)/,
        format: 'content:%s'
      },
      // BFCP https://tools.ietf.org/html/rfc4583
      {
        // a=floorctrl:c-s
        name: 'bfcpFloorCtrl',
        reg: /^floorctrl:(c-only|s-only|c-s)/,
        format: 'floorctrl:%s'
      },
      {
        // a=confid:1
        name: 'bfcpConfId',
        reg: /^confid:(\d+)/,
        format: 'confid:%s'
      },
      {
        // a=userid:1
        name: 'bfcpUserId',
        reg: /^userid:(\d+)/,
        format: 'userid:%s'
      },
      {
        // a=floorid:1
        name: 'bfcpFloorId',
        reg: /^floorid:(.+) (?:m-stream|mstrm):(.+)/,
        names: ['id', 'mStream'],
        format: 'floorid:%s mstrm:%s'
      },
      {
        // any a= that we don't understand is kept verbatim on media.invalid
        push: 'invalid',
        names: ['value']
      }
    ]
  };
  
  // set sensible defaults to avoid polluting the grammar with boring details
  Object.keys(grammar).forEach(function (key) {
    var objs = grammar[key];
    objs.forEach(function (obj) {
      if (!obj.reg) {
        obj.reg = /(.*)/;
      }
      if (!obj.format) {
        obj.format = '%s';
      }
    });
  });
  
  },{}],"/home/ubuntu/umbrella-voice2/app/node_modules/sdp-transform/lib/index.js":[function(require,module,exports){
  var parser = require('./parser');
  var writer = require('./writer');
  
  exports.write = writer;
  exports.parse = parser.parse;
  exports.parseParams = parser.parseParams;
  exports.parseFmtpConfig = parser.parseFmtpConfig; // Alias of parseParams().
  exports.parsePayloads = parser.parsePayloads;
  exports.parseRemoteCandidates = parser.parseRemoteCandidates;
  exports.parseImageAttributes = parser.parseImageAttributes;
  exports.parseSimulcastStreamList = parser.parseSimulcastStreamList;
  
  },{"./parser":"/home/ubuntu/umbrella-voice2/app/node_modules/sdp-transform/lib/parser.js","./writer":"/home/ubuntu/umbrella-voice2/app/node_modules/sdp-transform/lib/writer.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/sdp-transform/lib/parser.js":[function(require,module,exports){
  var toIntIfInt = function (v) {
    return String(Number(v)) === v ? Number(v) : v;
  };
  
  var attachProperties = function (match, location, names, rawName) {
    if (rawName && !names) {
      location[rawName] = toIntIfInt(match[1]);
    }
    else {
      for (var i = 0; i < names.length; i += 1) {
        if (match[i+1] != null) {
          location[names[i]] = toIntIfInt(match[i+1]);
        }
      }
    }
  };
  
  var parseReg = function (obj, location, content) {
    var needsBlank = obj.name && obj.names;
    if (obj.push && !location[obj.push]) {
      location[obj.push] = [];
    }
    else if (needsBlank && !location[obj.name]) {
      location[obj.name] = {};
    }
    var keyLocation = obj.push ?
      {} :  // blank object that will be pushed
      needsBlank ? location[obj.name] : location; // otherwise, named location or root
  
    attachProperties(content.match(obj.reg), keyLocation, obj.names, obj.name);
  
    if (obj.push) {
      location[obj.push].push(keyLocation);
    }
  };
  
  var grammar = require('./grammar');
  var validLine = RegExp.prototype.test.bind(/^([a-z])=(.*)/);
  
  exports.parse = function (sdp) {
    var session = {}
      , media = []
      , location = session; // points at where properties go under (one of the above)
  
    // parse lines we understand
    sdp.split(/(\r\n|\r|\n)/).filter(validLine).forEach(function (l) {
      var type = l[0];
      var content = l.slice(2);
      if (type === 'm') {
        media.push({rtp: [], fmtp: []});
        location = media[media.length-1]; // point at latest media line
      }
  
      for (var j = 0; j < (grammar[type] || []).length; j += 1) {
        var obj = grammar[type][j];
        if (obj.reg.test(content)) {
          return parseReg(obj, location, content);
        }
      }
    });
  
    session.media = media; // link it up
    return session;
  };
  
  var paramReducer = function (acc, expr) {
    var s = expr.split(/=(.+)/, 2);
    if (s.length === 2) {
      acc[s[0]] = toIntIfInt(s[1]);
    } else if (s.length === 1 && expr.length > 1) {
      acc[s[0]] = undefined;
    }
    return acc;
  };
  
  exports.parseParams = function (str) {
    return str.split(/;\s?/).reduce(paramReducer, {});
  };
  
  // For backward compatibility - alias will be removed in 3.0.0
  exports.parseFmtpConfig = exports.parseParams;
  
  exports.parsePayloads = function (str) {
    return str.toString().split(' ').map(Number);
  };
  
  exports.parseRemoteCandidates = function (str) {
    var candidates = [];
    var parts = str.split(' ').map(toIntIfInt);
    for (var i = 0; i < parts.length; i += 3) {
      candidates.push({
        component: parts[i],
        ip: parts[i + 1],
        port: parts[i + 2]
      });
    }
    return candidates;
  };
  
  exports.parseImageAttributes = function (str) {
    return str.split(' ').map(function (item) {
      return item.substring(1, item.length-1).split(',').reduce(paramReducer, {});
    });
  };
  
  exports.parseSimulcastStreamList = function (str) {
    return str.split(';').map(function (stream) {
      return stream.split(',').map(function (format) {
        var scid, paused = false;
  
        if (format[0] !== '~') {
          scid = toIntIfInt(format);
        } else {
          scid = toIntIfInt(format.substring(1, format.length));
          paused = true;
        }
  
        return {
          scid: scid,
          paused: paused
        };
      });
    });
  };
  
  },{"./grammar":"/home/ubuntu/umbrella-voice2/app/node_modules/sdp-transform/lib/grammar.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/sdp-transform/lib/writer.js":[function(require,module,exports){
  var grammar = require('./grammar');
  
  // customized util.format - discards excess arguments and can void middle ones
  var formatRegExp = /%[sdv%]/g;
  var format = function (formatStr) {
    var i = 1;
    var args = arguments;
    var len = args.length;
    return formatStr.replace(formatRegExp, function (x) {
      if (i >= len) {
        return x; // missing argument
      }
      var arg = args[i];
      i += 1;
      switch (x) {
      case '%%':
        return '%';
      case '%s':
        return String(arg);
      case '%d':
        return Number(arg);
      case '%v':
        return '';
      }
    });
    // NB: we discard excess arguments - they are typically undefined from makeLine
  };
  
  var makeLine = function (type, obj, location) {
    var str = obj.format instanceof Function ?
      (obj.format(obj.push ? location : location[obj.name])) :
      obj.format;
  
    var args = [type + '=' + str];
    if (obj.names) {
      for (var i = 0; i < obj.names.length; i += 1) {
        var n = obj.names[i];
        if (obj.name) {
          args.push(location[obj.name][n]);
        }
        else { // for mLine and push attributes
          args.push(location[obj.names[i]]);
        }
      }
    }
    else {
      args.push(location[obj.name]);
    }
    return format.apply(null, args);
  };
  
  // RFC specified order
  // TODO: extend this with all the rest
  var defaultOuterOrder = [
    'v', 'o', 's', 'i',
    'u', 'e', 'p', 'c',
    'b', 't', 'r', 'z', 'a'
  ];
  var defaultInnerOrder = ['i', 'c', 'b', 'a'];
  
  
  module.exports = function (session, opts) {
    opts = opts || {};
    // ensure certain properties exist
    if (session.version == null) {
      session.version = 0; // 'v=0' must be there (only defined version atm)
    }
    if (session.name == null) {
      session.name = ' '; // 's= ' must be there if no meaningful name set
    }
    session.media.forEach(function (mLine) {
      if (mLine.payloads == null) {
        mLine.payloads = '';
      }
    });
  
    var outerOrder = opts.outerOrder || defaultOuterOrder;
    var innerOrder = opts.innerOrder || defaultInnerOrder;
    var sdp = [];
  
    // loop through outerOrder for matching properties on session
    outerOrder.forEach(function (type) {
      grammar[type].forEach(function (obj) {
        if (obj.name in session && session[obj.name] != null) {
          sdp.push(makeLine(type, obj, session));
        }
        else if (obj.push in session && session[obj.push] != null) {
          session[obj.push].forEach(function (el) {
            sdp.push(makeLine(type, obj, el));
          });
        }
      });
    });
  
    // then for each media line, follow the innerOrder
    session.media.forEach(function (mLine) {
      sdp.push(makeLine('m', grammar.m[0], mLine));
  
      innerOrder.forEach(function (type) {
        grammar[type].forEach(function (obj) {
          if (obj.name in mLine && mLine[obj.name] != null) {
            sdp.push(makeLine(type, obj, mLine));
          }
          else if (obj.push in mLine && mLine[obj.push] != null) {
            mLine[obj.push].forEach(function (el) {
              sdp.push(makeLine(type, obj, el));
            });
          }
        });
      });
    });
  
    return sdp.join('\r\n') + '\r\n';
  };
  
  },{"./grammar":"/home/ubuntu/umbrella-voice2/app/node_modules/sdp-transform/lib/grammar.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/url-parse/index.js":[function(require,module,exports){
  (function (global){(function (){
  'use strict';
  
  var required = require('requires-port')
    , qs = require('querystringify')
    , slashes = /^[A-Za-z][A-Za-z0-9+-.]*:[\\/]+/
    , protocolre = /^([a-z][a-z0-9.+-]*:)?([\\/]{1,})?([\S\s]*)/i
    , whitespace = '[\\x09\\x0A\\x0B\\x0C\\x0D\\x20\\xA0\\u1680\\u180E\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200A\\u202F\\u205F\\u3000\\u2028\\u2029\\uFEFF]'
    , left = new RegExp('^'+ whitespace +'+');
  
  /**
   * Trim a given string.
   *
   * @param {String} str String to trim.
   * @public
   */
  function trimLeft(str) {
    return (str ? str : '').toString().replace(left, '');
  }
  
  /**
   * These are the parse rules for the URL parser, it informs the parser
   * about:
   *
   * 0. The char it Needs to parse, if it's a string it should be done using
   *    indexOf, RegExp using exec and NaN means set as current value.
   * 1. The property we should set when parsing this value.
   * 2. Indication if it's backwards or forward parsing, when set as number it's
   *    the value of extra chars that should be split off.
   * 3. Inherit from location if non existing in the parser.
   * 4. `toLowerCase` the resulting value.
   */
  var rules = [
    ['#', 'hash'],                        // Extract from the back.
    ['?', 'query'],                       // Extract from the back.
    function sanitize(address) {          // Sanitize what is left of the address
      return address.replace('\\', '/');
    },
    ['/', 'pathname'],                    // Extract from the back.
    ['@', 'auth', 1],                     // Extract from the front.
    [NaN, 'host', undefined, 1, 1],       // Set left over value.
    [/:(\d+)$/, 'port', undefined, 1],    // RegExp the back.
    [NaN, 'hostname', undefined, 1, 1]    // Set left over.
  ];
  
  /**
   * These properties should not be copied or inherited from. This is only needed
   * for all non blob URL's as a blob URL does not include a hash, only the
   * origin.
   *
   * @type {Object}
   * @private
   */
  var ignore = { hash: 1, query: 1 };
  
  /**
   * The location object differs when your code is loaded through a normal page,
   * Worker or through a worker using a blob. And with the blobble begins the
   * trouble as the location object will contain the URL of the blob, not the
   * location of the page where our code is loaded in. The actual origin is
   * encoded in the `pathname` so we can thankfully generate a good "default"
   * location from it so we can generate proper relative URL's again.
   *
   * @param {Object|String} loc Optional default location object.
   * @returns {Object} lolcation object.
   * @public
   */
  function lolcation(loc) {
    var globalVar;
  
    if (typeof window !== 'undefined') globalVar = window;
    else if (typeof global !== 'undefined') globalVar = global;
    else if (typeof self !== 'undefined') globalVar = self;
    else globalVar = {};
  
    var location = globalVar.location || {};
    loc = loc || location;
  
    var finaldestination = {}
      , type = typeof loc
      , key;
  
    if ('blob:' === loc.protocol) {
      finaldestination = new Url(unescape(loc.pathname), {});
    } else if ('string' === type) {
      finaldestination = new Url(loc, {});
      for (key in ignore) delete finaldestination[key];
    } else if ('object' === type) {
      for (key in loc) {
        if (key in ignore) continue;
        finaldestination[key] = loc[key];
      }
  
      if (finaldestination.slashes === undefined) {
        finaldestination.slashes = slashes.test(loc.href);
      }
    }
  
    return finaldestination;
  }
  
  /**
   * @typedef ProtocolExtract
   * @type Object
   * @property {String} protocol Protocol matched in the URL, in lowercase.
   * @property {Boolean} slashes `true` if protocol is followed by "//", else `false`.
   * @property {String} rest Rest of the URL that is not part of the protocol.
   */
  
  /**
   * Extract protocol information from a URL with/without double slash ("//").
   *
   * @param {String} address URL we want to extract from.
   * @return {ProtocolExtract} Extracted information.
   * @private
   */
  function extractProtocol(address) {
    address = trimLeft(address);
  
    var match = protocolre.exec(address)
      , protocol = match[1] ? match[1].toLowerCase() : ''
      , slashes = !!(match[2] && match[2].length >= 2)
      , rest =  match[2] && match[2].length === 1 ? '/' + match[3] : match[3];
  
    return {
      protocol: protocol,
      slashes: slashes,
      rest: rest
    };
  }
  
  /**
   * Resolve a relative URL pathname against a base URL pathname.
   *
   * @param {String} relative Pathname of the relative URL.
   * @param {String} base Pathname of the base URL.
   * @return {String} Resolved pathname.
   * @private
   */
  function resolve(relative, base) {
    if (relative === '') return base;
  
    var path = (base || '/').split('/').slice(0, -1).concat(relative.split('/'))
      , i = path.length
      , last = path[i - 1]
      , unshift = false
      , up = 0;
  
    while (i--) {
      if (path[i] === '.') {
        path.splice(i, 1);
      } else if (path[i] === '..') {
        path.splice(i, 1);
        up++;
      } else if (up) {
        if (i === 0) unshift = true;
        path.splice(i, 1);
        up--;
      }
    }
  
    if (unshift) path.unshift('');
    if (last === '.' || last === '..') path.push('');
  
    return path.join('/');
  }
  
  /**
   * The actual URL instance. Instead of returning an object we've opted-in to
   * create an actual constructor as it's much more memory efficient and
   * faster and it pleases my OCD.
   *
   * It is worth noting that we should not use `URL` as class name to prevent
   * clashes with the global URL instance that got introduced in browsers.
   *
   * @constructor
   * @param {String} address URL we want to parse.
   * @param {Object|String} [location] Location defaults for relative paths.
   * @param {Boolean|Function} [parser] Parser for the query string.
   * @private
   */
  function Url(address, location, parser) {
    address = trimLeft(address);
  
    if (!(this instanceof Url)) {
      return new Url(address, location, parser);
    }
  
    var relative, extracted, parse, instruction, index, key
      , instructions = rules.slice()
      , type = typeof location
      , url = this
      , i = 0;
  
    //
    // The following if statements allows this module two have compatibility with
    // 2 different API:
    //
    // 1. Node.js's `url.parse` api which accepts a URL, boolean as arguments
    //    where the boolean indicates that the query string should also be parsed.
    //
    // 2. The `URL` interface of the browser which accepts a URL, object as
    //    arguments. The supplied object will be used as default values / fall-back
    //    for relative paths.
    //
    if ('object' !== type && 'string' !== type) {
      parser = location;
      location = null;
    }
  
    if (parser && 'function' !== typeof parser) parser = qs.parse;
  
    location = lolcation(location);
  
    //
    // Extract protocol information before running the instructions.
    //
    extracted = extractProtocol(address || '');
    relative = !extracted.protocol && !extracted.slashes;
    url.slashes = extracted.slashes || relative && location.slashes;
    url.protocol = extracted.protocol || location.protocol || '';
    address = extracted.rest;
  
    //
    // When the authority component is absent the URL starts with a path
    // component.
    //
    if (!extracted.slashes) instructions[3] = [/(.*)/, 'pathname'];
  
    for (; i < instructions.length; i++) {
      instruction = instructions[i];
  
      if (typeof instruction === 'function') {
        address = instruction(address);
        continue;
      }
  
      parse = instruction[0];
      key = instruction[1];
  
      if (parse !== parse) {
        url[key] = address;
      } else if ('string' === typeof parse) {
        if (~(index = address.indexOf(parse))) {
          if ('number' === typeof instruction[2]) {
            url[key] = address.slice(0, index);
            address = address.slice(index + instruction[2]);
          } else {
            url[key] = address.slice(index);
            address = address.slice(0, index);
          }
        }
      } else if ((index = parse.exec(address))) {
        url[key] = index[1];
        address = address.slice(0, index.index);
      }
  
      url[key] = url[key] || (
        relative && instruction[3] ? location[key] || '' : ''
      );
  
      //
      // Hostname, host and protocol should be lowercased so they can be used to
      // create a proper `origin`.
      //
      if (instruction[4]) url[key] = url[key].toLowerCase();
    }
  
    //
    // Also parse the supplied query string in to an object. If we're supplied
    // with a custom parser as function use that instead of the default build-in
    // parser.
    //
    if (parser) url.query = parser(url.query);
  
    //
    // If the URL is relative, resolve the pathname against the base URL.
    //
    if (
        relative
      && location.slashes
      && url.pathname.charAt(0) !== '/'
      && (url.pathname !== '' || location.pathname !== '')
    ) {
      url.pathname = resolve(url.pathname, location.pathname);
    }
  
    //
    // Default to a / for pathname if none exists. This normalizes the URL
    // to always have a /
    //
    if (url.pathname.charAt(0) !== '/' && url.hostname) {
      url.pathname = '/' + url.pathname;
    }
  
    //
    // We should not add port numbers if they are already the default port number
    // for a given protocol. As the host also contains the port number we're going
    // override it with the hostname which contains no port number.
    //
    if (!required(url.port, url.protocol)) {
      url.host = url.hostname;
      url.port = '';
    }
  
    //
    // Parse down the `auth` for the username and password.
    //
    url.username = url.password = '';
    if (url.auth) {
      instruction = url.auth.split(':');
      url.username = instruction[0] || '';
      url.password = instruction[1] || '';
    }
  
    url.origin = url.protocol && url.host && url.protocol !== 'file:'
      ? url.protocol +'//'+ url.host
      : 'null';
  
    //
    // The href is just the compiled result.
    //
    url.href = url.toString();
  }
  
  /**
   * This is convenience method for changing properties in the URL instance to
   * insure that they all propagate correctly.
   *
   * @param {String} part          Property we need to adjust.
   * @param {Mixed} value          The newly assigned value.
   * @param {Boolean|Function} fn  When setting the query, it will be the function
   *                               used to parse the query.
   *                               When setting the protocol, double slash will be
   *                               removed from the final url if it is true.
   * @returns {URL} URL instance for chaining.
   * @public
   */
  function set(part, value, fn) {
    var url = this;
  
    switch (part) {
      case 'query':
        if ('string' === typeof value && value.length) {
          value = (fn || qs.parse)(value);
        }
  
        url[part] = value;
        break;
  
      case 'port':
        url[part] = value;
  
        if (!required(value, url.protocol)) {
          url.host = url.hostname;
          url[part] = '';
        } else if (value) {
          url.host = url.hostname +':'+ value;
        }
  
        break;
  
      case 'hostname':
        url[part] = value;
  
        if (url.port) value += ':'+ url.port;
        url.host = value;
        break;
  
      case 'host':
        url[part] = value;
  
        if (/:\d+$/.test(value)) {
          value = value.split(':');
          url.port = value.pop();
          url.hostname = value.join(':');
        } else {
          url.hostname = value;
          url.port = '';
        }
  
        break;
  
      case 'protocol':
        url.protocol = value.toLowerCase();
        url.slashes = !fn;
        break;
  
      case 'pathname':
      case 'hash':
        if (value) {
          var char = part === 'pathname' ? '/' : '#';
          url[part] = value.charAt(0) !== char ? char + value : value;
        } else {
          url[part] = value;
        }
        break;
  
      default:
        url[part] = value;
    }
  
    for (var i = 0; i < rules.length; i++) {
      var ins = rules[i];
  
      if (ins[4]) url[ins[1]] = url[ins[1]].toLowerCase();
    }
  
    url.origin = url.protocol && url.host && url.protocol !== 'file:'
      ? url.protocol +'//'+ url.host
      : 'null';
  
    url.href = url.toString();
  
    return url;
  }
  
  /**
   * Transform the properties back in to a valid and full URL string.
   *
   * @param {Function} stringify Optional query stringify function.
   * @returns {String} Compiled version of the URL.
   * @public
   */
  function toString(stringify) {
    if (!stringify || 'function' !== typeof stringify) stringify = qs.stringify;
  
    var query
      , url = this
      , protocol = url.protocol;
  
    if (protocol && protocol.charAt(protocol.length - 1) !== ':') protocol += ':';
  
    var result = protocol + (url.slashes ? '//' : '');
  
    if (url.username) {
      result += url.username;
      if (url.password) result += ':'+ url.password;
      result += '@';
    }
  
    result += url.host + url.pathname;
  
    query = 'object' === typeof url.query ? stringify(url.query) : url.query;
    if (query) result += '?' !== query.charAt(0) ? '?'+ query : query;
  
    if (url.hash) result += url.hash;
  
    return result;
  }
  
  Url.prototype = { set: set, toString: toString };
  
  //
  // Expose the URL parser and some additional properties that might be useful for
  // others or testing.
  //
  Url.extractProtocol = extractProtocol;
  Url.location = lolcation;
  Url.trimLeft = trimLeft;
  Url.qs = qs;
  
  module.exports = Url;
  
  }).call(this)}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
  
  },{"querystringify":"/home/ubuntu/umbrella-voice2/app/node_modules/querystringify/index.js","requires-port":"/home/ubuntu/umbrella-voice2/app/node_modules/requires-port/index.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/websocket/lib/browser.js":[function(require,module,exports){
  var _globalThis;
  if (typeof globalThis === 'object') {
    _globalThis = globalThis;
  } else {
    try {
      _globalThis = require('es5-ext/global');
    } catch (error) {
    } finally {
      if (!_globalThis && typeof window !== 'undefined') { _globalThis = window; }
      if (!_globalThis) { throw new Error('Could not determine global this'); }
    }
  }
  
  var NativeWebSocket = _globalThis.WebSocket || _globalThis.MozWebSocket;
  var websocket_version = require('./version');
  
  
  /**
   * Expose a W3C WebSocket class with just one or two arguments.
   */
  function W3CWebSocket(uri, protocols) {
    var native_instance;
  
    if (protocols) {
      native_instance = new NativeWebSocket(uri, protocols);
    }
    else {
      native_instance = new NativeWebSocket(uri);
    }
  
    /**
     * 'native_instance' is an instance of nativeWebSocket (the browser's WebSocket
     * class). Since it is an Object it will be returned as it is when creating an
     * instance of W3CWebSocket via 'new W3CWebSocket()'.
     *
     * ECMAScript 5: http://bclary.com/2004/11/07/#a-13.2.2
     */
    return native_instance;
  }
  if (NativeWebSocket) {
    ['CONNECTING', 'OPEN', 'CLOSING', 'CLOSED'].forEach(function(prop) {
      Object.defineProperty(W3CWebSocket, prop, {
        get: function() { return NativeWebSocket[prop]; }
      });
    });
  }
  
  /**
   * Module exports.
   */
  module.exports = {
      'w3cwebsocket' : NativeWebSocket ? W3CWebSocket : null,
      'version'      : websocket_version
  };
  
  },{"./version":"/home/ubuntu/umbrella-voice2/app/node_modules/websocket/lib/version.js","es5-ext/global":"/home/ubuntu/umbrella-voice2/app/node_modules/es5-ext/global.js"}],"/home/ubuntu/umbrella-voice2/app/node_modules/websocket/lib/version.js":[function(require,module,exports){
  module.exports = require('../package.json').version;
  
  },{"../package.json":"/home/ubuntu/umbrella-voice2/app/node_modules/websocket/package.json"}],"/home/ubuntu/umbrella-voice2/app/node_modules/websocket/package.json":[function(require,module,exports){
  module.exports={
    "_from": "websocket@^1.0.33",
    "_id": "websocket@1.0.34",
    "_inBundle": false,
    "_integrity": "sha512-PRDso2sGwF6kM75QykIesBijKSVceR6jL2G8NGYyq2XrItNC2P5/qL5XeR056GhA+Ly7JMFvJb9I312mJfmqnQ==",
    "_location": "/websocket",
    "_phantomChildren": {},
    "_requested": {
      "type": "range",
      "registry": true,
      "raw": "websocket@^1.0.33",
      "name": "websocket",
      "escapedName": "websocket",
      "rawSpec": "^1.0.33",
      "saveSpec": null,
      "fetchSpec": "^1.0.33"
    },
    "_requiredBy": [
      "/protoo-client"
    ],
    "_resolved": "https://registry.npmjs.org/websocket/-/websocket-1.0.34.tgz",
    "_shasum": "2bdc2602c08bf2c82253b730655c0ef7dcab3111",
    "_spec": "websocket@^1.0.33",
    "_where": "/home/ubuntu/umbrella-voice/app/node_modules/protoo-client",
    "author": {
      "name": "Brian McKelvey",
      "email": "theturtle32@gmail.com",
      "url": "https://github.com/theturtle32"
    },
    "browser": "lib/browser.js",
    "bugs": {
      "url": "https://github.com/theturtle32/WebSocket-Node/issues"
    },
    "bundleDependencies": false,
    "config": {
      "verbose": false
    },
    "contributors": [
      {
        "name": "Iñaki Baz Castillo",
        "email": "ibc@aliax.net",
        "url": "http://dev.sipdoc.net"
      }
    ],
    "dependencies": {
      "bufferutil": "^4.0.1",
      "debug": "^2.2.0",
      "es5-ext": "^0.10.50",
      "typedarray-to-buffer": "^3.1.5",
      "utf-8-validate": "^5.0.2",
      "yaeti": "^0.0.6"
    },
    "deprecated": false,
    "description": "Websocket Client & Server Library implementing the WebSocket protocol as specified in RFC 6455.",
    "devDependencies": {
      "buffer-equal": "^1.0.0",
      "gulp": "^4.0.2",
      "gulp-jshint": "^2.0.4",
      "jshint": "^2.0.0",
      "jshint-stylish": "^2.2.1",
      "tape": "^4.9.1"
    },
    "directories": {
      "lib": "./lib"
    },
    "engines": {
      "node": ">=4.0.0"
    },
    "homepage": "https://github.com/theturtle32/WebSocket-Node",
    "keywords": [
      "websocket",
      "websockets",
      "socket",
      "networking",
      "comet",
      "push",
      "RFC-6455",
      "realtime",
      "server",
      "client"
    ],
    "license": "Apache-2.0",
    "main": "index",
    "name": "websocket",
    "repository": {
      "type": "git",
      "url": "git+https://github.com/theturtle32/WebSocket-Node.git"
    },
    "scripts": {
      "gulp": "gulp",
      "test": "tape test/unit/*.js"
    },
    "version": "1.0.34"
  }
  
  },{}]},{},["/home/ubuntu/umbrella-voice2/app/lib/index.js"])
  //# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJsaWIvTG9nZ2VyLmpzIiwibGliL1Jvb21DbGllbnQuanMiLCJsaWIvZGV2aWNlSW5mby5qcyIsImxpYi9ldmVudHMuanMiLCJsaWIvaW5kZXguanMiLCJsaWIvdXJsRmFjdG9yeS5qcyIsImxpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FycmF5TGlrZVRvQXJyYXkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9hcnJheVdpdGhvdXRIb2xlcy5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2FzeW5jVG9HZW5lcmF0b3IuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9jbGFzc0NhbGxDaGVjay5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL2NyZWF0ZUNsYXNzLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZGVmaW5lUHJvcGVydHkuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZURlZmF1bHQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy9pbnRlcm9wUmVxdWlyZVdpbGRjYXJkLmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvaXRlcmFibGVUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvbm9uSXRlcmFibGVTcHJlYWQuanMiLCJub2RlX21vZHVsZXMvQGJhYmVsL3J1bnRpbWUvaGVscGVycy90b0NvbnN1bWFibGVBcnJheS5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZi5qcyIsIm5vZGVfbW9kdWxlcy9AYmFiZWwvcnVudGltZS9oZWxwZXJzL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzIiwibm9kZV9tb2R1bGVzL0BiYWJlbC9ydW50aW1lL3JlZ2VuZXJhdG9yL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2F3YWl0cXVldWUvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL2Jvd3Nlci9lczUuanMiLCJub2RlX21vZHVsZXMvYnJvd3NlcmlmeS9ub2RlX21vZHVsZXMvZXZlbnRzL2V2ZW50cy5qcyIsIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy9kZWJ1Zy9zcmMvY29tbW9uLmpzIiwibm9kZV9tb2R1bGVzL2RvbXJlYWR5L3JlYWR5LmpzIiwibm9kZV9tb2R1bGVzL2VzNS1leHQvZ2xvYmFsLmpzIiwibm9kZV9tb2R1bGVzL2gyNjQtcHJvZmlsZS1sZXZlbC1pZC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9Db25zdW1lci5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9EYXRhQ29uc3VtZXIuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvRGF0YVByb2R1Y2VyLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL0RldmljZS5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9FbmhhbmNlZEV2ZW50RW1pdHRlci5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9Mb2dnZXIuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvUHJvZHVjZXIuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvUnRwUGFyYW1ldGVycy5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9TY3RwUGFyYW1ldGVycy5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9UcmFuc3BvcnQuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvZXJyb3JzLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0Nocm9tZTU1LmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0Nocm9tZTY3LmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0Nocm9tZTcwLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0Nocm9tZTc0LmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL0VkZ2UxMS5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9oYW5kbGVycy9GaXJlZm94NjAuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvSGFuZGxlckludGVyZmFjZS5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9oYW5kbGVycy9SZWFjdE5hdGl2ZS5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9oYW5kbGVycy9TYWZhcmkxMS5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9oYW5kbGVycy9TYWZhcmkxMi5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9oYW5kbGVycy9vcnRjL2VkZ2VVdGlscy5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi9oYW5kbGVycy9zZHAvTWVkaWFTZWN0aW9uLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL3NkcC9SZW1vdGVTZHAuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvaGFuZGxlcnMvc2RwL2NvbW1vblV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL3NkcC9wbGFuQlV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2hhbmRsZXJzL3NkcC91bmlmaWVkUGxhblV0aWxzLmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL21lZGlhc291cC1jbGllbnQvbGliL29ydGMuanMiLCJub2RlX21vZHVsZXMvbWVkaWFzb3VwLWNsaWVudC9saWIvc2NhbGFiaWxpdHlNb2Rlcy5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi90eXBlcy5qcyIsIm5vZGVfbW9kdWxlcy9tZWRpYXNvdXAtY2xpZW50L2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9tcy9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJub2RlX21vZHVsZXMvcHJvdG9vLWNsaWVudC9saWIvRW5oYW5jZWRFdmVudEVtaXR0ZXIuanMiLCJub2RlX21vZHVsZXMvcHJvdG9vLWNsaWVudC9saWIvTG9nZ2VyLmpzIiwibm9kZV9tb2R1bGVzL3Byb3Rvby1jbGllbnQvbGliL01lc3NhZ2UuanMiLCJub2RlX21vZHVsZXMvcHJvdG9vLWNsaWVudC9saWIvUGVlci5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b28tY2xpZW50L2xpYi9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b28tY2xpZW50L2xpYi90cmFuc3BvcnRzL1dlYlNvY2tldFRyYW5zcG9ydC5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b28tY2xpZW50L2xpYi91dGlscy5qcyIsIm5vZGVfbW9kdWxlcy9wcm90b28tY2xpZW50L3BhY2thZ2UuanNvbiIsIm5vZGVfbW9kdWxlcy9xdWVyeXN0cmluZ2lmeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZWdlbmVyYXRvci1ydW50aW1lL3J1bnRpbWUuanMiLCJub2RlX21vZHVsZXMvcmVxdWlyZXMtcG9ydC9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZXRyeS9pbmRleC5qcyIsIm5vZGVfbW9kdWxlcy9yZXRyeS9saWIvcmV0cnkuanMiLCJub2RlX21vZHVsZXMvcmV0cnkvbGliL3JldHJ5X29wZXJhdGlvbi5qcyIsIm5vZGVfbW9kdWxlcy9zZHAtdHJhbnNmb3JtL2xpYi9ncmFtbWFyLmpzIiwibm9kZV9tb2R1bGVzL3NkcC10cmFuc2Zvcm0vbGliL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3NkcC10cmFuc2Zvcm0vbGliL3BhcnNlci5qcyIsIm5vZGVfbW9kdWxlcy9zZHAtdHJhbnNmb3JtL2xpYi93cml0ZXIuanMiLCJub2RlX21vZHVsZXMvdXJsLXBhcnNlL2luZGV4LmpzIiwibm9kZV9tb2R1bGVzL3dlYnNvY2tldC9saWIvYnJvd3Nlci5qcyIsIm5vZGVfbW9kdWxlcy93ZWJzb2NrZXQvbGliL3ZlcnNpb24uanMiLCJub2RlX21vZHVsZXMvd2Vic29ja2V0L3BhY2thZ2UuanNvbiJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Ozs7Ozs7QUNBQTs7QUFFQSxJQUFNLFFBQVEsR0FBRyxnQkFBakI7O0lBRXFCLE07QUFFcEIsa0JBQVksTUFBWixFQUNBO0FBQUE7O0FBQ0MsUUFBSSxNQUFKLEVBQ0E7QUFDQyxXQUFLLE1BQUwsR0FBYyxpQ0FBUyxRQUFULGNBQXFCLE1BQXJCLEVBQWQ7QUFDQSxXQUFLLEtBQUwsR0FBYSxpQ0FBUyxRQUFULG1CQUEwQixNQUExQixFQUFiO0FBQ0EsV0FBSyxNQUFMLEdBQWMsaUNBQVMsUUFBVCxvQkFBMkIsTUFBM0IsRUFBZDtBQUNBLEtBTEQsTUFPQTtBQUNDLFdBQUssTUFBTCxHQUFjLHVCQUFNLFFBQU4sQ0FBZDtBQUNBLFdBQUssS0FBTCxHQUFhLGlDQUFTLFFBQVQsV0FBYjtBQUNBLFdBQUssTUFBTCxHQUFjLGlDQUFTLFFBQVQsWUFBZDtBQUNBO0FBRUQ7OztBQUNBLFNBQUssTUFBTCxDQUFZLEdBQVosR0FBa0IsT0FBTyxDQUFDLElBQVIsQ0FBYSxJQUFiLENBQWtCLE9BQWxCLENBQWxCO0FBQ0EsU0FBSyxLQUFMLENBQVcsR0FBWCxHQUFpQixPQUFPLENBQUMsSUFBUixDQUFhLElBQWIsQ0FBa0IsT0FBbEIsQ0FBakI7QUFDQSxTQUFLLE1BQUwsQ0FBWSxHQUFaLEdBQWtCLE9BQU8sQ0FBQyxLQUFSLENBQWMsSUFBZCxDQUFtQixPQUFuQixDQUFsQjtBQUNBO0FBQ0E7Ozs7U0FFRCxlQUNBO0FBQ0MsYUFBTyxLQUFLLE1BQVo7QUFDQTs7O1NBRUQsZUFDQTtBQUNDLGFBQU8sS0FBSyxLQUFaO0FBQ0E7OztTQUVELGVBQ0E7QUFDQyxhQUFPLEtBQUssTUFBWjtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3pDRjs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7O0FBRUEsSUFBTSwwQkFBMEIsR0FDaEM7QUFDQyxFQUFBLFFBQVEsRUFBRSxDQUFDO0FBQUUsSUFBQSxRQUFRLEVBQUU7QUFBWixHQUFEO0FBRFgsQ0FEQTtBQUtBLElBQU0sVUFBVSxHQUFHLENBQUM7QUFDbkIsRUFBQSxJQUFJLEVBQUUsOEJBRGE7QUFFbkIsRUFBQSxRQUFRLEVBQUUsRUFGUztBQUduQixFQUFBLFVBQVUsRUFBRTtBQUhPLENBQUQsRUFJaEI7QUFDRixFQUFBLElBQUksRUFBRSwrQkFESjtBQUVGLEVBQUEsUUFBUSxFQUFFLEVBRlI7QUFHRixFQUFBLFVBQVUsRUFBRTtBQUhWLENBSmdCLEVBUWhCO0FBQ0YsRUFBQSxJQUFJLEVBQUUsK0JBREo7QUFFRixFQUFBLFFBQVEsRUFBRSxFQUZSO0FBR0YsRUFBQSxVQUFVLEVBQUU7QUFIVixDQVJnQixFQVloQjtBQUNGLEVBQUEsSUFBSSxFQUFFLCtCQURKO0FBRUYsRUFBQSxRQUFRLEVBQUUsRUFGUjtBQUdGLEVBQUEsVUFBVSxFQUFFO0FBSFYsQ0FaZ0IsRUFnQmhCO0FBQ0YsRUFBQSxJQUFJLEVBQUUsK0JBREo7QUFFRixFQUFBLFFBQVEsRUFBRSxFQUZSO0FBR0YsRUFBQSxVQUFVLEVBQUU7QUFIVixDQWhCZ0IsQ0FBbkI7QUFzQkEsSUFBTSxNQUFNLEdBQUcsSUFBSSxrQkFBSixDQUFXLFlBQVgsQ0FBZjs7SUFFcUIsVTtBQUNwQjtBQUNEO0FBQ0E7QUFDQTtBQUNDO0FBQ0E7QUFDQTtBQUNBO0FBRUEsNEJBY0U7QUFBQSxRQVpBLE1BWUEsUUFaQSxNQVlBO0FBQUEsUUFYQSxNQVdBLFFBWEEsTUFXQTtBQUFBLFFBVkEsTUFVQSxRQVZBLE1BVUE7QUFBQSxRQVRBLFdBU0EsUUFUQSxXQVNBO0FBQUEsUUFSQSxZQVFBLFFBUkEsWUFRQTtBQUFBLFFBUEEsUUFPQSxRQVBBLFFBT0E7QUFBQSxRQU5BLE9BTUEsUUFOQSxPQU1BO0FBQUEsUUFMQSxPQUtBLFFBTEEsT0FLQTtBQUFBLFFBSkEsU0FJQSxRQUpBLFNBSUE7QUFBQSxRQUhBLFFBR0EsUUFIQSxRQUdBO0FBQUEsUUFGQSxXQUVBLFFBRkEsV0FFQTtBQUFBO0FBQ0QsSUFBQSxNQUFNLENBQUMsS0FBUCxDQUNDLHFEQURELEVBRUMsTUFGRCxFQUVTLE1BRlQsRUFFaUIsTUFBTSxDQUFDLElBRnhCO0FBSUEsU0FBSyxZQUFMLEdBQW9CLElBQUksWUFBSixFQUFwQjtBQUVBLFNBQUssVUFBTCxHQUFrQixLQUFLLFlBQUwsQ0FBa0IsVUFBbEIsRUFBbEI7QUFFQSxTQUFLLFVBQUwsQ0FBZ0IsT0FBaEIsQ0FBd0IsS0FBSyxZQUFMLENBQWtCLFdBQTFDO0FBQ0EsU0FBSyxVQUFMLENBQWdCLElBQWhCLENBQXFCLGNBQXJCLENBQW9DLENBQXBDLEVBQXVDLEtBQUssWUFBTCxDQUFrQixXQUF6RDtBQUVBLFNBQUssTUFBTCxHQUFjLE1BQWQ7QUFDQSxTQUFLLE1BQUwsR0FBYyxNQUFkLENBYkMsQ0FlRDtBQUNBOztBQUNBLFNBQUssT0FBTCxHQUFlLEtBQWYsQ0FqQkMsQ0FtQkQ7QUFDQTs7QUFDQSxTQUFLLE9BQUwsR0FBZSxNQUFmLENBckJDLENBdUJEO0FBQ0E7O0FBQ0EsU0FBSyxTQUFMLEdBQWlCLFFBQWpCLENBekJDLENBMkJEO0FBQ0E7O0FBQ0EsU0FBSyxRQUFMLEdBQWdCLE9BQWhCLENBN0JDLENBK0JEO0FBQ0E7O0FBQ0EsU0FBSyxRQUFMLEdBQWdCLE9BQWhCLENBakNDLENBbUNEO0FBQ0E7O0FBQ0EsU0FBSyxlQUFMLEdBQXVCLFdBQXZCLENBckNDLENBdUNEOztBQUNBLFNBQUssVUFBTCxHQUFrQixPQUFPLENBQUMsU0FBRCxDQUF6QixDQXhDQyxDQTBDRDs7QUFDQSxTQUFLLFNBQUwsR0FBaUIsT0FBTyxDQUFDLFFBQUQsQ0FBeEIsQ0EzQ0MsQ0E2Q0Q7QUFDQTs7QUFDQSxTQUFLLGNBQUwsR0FBc0IsSUFBdEIsQ0EvQ0MsQ0FpREQ7QUFDQTs7QUFDQSxTQUFLLDBCQUFMLEdBQWtDLENBQWxDLENBbkRDLENBcUREO0FBQ0E7QUFDQTs7QUFDQSxTQUFLLFlBQUwsR0FBb0IsV0FBcEIsQ0F4REMsQ0EwREQ7QUFDQTs7QUFDQSxTQUFLLGFBQUwsR0FBcUIsWUFBckIsQ0E1REMsQ0E4REQ7QUFDQTs7QUFDQSxTQUFLLE9BQUwsR0FBZSxJQUFmLENBaEVDLENBa0VEO0FBQ0E7O0FBQ0EsU0FBSyxnQkFBTCxHQUF3QixJQUF4QixDQXBFQyxDQXNFRDtBQUNBOztBQUNBLFNBQUssY0FBTCxHQUFzQixJQUF0QixDQXhFQyxDQTBFRDtBQUNBOztBQUNBLFNBQUssY0FBTCxHQUFzQixJQUF0QixDQTVFQyxDQThFRDtBQUNBOztBQUNBLFNBQUssWUFBTCxHQUFvQixJQUFwQixDQWhGQyxDQWtGRDtBQUNBOztBQUNBLFNBQUssVUFBTCxHQUFrQixJQUFJLEdBQUosRUFBbEIsQ0FwRkMsQ0FzRkQ7QUFDQTs7QUFDQSxTQUFLLE1BQUwsR0FBYyxJQUFJLEdBQUosRUFBZDtBQUNBOzs7O1dBRUQsaUJBQVE7QUFDUCxVQUFJLEtBQUssT0FBVCxFQUNDO0FBRUQsV0FBSyxPQUFMLEdBQWUsSUFBZjtBQUVBLE1BQUEsTUFBTSxDQUFDLEtBQVAsQ0FBYSxTQUFiLEVBTk8sQ0FRUDs7QUFDQSxXQUFLLE9BQUwsQ0FBYSxLQUFiOztBQUNBLHlCQUFPLGtDQUFQLENBQTBDLEtBQUssTUFBL0MsRUFBdUQsY0FBdkQsRUFWTyxDQVlQOzs7QUFDQSxVQUFJLEtBQUssY0FBVCxFQUNDLEtBQUssY0FBTCxDQUFvQixLQUFwQjtBQUVELFVBQUksS0FBSyxjQUFULEVBQ0MsS0FBSyxjQUFMLENBQW9CLEtBQXBCO0FBQ0Q7Ozs7Z0dBRUQ7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ08sZ0JBQUEsU0FEUCxHQUNtQiw4QkFBYTtBQUFFLGtCQUFBLE1BQU0sRUFBRSxLQUFLLE1BQWY7QUFBdUIsa0JBQUEsTUFBTSxFQUFFLEtBQUs7QUFBcEMsaUJBQWIsQ0FEbkI7QUFFTyxnQkFBQSxlQUZQLEdBRXlCLElBQUkseUJBQWEsa0JBQWpCLENBQW9DLFNBQXBDLENBRnpCO0FBSUMscUJBQUssT0FBTCxHQUFlLElBQUkseUJBQWEsSUFBakIsQ0FBc0IsZUFBdEIsQ0FBZjs7QUFFQSxxQkFBSyxPQUFMLENBQWEsRUFBYixDQUFnQixNQUFoQixFQUF3QjtBQUFBLHlCQUFNLEtBQUksQ0FBQyxTQUFMLEVBQU47QUFBQSxpQkFBeEI7O0FBRUEscUJBQUssT0FBTCxDQUFhLEVBQWIsQ0FBZ0IsUUFBaEIsRUFBMEIsWUFBTTtBQUMvQixrQkFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLHNCQUFiOztBQUNBLHFDQUFPLGtDQUFQLENBQTBDLEtBQUksQ0FBQyxNQUEvQyxFQUF1RCxjQUF2RDtBQUNBLGlCQUhEOztBQUtBLHFCQUFLLE9BQUwsQ0FBYSxFQUFiLENBQWdCLGNBQWhCLEVBQWdDLFlBQU07QUFDckMsa0JBQUEsTUFBTSxDQUFDLEtBQVAsQ0FBYSxvQkFBYjs7QUFDQSxxQ0FBTyxrQ0FBUCxDQUEwQyxLQUFJLENBQUMsTUFBL0MsRUFBdUQsY0FBdkQsRUFGcUMsQ0FJckM7OztBQUNBLHNCQUFJLEtBQUksQ0FBQyxjQUFULEVBQXlCO0FBQ3hCLG9CQUFBLEtBQUksQ0FBQyxjQUFMLENBQW9CLEtBQXBCOztBQUNBLG9CQUFBLEtBQUksQ0FBQyxjQUFMLEdBQXNCLElBQXRCO0FBQ0E7O0FBRUQsc0JBQUksS0FBSSxDQUFDLGNBQVQsRUFBeUI7QUFDeEIsb0JBQUEsS0FBSSxDQUFDLGNBQUwsQ0FBb0IsS0FBcEI7O0FBQ0Esb0JBQUEsS0FBSSxDQUFDLGNBQUwsR0FBc0IsSUFBdEI7QUFDQTtBQUNELGlCQWREOztBQWdCQSxxQkFBSyxPQUFMLENBQWEsRUFBYixDQUFnQixPQUFoQixFQUF5QixZQUFNO0FBQzlCLHNCQUFJLEtBQUksQ0FBQyxPQUFULEVBQ0M7O0FBRUQsa0JBQUEsS0FBSSxDQUFDLEtBQUw7QUFDQSxpQkFMRCxFQTdCRCxDQW9DQzs7O0FBQ0EscUJBQUssT0FBTCxDQUFhLEVBQWIsQ0FBZ0IsU0FBaEI7QUFBQSw0R0FBMkIsaUJBQU8sT0FBUCxFQUFnQixNQUFoQixFQUF3QixNQUF4QjtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQzFCLDRCQUFBLE1BQU0sQ0FBQyxLQUFQLENBQ0MsNENBREQsRUFFQyxPQUFPLENBQUMsTUFGVCxFQUVpQixPQUFPLENBQUMsSUFGekI7QUFEMEIsMENBS2xCLE9BQU8sQ0FBQyxNQUxVO0FBQUEsNERBTXBCLGFBTm9CO0FBQUE7O0FBQUE7QUFBQSxnQ0FRbEIsS0FBSSxDQUFDLFFBUmE7QUFBQTtBQUFBO0FBQUE7O0FBU3RCLDRCQUFBLE1BQU0sQ0FBQyxHQUFELEVBQU0sMEJBQU4sQ0FBTjtBQVRzQjs7QUFBQTtBQUFBLDRDQXFCbkIsT0FBTyxDQUFDLElBckJXLEVBZXRCLE1BZnNCLGlCQWV0QixNQWZzQixFQWdCdEIsVUFoQnNCLGlCQWdCdEIsVUFoQnNCLEVBaUJ0QixFQWpCc0IsaUJBaUJ0QixFQWpCc0IsRUFrQnRCLElBbEJzQixpQkFrQnRCLElBbEJzQixFQW1CdEIsYUFuQnNCLGlCQW1CdEIsYUFuQnNCLEVBb0J0QixPQXBCc0IsaUJBb0J0QixPQXBCc0I7QUFBQTtBQUFBO0FBQUEsbUNBd0JDLEtBQUksQ0FBQyxjQUFMLENBQW9CLE9BQXBCLENBQ3RCO0FBQ0MsOEJBQUEsRUFBRSxFQUFGLEVBREQ7QUFFQyw4QkFBQSxVQUFVLEVBQVYsVUFGRDtBQUdDLDhCQUFBLElBQUksRUFBSixJQUhEO0FBSUMsOEJBQUEsYUFBYSxFQUFiLGFBSkQ7QUFLQyw4QkFBQSxPQUFPLGtDQUFPLE9BQVA7QUFBZ0IsZ0NBQUEsTUFBTSxFQUFOO0FBQWhCLGdDQUxSLENBS2lDOztBQUxqQyw2QkFEc0IsQ0F4QkQ7O0FBQUE7QUF3QmhCLDRCQUFBLFFBeEJnQjs7QUFpQ3RCO0FBQ0EsNEJBQUEsS0FBSSxDQUFDLFVBQUwsQ0FBZ0IsR0FBaEIsQ0FBb0IsUUFBUSxDQUFDLEVBQTdCLEVBQWlDLFFBQWpDOztBQUNBLDRCQUFBLEtBQUksQ0FBQyxNQUFMLENBQVksR0FBWixDQUFnQixNQUFoQixFQUF3QixRQUFRLENBQUMsRUFBakM7O0FBRUEsNEJBQUEsUUFBUSxDQUFDLEVBQVQsQ0FBWSxnQkFBWixFQUE4QixZQUFNO0FBQ25DLDhCQUFBLEtBQUksQ0FBQyxNQUFMLFdBQW1CLFFBQVEsQ0FBQyxNQUE1Qjs7QUFDQSw4QkFBQSxLQUFJLENBQUMsVUFBTCxXQUF1QixRQUFRLENBQUMsRUFBaEM7QUFDQSw2QkFIRCxFQXJDc0IsQ0EwQ3RCO0FBQ0E7QUFDQTs7QUFFQSw0QkFBQSxLQUFJLENBQUMsaUJBQUwsQ0FBdUIsUUFBUSxDQUFDLEVBQWhDLEVBOUNzQixDQWdEdEI7QUFDQTs7O0FBQ0EsNEJBQUEsTUFBTSxHQWxEZ0IsQ0FvRHRCO0FBQ0E7QUFDQTs7QUF0RHNCO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBeUR0Qiw0QkFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLGlDQUFiO0FBekRzQjs7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUEzQjs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFtRUEscUJBQUssT0FBTCxDQUFhLEVBQWIsQ0FBZ0IsY0FBaEIsRUFBZ0MsVUFBQyxZQUFELEVBQWtCO0FBQ2pELHNCQUFJLFlBQVksQ0FBQyxNQUFiLEtBQXdCLGVBQTVCLEVBQTZDO0FBQzVDLG9CQUFBLE1BQU0sQ0FBQyxLQUFQLENBQ0MsaURBREQsRUFFQyxZQUFZLENBQUMsTUFGZCxFQUVzQixZQUFZLENBQUMsSUFGbkM7QUFHQTs7QUFFRCwwQkFBUSxZQUFZLENBQUMsTUFBckI7QUFFQyx5QkFBSyxnQkFBTDtBQUNDO0FBQ0MsNEJBQVEsVUFBUixHQUF1QixZQUFZLENBQUMsSUFBcEMsQ0FBUSxVQUFSOztBQUNBLDRCQUFNLFFBQVEsR0FBRyxLQUFJLENBQUMsVUFBTCxDQUFnQixHQUFoQixDQUFvQixVQUFwQixDQUFqQjs7QUFFQSw0QkFBSSxDQUFDLFFBQUwsRUFDQztBQUVELHdCQUFBLFFBQVEsQ0FBQyxLQUFUOztBQUVBLHdCQUFBLEtBQUksQ0FBQyxtQkFBTCxDQUF5QixVQUF6Qjs7QUFFQSx3QkFBQSxLQUFJLENBQUMsTUFBTCxXQUFtQixRQUFRLENBQUMsTUFBNUI7O0FBQ0Esd0JBQUEsS0FBSSxDQUFDLFVBQUwsV0FBdUIsVUFBdkIsRUFaRCxDQWNDOzs7QUFFQTtBQUNBOztBQUVGLHlCQUFLLGdCQUFMO0FBQ0M7QUFDQyw0QkFBUSxXQUFSLEdBQXVCLFlBQVksQ0FBQyxJQUFwQyxDQUFRLFVBQVI7O0FBQ0EsNEJBQU0sU0FBUSxHQUFHLEtBQUksQ0FBQyxVQUFMLENBQWdCLEdBQWhCLENBQW9CLFdBQXBCLENBQWpCOztBQUVBLDRCQUFJLENBQUMsU0FBTCxFQUNDOztBQUVELHdCQUFBLFNBQVEsQ0FBQyxLQUFUOztBQUVBO0FBQ0E7O0FBRUYseUJBQUssaUJBQUw7QUFDQztBQUNDLDRCQUFRLFlBQVIsR0FBdUIsWUFBWSxDQUFDLElBQXBDLENBQVEsVUFBUjs7QUFDQSw0QkFBTSxVQUFRLEdBQUcsS0FBSSxDQUFDLFVBQUwsQ0FBZ0IsR0FBaEIsQ0FBb0IsWUFBcEIsQ0FBakI7O0FBRUEsNEJBQUksQ0FBQyxVQUFMLEVBQ0M7O0FBRUQsd0JBQUEsVUFBUSxDQUFDLE1BQVQ7O0FBRUE7QUFDQTs7QUFFRjtBQUNDO0FBQ0Msd0JBQUEsTUFBTSxDQUFDLEtBQVAsQ0FDQyx5Q0FERCxFQUM0QyxZQUFZLENBQUMsTUFEekQ7QUFFQTtBQXBESDtBQXNEQSxpQkE3REQ7O0FBeEdEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE87Ozs7Ozs7Ozs7O3FHQXdLQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQyxnQkFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLGFBQWI7O0FBREQscUJBR0ssS0FBSyxZQUhWO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUEsb0JBTU0sS0FBSyxnQkFBTCxDQUFzQixVQUF0QixDQUFpQyxPQUFqQyxDQU5OO0FBQUE7QUFBQTtBQUFBOztBQU9FLGdCQUFBLE1BQU0sQ0FBQyxLQUFQLENBQWEsb0NBQWI7QUFQRjs7QUFBQTtBQUFBO0FBZ0JFLGdCQUFBLE1BQU0sQ0FBQyxLQUFQLENBQWEsc0NBQWI7QUFFTSxnQkFBQSxXQWxCUixHQWtCc0I7QUFDbkIsa0JBQUEsS0FBSyxFQUFFO0FBQ047QUFDQSxvQkFBQSxnQkFBZ0IsRUFBRSxLQUZaO0FBR04sb0JBQUEsZ0JBQWdCLEVBQUUsSUFIWjtBQUlOLG9CQUFBLGVBQWUsRUFBRSxLQUpYLENBS047O0FBTE07QUFEWSxpQkFsQnRCO0FBQUE7QUFBQSx1QkE0QnVCLFNBQVMsQ0FBQyxZQUFWLENBQXVCLFlBQXZCLENBQW9DLFdBQXBDLENBNUJ2Qjs7QUFBQTtBQTRCUSxnQkFBQSxNQTVCUjtBQThCRSxnQkFBQSxLQUFLLEdBQUcsTUFBTSxDQUFDLGNBQVAsR0FBd0IsQ0FBeEIsQ0FBUjtBQTlCRjtBQUFBLHVCQWdDNEIsS0FBSyxjQUFMLENBQW9CLE9BQXBCLENBQ3pCO0FBQ0Msa0JBQUEsS0FBSyxFQUFMLEtBREQ7QUFFQyxrQkFBQSxZQUFZLEVBQ1o7QUFDQyxvQkFBQSxVQUFVLEVBQUUsQ0FEYjtBQUVDLG9CQUFBLE9BQU8sRUFBRTtBQUZWLG1CQUhELENBT0M7QUFDQTtBQUNBOztBQVRELGlCQUR5QixDQWhDNUI7O0FBQUE7QUFnQ0UscUJBQUssWUFoQ1A7O0FBNkNFLHFCQUFLLFlBQUwsQ0FBa0IsS0FBbEI7O0FBRUEscUJBQUssWUFBTCxDQUFrQixFQUFsQixDQUFxQixnQkFBckIsRUFBdUMsWUFBTTtBQUM1QyxrQkFBQSxNQUFJLENBQUMsWUFBTCxHQUFvQixJQUFwQjtBQUNBLGlCQUZEOztBQUlBLHFCQUFLLFlBQUwsQ0FBa0IsRUFBbEIsQ0FBcUIsWUFBckIsRUFBbUMsWUFBTTtBQUV4QyxrQkFBQSxNQUFJLENBQUMsVUFBTCxZQUNRLFlBQU0sQ0FBRyxDQURqQjtBQUVBLGlCQUpEOztBQW5ERjtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQTBERSxnQkFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLHlCQUFiO0FBRUEsb0JBQUksS0FBSixFQUNDLEtBQUssQ0FBQyxJQUFOOztBQTdESDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPOzs7Ozs7Ozs7OztzR0FpRUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNDLGdCQUFBLE1BQU0sQ0FBQyxLQUFQLENBQWEsY0FBYjs7QUFERCxvQkFHTSxLQUFLLFlBSFg7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFNQyxxQkFBSyxZQUFMLENBQWtCLEtBQWxCOztBQU5EO0FBQUE7QUFBQSx1QkFTUSxLQUFLLE9BQUwsQ0FBYSxPQUFiLENBQ0wsZUFESyxFQUNZO0FBQUUsa0JBQUEsVUFBVSxFQUFFLEtBQUssWUFBTCxDQUFrQjtBQUFoQyxpQkFEWixDQVRSOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFhRSxnQkFBQSxNQUFNLENBQUMsS0FBUDs7QUFiRjtBQWdCQyxxQkFBSyxZQUFMLEdBQW9CLElBQXBCOztBQWhCRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPOzs7Ozs7Ozs7OzttR0FtQkE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNDLGdCQUFBLE1BQU0sQ0FBQyxLQUFQLENBQWEsV0FBYjs7QUFFQSxxQkFBSyxZQUFMLENBQWtCLEtBQWxCOztBQUhEO0FBQUE7QUFBQSx1QkFNUSxLQUFLLE9BQUwsQ0FBYSxPQUFiLENBQ0wsZUFESyxFQUNZO0FBQUUsa0JBQUEsVUFBVSxFQUFFLEtBQUssWUFBTCxDQUFrQjtBQUFoQyxpQkFEWixDQU5SOztBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFVRSxnQkFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLHdCQUFiOztBQVZGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE87Ozs7Ozs7Ozs7O3FHQWNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQyxnQkFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLGFBQWI7O0FBRUEscUJBQUssWUFBTCxDQUFrQixNQUFsQjs7QUFIRDtBQUFBO0FBQUEsdUJBTVEsS0FBSyxPQUFMLENBQWEsT0FBYixDQUNMLGdCQURLLEVBQ2E7QUFBRSxrQkFBQSxVQUFVLEVBQUUsS0FBSyxZQUFMLENBQWtCO0FBQWhDLGlCQURiLENBTlI7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQVVFLGdCQUFBLE1BQU0sQ0FBQyxLQUFQLENBQWEsMEJBQWI7O0FBVkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTzs7Ozs7Ozs7Ozs7NEdBY0Esa0JBQXVCLE1BQXZCO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQyxnQkFBQSxNQUFNLENBQUMsS0FBUCx5QkFBOEIsTUFBOUI7O0FBQ0EscUJBQUssT0FBTCxDQUFhLE9BQWIsQ0FBcUIsYUFBckIsRUFBb0M7QUFBRSxrQkFBQSxNQUFNLEVBQU47QUFBRixpQkFBcEMsRUFDRSxJQURGLENBQ08sWUFBTTtBQUNYLHFDQUFPLHFDQUFQLENBQTZDLE1BQUksQ0FBQyxNQUFsRCxFQUEwRCxNQUExRCxFQUFrRSxJQUFsRTtBQUNBLGlCQUhGLFdBSVEsVUFBQyxHQUFELEVBQVM7QUFDZjtBQUNBLGtCQUFBLE1BQU0sQ0FBQyxLQUFQLENBQWEsK0JBQWIsRUFBOEMsTUFBOUMsRUFBc0QsR0FBdEQ7O0FBQ0EscUNBQU8scUNBQVAsQ0FBNkMsTUFBSSxDQUFDLE1BQWxELEVBQTBELE1BQTFELEVBQWtFLEtBQWxFO0FBQ0EsaUJBUkY7O0FBRkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTzs7Ozs7Ozs7Ozs7aUhBYUEsa0JBQTRCLE1BQTVCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNDO0FBQ0E7QUFFTSxnQkFBQSxVQUpQLEdBSW9CLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0IsTUFBaEIsQ0FKcEI7O0FBQUEsb0JBTU0sVUFOTjtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQVFPLGdCQUFBLFFBUlAsR0FRa0IsS0FBSyxVQUFMLENBQWdCLEdBQWhCLENBQW9CLFVBQXBCLENBUmxCOztBQVVDLHFCQUFLLGNBQUwsQ0FBb0IsUUFBcEIsRUFBOEIsTUFBOUI7O0FBVkQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTzs7Ozs7Ozs7Ozs7cUdBYUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNDLGdCQUFBLE1BQU0sQ0FBQyxLQUFQLENBQWEsYUFBYjs7QUFERDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPOzs7Ozs7Ozs7Ozt1R0FJQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0MsZ0JBQUEsTUFBTSxDQUFDLEtBQVAsQ0FBYSxlQUFiOztBQUREO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE87Ozs7Ozs7Ozs7O3NHQUlBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQyxnQkFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLGNBQWI7QUFERDs7QUFBQSxxQkFJTSxLQUFLLGNBSlg7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSx1QkFLK0IsS0FBSyxPQUFMLENBQWEsT0FBYixDQUMzQixZQUQyQixFQUUzQjtBQUFFLGtCQUFBLFdBQVcsRUFBRSxLQUFLLGNBQUwsQ0FBb0I7QUFBbkMsaUJBRjJCLENBTC9COztBQUFBO0FBS1MsZ0JBQUEsYUFMVDtBQUFBO0FBQUEsdUJBU1MsS0FBSyxjQUFMLENBQW9CLFVBQXBCLENBQStCO0FBQUUsa0JBQUEsYUFBYSxFQUFiO0FBQUYsaUJBQS9CLENBVFQ7O0FBQUE7QUFBQSxxQkFZTSxLQUFLLGNBWlg7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSx1QkFhK0IsS0FBSyxPQUFMLENBQWEsT0FBYixDQUMzQixZQUQyQixFQUUzQjtBQUFFLGtCQUFBLFdBQVcsRUFBRSxLQUFLLGNBQUwsQ0FBb0I7QUFBbkMsaUJBRjJCLENBYi9COztBQUFBO0FBYVMsZ0JBQUEsY0FiVDtBQUFBO0FBQUEsdUJBaUJTLEtBQUssY0FBTCxDQUFvQixVQUFwQixDQUErQjtBQUFFLGtCQUFBLGFBQWEsRUFBYjtBQUFGLGlCQUEvQixDQWpCVDs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBc0JFLGdCQUFBLE1BQU0sQ0FBQyxLQUFQLENBQWEsMEJBQWI7O0FBdEJGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE87Ozs7Ozs7Ozs7O3NIQTJCQSxtQkFBaUMsVUFBakMsRUFBNkMsWUFBN0MsRUFBMkQsYUFBM0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNDLGdCQUFBLE1BQU0sQ0FBQyxLQUFQLENBQ0MsaUZBREQsRUFFQyxVQUZELEVBRWEsWUFGYixFQUUyQixhQUYzQjtBQUREO0FBQUE7QUFBQSx1QkFNUSxLQUFLLE9BQUwsQ0FBYSxPQUFiLENBQ0wsNEJBREssRUFDeUI7QUFBRSxrQkFBQSxVQUFVLEVBQVYsVUFBRjtBQUFjLGtCQUFBLFlBQVksRUFBWixZQUFkO0FBQTRCLGtCQUFBLGFBQWEsRUFBYjtBQUE1QixpQkFEekIsQ0FOUjs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBVUUsZ0JBQUEsTUFBTSxDQUFDLEtBQVAsQ0FBYSwwQ0FBYjs7QUFWRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPOzs7Ozs7Ozs7OzsrR0FjQSxtQkFBMEIsVUFBMUIsRUFBc0MsUUFBdEM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNDLGdCQUFBLE1BQU0sQ0FBQyxLQUFQLENBQ0Msb0RBREQsRUFFQyxVQUZELEVBRWEsUUFGYjtBQUREO0FBQUE7QUFBQSx1QkFNUSxLQUFLLE9BQUwsQ0FBYSxPQUFiLENBQXFCLHFCQUFyQixFQUE0QztBQUFFLGtCQUFBLFVBQVUsRUFBVixVQUFGO0FBQWMsa0JBQUEsUUFBUSxFQUFSO0FBQWQsaUJBQTVDLENBTlI7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQVNFLGdCQUFBLE1BQU0sQ0FBQyxLQUFQLENBQWEsbUNBQWI7O0FBVEY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTzs7Ozs7Ozs7Ozs7dUhBYUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNDLGdCQUFBLE1BQU0sQ0FBQyxLQUFQLENBQWEsK0JBQWI7O0FBREQsb0JBR00sS0FBSyxjQUhYO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUEsbURBTVEsS0FBSyxPQUFMLENBQWEsT0FBYixDQUNOLG1CQURNLEVBQ2U7QUFBRSxrQkFBQSxXQUFXLEVBQUUsS0FBSyxjQUFMLENBQW9CO0FBQW5DLGlCQURmLENBTlI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTzs7Ozs7Ozs7Ozs7dUhBVUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNDLGdCQUFBLE1BQU0sQ0FBQyxLQUFQLENBQWEsK0JBQWI7O0FBREQsb0JBR00sS0FBSyxjQUhYO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUEsbURBTVEsS0FBSyxPQUFMLENBQWEsT0FBYixDQUNOLG1CQURNLEVBQ2U7QUFBRSxrQkFBQSxXQUFXLEVBQUUsS0FBSyxjQUFMLENBQW9CO0FBQW5DLGlCQURmLENBTlI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTzs7Ozs7Ozs7Ozs7K0dBVUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNDLGdCQUFBLE1BQU0sQ0FBQyxLQUFQLENBQWEsdUJBQWI7O0FBREQsb0JBR00sS0FBSyxZQUhYO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUEsbURBTVEsS0FBSyxPQUFMLENBQWEsT0FBYixDQUNOLGtCQURNLEVBQ2M7QUFBRSxrQkFBQSxVQUFVLEVBQUUsS0FBSyxZQUFMLENBQWtCO0FBQWhDLGlCQURkLENBTlI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTzs7Ozs7Ozs7Ozs7a0hBVUEsbUJBQTZCLFVBQTdCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUNDLGdCQUFBLE1BQU0sQ0FBQyxLQUFQLENBQWEsMEJBQWI7QUFFTSxnQkFBQSxRQUhQLEdBR2tCLEtBQUssVUFBTCxDQUFnQixHQUFoQixDQUFvQixVQUFwQixDQUhsQjs7QUFBQSxvQkFLTSxRQUxOO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUEsbURBUVEsS0FBSyxPQUFMLENBQWEsT0FBYixDQUFxQixrQkFBckIsRUFBeUM7QUFBRSxrQkFBQSxVQUFVLEVBQVY7QUFBRixpQkFBekMsQ0FSUjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPOzs7Ozs7Ozs7Ozt5SEFXQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQyxnQkFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLGlDQUFiO0FBRU0sZ0JBQUEsWUFIUCxHQUdzQixLQUFLLGdCQUgzQjs7QUFBQSxvQkFLTSxZQUxOO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUEsbURBUVEsS0FBSyxPQUFMLENBQWEsT0FBYixDQUNOLHNCQURNLEVBQ2tCO0FBQUUsa0JBQUEsY0FBYyxFQUFFLFlBQVksQ0FBQztBQUEvQixpQkFEbEIsQ0FSUjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPOzs7Ozs7Ozs7OztzSEFZQSxtQkFBaUMsY0FBakM7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0MsZ0JBQUEsTUFBTSxDQUFDLEtBQVAsQ0FBYSw4QkFBYjtBQUVNLGdCQUFBLFlBSFAsR0FHc0IsS0FBSyxjQUFMLENBQW9CLEdBQXBCLENBQXdCLGNBQXhCLENBSHRCOztBQUFBLG9CQUtNLFlBTE47QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQSxtREFRUSxLQUFLLE9BQUwsQ0FBYSxPQUFiLENBQXFCLHNCQUFyQixFQUE2QztBQUFFLGtCQUFBLGNBQWMsRUFBZDtBQUFGLGlCQUE3QyxDQVJSOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE87Ozs7Ozs7Ozs7O3NIQVdBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQyxnQkFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLDhCQUFiOztBQURELG9CQUdNLEtBQUssY0FIWDtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBLG1EQU1RLEtBQUssY0FBTCxDQUFvQixRQUFwQixFQU5SOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE87Ozs7Ozs7Ozs7O3NIQVNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQyxnQkFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLDhCQUFiOztBQURELG9CQUdNLEtBQUssY0FIWDtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBLG1EQU1RLEtBQUssY0FBTCxDQUFvQixRQUFwQixFQU5SOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE87Ozs7Ozs7Ozs7OzhHQVNBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQyxnQkFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLHNCQUFiOztBQURELG9CQUdNLEtBQUssWUFIWDtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUFBLG1EQU1RLEtBQUssWUFBTCxDQUFrQixRQUFsQixFQU5SOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE87Ozs7Ozs7Ozs7O2lIQVNBLG1CQUE0QixVQUE1QjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDTyxnQkFBQSxRQURQLEdBQ2tCLEtBQUssVUFBTCxDQUFnQixHQUFoQixDQUFvQixVQUFwQixDQURsQjs7QUFBQSxvQkFHTSxRQUhOO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUEsbURBTVEsUUFBUSxDQUFDLFFBQVQsRUFOUjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPOzs7Ozs7Ozs7OztnSEFTQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBNkIsZ0JBQUEsTUFBN0IsU0FBNkIsTUFBN0IsRUFBcUMsUUFBckMsU0FBcUMsUUFBckMsRUFBK0MsR0FBL0MsU0FBK0MsR0FBL0MsRUFBb0QsTUFBcEQsU0FBb0QsTUFBcEQ7QUFDQyxnQkFBQSxNQUFNLENBQUMsS0FBUCxDQUNDLHlEQURELEVBRUMsTUFGRCxFQUVTLFFBRlQsRUFFbUIsR0FGbkI7QUFERDtBQUFBO0FBQUEsdUJBTVEsS0FBSyxPQUFMLENBQWEsT0FBYixDQUNMLHNCQURLLEVBRUw7QUFBRSxrQkFBQSxNQUFNLEVBQU4sTUFBRjtBQUFVLGtCQUFBLFFBQVEsRUFBUixRQUFWO0FBQW9CLGtCQUFBLEdBQUcsRUFBSCxHQUFwQjtBQUF5QixrQkFBQSxNQUFNLEVBQU47QUFBekIsaUJBRkssQ0FOUjs7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBV0UsZ0JBQUEsTUFBTSxDQUFDLEtBQVAsQ0FBYSxvQ0FBYjs7QUFYRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPOzs7Ozs7Ozs7OztnSEFlQTtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEscUNBQTZCLE1BQTdCLEVBQTZCLE1BQTdCLDZCQUFzQyxLQUF0QyxpQkFBNkMsTUFBN0MsU0FBNkMsTUFBN0M7QUFDQyxnQkFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLHdCQUFiO0FBREQ7QUFBQTtBQUFBLHVCQUlRLEtBQUssT0FBTCxDQUFhLE9BQWIsQ0FBcUIsc0JBQXJCLEVBQTZDO0FBQUUsa0JBQUEsTUFBTSxFQUFOO0FBQUYsaUJBQTdDLENBSlI7O0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUE7QUFBQTs7QUFPRSxvQkFBSSxDQUFDLE1BQUwsRUFBYTtBQUNaLGtCQUFBLE1BQU0sQ0FBQyxLQUFQLENBQWEsb0NBQWI7QUFDQTs7QUFUSDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPOzs7Ozs7Ozs7OztxR0FhQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0MsZ0JBQUEsTUFBTSxDQUFDLEtBQVAsQ0FBYSxhQUFiO0FBREQ7QUFJRSxxQkFBSyxnQkFBTCxHQUF3QixJQUFJLGVBQWUsQ0FBQyxNQUFwQixDQUN2QjtBQUNDLGtCQUFBLFdBQVcsRUFBRSxLQUFLO0FBRG5CLGlCQUR1QixDQUF4QjtBQUpGO0FBQUEsdUJBVVMsS0FBSyxPQUFMLENBQWEsT0FBYixDQUFxQiwwQkFBckIsQ0FWVDs7QUFBQTtBQVNRLGdCQUFBLHFCQVRSO0FBQUE7QUFBQSx1QkFZUSxLQUFLLGdCQUFMLENBQXNCLElBQXRCLENBQTJCO0FBQUUsa0JBQUEscUJBQXFCLEVBQXJCO0FBQUYsaUJBQTNCLENBWlI7O0FBQUE7QUFjRTtBQUNBO0FBQ0E7QUFDQTtBQUNNLGdCQUFBLFdBbEJSLEdBa0JzQjtBQUNuQixrQkFBQSxLQUFLLEVBQUU7QUFDTjtBQUNBLG9CQUFBLGdCQUFnQixFQUFFLEtBRlo7QUFHTixvQkFBQSxnQkFBZ0IsRUFBRSxJQUhaO0FBSU4sb0JBQUEsZUFBZSxFQUFFLEtBSlgsQ0FLTjs7QUFMTTtBQURZLGlCQWxCdEI7QUFBQTtBQUFBLHVCQTRCdUIsU0FBUyxDQUFDLFlBQVYsQ0FBdUIsWUFBdkIsQ0FBb0MsV0FBcEMsQ0E1QnZCOztBQUFBO0FBNEJRLGdCQUFBLE1BNUJSO0FBNkJRLGdCQUFBLFVBN0JSLEdBNkJxQixNQUFNLENBQUMsY0FBUCxHQUF3QixDQUF4QixDQTdCckI7QUErQkUsZ0JBQUEsVUFBVSxDQUFDLE9BQVgsR0FBcUIsS0FBckI7QUFFQSxnQkFBQSxVQUFVLENBQUM7QUFBQSx5QkFBTSxVQUFVLENBQUMsSUFBWCxFQUFOO0FBQUEsaUJBQUQsRUFBMEIsTUFBMUIsQ0FBVixDQWpDRixDQWtDRTs7QUFsQ0YscUJBbUNNLEtBQUssUUFuQ1g7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSx1QkFvQytCLEtBQUssT0FBTCxDQUFhLE9BQWIsQ0FDM0IsdUJBRDJCLEVBRTNCO0FBQ0Msa0JBQUEsUUFBUSxFQUFFLEtBQUssU0FEaEI7QUFFQyxrQkFBQSxTQUFTLEVBQUUsSUFGWjtBQUdDLGtCQUFBLFNBQVMsRUFBRSxLQUhaO0FBSUMsa0JBQUEsZ0JBQWdCLEVBQUUsS0FBSyxlQUFMLEdBQ2YsS0FBSyxnQkFBTCxDQUFzQixnQkFEUCxHQUVmO0FBTkosaUJBRjJCLENBcEMvQjs7QUFBQTtBQW9DUyxnQkFBQSxhQXBDVDtBQWdESSxnQkFBQSxFQWhESixHQXFETyxhQXJEUCxDQWdESSxFQWhESixFQWlESSxhQWpESixHQXFETyxhQXJEUCxDQWlESSxhQWpESixFQWtESSxhQWxESixHQXFETyxhQXJEUCxDQWtESSxhQWxESixFQW1ESSxjQW5ESixHQXFETyxhQXJEUCxDQW1ESSxjQW5ESixFQW9ESSxjQXBESixHQXFETyxhQXJEUCxDQW9ESSxjQXBESjtBQXVERyxxQkFBSyxjQUFMLEdBQXNCLEtBQUssZ0JBQUwsQ0FBc0IsbUJBQXRCLENBQ3JCO0FBQ0Msa0JBQUEsRUFBRSxFQUFGLEVBREQ7QUFFQyxrQkFBQSxhQUFhLEVBQWIsYUFGRDtBQUdDLGtCQUFBLGFBQWEsRUFBYixhQUhEO0FBSUMsa0JBQUEsY0FBYyxFQUFkLGNBSkQ7QUFLQyxrQkFBQSxjQUFjLEVBQWQsY0FMRDtBQU1DLGtCQUFBLFVBQVUsRUFBVixVQU5EO0FBT0Msa0JBQUEsc0JBQXNCLEVBQUU7QUFQekIsaUJBRHFCLENBQXRCOztBQVdBLHFCQUFLLGNBQUwsQ0FBb0IsRUFBcEIsQ0FDQyxTQURELEVBQ1ksaUJBQXFCLFFBQXJCLEVBQStCLE9BQS9CLEVBQTJDO0FBQ3ZEO0FBQUEsc0JBRGUsY0FDZixTQURlLGNBQ2Y7O0FBQ0Msa0JBQUEsTUFBSSxDQUFDLE9BQUwsQ0FBYSxPQUFiLENBQ0Msd0JBREQsRUFFQztBQUNDLG9CQUFBLFdBQVcsRUFBRSxNQUFJLENBQUMsY0FBTCxDQUFvQixFQURsQztBQUVDLG9CQUFBLGNBQWMsRUFBZDtBQUZELG1CQUZELEVBTUUsSUFORixDQU1PLFFBTlAsV0FPUSxPQVBSO0FBUUEsaUJBWEQ7O0FBYUEscUJBQUssY0FBTCxDQUFvQixFQUFwQixDQUNDLFNBREQ7QUFBQSw0R0FDWSwwQkFBeUMsUUFBekMsRUFBbUQsT0FBbkQ7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFTLDRCQUFBLElBQVQsU0FBUyxJQUFULEVBQWUsYUFBZixTQUFlLGFBQWYsRUFBOEIsT0FBOUIsU0FBOEIsT0FBOUI7QUFBQTtBQUFBO0FBQUEsbUNBR1csTUFBSSxDQUFDLE9BQUwsQ0FBYSxPQUFiLENBQ3BCLFNBRG9CLEVBRXBCO0FBQ0MsOEJBQUEsV0FBVyxFQUFFLE1BQUksQ0FBQyxjQUFMLENBQW9CLEVBRGxDO0FBRUMsOEJBQUEsSUFBSSxFQUFKLElBRkQ7QUFHQyw4QkFBQSxhQUFhLEVBQWIsYUFIRDtBQUlDLDhCQUFBLE9BQU8sRUFBUDtBQUpELDZCQUZvQixDQUhYOztBQUFBO0FBQUE7QUFHRiw0QkFBQSxHQUhFLHlCQUdGLEVBSEU7QUFZViw0QkFBQSxRQUFRLENBQUM7QUFBRSw4QkFBQSxFQUFFLEVBQUY7QUFBRiw2QkFBRCxDQUFSO0FBWlU7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFlViw0QkFBQSxPQUFPLGVBQVA7O0FBZlU7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsbUJBRFo7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBb0JBLHFCQUFLLGNBQUwsQ0FBb0IsRUFBcEIsQ0FBdUIsYUFBdkI7QUFBQSw0R0FBc0MsMEJBT3JDLFFBUHFDLEVBUXJDLE9BUnFDO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFcEMsNEJBQUEsb0JBRm9DLFNBRXBDLG9CQUZvQyxFQUdwQyxLQUhvQyxTQUdwQyxLQUhvQyxFQUlwQyxRQUpvQyxTQUlwQyxRQUpvQyxFQUtwQyxPQUxvQyxTQUtwQyxPQUxvQztBQVVyQyw0QkFBQSxNQUFNLENBQUMsS0FBUCxDQUNDLDREQURELEVBRUMsb0JBRkQsRUFFdUIsT0FGdkI7QUFWcUM7QUFBQTtBQUFBLG1DQWdCZixNQUFJLENBQUMsT0FBTCxDQUFhLE9BQWIsQ0FDcEIsYUFEb0IsRUFFcEI7QUFDQyw4QkFBQSxXQUFXLEVBQUUsTUFBSSxDQUFDLGNBQUwsQ0FBb0IsRUFEbEM7QUFFQyw4QkFBQSxvQkFBb0IsRUFBcEIsb0JBRkQ7QUFHQyw4QkFBQSxLQUFLLEVBQUwsS0FIRDtBQUlDLDhCQUFBLFFBQVEsRUFBUixRQUpEO0FBS0MsOEJBQUEsT0FBTyxFQUFQO0FBTEQsNkJBRm9CLENBaEJlOztBQUFBO0FBQUE7QUFnQjVCLDRCQUFBLElBaEI0QiwwQkFnQjVCLEVBaEI0QjtBQTBCcEMsNEJBQUEsUUFBUSxDQUFDO0FBQUUsOEJBQUEsRUFBRSxFQUFGO0FBQUYsNkJBQUQsQ0FBUjtBQTFCb0M7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUE2QnBDLDRCQUFBLE9BQU8sZUFBUDs7QUE3Qm9DO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG1CQUF0Qzs7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFuR0g7QUFBQSxxQkFzSU0sS0FBSyxRQXRJWDtBQUFBO0FBQUE7QUFBQTs7QUFBQTtBQUFBLHVCQXVJK0IsS0FBSyxPQUFMLENBQWEsT0FBYixDQUMzQix1QkFEMkIsRUFFM0I7QUFDQyxrQkFBQSxRQUFRLEVBQUUsS0FBSyxTQURoQjtBQUVDLGtCQUFBLFNBQVMsRUFBRSxLQUZaO0FBR0Msa0JBQUEsU0FBUyxFQUFFLElBSFo7QUFJQyxrQkFBQSxnQkFBZ0IsRUFBRSxLQUFLLGVBQUwsR0FDZixLQUFLLGdCQUFMLENBQXNCLGdCQURQLEdBRWY7QUFOSixpQkFGMkIsQ0F2SS9COztBQUFBO0FBdUlTLGdCQUFBLGNBdklUO0FBbUpJLGdCQUFBLElBbkpKLEdBd0pPLGNBeEpQLENBbUpJLEVBbkpKLEVBb0pJLGVBcEpKLEdBd0pPLGNBeEpQLENBb0pJLGFBcEpKLEVBcUpJLGNBckpKLEdBd0pPLGNBeEpQLENBcUpJLGFBckpKLEVBc0pJLGVBdEpKLEdBd0pPLGNBeEpQLENBc0pJLGNBdEpKLEVBdUpJLGVBdkpKLEdBd0pPLGNBeEpQLENBdUpJLGNBdkpKO0FBMEpHLHFCQUFLLGNBQUwsR0FBc0IsS0FBSyxnQkFBTCxDQUFzQixtQkFBdEIsQ0FDckI7QUFDQyxrQkFBQSxFQUFFLEVBQUYsSUFERDtBQUVDLGtCQUFBLGFBQWEsRUFBYixlQUZEO0FBR0Msa0JBQUEsYUFBYSxFQUFiLGNBSEQ7QUFJQyxrQkFBQSxjQUFjLEVBQWQsZUFKRDtBQUtDLGtCQUFBLGNBQWMsRUFBZCxlQUxEO0FBTUMsa0JBQUEsVUFBVSxFQUFWO0FBTkQsaUJBRHFCLENBQXRCOztBQVVBLHFCQUFLLGNBQUwsQ0FBb0IsRUFBcEIsQ0FDQyxTQURELEVBQ1ksa0JBQXFCLFFBQXJCLEVBQStCLE9BQS9CLEVBQTJDO0FBQ3ZEO0FBQUEsc0JBRGUsY0FDZixVQURlLGNBQ2Y7O0FBQ0Msa0JBQUEsTUFBSSxDQUFDLE9BQUwsQ0FBYSxPQUFiLENBQ0Msd0JBREQsRUFFQztBQUNDLG9CQUFBLFdBQVcsRUFBRSxNQUFJLENBQUMsY0FBTCxDQUFvQixFQURsQztBQUVDLG9CQUFBLGNBQWMsRUFBZDtBQUZELG1CQUZELEVBTUUsSUFORixDQU1PLFFBTlAsV0FPUSxPQVBSO0FBUUEsaUJBWEQ7O0FBcEtIO0FBQUE7QUFBQSx1QkFvTFEsS0FBSyxPQUFMLENBQWEsT0FBYixDQUNMLE1BREssRUFFTDtBQUNDLGtCQUFBLFdBQVcsRUFBRSxLQUFLLE1BRG5CO0FBRUMsa0JBQUEsTUFBTSxFQUFFLEtBQUssT0FGZDtBQUdDLGtCQUFBLGVBQWUsRUFBRSxLQUFLLFFBQUwsR0FDZCxLQUFLLGdCQUFMLENBQXNCLGVBRFIsR0FFZCxTQUxKO0FBTUMsa0JBQUEsZ0JBQWdCLEVBQUUsS0FBSyxlQUFMLElBQXdCLEtBQUssUUFBN0IsR0FDZixLQUFLLGdCQUFMLENBQXNCLGdCQURQLEdBRWY7QUFSSixpQkFGSyxDQXBMUjs7QUFBQTtBQWlNRTtBQUNBLG9CQUFJLEtBQUssUUFBVCxFQUFtQjtBQUNsQjtBQUVBLHVCQUFLLFNBQUwsR0FIa0IsQ0FLbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFRCxtQ0FBTyxrQ0FBUCxDQUEwQyxLQUFLLE1BQS9DLEVBQXVELFdBQXZEOztBQTdNRjtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQWlORSxnQkFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLHVCQUFiO0FBRUEscUJBQUssS0FBTDs7QUFuTkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTzs7Ozs7Ozs7Ozs7MEdBdU5BLG1CQUFxQixRQUFyQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEscUJBQ0ssUUFBUSxDQUFDLE1BRGQ7QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUEsdUJBS1EsS0FBSyxPQUFMLENBQWEsT0FBYixDQUFxQixlQUFyQixFQUFzQztBQUFFLGtCQUFBLFVBQVUsRUFBRSxRQUFRLENBQUM7QUFBdkIsaUJBQXRDLENBTFI7O0FBQUE7QUFPRSxnQkFBQSxRQUFRLENBQUMsS0FBVDtBQVBGO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBVUUsZ0JBQUEsTUFBTSxDQUFDLEtBQVAsQ0FBYSw4QkFBYjs7QUFWRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPOzs7Ozs7Ozs7OzsyR0FjQSxtQkFBc0IsUUFBdEI7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLG9CQUNNLFFBQVEsQ0FBQyxNQURmO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBLHVCQUtRLEtBQUssT0FBTCxDQUFhLE9BQWIsQ0FBcUIsZ0JBQXJCLEVBQXVDO0FBQUUsa0JBQUEsVUFBVSxFQUFFLFFBQVEsQ0FBQztBQUF2QixpQkFBdkMsQ0FMUjs7QUFBQTtBQU9FLGdCQUFBLFFBQVEsQ0FBQyxNQUFUO0FBUEY7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFVRSxnQkFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLCtCQUFiOztBQVZGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE87Ozs7Ozs7Ozs7OzBHQWNBLG1CQUFxQixRQUFyQixFQUErQixNQUEvQjtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsc0JBQ0ssQ0FBQyxRQUFELElBQWEsUUFBUSxDQUFDLE1BRDNCO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBSUMsb0JBQUk7QUFDSCx1QkFBSyxPQUFMLENBQWEsT0FBYixDQUFxQixlQUFyQixFQUFzQztBQUFFLG9CQUFBLFVBQVUsRUFBRSxRQUFRLENBQUM7QUFBdkIsbUJBQXRDLEVBQ0UsSUFERixDQUNPLFlBQU07QUFDWCx1Q0FBTywwQ0FBUCxDQUNDLE1BQUksQ0FBQyxNQUROLEVBRUMsTUFGRCxFQUdDLElBSEQ7O0FBS0Esb0JBQUEsUUFBUSxDQUFDLEtBQVQ7O0FBQ0Esb0JBQUEsTUFBSSxDQUFDLG1CQUFMLENBQXlCLFFBQVEsQ0FBQyxFQUFsQzs7QUFDQSxvQkFBQSxNQUFJLENBQUMsTUFBTCxXQUFtQixRQUFRLENBQUMsTUFBNUI7O0FBQ0Esb0JBQUEsTUFBSSxDQUFDLFVBQUwsV0FBdUIsUUFBUSxDQUFDLEVBQWhDO0FBQ0EsbUJBWEYsV0FZUSxVQUFDLEdBQUQsRUFBUztBQUNmO0FBQ0Esb0JBQUEsTUFBTSxDQUFDLEtBQVAsQ0FBYSwrQkFBYixFQUE4QyxNQUE5QyxFQUFzRCxHQUF0RDs7QUFDQSx1Q0FBTywwQ0FBUCxDQUFrRCxNQUFJLENBQUMsTUFBdkQsRUFBK0QsTUFBL0QsRUFBdUUsS0FBdkU7QUFDQSxtQkFoQkY7QUFpQkEsaUJBbEJELENBbUJBLE9BQU8sS0FBUCxFQUFjO0FBQ2Isa0JBQUEsTUFBTSxDQUFDLEtBQVAsQ0FBYSw4QkFBYixFQUE2QyxLQUE3QztBQUNBOztBQXpCRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPOzs7Ozs7Ozs7Ozs2R0E0QkEsbUJBQXdCLFVBQXhCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVPLGdCQUFBLFFBRlAsR0FFa0IsS0FBSyxVQUFMLENBQWdCLEdBQWhCLENBQW9CLFVBQXBCLENBRmxCO0FBR08sZ0JBQUEsTUFIUCxHQUdnQixJQUFJLFdBQUosRUFIaEI7QUFLTyxnQkFBQSxLQUxQLEdBS2UsSUFBSSxLQUFKLEVBTGY7QUFPQyxnQkFBQSxLQUFLLENBQUMsUUFBTixHQUFpQixLQUFqQjtBQUNBLGdCQUFBLEtBQUssQ0FBQyxNQUFOLEdBQWUsQ0FBZjtBQUVBLGdCQUFBLE1BQU0sQ0FBQyxRQUFQLENBQWdCLFFBQVEsQ0FBQyxLQUF6QjtBQUVBLGdCQUFBLEtBQUssQ0FBQyxTQUFOLEdBQWtCLE1BQWxCO0FBRU0sZ0JBQUEsTUFkUCxHQWNnQixLQUFLLFlBQUwsQ0FBa0IsdUJBQWxCLENBQTBDLE1BQTFDLENBZGhCLEVBZ0JDOztBQUNBLGdCQUFBLFFBQVEsQ0FBQyxRQUFULEdBQW9CLEtBQUssWUFBTCxDQUFrQixVQUFsQixFQUFwQjtBQUNBLGdCQUFBLE1BQU0sQ0FBQyxPQUFQLENBQWUsUUFBUSxDQUFDLFFBQXhCLEVBbEJELENBbUJDOztBQUNBLGdCQUFBLFFBQVEsQ0FBQyxRQUFULENBQWtCLElBQWxCLENBQXVCLGNBQXZCLENBQXNDLENBQXRDLEVBQXlDLEtBQUssWUFBTCxDQUFrQixXQUEzRCxFQXBCRCxDQXNCQzs7QUFDTSxnQkFBQSxNQXZCUCxHQXVCZ0IsS0FBSyxZQUFMLENBQWtCLFlBQWxCLEVBdkJoQjtBQXlCQyxnQkFBQSxRQUFRLENBQUMsTUFBVCxHQUFrQixNQUFsQjtBQUNBLGdCQUFBLFFBQVEsQ0FBQyxRQUFULENBQWtCLE9BQWxCLENBQTBCLFFBQVEsQ0FBQyxNQUFuQztBQUNBLGdCQUFBLFFBQVEsQ0FBQyxNQUFULENBQWdCLE9BQWhCLENBQXdCLEtBQUssVUFBN0I7QUFDQSxnQkFBQSxRQUFRLENBQUMsTUFBVCxDQUFnQixjQUFoQixDQUErQixDQUEvQixFQUFrQyxDQUFsQyxFQUFxQyxDQUFyQztBQUVBLGdCQUFBLFFBQVEsQ0FBQyxZQUFULEdBQXdCLE1BQXhCO0FBQ0EsZ0JBQUEsUUFBUSxDQUFDLFdBQVQsR0FBdUIsS0FBdkI7QUFDQSxnQkFBQSxRQUFRLENBQUMsaUJBQVQsR0FBNkIsUUFBUSxDQUFDLE1BQXRDO0FBQ0EsZ0JBQUEsUUFBUSxDQUFDLGlCQUFULEdBQTZCLFFBQVEsQ0FBQyxNQUF0QyxDQWpDRCxDQW1DQzs7QUFuQ0Q7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTzs7Ozs7Ozs7Ozs7K0dBc0NBLG1CQUEwQixVQUExQjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDTyxnQkFBQSxRQURQLEdBQ2tCLEtBQUssVUFBTCxDQUFnQixHQUFoQixDQUFvQixVQUFwQixDQURsQjs7QUFBQSxvQkFHTSxRQUhOO0FBQUE7QUFBQTtBQUFBOztBQUFBOztBQUFBO0FBS0Msb0JBQUksUUFBUSxDQUFDLFlBQWIsRUFBMkI7QUFDMUIsc0JBQUksUUFBUSxDQUFDLFlBQVQsQ0FBc0IsZUFBdEIsR0FBd0MsQ0FBNUMsRUFBK0M7QUFDOUMsb0JBQUEsUUFBUSxDQUFDLFlBQVQsQ0FBc0IsVUFBdEIsQ0FBaUMsUUFBUSxDQUFDLFFBQTFDO0FBQ0E7O0FBQ0Qsc0JBQUksUUFBUSxDQUFDLFFBQVQsQ0FBa0IsZUFBbEIsR0FBb0MsQ0FBeEMsRUFBMkM7QUFDMUMsb0JBQUEsUUFBUSxDQUFDLFFBQVQsQ0FBa0IsVUFBbEIsQ0FBNkIsUUFBUSxDQUFDLE1BQXRDO0FBQ0E7O0FBQ0Qsc0JBQUksUUFBUSxDQUFDLE1BQVQsQ0FBZ0IsZUFBaEIsR0FBa0MsQ0FBdEMsRUFBeUM7QUFDeEMsb0JBQUEsUUFBUSxDQUFDLE1BQVQsQ0FBZ0IsVUFBaEIsQ0FBMkIsS0FBSyxVQUFoQztBQUNBO0FBQ0Q7O0FBRUQsb0JBQUksUUFBUSxJQUFJLFFBQVEsQ0FBQyxZQUF6QixFQUF1QztBQUN0QyxrQkFBQSxRQUFRLENBQUMsWUFBVCxDQUFzQixNQUF0QjtBQUNBOztBQW5CRjtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxPOzs7Ozs7Ozs7Ozs0R0FzQkEsbUJBQXVCLE1BQXZCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDQyxvQkFBSSxDQUFDLEtBQUssQ0FBQyxNQUFELENBQVYsRUFDQyxLQUFLLFVBQUwsQ0FBZ0IsSUFBaEIsQ0FBcUIsY0FBckIsQ0FBb0MsTUFBcEMsRUFBNEMsS0FBSyxZQUFMLENBQWtCLFdBQTlEOztBQUZGO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE87Ozs7Ozs7Ozs7O2dIQUtBLG1CQUEyQixNQUEzQixFQUFtQyxNQUFuQyxFQUEyQyxPQUEzQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDTyxnQkFBQSxVQURQLEdBQ29CLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0IsTUFBaEIsQ0FEcEI7O0FBQUEsb0JBR00sVUFITjtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUtPLGdCQUFBLFFBTFAsR0FLa0IsS0FBSyxVQUFMLENBQWdCLEdBQWhCLENBQW9CLFVBQXBCLENBTGxCOztBQUFBLG9CQU9NLFFBUE47QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFTQyxvQkFBSSxRQUFRLENBQUMsWUFBYixFQUEyQjtBQUMxQixrQkFBQSxRQUFRLENBQUMsWUFBVCxDQUFzQixNQUF0QixHQUErQixNQUEvQjtBQUNBOztBQUVELG9CQUFJLFFBQVEsQ0FBQyxRQUFULElBQXFCLENBQUMsS0FBSyxDQUFDLE1BQUQsQ0FBL0IsRUFBeUM7QUFDeEMsa0JBQUEsUUFBUSxDQUFDLFFBQVQsQ0FBa0IsSUFBbEIsQ0FBdUIsY0FBdkIsQ0FBc0MsTUFBdEMsRUFBOEMsS0FBSyxZQUFMLENBQWtCLFdBQWhFO0FBQ0Esa0JBQUEsUUFBUSxDQUFDLE1BQVQsR0FBa0IsTUFBbEI7QUFDQTs7QUFFRCxvQkFBSSxRQUFRLENBQUMsTUFBVCxJQUFtQixDQUFDLEtBQUssQ0FBQyxPQUFELENBQTdCLEVBQXdDO0FBQ3ZDLGtCQUFBLFFBQVEsQ0FBQyxNQUFULENBQWdCLFdBQWhCLENBQTRCLE9BQTVCLEVBQXFDLENBQXJDLEVBQXlDLElBQUksSUFBSSxDQUFDLEdBQUwsQ0FBUyxPQUFULENBQTdDO0FBQ0Esa0JBQUEsUUFBUSxDQUFDLE9BQVQsR0FBbUIsT0FBbkI7QUFDQTs7QUFyQkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTzs7Ozs7Ozs7Ozs7aUhBd0JBLG1CQUE0QixLQUE1QjtBQUFBOztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQ0MsZ0JBQUEsS0FBSyxHQUFHLE9BQU8sS0FBUCxLQUFpQixRQUFqQixHQUE0QixJQUFJLENBQUMsS0FBTCxDQUFXLEtBQVgsQ0FBNUIsR0FBZ0QsS0FBeEQ7QUFFQSxnQkFBQSxLQUFLLENBQUMsT0FBTixDQUFjLFVBQUMsSUFBRCxFQUFVO0FBQ3ZCLHNCQUFJLElBQUosRUFBVTtBQUNULG9CQUFBLE1BQUksQ0FBQyxvQkFBTCxDQUEwQixJQUFJLENBQUMsSUFBL0IsRUFBcUMsSUFBSSxDQUFDLE1BQTFDLEVBQWtELElBQUksQ0FBQyxPQUF2RDs7QUFDQSx3QkFBSSxJQUFJLENBQUMsWUFBVCxFQUF1QjtBQUN0QixzQkFBQSxNQUFJLENBQUMseUJBQUwsQ0FBK0IsSUFBSSxDQUFDLElBQXBDO0FBQ0E7O0FBQ0Qsd0JBQUksSUFBSSxDQUFDLE9BQVQsRUFBa0I7QUFDakIsc0JBQUEsTUFBSSxDQUFDLHVCQUFMLENBQTZCLElBQUksQ0FBQyxJQUFsQyxFQUF3QyxJQUFJLENBQUMsT0FBN0M7QUFDQTtBQUNEO0FBQ0QsaUJBVkQ7O0FBSEQ7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTzs7Ozs7Ozs7Ozs7cUhBZ0JBLG1CQUFnQyxNQUFoQztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDTyxnQkFBQSxVQURQLEdBQ29CLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0IsTUFBaEIsQ0FEcEI7O0FBQUEsb0JBR00sVUFITjtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUtPLGdCQUFBLFFBTFAsR0FLa0IsS0FBSyxVQUFMLENBQWdCLEdBQWhCLENBQW9CLFVBQXBCLENBTGxCOztBQUFBLG9CQU9NLFFBUE47QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQSxvQkFTTSxRQUFRLENBQUMsT0FUZjtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQVdDLG9CQUFJLFFBQVEsQ0FBQyxpQkFBVCxDQUEyQixlQUEzQixHQUE2QyxDQUFqRCxFQUFvRDtBQUNuRCxrQkFBQSxRQUFRLENBQUMsaUJBQVQsQ0FBMkIsVUFBM0IsQ0FBc0MsS0FBSyxVQUEzQztBQUVBLGtCQUFBLFFBQVEsQ0FBQyxpQkFBVCxHQUE2QixRQUFRLENBQUMsaUJBQXRDO0FBQ0Esa0JBQUEsUUFBUSxDQUFDLGlCQUFULENBQTJCLE9BQTNCLENBQW1DLEtBQUssVUFBeEM7QUFFQSx5QkFBTyxRQUFRLENBQUMsT0FBaEI7QUFDQTs7QUFsQkY7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsTzs7Ozs7Ozs7OztXQXFCQSw2QkFBb0IsTUFBcEIsRUFBNEI7QUFDM0IsVUFBTSxDQUFDLEdBQUcsT0FBTyxNQUFQLEtBQWtCLFFBQWxCLEdBQTZCLE1BQTdCLEdBQXNDLEVBQWhEO0FBQ0EsVUFBTSxRQUFRLEdBQUcsS0FBakI7QUFDQSxVQUFNLEtBQUssR0FBRyxJQUFJLFlBQUosQ0FBaUIsUUFBakIsQ0FBZDtBQUNBLFVBQU0sR0FBRyxHQUFHLElBQUksQ0FBQyxFQUFMLEdBQVUsR0FBdEI7QUFDQSxVQUFJLENBQUMsR0FBRyxDQUFSO0FBQ0EsVUFBSSxDQUFKOztBQUVBLGFBQU8sQ0FBQyxHQUFHLFFBQVgsRUFBcUIsRUFBRSxDQUF2QixFQUEwQjtBQUN6QixRQUFBLENBQUMsR0FBSSxDQUFDLEdBQUcsQ0FBSixHQUFRLFFBQVQsR0FBcUIsQ0FBekI7QUFDQSxRQUFBLEtBQUssQ0FBQyxDQUFELENBQUwsR0FBVyxDQUFDLElBQUksQ0FBTCxJQUFVLENBQVYsR0FBYyxFQUFkLEdBQW1CLEdBQW5CLElBQTBCLElBQUksQ0FBQyxFQUFMLEdBQVcsQ0FBQyxHQUFHLElBQUksQ0FBQyxHQUFMLENBQVMsQ0FBVCxDQUF6QyxDQUFYO0FBQ0E7O0FBRUQsYUFBTyxLQUFQO0FBQ0E7Ozs7bUhBRUQsbUJBQThCLE1BQTlCLEVBQXNDLE9BQXRDO0FBQUE7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFDTyxnQkFBQSxVQURQLEdBQ29CLEtBQUssTUFBTCxDQUFZLEdBQVosQ0FBZ0IsTUFBaEIsQ0FEcEI7O0FBQUEsb0JBR00sVUFITjtBQUFBO0FBQUE7QUFBQTs7QUFBQTs7QUFBQTtBQUtPLGdCQUFBLFFBTFAsR0FLa0IsS0FBSyxVQUFMLENBQWdCLEdBQWhCLENBQW9CLFVBQXBCLENBTGxCOztBQUFBLG9CQU9NLFFBUE47QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFTTyxnQkFBQSxNQVRQLEdBU2dCLE1BQU0sQ0FBQyxNQUFQLENBQWMsT0FBZCxDQVRoQjtBQVVLLGdCQUFBLGNBVkwsR0FVc0IsS0FWdEI7QUFBQSxrQ0FZc0IsTUFadEI7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTs7QUFZWSxnQkFBQSxNQVpaO0FBYUUsb0JBQUksQ0FBQyxRQUFRLENBQUMsT0FBZCxFQUF1QixRQUFRLENBQUMsT0FBVCxHQUFtQixFQUFuQjs7QUFiekIscUJBY00sUUFBUSxDQUFDLE9BQVQsQ0FBaUIsTUFBTSxDQUFDLElBQXhCLENBZE47QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUFBQSxnQ0FpQlUsTUFBTSxDQUFDLElBakJqQjtBQUFBLG9EQWtCUSxRQWxCUiwwQkFtQ1EsWUFuQ1IsMEJBa0RRLFlBbERSO0FBQUE7O0FBQUE7QUFvQlcsZ0JBQUEsTUFwQlgsR0FvQm9CLFFBQVEsQ0FBQyxPQUFULENBQWlCLE1BQU0sQ0FBQyxJQUF4QixLQUNkLEtBQUssWUFBTCxDQUFrQixrQkFBbEIsRUFyQk47QUF1QkssZ0JBQUEsTUFBTSxDQUFDLElBQVAsR0FBYyxNQUFNLENBQUMsSUFBUCxDQUFZLElBQTFCO0FBRUEsb0JBQUksQ0FBQyxLQUFLLENBQUMsTUFBTSxDQUFDLElBQVAsQ0FBWSxTQUFaLENBQXNCLEtBQXZCLENBQVYsRUFDQyxNQUFNLENBQUMsU0FBUCxDQUFpQixLQUFqQixHQUF5QixNQUFNLENBQUMsSUFBUCxDQUFZLFNBQVosQ0FBc0IsS0FBL0M7QUFFRCxnQkFBQSxRQUFRLENBQUMsT0FBVCxDQUFpQixNQUFNLENBQUMsSUFBeEIsSUFBZ0MsTUFBaEM7QUFFQSxnQkFBQSxjQUFjLEdBQUcsSUFBakI7QUE5Qkw7O0FBQUE7QUFxQ1csZ0JBQUEsT0FyQ1gsR0FxQ29CLFFBQVEsQ0FBQyxPQUFULENBQWlCLE1BQU0sQ0FBQyxJQUF4QixLQUNkLEtBQUssWUFBTCxDQUFrQix3QkFBbEIsRUF0Q04sRUF3Q0s7QUFDQTs7QUFFQSxnQkFBQSxRQUFRLENBQUMsT0FBVCxDQUFpQixNQUFNLENBQUMsSUFBeEIsSUFBZ0MsT0FBaEM7QUFFQSxnQkFBQSxjQUFjLEdBQUcsSUFBakI7QUE3Q0w7O0FBQUE7QUFvRFcsZ0JBQUEsUUFwRFgsR0FvRG9CLFFBQVEsQ0FBQyxPQUFULENBQWlCLE1BQU0sQ0FBQyxJQUF4QixLQUNkLEtBQUssWUFBTCxDQUFrQixnQkFBbEIsRUFyRE47QUF1REssZ0JBQUEsUUFBTSxDQUFDLEtBQVAsR0FBZSxLQUFLLG1CQUFMLEVBQWYsQ0F2REwsQ0F5REs7QUFDQTs7QUFFQSxnQkFBQSxRQUFRLENBQUMsT0FBVCxDQUFpQixNQUFNLENBQUMsSUFBeEIsSUFBZ0MsUUFBaEM7QUFFQSxnQkFBQSxjQUFjLEdBQUcsSUFBakI7QUE5REw7O0FBQUE7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUFBQSxvQkF1RU0sY0F2RU47QUFBQTtBQUFBO0FBQUE7O0FBQUE7O0FBQUE7QUF5RUMsZ0JBQUEsUUFBUSxDQUFDLGlCQUFULENBQTJCLFVBQTNCLENBQXNDLEtBQUssVUFBM0M7O0FBSUEsK0NBQXFCLE1BQU0sQ0FBQyxNQUFQLENBQWMsUUFBUSxDQUFDLE9BQXZCLENBQXJCLHNDQUFzRDtBQUEzQyxrQkFBQSxPQUEyQzs7QUFDckQsc0JBQUksQ0FBQyxZQUFMLEVBQW1CO0FBQ2xCLG9CQUFBLFFBQVEsQ0FBQyxpQkFBVCxDQUEyQixPQUEzQixDQUFtQyxPQUFuQztBQUNBLG1CQUZELE1BR0s7QUFDSixvQkFBQSxZQUFZLENBQUMsT0FBYixDQUFxQixPQUFyQjtBQUNBOztBQUVELGtCQUFBLFlBQVksR0FBRyxPQUFmO0FBQ0E7O0FBRUQsZ0JBQUEsUUFBUSxDQUFDLGlCQUFULEdBQTZCLFlBQTdCO0FBQ0EsZ0JBQUEsUUFBUSxDQUFDLGlCQUFULENBQTJCLE9BQTNCLENBQW1DLEtBQUssVUFBeEMsRUF6RkQsQ0EyRkM7O0FBM0ZEO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBLE87Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQ3hqQ0Q7O0FBRUE7QUFDQSxNQUFNLENBQUMsTUFBUCxHQUFnQixrQkFBaEI7O0FBRWUsb0JBQ2Y7QUFDQyxNQUFNLEVBQUUsR0FBRyxTQUFTLENBQUMsU0FBckI7O0FBQ0EsTUFBTSxPQUFPLEdBQUcsbUJBQU8sU0FBUCxDQUFpQixFQUFqQixDQUFoQjs7QUFDQSxNQUFJLElBQUo7QUFFQSxNQUFJLE9BQU8sQ0FBQyxTQUFSLENBQWtCO0FBQUUsSUFBQSxNQUFNLEVBQUUsS0FBVjtBQUFpQixJQUFBLFFBQVEsRUFBRTtBQUEzQixHQUFsQixDQUFKLEVBQ0MsSUFBSSxHQUFHLFFBQVAsQ0FERCxLQUVLLElBQUksT0FBTyxDQUFDLFNBQVIsQ0FBa0I7QUFBRSxJQUFBLE9BQU8sRUFBRTtBQUFYLEdBQWxCLENBQUosRUFDSixJQUFJLEdBQUcsU0FBUCxDQURJLEtBRUEsSUFBSSxPQUFPLENBQUMsU0FBUixDQUFrQjtBQUFFLElBQUEsTUFBTSxFQUFFO0FBQVYsR0FBbEIsQ0FBSixFQUNKLElBQUksR0FBRyxRQUFQLENBREksS0FFQSxJQUFJLE9BQU8sQ0FBQyxTQUFSLENBQWtCO0FBQUUsSUFBQSxLQUFLLEVBQUU7QUFBVCxHQUFsQixDQUFKLEVBQ0osSUFBSSxHQUFHLE9BQVAsQ0FESSxLQUVBLElBQUksT0FBTyxDQUFDLFNBQVIsQ0FBa0I7QUFBRSxzQkFBa0I7QUFBcEIsR0FBbEIsQ0FBSixFQUNKLElBQUksR0FBRyxNQUFQLENBREksS0FHSixJQUFJLEdBQUcsU0FBUDtBQUVELFNBQU87QUFDTixJQUFBLElBQUksRUFBSixJQURNO0FBRU4sSUFBQSxJQUFJLEVBQU0sT0FBTyxDQUFDLGNBQVIsRUFGSjtBQUdOLElBQUEsT0FBTyxFQUFHLE9BQU8sQ0FBQyxpQkFBUjtBQUhKLEdBQVA7QUFLQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUM3QkQ7QUFDQTtBQUNBO0FBQ0EsSUFBTSxRQUFRLEdBQUcsSUFBSSxHQUFKLEVBQWpCOztBQUVBLElBQU0sV0FBVyxHQUFHLFNBQWQsV0FBYyxDQUFDLFNBQUQsRUFBWSxhQUFaLEVBQ3BCO0FBQ0MsTUFBSSxRQUFRLENBQUMsR0FBVCxDQUFhLFNBQWIsQ0FBSixFQUNBO0FBQ0MsUUFBTSxLQUFLLEdBQUcsUUFBUSxDQUFDLEdBQVQsQ0FBYSxTQUFiLENBQWQ7O0FBRUEsUUFBSSxDQUFDLEtBQUssQ0FBQyxHQUFOLENBQVUsYUFBVixDQUFMLEVBQ0E7QUFDQyxNQUFBLEtBQUssQ0FBQyxHQUFOLENBQVUsYUFBVjtBQUNBO0FBQ0QsR0FSRCxNQVVBO0FBQ0MsSUFBQSxRQUFRLENBQUMsR0FBVCxDQUFhLFNBQWIsRUFBd0IsSUFBSSxHQUFKLENBQVEsQ0FBRSxhQUFGLENBQVIsQ0FBeEI7QUFDQTtBQUNELENBZkQ7O0FBaUJBLElBQU0sU0FBUyxHQUFHLFNBQVosU0FBWSxDQUFDLFNBQUQsRUFDbEI7QUFBQSxvQ0FEaUMsSUFDakM7QUFEaUMsSUFBQSxJQUNqQztBQUFBOztBQUNDLE1BQUksUUFBUSxDQUFDLEdBQVQsQ0FBYSxTQUFiLENBQUosRUFDQTtBQUNDLFFBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxHQUFULENBQWEsU0FBYixDQUFkOztBQUVBLElBQUEsS0FBSyxDQUFDLE9BQU4sQ0FBYyxVQUFDLGFBQUQsRUFDZDtBQUNDLE1BQUEsYUFBYSxNQUFiLFNBQWlCLElBQWpCO0FBQ0EsS0FIRDtBQUlBO0FBQ0QsQ0FYRDs7QUFhQSxJQUFNLFdBQVcsR0FBRyxTQUFkLFdBQWMsQ0FBQyxTQUFELEVBQVksYUFBWixFQUNwQjtBQUNDLE1BQUksUUFBUSxDQUFDLEdBQVQsQ0FBYSxTQUFiLENBQUosRUFDQTtBQUNDLFFBQU0sS0FBSyxHQUFHLFFBQVEsQ0FBQyxHQUFULENBQWEsU0FBYixDQUFkOztBQUVBLFFBQUksS0FBSyxDQUFDLEdBQU4sQ0FBVSxhQUFWLENBQUosRUFDQTtBQUNDLE1BQUEsS0FBSyxVQUFMLENBQWEsYUFBYjtBQUNBLEtBSEQsTUFLQTtBQUNDLE1BQUEsS0FBSyxDQUFDLEtBQU47QUFDQTtBQUNEO0FBQ0QsQ0FmRDs7QUFpQkEsSUFBTSxhQUFhLEdBQUcsU0FBaEIsYUFBZ0IsQ0FBQyxTQUFELEVBQVksSUFBWixFQUN0QjtBQUNDLEVBQUEsSUFBSSxxQkFBUSxJQUFSLENBQUosQ0FERCxDQUdDO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxNQUFNLEdBQUcsR0FBRyxJQUFJLGNBQUosRUFBWjtBQUNBLEVBQUEsR0FBRyxDQUFDLElBQUosQ0FBUyxNQUFULG9CQUE0QixTQUE1QjtBQUNBLEVBQUEsR0FBRyxDQUFDLElBQUosQ0FBUyxJQUFJLENBQUMsU0FBTCxDQUFlLElBQWYsQ0FBVDtBQUNBLENBbEJEOztBQW9CQSxJQUFNLGtDQUFrQyxHQUFHLFNBQXJDLGtDQUFxQyxDQUFDLE1BQUQsRUFBUyxLQUFULEVBQzNDO0FBQ0MsRUFBQSxhQUFhLENBQUMsK0JBQUQsRUFBa0M7QUFBRSxJQUFBLE1BQU0sRUFBTixNQUFGO0FBQVUsSUFBQSxLQUFLLEVBQUw7QUFBVixHQUFsQyxDQUFiO0FBQ0EsQ0FIRDs7QUFLQSxJQUFNLHFDQUFxQyxHQUFHLFNBQXhDLHFDQUF3QyxDQUFDLE1BQUQsRUFBUyxRQUFULEVBQW1CLE1BQW5CLEVBQzlDO0FBQ0MsRUFBQSxhQUFhLENBQUMsa0NBQUQsRUFBcUM7QUFBRSxJQUFBLE1BQU0sRUFBTixNQUFGO0FBQVUsSUFBQSxRQUFRLEVBQVIsUUFBVjtBQUFvQixJQUFBLE1BQU0sRUFBTjtBQUFwQixHQUFyQyxDQUFiO0FBQ0EsQ0FIRDs7QUFLQSxJQUFNLDBDQUEwQyxHQUFHLFNBQTdDLDBDQUE2QyxDQUFDLE1BQUQsRUFBUyxRQUFULEVBQW1CLE1BQW5CLEVBQ25EO0FBQ0MsRUFBQSxhQUFhLENBQUMsdUNBQUQsRUFBMEM7QUFBRSxJQUFBLE1BQU0sRUFBTixNQUFGO0FBQVUsSUFBQSxRQUFRLEVBQVIsUUFBVjtBQUFvQixJQUFBLE1BQU0sRUFBTjtBQUFwQixHQUExQyxDQUFiO0FBQ0EsQ0FIRDs7QUFLQSxJQUFNLGlDQUFpQyxHQUFHLFNBQXBDLGlDQUFvQyxDQUFDLE1BQUQsRUFDMUM7QUFDQyxFQUFBLGFBQWEsQ0FBQyw4QkFBRCxFQUFpQztBQUFFLElBQUEsTUFBTSxFQUFOO0FBQUYsR0FBakMsQ0FBYjtBQUNBLENBSEQ7O0FBS0EsSUFBTSxpQ0FBaUMsR0FBRyxTQUFwQyxpQ0FBb0MsQ0FBQyxNQUFELEVBQVMsUUFBVCxFQUFtQixNQUFuQixFQUMxQztBQUNDLEVBQUEsYUFBYSxDQUFDLDhCQUFELEVBQWlDO0FBQUUsSUFBQSxNQUFNLEVBQU4sTUFBRjtBQUFVLElBQUEsUUFBUSxFQUFSLFFBQVY7QUFBb0IsSUFBQSxNQUFNLEVBQU47QUFBcEIsR0FBakMsQ0FBYjtBQUNBLENBSEQ7O0FBS0EsSUFBTSxrQ0FBa0MsR0FBRyxTQUFyQyxrQ0FBcUMsQ0FBQyxNQUFELEVBQVMsU0FBVCxFQUMzQztBQUNDLEVBQUEsYUFBYSxDQUFDLCtCQUFELEVBQWtDO0FBQUUsSUFBQSxNQUFNLEVBQU4sTUFBRjtBQUFVLElBQUEsU0FBUyxFQUFUO0FBQVYsR0FBbEMsQ0FBYjtBQUNBLENBSEQ7O0FBS0EsSUFBTSw4QkFBOEIsR0FBRyxTQUFqQyw4QkFBaUMsQ0FBQyxNQUFELEVBQVMsUUFBVCxFQUFtQixTQUFuQixFQUN2QztBQUNDLEVBQUEsYUFBYSxDQUFDLDBCQUFELEVBQTZCO0FBQUUsSUFBQSxNQUFNLEVBQU4sTUFBRjtBQUFVLElBQUEsUUFBUSxFQUFSLFFBQVY7QUFBb0IsSUFBQSxTQUFTLEVBQVQ7QUFBcEIsR0FBN0IsQ0FBYjtBQUNBLENBSEQ7O0FBS0EsTUFBTSxDQUFDLGdCQUFQLENBQXdCLFNBQXhCLEVBQW1DLFVBQUMsS0FBRCxFQUNuQztBQUNDLE1BQU0sSUFBSSxHQUFHLEtBQUssQ0FBQyxJQUFuQjs7QUFFQSxNQUFJLFFBQVEsQ0FBQyxHQUFULENBQWEsSUFBSSxDQUFDLElBQWxCLENBQUosRUFDQTtBQUNDLFFBQU0sSUFBSSxHQUFHLElBQUksQ0FBQyxJQUFMLElBQWEsRUFBMUI7QUFFQSxJQUFBLFNBQVMsTUFBVCxVQUFVLElBQUksQ0FBQyxJQUFmLDZDQUF3QixJQUF4QjtBQUNBO0FBQ0QsQ0FWRDtlQVllO0FBQ2QsRUFBQSxFQUFFLEVBQU8sV0FESztBQUVkLEVBQUEsSUFBSSxFQUFLLFNBRks7QUFHZCxFQUFBLE1BQU0sRUFBRyxXQUhLO0FBSWQsRUFBQSxrQ0FBa0MsRUFBbEMsa0NBSmM7QUFLZCxFQUFBLHFDQUFxQyxFQUFyQyxxQ0FMYztBQU1kLEVBQUEsMENBQTBDLEVBQTFDLDBDQU5jO0FBT2QsRUFBQSxpQ0FBaUMsRUFBakMsaUNBUGM7QUFRZCxFQUFBLGlDQUFpQyxFQUFqQyxpQ0FSYztBQVNkLEVBQUEsa0NBQWtDLEVBQWxDLGtDQVRjO0FBVWQsRUFBQSw4QkFBOEIsRUFBOUIsOEJBVmM7QUFXZCxFQUFBLFFBQVEsRUFBUjtBQVhjLEM7Ozs7Ozs7Ozs7Ozs7O0FDdkhmOztBQUNBOztBQUVBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQUNBOztBQU5BO0FBUUEsSUFBTSxNQUFNLEdBQUcsSUFBSSxrQkFBSixFQUFmLEMsQ0FFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFFQTtBQUNBOztBQUVBLElBQU0sS0FBSyxHQUFHLEVBQWQ7QUFFQSxzSEFBUztBQUFBO0FBQUE7QUFBQTtBQUFBO0FBRVIsVUFBQSxNQUFNLENBQUMsS0FBUCxDQUFhLFdBQWI7QUFGUTtBQUFBLGlCQUlGLEtBQUssQ0FBQyxVQUFOLEVBSkU7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsQ0FBVDs7U0FTZSxHOzs7Ozt1RkFBZixrQkFBbUIsTUFBbkIsRUFBMkIsTUFBM0I7QUFBQTs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUVDLFlBQUEsTUFBTSxDQUFDLEtBQVAsQ0FBYSx3QkFBYixFQUF1QyxPQUFPLENBQUMsR0FBUixDQUFZLFFBQW5EO0FBRU0sWUFBQSxTQUpQLEdBSW1CLElBQUksb0JBQUosQ0FBYSxNQUFNLENBQUMsUUFBUCxDQUFnQixJQUE3QixFQUFtQyxJQUFuQyxDQUpuQixFQUtDO0FBQ0E7O0FBQ00sWUFBQSxPQVBQLEdBT2lCLFNBQVMsQ0FBQyxLQUFWLENBQWdCLE9BUGpDO0FBUU8sWUFBQSxZQVJQLEdBUXNCLFNBQVMsQ0FBQyxLQUFWLENBQWdCLFNBQWhCLEtBQThCLE9BUnBEO0FBU08sWUFBQSxRQVRQLEdBU2tCLFNBQVMsQ0FBQyxLQUFWLENBQWdCLFFBQWhCLEtBQTZCLE1BVC9DO0FBVU8sWUFBQSxPQVZQLEdBVWlCLFNBQVMsQ0FBQyxLQUFWLENBQWdCLE9BQWhCLEtBQTRCLE9BVjdDO0FBV08sWUFBQSxPQVhQLEdBV2lCLFNBQVMsQ0FBQyxLQUFWLENBQWdCLE9BQWhCLEtBQTRCLE9BWDdDO0FBWU8sWUFBQSxTQVpQLEdBWW1CLFNBQVMsQ0FBQyxLQUFWLENBQWdCLFNBQWhCLEtBQThCLE1BWmpEO0FBYU8sWUFBQSxRQWJQLEdBYWtCLFNBQVMsQ0FBQyxLQUFWLENBQWdCLFFBQWhCLEtBQTZCLE1BYi9DO0FBY08sWUFBQSxXQWRQLEdBY3FCLFNBQVMsQ0FBQyxLQUFWLENBQWdCLFdBQWhCLEtBQWdDLE9BZHJELEVBZ0JDOztBQUNNLFlBQUEsYUFqQlAsR0FpQnVCLElBQUksb0JBQUosQ0FBYSxNQUFNLENBQUMsUUFBUCxDQUFnQixJQUE3QixFQUFtQyxJQUFuQyxDQWpCdkI7QUFBQSxvQ0FtQm1CLE1BQU0sQ0FBQyxJQUFQLENBQVksYUFBYSxDQUFDLEtBQTFCLENBbkJuQjs7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBOztBQW1CWSxZQUFBLEdBbkJaO0FBQUEsMkJBc0JVLEdBdEJWO0FBQUEsOENBd0JRLFFBeEJSLHlCQXlCUSxTQXpCUix5QkEwQlEsV0ExQlIseUJBMkJRLGtCQTNCUix5QkE0QlEsU0E1QlIseUJBNkJRLFNBN0JSLHlCQThCUSxXQTlCUix5QkErQlEsVUEvQlIseUJBZ0NRLFVBaENSLHlCQWlDUSxLQWpDUix5QkFrQ1EsYUFsQ1IseUJBbUNRLE1BbkNSLHlCQW9DUSxlQXBDUix5QkFxQ1EsZUFyQ1IseUJBc0NRLGdCQXRDUjtBQUFBOztBQUFBO0FBQUE7O0FBQUE7QUF5Q0ksbUJBQU8sYUFBYSxDQUFDLEtBQWQsQ0FBb0IsR0FBcEIsQ0FBUDs7QUF6Q0o7QUFBQTtBQUFBO0FBQUE7O0FBQUE7QUE0Q0MsbUJBQU8sYUFBYSxDQUFDLElBQXJCLENBNUNELENBOENDOztBQUNNLFlBQUEsTUEvQ1AsR0ErQ2dCLDZCQS9DaEI7QUFpREMsWUFBQSxLQUFLLENBQUMsTUFBRCxDQUFMLEdBQWdCLElBQUksc0JBQUosQ0FDZjtBQUNDLGNBQUEsTUFBTSxFQUFOLE1BREQ7QUFFQyxjQUFBLE1BQU0sRUFBTixNQUZEO0FBR0MsY0FBQSxNQUFNLEVBQU4sTUFIRDtBQUlDLGNBQUEsV0FBVyxFQUFHLE9BSmY7QUFLQyxjQUFBLFlBQVksRUFBWixZQUxEO0FBTUMsY0FBQSxRQUFRLEVBQVIsUUFORDtBQU9DLGNBQUEsT0FBTyxFQUFQLE9BUEQ7QUFRQyxjQUFBLE9BQU8sRUFBUCxPQVJEO0FBU0MsY0FBQSxTQUFTLEVBQVQsU0FURDtBQVVDLGNBQUEsUUFBUSxFQUFSLFFBVkQ7QUFXQyxjQUFBLFdBQVcsRUFBWDtBQVhELGFBRGUsQ0FBaEIsQ0FqREQsQ0FnRUM7O0FBRUEsWUFBQSxVQUFVLENBQUM7QUFBQSxxQkFBTSxLQUFLLENBQUMsTUFBRCxDQUFMLENBQWMsSUFBZCxFQUFOO0FBQUEsYUFBRCxFQUE2QixHQUE3QixDQUFWOztBQWxFRDtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQSxHOzs7O0FBcUVBLG1CQUFPLEVBQVAsQ0FBVSxLQUFWLEVBQWlCLFVBQUMsTUFBRCxFQUFTLE1BQVQsRUFBaUIsS0FBakIsRUFBd0IsUUFBeEIsRUFBa0MsY0FBbEMsRUFBa0QsS0FBbEQsRUFBeUQsYUFBekQsRUFDakI7QUFDQyxFQUFBLEdBQUcsQ0FBQyxNQUFELEVBQVMsTUFBVCxFQUFpQixLQUFqQixFQUF3QixRQUF4QixFQUFrQyxjQUFsQyxFQUFrRCxLQUFsRCxFQUF5RCxhQUF6RCxDQUFIO0FBQ0EsQ0FIRDs7QUFLQSxtQkFBTyxFQUFQLENBQVUsVUFBVixFQUFzQixVQUFDLE1BQUQsRUFBUyxNQUFULEVBQ3RCO0FBQ0MsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLE1BQUQsQ0FBekI7O0FBRUEsTUFBSSxXQUFXLElBQUksV0FBVyxDQUFDLGdCQUFaLEtBQWlDLFFBQXBELEVBQ0E7QUFDQyxJQUFBLFdBQVcsQ0FBQyxnQkFBWixDQUE2QixNQUE3QjtBQUNBO0FBQ0QsQ0FSRDs7QUFVQSxtQkFBTyxFQUFQLENBQVUsV0FBVixFQUF1QixVQUFDLE1BQUQsRUFBUyxNQUFULEVBQ3ZCO0FBQ0MsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLE1BQUQsQ0FBekI7O0FBRUEsTUFBSSxXQUFXLElBQUksV0FBVyxDQUFDLGdCQUFaLEtBQWlDLFFBQXBELEVBQ0E7QUFDQyxJQUFBLFdBQVcsQ0FBQyxxQkFBWixDQUFrQyxNQUFsQztBQUNBO0FBQ0QsQ0FSRDs7QUFVQSxtQkFBTyxFQUFQLENBQVUsc0JBQVYsRUFBa0MsVUFBQyxNQUFELEVBQVMsTUFBVCxFQUFpQixNQUFqQixFQUF5QixPQUF6QixFQUNsQztBQUNDLE1BQU0sV0FBVyxHQUFHLEtBQUssQ0FBQyxNQUFELENBQXpCOztBQUVBLE1BQUksV0FBVyxJQUFJLFdBQVcsQ0FBQyxnQkFBWixLQUFpQyxRQUFwRCxFQUNBO0FBQ0MsSUFBQSxXQUFXLENBQUMsb0JBQVosQ0FBaUMsTUFBakMsRUFBeUMsTUFBekMsRUFBaUQsT0FBakQ7QUFDQTtBQUNELENBUkQ7O0FBVUEsbUJBQU8sRUFBUCxDQUFVLHVCQUFWLEVBQW1DLFVBQUMsTUFBRCxFQUFTLEtBQVQsRUFDbkM7QUFDQyxNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsTUFBRCxDQUF6Qjs7QUFFQSxNQUFJLFdBQVcsSUFBSSxXQUFXLENBQUMsZ0JBQVosS0FBaUMsUUFBcEQsRUFDQTtBQUNDLElBQUEsV0FBVyxDQUFDLHFCQUFaLENBQWtDLEtBQWxDO0FBQ0E7QUFDRCxDQVJEOztBQVVBLG1CQUFPLEVBQVAsQ0FBVSx5QkFBVixFQUFxQyxVQUFDLE1BQUQsRUFBUyxNQUFULEVBQWlCLE9BQWpCLEVBQ3JDO0FBQ0MsTUFBTSxXQUFXLEdBQUcsS0FBSyxDQUFDLE1BQUQsQ0FBekI7O0FBRUEsTUFBSSxXQUFXLElBQUksV0FBVyxDQUFDLGdCQUFaLEtBQWlDLFFBQXBELEVBQ0E7QUFDQyxJQUFBLFdBQVcsQ0FBQyx1QkFBWixDQUFvQyxNQUFwQyxFQUE0QyxPQUE1QztBQUNBO0FBQ0QsQ0FSRCxFLENBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUEsbUJBQU8sRUFBUCxDQUFVLGtCQUFWLEVBQThCLFVBQUMsTUFBRCxFQUFTLE1BQVQsRUFDOUI7QUFDQyxNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsTUFBRCxDQUF6Qjs7QUFFQSxNQUFJLFdBQVcsSUFBSSxXQUFXLENBQUMsZ0JBQVosS0FBaUMsUUFBcEQsRUFDQTtBQUNDLElBQUEsV0FBVyxDQUFDLGdCQUFaLENBQTZCLE1BQTdCO0FBQ0E7QUFDRCxDQVJELEUsQ0FVQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQUVBLG1CQUFPLEVBQVAsQ0FBVSxTQUFWLEVBQXFCLFVBQUMsTUFBRCxFQUFTLEdBQVQsRUFDckI7QUFDQyxNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsTUFBRCxDQUF6Qjs7QUFFQSxNQUFJLFdBQVcsSUFBSSxXQUFXLENBQUMsZ0JBQVosS0FBaUMsUUFBcEQsRUFDQTtBQUNDLElBQUEsV0FBVyxDQUFDLE9BQVosQ0FBb0IsR0FBcEI7QUFDQTtBQUNELENBUkQ7O0FBVUEsbUJBQU8sRUFBUCxDQUFVLFdBQVYsRUFBdUIsVUFBQyxNQUFELEVBQVMsR0FBVCxFQUN2QjtBQUNDLE1BQU0sV0FBVyxHQUFHLEtBQUssQ0FBQyxNQUFELENBQXpCOztBQUVBLE1BQUksV0FBVyxJQUFJLFdBQVcsQ0FBQyxnQkFBWixLQUFpQyxRQUFwRCxFQUNBO0FBQ0MsSUFBQSxXQUFXLENBQUMsU0FBWixDQUFzQixHQUF0QjtBQUNBO0FBQ0QsQ0FSRCxFLENBVUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBRUEsbUJBQU8sRUFBUCxDQUFVLG9CQUFWLEVBQWdDLFlBQ2hDO0FBQ0Msb0NBQW1CLE1BQU0sQ0FBQyxNQUFQLENBQWMsS0FBZCxDQUFuQixvQ0FDQTtBQURLLFFBQU0sSUFBSSxxQkFBVjs7QUFFSixRQUFJLElBQUksQ0FBQyxnQkFBTCxLQUEwQixRQUE5QixFQUNBO0FBQ0MsTUFBQSxJQUFJLENBQUMsVUFBTDtBQUNBO0FBQ0Q7QUFDRCxDQVREOztBQVdBLG1CQUFPLEVBQVAsQ0FBVSxZQUFWLEVBQXdCLFVBQUMsTUFBRCxFQUN4QjtBQUNDLE1BQU0sV0FBVyxHQUFHLEtBQUssQ0FBQyxNQUFELENBQXpCOztBQUVBLE1BQUksV0FBVyxJQUFJLFdBQVcsQ0FBQyxnQkFBWixLQUFpQyxRQUFwRCxFQUNBO0FBQ0MsSUFBQSxXQUFXLENBQUMsVUFBWjtBQUNBO0FBQ0QsQ0FSRDs7QUFVQSxtQkFBTyxFQUFQLENBQVUsTUFBVixFQUFrQixVQUFDLE1BQUQsRUFDbEI7QUFDQyxNQUFNLFdBQVcsR0FBRyxLQUFLLENBQUMsTUFBRCxDQUF6Qjs7QUFFQSxNQUFJLFdBQVcsSUFBSSxXQUFXLENBQUMsZ0JBQVosS0FBaUMsUUFBcEQsRUFDQTtBQUNDLElBQUEsV0FBVyxDQUFDLEtBQVo7O0FBQ0EsUUFBSSxXQUFXLENBQUMsT0FBaEIsRUFDQTtBQUNDLGFBQU8sS0FBSyxDQUFDLE1BQUQsQ0FBWjtBQUNBO0FBQ0Q7QUFDRCxDQVpEOztBQWNBLG1CQUFPLEVBQVAsQ0FBVSxjQUFWLEVBQTBCLFVBQUMsU0FBRCxFQUFZLFVBQVosRUFDMUI7QUFDQyxpQ0FBYyxTQUFkO0FBQ0Esa0NBQWUsVUFBZjtBQUNBLENBSkQ7Ozs7Ozs7Ozs7O0FDL1BBLElBQUksVUFBVSxHQUFHLElBQWpCO0FBQ0EsSUFBSSxTQUFTLEdBQUcseUJBQWhCOztBQUVPLFNBQVMsYUFBVCxDQUF1QixHQUF2QixFQUNQO0FBQ0MsRUFBQSxTQUFTLEdBQUcsR0FBWjtBQUNBOztBQUVNLFNBQVMsY0FBVCxDQUF3QixJQUF4QixFQUNQO0FBQ0MsRUFBQSxVQUFVLEdBQUcsTUFBTSxDQUFDLElBQUQsQ0FBbkI7QUFDQTs7QUFFTSxTQUFTLFlBQVQsT0FDUDtBQUFBLE1BRCtCLE1BQy9CLFFBRCtCLE1BQy9CO0FBQUEsTUFEdUMsTUFDdkMsUUFEdUMsTUFDdkM7QUFDQyx5QkFBZ0IsU0FBaEIsY0FBNkIsVUFBN0Isc0JBQW1ELE1BQW5ELHFCQUFvRSxNQUFwRTtBQUNBOzs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FDaEJEO0FBQ0EsSUFBSSxzQkFBSjtBQUNBLElBQUksU0FBSjs7U0FFc0IsWTs7Ozs7Z0dBQWYsaUJBQTRCLFdBQTVCO0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFFTixZQUFBLE9BQU8sQ0FBQyxHQUFSLGtCQUFzQixTQUF0Qjs7QUFGTSxnQkFHRCxTQUhDO0FBQUE7QUFBQTtBQUFBOztBQUFBO0FBQUEsbUJBSWEsU0FBUyxDQUFDLFlBQVYsQ0FBdUIsWUFBdkIsQ0FBb0MsV0FBcEMsQ0FKYjs7QUFBQTtBQUlMLFlBQUEsU0FKSzs7QUFBQTtBQUFBLDZDQU9DLFNBUEQ7O0FBQUE7QUFBQTtBQUFBO0FBQUE7QUFBQTtBQUFBO0FBQUEsRzs7OztBQVVBLFNBQVMsVUFBVCxHQUNQO0FBQ0M7QUFDQSxFQUFBLHNCQUFzQixHQUNyQixRQUFRLENBQUMsY0FBVCxDQUF3Qix5Q0FBeEIsQ0FERDtBQUdBLFNBQU8sT0FBTyxDQUFDLE9BQVIsRUFBUDtBQUNBOztBQUVNLFNBQVMsU0FBVCxHQUNQO0FBQ0MsU0FBTyxPQUFPLENBQUMsc0JBQXNCLENBQUMsWUFBeEIsQ0FBZDtBQUNBOztBQUVNLFNBQVMsUUFBVCxHQUNQO0FBQ0MsU0FBTyxDQUFDLHNCQUFzQixDQUFDLFlBQS9CO0FBQ0E7OztBQy9CRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDWEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1BBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNoQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNQQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZEQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0xBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDYkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDckJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1pBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUMxSkE7O0FDQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDM2dCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3UUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDclFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzlCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JjQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0S0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNsQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN1JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ05BO0FBQ0E7QUFDQTs7QUNGQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN6aEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3ZDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMWNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDN2ZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xmQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM1WUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzVnQkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbGRBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbmZBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN0ZEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNyaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNuUkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDaEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzNIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNwQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDMzBCQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDcEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDbkJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2xLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3hMQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3JDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM3Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ2pLQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzFWQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BOQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNUQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ25FQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RIQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQzV1QkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3RDQTs7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ3BHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDOUpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUM5ZUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ1hBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDNUhBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUNsSEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM5Y0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdERBO0FBQ0E7O0FDREE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsImZpbGUiOiJnZW5lcmF0ZWQuanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7ZnVuY3Rpb24gcihlLG4sdCl7ZnVuY3Rpb24gbyhpLGYpe2lmKCFuW2ldKXtpZighZVtpXSl7dmFyIGM9XCJmdW5jdGlvblwiPT10eXBlb2YgcmVxdWlyZSYmcmVxdWlyZTtpZighZiYmYylyZXR1cm4gYyhpLCEwKTtpZih1KXJldHVybiB1KGksITApO3ZhciBhPW5ldyBFcnJvcihcIkNhbm5vdCBmaW5kIG1vZHVsZSAnXCIraStcIidcIik7dGhyb3cgYS5jb2RlPVwiTU9EVUxFX05PVF9GT1VORFwiLGF9dmFyIHA9bltpXT17ZXhwb3J0czp7fX07ZVtpXVswXS5jYWxsKHAuZXhwb3J0cyxmdW5jdGlvbihyKXt2YXIgbj1lW2ldWzFdW3JdO3JldHVybiBvKG58fHIpfSxwLHAuZXhwb3J0cyxyLGUsbix0KX1yZXR1cm4gbltpXS5leHBvcnRzfWZvcih2YXIgdT1cImZ1bmN0aW9uXCI9PXR5cGVvZiByZXF1aXJlJiZyZXF1aXJlLGk9MDtpPHQubGVuZ3RoO2krKylvKHRbaV0pO3JldHVybiBvfXJldHVybiByfSkoKSIsImltcG9ydCBkZWJ1ZyBmcm9tICdkZWJ1Zyc7XG5cbmNvbnN0IEFQUF9OQU1FID0gJ21lZGlhc291cC1kZW1vJztcblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTG9nZ2VyXG57XG5cdGNvbnN0cnVjdG9yKHByZWZpeClcblx0e1xuXHRcdGlmIChwcmVmaXgpXG5cdFx0e1xuXHRcdFx0dGhpcy5fZGVidWcgPSBkZWJ1ZyhgJHtBUFBfTkFNRX06JHtwcmVmaXh9YCk7XG5cdFx0XHR0aGlzLl93YXJuID0gZGVidWcoYCR7QVBQX05BTUV9OldBUk46JHtwcmVmaXh9YCk7XG5cdFx0XHR0aGlzLl9lcnJvciA9IGRlYnVnKGAke0FQUF9OQU1FfTpFUlJPUjoke3ByZWZpeH1gKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdHRoaXMuX2RlYnVnID0gZGVidWcoQVBQX05BTUUpO1xuXHRcdFx0dGhpcy5fd2FybiA9IGRlYnVnKGAke0FQUF9OQU1FfTpXQVJOYCk7XG5cdFx0XHR0aGlzLl9lcnJvciA9IGRlYnVnKGAke0FQUF9OQU1FfTpFUlJPUmApO1xuXHRcdH1cblxuXHRcdC8qIGVzbGludC1kaXNhYmxlIG5vLWNvbnNvbGUgKi9cblx0XHR0aGlzLl9kZWJ1Zy5sb2cgPSBjb25zb2xlLmluZm8uYmluZChjb25zb2xlKTtcblx0XHR0aGlzLl93YXJuLmxvZyA9IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuXHRcdHRoaXMuX2Vycm9yLmxvZyA9IGNvbnNvbGUuZXJyb3IuYmluZChjb25zb2xlKTtcblx0XHQvKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cblx0fVxuXG5cdGdldCBkZWJ1ZygpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fZGVidWc7XG5cdH1cblxuXHRnZXQgd2FybigpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fd2Fybjtcblx0fVxuXG5cdGdldCBlcnJvcigpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fZXJyb3I7XG5cdH1cbn1cbiIsImltcG9ydCBwcm90b29DbGllbnQgZnJvbSAncHJvdG9vLWNsaWVudCc7XG5pbXBvcnQgKiBhcyBtZWRpYXNvdXBDbGllbnQgZnJvbSAnbWVkaWFzb3VwLWNsaWVudCc7XG5pbXBvcnQgTG9nZ2VyIGZyb20gJy4vTG9nZ2VyJztcbmltcG9ydCB7IGdldFByb3Rvb1VybCB9IGZyb20gJy4vdXJsRmFjdG9yeSc7XG5pbXBvcnQgRXZlbnRzIGZyb20gJy4vZXZlbnRzJztcbmltcG9ydCAqIGFzIHV0aWxzIGZyb20gJy4vdXRpbHMnO1xuXG5jb25zdCBQQ19QUk9QUklFVEFSWV9DT05TVFJBSU5UUyA9XG57XG5cdG9wdGlvbmFsOiBbeyBnb29nRHNjcDogdHJ1ZSB9XVxufTtcblxuY29uc3QgaWNlU2VydmVycyA9IFt7XG5cdHVybHM6ICdzdHVuOnN0dW4ubC5nb29nbGUuY29tOjE5MzAyJyxcblx0dXNlcm5hbWU6ICcnLFxuXHRjcmVkZW50aWFsOiAnJ1xufSwge1xuXHR1cmxzOiAnc3R1bjpzdHVuMS5sLmdvb2dsZS5jb206MTkzMDInLFxuXHR1c2VybmFtZTogJycsXG5cdGNyZWRlbnRpYWw6ICcnXG59LCB7XG5cdHVybHM6ICdzdHVuOnN0dW4yLmwuZ29vZ2xlLmNvbToxOTMwMicsXG5cdHVzZXJuYW1lOiAnJyxcblx0Y3JlZGVudGlhbDogJydcbn0sIHtcblx0dXJsczogJ3N0dW46c3R1bjMubC5nb29nbGUuY29tOjE5MzAyJyxcblx0dXNlcm5hbWU6ICcnLFxuXHRjcmVkZW50aWFsOiAnJ1xufSwge1xuXHR1cmxzOiAnc3R1bjpzdHVuNC5sLmdvb2dsZS5jb206MTkzMDInLFxuXHR1c2VybmFtZTogJycsXG5cdGNyZWRlbnRpYWw6ICcnXG59XTtcblxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcignUm9vbUNsaWVudCcpO1xuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBSb29tQ2xpZW50IHtcblx0LyoqXG5cdCAqIEBwYXJhbSAge09iamVjdH0gZGF0YVxuXHQgKiBAcGFyYW0gIHtPYmplY3R9IGRhdGEuc3RvcmUgLSBUaGUgUmVkdXggc3RvcmUuXG5cdCAqL1xuXHQvLyBzdGF0aWMgaW5pdChkYXRhKVxuXHQvLyB7XG5cdC8vIFx0c3RvcmUgPSBkYXRhLnN0b3JlO1xuXHQvLyB9XG5cblx0Y29uc3RydWN0b3IoXG5cdFx0e1xuXHRcdFx0cm9vbUlkLFxuXHRcdFx0cGVlcklkLFxuXHRcdFx0ZGV2aWNlLFxuXHRcdFx0aGFuZGxlck5hbWUsXG5cdFx0XHR1c2VTaW11bGNhc3QsXG5cdFx0XHRmb3JjZVRjcCxcblx0XHRcdHByb2R1Y2UsXG5cdFx0XHRjb25zdW1lLFxuXHRcdFx0Zm9yY2VIMjY0LFxuXHRcdFx0Zm9yY2VWUDksXG5cdFx0XHRkYXRhY2hhbm5lbFxuXHRcdH1cblx0KSB7XG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J2NvbnN0cnVjdG9yKCkgW3Jvb21JZDpcIiVzXCIsIHBlZXJJZDpcIiVzXCIsIGRldmljZTolc10nLFxuXHRcdFx0cm9vbUlkLCBwZWVySWQsIGRldmljZS5mbGFnKTtcblxuXHRcdHRoaXMuYXVkaW9Db250ZXh0ID0gbmV3IEF1ZGlvQ29udGV4dCgpO1xuXG5cdFx0dGhpcy5tYWluVm9sdW1lID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlR2FpbigpO1xuXG5cdFx0dGhpcy5tYWluVm9sdW1lLmNvbm5lY3QodGhpcy5hdWRpb0NvbnRleHQuZGVzdGluYXRpb24pO1xuXHRcdHRoaXMubWFpblZvbHVtZS5nYWluLnNldFZhbHVlQXRUaW1lKDEsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKTtcblxuXHRcdHRoaXMucm9vbUlkID0gcm9vbUlkO1xuXHRcdHRoaXMucGVlcklkID0gcGVlcklkO1xuXG5cdFx0Ly8gQ2xvc2VkIGZsYWcuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0dGhpcy5fY2xvc2VkID0gZmFsc2U7XG5cblx0XHQvLyBEZXZpY2UgaW5mby5cblx0XHQvLyBAdHlwZSB7T2JqZWN0fVxuXHRcdHRoaXMuX2RldmljZSA9IGRldmljZTtcblxuXHRcdC8vIFdoZXRoZXIgd2Ugd2FudCB0byBmb3JjZSBSVEMgb3ZlciBUQ1AuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0dGhpcy5fZm9yY2VUY3AgPSBmb3JjZVRjcDtcblxuXHRcdC8vIFdoZXRoZXIgd2Ugd2FudCB0byBwcm9kdWNlIGF1ZGlvL3ZpZGVvLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdHRoaXMuX3Byb2R1Y2UgPSBwcm9kdWNlO1xuXG5cdFx0Ly8gV2hldGhlciB3ZSBzaG91bGQgY29uc3VtZS5cblx0XHQvLyBAdHlwZSB7Qm9vbGVhbn1cblx0XHR0aGlzLl9jb25zdW1lID0gY29uc3VtZTtcblxuXHRcdC8vIFdoZXRoZXIgd2Ugd2FudCBEYXRhQ2hhbm5lbHMuXG5cdFx0Ly8gQHR5cGUge0Jvb2xlYW59XG5cdFx0dGhpcy5fdXNlRGF0YUNoYW5uZWwgPSBkYXRhY2hhbm5lbDtcblxuXHRcdC8vIEZvcmNlIEgyNjQgY29kZWMgZm9yIHNlbmRpbmcuXG5cdFx0dGhpcy5fZm9yY2VIMjY0ID0gQm9vbGVhbihmb3JjZUgyNjQpO1xuXG5cdFx0Ly8gRm9yY2UgVlA5IGNvZGVjIGZvciBzZW5kaW5nLlxuXHRcdHRoaXMuX2ZvcmNlVlA5ID0gQm9vbGVhbihmb3JjZVZQOSk7XG5cblx0XHQvLyBFeHRlcm5hbCB2aWRlby5cblx0XHQvLyBAdHlwZSB7SFRNTFZpZGVvRWxlbWVudH1cblx0XHR0aGlzLl9leHRlcm5hbFZpZGVvID0gbnVsbDtcblxuXHRcdC8vIE5leHQgZXhwZWN0ZWQgZGF0YUNoYW5uZWwgdGVzdCBudW1iZXIuXG5cdFx0Ly8gQHR5cGUge051bWJlcn1cblx0XHR0aGlzLl9uZXh0RGF0YUNoYW5uZWxUZXN0TnVtYmVyID0gMDtcblxuXHRcdC8vIEN1c3RvbSBtZWRpYXNvdXAtY2xpZW50IGhhbmRsZXIgbmFtZSAodG8gb3ZlcnJpZGUgZGVmYXVsdCBicm93c2VyXG5cdFx0Ly8gZGV0ZWN0aW9uIGlmIGRlc2lyZWQpLlxuXHRcdC8vIEB0eXBlIHtTdHJpbmd9XG5cdFx0dGhpcy5faGFuZGxlck5hbWUgPSBoYW5kbGVyTmFtZTtcblxuXHRcdC8vIFdoZXRoZXIgc2ltdWxjYXN0IHNob3VsZCBiZSB1c2VkLlxuXHRcdC8vIEB0eXBlIHtCb29sZWFufVxuXHRcdHRoaXMuX3VzZVNpbXVsY2FzdCA9IHVzZVNpbXVsY2FzdDtcblxuXHRcdC8vIHByb3Rvby1jbGllbnQgUGVlciBpbnN0YW5jZS5cblx0XHQvLyBAdHlwZSB7cHJvdG9vQ2xpZW50LlBlZXJ9XG5cdFx0dGhpcy5fcHJvdG9vID0gbnVsbDtcblxuXHRcdC8vIG1lZGlhc291cC1jbGllbnQgRGV2aWNlIGluc3RhbmNlLlxuXHRcdC8vIEB0eXBlIHttZWRpYXNvdXBDbGllbnQuRGV2aWNlfVxuXHRcdHRoaXMuX21lZGlhc291cERldmljZSA9IG51bGw7XG5cblx0XHQvLyBtZWRpYXNvdXAgVHJhbnNwb3J0IGZvciBzZW5kaW5nLlxuXHRcdC8vIEB0eXBlIHttZWRpYXNvdXBDbGllbnQuVHJhbnNwb3J0fVxuXHRcdHRoaXMuX3NlbmRUcmFuc3BvcnQgPSBudWxsO1xuXG5cdFx0Ly8gbWVkaWFzb3VwIFRyYW5zcG9ydCBmb3IgcmVjZWl2aW5nLlxuXHRcdC8vIEB0eXBlIHttZWRpYXNvdXBDbGllbnQuVHJhbnNwb3J0fVxuXHRcdHRoaXMuX3JlY3ZUcmFuc3BvcnQgPSBudWxsO1xuXG5cdFx0Ly8gTG9jYWwgbWljIG1lZGlhc291cCBQcm9kdWNlci5cblx0XHQvLyBAdHlwZSB7bWVkaWFzb3VwQ2xpZW50LlByb2R1Y2VyfVxuXHRcdHRoaXMuX21pY1Byb2R1Y2VyID0gbnVsbDtcblxuXHRcdC8vIG1lZGlhc291cCBDb25zdW1lcnMuXG5cdFx0Ly8gQHR5cGUge01hcDxTdHJpbmcsIG1lZGlhc291cENsaWVudC5Db25zdW1lcj59XG5cdFx0dGhpcy5fY29uc3VtZXJzID0gbmV3IE1hcCgpO1xuXG5cdFx0Ly8gbWVkaWFzb3VwIENvbnN1bWVycy5cblx0XHQvLyBAdHlwZSB7TWFwPFN0cmluZywgbWVkaWFzb3VwQ2xpZW50LkNvbnN1bWVyPn1cblx0XHR0aGlzLl9wZWVycyA9IG5ldyBNYXAoKTtcblx0fVxuXG5cdGNsb3NlKCkge1xuXHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0XHRyZXR1cm47XG5cblx0XHR0aGlzLl9jbG9zZWQgPSB0cnVlO1xuXG5cdFx0bG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG5cblx0XHQvLyBDbG9zZSBwcm90b28gUGVlclxuXHRcdHRoaXMuX3Byb3Rvby5jbG9zZSgpO1xuXHRcdEV2ZW50cy50cmlnZ2VyQ2xpZW50Q2hhbmdlU3RhdGVDb25uZWN0aW9uKHRoaXMucm9vbUlkLCAnZGlzY29ubmVjdGVkJyk7XG5cblx0XHQvLyBDbG9zZSBtZWRpYXNvdXAgVHJhbnNwb3J0cy5cblx0XHRpZiAodGhpcy5fc2VuZFRyYW5zcG9ydClcblx0XHRcdHRoaXMuX3NlbmRUcmFuc3BvcnQuY2xvc2UoKTtcblxuXHRcdGlmICh0aGlzLl9yZWN2VHJhbnNwb3J0KVxuXHRcdFx0dGhpcy5fcmVjdlRyYW5zcG9ydC5jbG9zZSgpO1xuXHR9XG5cblx0YXN5bmMgam9pbigpIHtcblx0XHRjb25zdCBwcm90b29VcmwgPSBnZXRQcm90b29VcmwoeyByb29tSWQ6IHRoaXMucm9vbUlkLCBwZWVySWQ6IHRoaXMucGVlcklkIH0pO1xuXHRcdGNvbnN0IHByb3Rvb1RyYW5zcG9ydCA9IG5ldyBwcm90b29DbGllbnQuV2ViU29ja2V0VHJhbnNwb3J0KHByb3Rvb1VybCk7XG5cblx0XHR0aGlzLl9wcm90b28gPSBuZXcgcHJvdG9vQ2xpZW50LlBlZXIocHJvdG9vVHJhbnNwb3J0KTtcblxuXHRcdHRoaXMuX3Byb3Rvby5vbignb3BlbicsICgpID0+IHRoaXMuX2pvaW5Sb29tKCkpO1xuXG5cdFx0dGhpcy5fcHJvdG9vLm9uKCdmYWlsZWQnLCAoKSA9PiB7XG5cdFx0XHRsb2dnZXIuZXJyb3IoJ3Byb3RvIGNvbm5lY3QgZmFpbGVkJyk7XG5cdFx0XHRFdmVudHMudHJpZ2dlckNsaWVudENoYW5nZVN0YXRlQ29ubmVjdGlvbih0aGlzLnJvb21JZCwgJ2Rpc2Nvbm5lY3RlZCcpO1xuXHRcdH0pO1xuXG5cdFx0dGhpcy5fcHJvdG9vLm9uKCdkaXNjb25uZWN0ZWQnLCAoKSA9PiB7XG5cdFx0XHRsb2dnZXIuZGVidWcoJ3Byb3RvIGRpc2Nvbm5lY3RlZCcpO1xuXHRcdFx0RXZlbnRzLnRyaWdnZXJDbGllbnRDaGFuZ2VTdGF0ZUNvbm5lY3Rpb24odGhpcy5yb29tSWQsICdkaXNjb25uZWN0ZWQnKTtcblxuXHRcdFx0Ly8gQ2xvc2UgbWVkaWFzb3VwIFRyYW5zcG9ydHMuXG5cdFx0XHRpZiAodGhpcy5fc2VuZFRyYW5zcG9ydCkge1xuXHRcdFx0XHR0aGlzLl9zZW5kVHJhbnNwb3J0LmNsb3NlKCk7XG5cdFx0XHRcdHRoaXMuX3NlbmRUcmFuc3BvcnQgPSBudWxsO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fcmVjdlRyYW5zcG9ydCkge1xuXHRcdFx0XHR0aGlzLl9yZWN2VHJhbnNwb3J0LmNsb3NlKCk7XG5cdFx0XHRcdHRoaXMuX3JlY3ZUcmFuc3BvcnQgPSBudWxsO1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0dGhpcy5fcHJvdG9vLm9uKCdjbG9zZScsICgpID0+IHtcblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0dGhpcy5jbG9zZSgpO1xuXHRcdH0pO1xuXG5cdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVudXNlZC12YXJzXG5cdFx0dGhpcy5fcHJvdG9vLm9uKCdyZXF1ZXN0JywgYXN5bmMgKHJlcXVlc3QsIGFjY2VwdCwgcmVqZWN0KSA9PiB7XG5cdFx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHRcdCdwcm90byBcInJlcXVlc3RcIiBldmVudCBbbWV0aG9kOiVzLCBkYXRhOiVvXScsXG5cdFx0XHRcdHJlcXVlc3QubWV0aG9kLCByZXF1ZXN0LmRhdGEpO1xuXG5cdFx0XHRzd2l0Y2ggKHJlcXVlc3QubWV0aG9kKSB7XG5cdFx0XHRcdGNhc2UgJ25ld0NvbnN1bWVyJzpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRpZiAoIXRoaXMuX2NvbnN1bWUpIHtcblx0XHRcdFx0XHRcdFx0cmVqZWN0KDQwMywgJ0kgZG8gbm90IHdhbnQgdG8gY29uc3VtZScpO1xuXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRjb25zdCB7XG5cdFx0XHRcdFx0XHRcdHBlZXJJZCxcblx0XHRcdFx0XHRcdFx0cHJvZHVjZXJJZCxcblx0XHRcdFx0XHRcdFx0aWQsXG5cdFx0XHRcdFx0XHRcdGtpbmQsXG5cdFx0XHRcdFx0XHRcdHJ0cFBhcmFtZXRlcnMsXG5cdFx0XHRcdFx0XHRcdGFwcERhdGFcblx0XHRcdFx0XHRcdH0gPSByZXF1ZXN0LmRhdGE7XG5cblx0XHRcdFx0XHRcdHRyeSB7XG5cdFx0XHRcdFx0XHRcdGNvbnN0IGNvbnN1bWVyID0gYXdhaXQgdGhpcy5fcmVjdlRyYW5zcG9ydC5jb25zdW1lKFxuXHRcdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHRcdGlkLFxuXHRcdFx0XHRcdFx0XHRcdFx0cHJvZHVjZXJJZCxcblx0XHRcdFx0XHRcdFx0XHRcdGtpbmQsXG5cdFx0XHRcdFx0XHRcdFx0XHRydHBQYXJhbWV0ZXJzLFxuXHRcdFx0XHRcdFx0XHRcdFx0YXBwRGF0YTogeyAuLi5hcHBEYXRhLCBwZWVySWQgfSAvLyBUcmljay5cblx0XHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0XHQvLyBTdG9yZSBpbiB0aGUgbWFwLlxuXHRcdFx0XHRcdFx0XHR0aGlzLl9jb25zdW1lcnMuc2V0KGNvbnN1bWVyLmlkLCBjb25zdW1lcik7XG5cdFx0XHRcdFx0XHRcdHRoaXMuX3BlZXJzLnNldChwZWVySWQsIGNvbnN1bWVyLmlkKTtcblxuXHRcdFx0XHRcdFx0XHRjb25zdW1lci5vbigndHJhbnNwb3J0Y2xvc2UnLCAoKSA9PiB7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fcGVlcnMuZGVsZXRlKGNvbnN1bWVyLnBlZXJJZCk7XG5cdFx0XHRcdFx0XHRcdFx0dGhpcy5fY29uc3VtZXJzLmRlbGV0ZShjb25zdW1lci5pZCk7XG5cdFx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRcdC8vIGNvbnN0IHsgc3BhdGlhbExheWVycywgdGVtcG9yYWxMYXllcnMgfSA9XG5cdFx0XHRcdFx0XHRcdC8vIFx0bWVkaWFzb3VwQ2xpZW50LnBhcnNlU2NhbGFiaWxpdHlNb2RlKFxuXHRcdFx0XHRcdFx0XHQvLyBcdFx0Y29uc3VtZXIucnRwUGFyYW1ldGVycy5lbmNvZGluZ3NbMF0uc2NhbGFiaWxpdHlNb2RlKTtcblxuXHRcdFx0XHRcdFx0XHR0aGlzLmluaXRDb25zdW1lckF1ZGlvKGNvbnN1bWVyLmlkKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBXZSBhcmUgcmVhZHkuIEFuc3dlciB0aGUgcHJvdG9vIHJlcXVlc3Qgc28gdGhlIHNlcnZlciB3aWxsXG5cdFx0XHRcdFx0XHRcdC8vIHJlc3VtZSB0aGlzIENvbnN1bWVyICh3aGljaCB3YXMgcGF1c2VkIGZvciBub3cgaWYgdmlkZW8pLlxuXHRcdFx0XHRcdFx0XHRhY2NlcHQoKTtcblxuXHRcdFx0XHRcdFx0XHQvLyBJZiBhdWRpby1vbmx5IG1vZGUgaXMgZW5hYmxlZCwgcGF1c2UgaXQuXG5cdFx0XHRcdFx0XHRcdC8vIGlmIChjb25zdW1lci5raW5kID09PSAndmlkZW8nICYmIHN0b3JlLmdldFN0YXRlKCkubWUuYXVkaW9Pbmx5KVxuXHRcdFx0XHRcdFx0XHQvLyBcdHRoaXMuX3BhdXNlQ29uc3VtZXIoY29uc3VtZXIpO1xuXHRcdFx0XHRcdFx0fVxuXHRcdFx0XHRcdFx0Y2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRcdGxvZ2dlci5lcnJvcignXCJuZXdDb25zdW1lclwiIHJlcXVlc3QgZmFpbGVkOiVvJywgZXJyb3IpO1xuXG5cdFx0XHRcdFx0XHRcdHRocm93IGVycm9yO1xuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cdFx0XHR9XG5cdFx0fSk7XG5cblx0XHR0aGlzLl9wcm90b28ub24oJ25vdGlmaWNhdGlvbicsIChub3RpZmljYXRpb24pID0+IHtcblx0XHRcdGlmIChub3RpZmljYXRpb24ubWV0aG9kICE9PSAnYWN0aXZlU3BlYWtlcicpIHtcblx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdCdwcm90byBcIm5vdGlmaWNhdGlvblwiIGV2ZW50IFttZXRob2Q6JXMsIGRhdGE6JW9dJyxcblx0XHRcdFx0XHRub3RpZmljYXRpb24ubWV0aG9kLCBub3RpZmljYXRpb24uZGF0YSk7XG5cdFx0XHR9XG5cblx0XHRcdHN3aXRjaCAobm90aWZpY2F0aW9uLm1ldGhvZCkge1xuXG5cdFx0XHRcdGNhc2UgJ2NvbnN1bWVyQ2xvc2VkJzpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCB7IGNvbnN1bWVySWQgfSA9IG5vdGlmaWNhdGlvbi5kYXRhO1xuXHRcdFx0XHRcdFx0Y29uc3QgY29uc3VtZXIgPSB0aGlzLl9jb25zdW1lcnMuZ2V0KGNvbnN1bWVySWQpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIWNvbnN1bWVyKVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y29uc3VtZXIuY2xvc2UoKTtcblxuXHRcdFx0XHRcdFx0dGhpcy5yZW1vdmVDb25zdW1lckF1ZGlvKGNvbnN1bWVySWQpO1xuXG5cdFx0XHRcdFx0XHR0aGlzLl9wZWVycy5kZWxldGUoY29uc3VtZXIucGVlcklkKTtcblx0XHRcdFx0XHRcdHRoaXMuX2NvbnN1bWVycy5kZWxldGUoY29uc3VtZXJJZCk7XG5cblx0XHRcdFx0XHRcdC8vIGNvbnN0IHsgcGVlcklkIH0gPSBjb25zdW1lci5hcHBEYXRhO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FzZSAnY29uc3VtZXJQYXVzZWQnOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IHsgY29uc3VtZXJJZCB9ID0gbm90aWZpY2F0aW9uLmRhdGE7XG5cdFx0XHRcdFx0XHRjb25zdCBjb25zdW1lciA9IHRoaXMuX2NvbnN1bWVycy5nZXQoY29uc3VtZXJJZCk7XG5cblx0XHRcdFx0XHRcdGlmICghY29uc3VtZXIpXG5cdFx0XHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdFx0XHRjb25zdW1lci5wYXVzZSgpO1xuXG5cdFx0XHRcdFx0XHRicmVhaztcblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0Y2FzZSAnY29uc3VtZXJSZXN1bWVkJzpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCB7IGNvbnN1bWVySWQgfSA9IG5vdGlmaWNhdGlvbi5kYXRhO1xuXHRcdFx0XHRcdFx0Y29uc3QgY29uc3VtZXIgPSB0aGlzLl9jb25zdW1lcnMuZ2V0KGNvbnN1bWVySWQpO1xuXG5cdFx0XHRcdFx0XHRpZiAoIWNvbnN1bWVyKVxuXHRcdFx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHRcdFx0Y29uc3VtZXIucmVzdW1lKCk7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGxvZ2dlci5lcnJvcihcblx0XHRcdFx0XHRcdFx0J3Vua25vd24gcHJvdG9vIG5vdGlmaWNhdGlvbi5tZXRob2QgXCIlc1wiJywgbm90aWZpY2F0aW9uLm1ldGhvZCk7XG5cdFx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0YXN5bmMgZW5hYmxlTWljKCkge1xuXHRcdGxvZ2dlci5kZWJ1ZygnZW5hYmxlTWljKCknKTtcblxuXHRcdGlmICh0aGlzLl9taWNQcm9kdWNlcilcblx0XHRcdHJldHVybjtcblxuXHRcdGlmICghdGhpcy5fbWVkaWFzb3VwRGV2aWNlLmNhblByb2R1Y2UoJ2F1ZGlvJykpIHtcblx0XHRcdGxvZ2dlci5lcnJvcignZW5hYmxlTWljKCkgfCBjYW5ub3QgcHJvZHVjZSBhdWRpbycpO1xuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0bGV0IHRyYWNrO1xuXG5cdFx0dHJ5IHtcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdlbmFibGVNaWMoKSB8IGNhbGxpbmcgZ2V0VXNlck1lZGlhKCknKTtcblxuXHRcdFx0Y29uc3QgY29uc3RyYWludHMgPSB7XG5cdFx0XHRcdGF1ZGlvOiB7XG5cdFx0XHRcdFx0Ly8gZWNob0NhbmNlbGxhdGlvbjogaXNVc2IgPyBmYWxzZSA6IG51bGwsXG5cdFx0XHRcdFx0ZWNob0NhbmNlbGxhdGlvbjogZmFsc2UsXG5cdFx0XHRcdFx0bm9pc2VTdXBwcmVzc2lvbjogdHJ1ZSxcblx0XHRcdFx0XHRhdXRvR2FpbkNvbnRyb2w6IGZhbHNlXG5cdFx0XHRcdFx0Ly8gZGV2aWNlSWQgOiBkZXZpY2VJZFxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG5cblx0XHRcdHRyYWNrID0gc3RyZWFtLmdldEF1ZGlvVHJhY2tzKClbMF07XG5cblx0XHRcdHRoaXMuX21pY1Byb2R1Y2VyID0gYXdhaXQgdGhpcy5fc2VuZFRyYW5zcG9ydC5wcm9kdWNlKFxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0dHJhY2ssXG5cdFx0XHRcdFx0Y29kZWNPcHRpb25zOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdG9wdXNTdGVyZW86IDEsXG5cdFx0XHRcdFx0XHRvcHVzRHR4OiAxXG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIE5PVEU6IGZvciB0ZXN0aW5nIGNvZGVjIHNlbGVjdGlvbi5cblx0XHRcdFx0XHQvLyBjb2RlYyA6IHRoaXMuX21lZGlhc291cERldmljZS5ydHBDYXBhYmlsaXRpZXMuY29kZWNzXG5cdFx0XHRcdFx0Ly8gXHQuZmluZCgoY29kZWMpID0+IGNvZGVjLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICdhdWRpby9wY21hJylcblx0XHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuX21pY1Byb2R1Y2VyLnBhdXNlKCk7XG5cblx0XHRcdHRoaXMuX21pY1Byb2R1Y2VyLm9uKCd0cmFuc3BvcnRjbG9zZScsICgpID0+IHtcblx0XHRcdFx0dGhpcy5fbWljUHJvZHVjZXIgPSBudWxsO1xuXHRcdFx0fSk7XG5cblx0XHRcdHRoaXMuX21pY1Byb2R1Y2VyLm9uKCd0cmFja2VuZGVkJywgKCkgPT4ge1xuXG5cdFx0XHRcdHRoaXMuZGlzYWJsZU1pYygpXG5cdFx0XHRcdFx0LmNhdGNoKCgpID0+IHsgfSk7XG5cdFx0XHR9KTtcblx0XHR9XG5cdFx0Y2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRsb2dnZXIuZXJyb3IoJ2VuYWJsZU1pYygpIHwgZmFpbGVkOiVvJywgZXJyb3IpO1xuXG5cdFx0XHRpZiAodHJhY2spXG5cdFx0XHRcdHRyYWNrLnN0b3AoKTtcblx0XHR9XG5cdH1cblxuXHRhc3luYyBkaXNhYmxlTWljKCkge1xuXHRcdGxvZ2dlci5kZWJ1ZygnZGlzYWJsZU1pYygpJyk7XG5cblx0XHRpZiAoIXRoaXMuX21pY1Byb2R1Y2VyKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dGhpcy5fbWljUHJvZHVjZXIuY2xvc2UoKTtcblxuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCB0aGlzLl9wcm90b28ucmVxdWVzdChcblx0XHRcdFx0J2Nsb3NlUHJvZHVjZXInLCB7IHByb2R1Y2VySWQ6IHRoaXMuX21pY1Byb2R1Y2VyLmlkIH0pO1xuXHRcdH1cblx0XHRjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGxvZ2dlci5lcnJvcihlcnJvcik7XG5cdFx0fVxuXG5cdFx0dGhpcy5fbWljUHJvZHVjZXIgPSBudWxsO1xuXHR9XG5cblx0YXN5bmMgbXV0ZU1pYygpIHtcblx0XHRsb2dnZXIuZGVidWcoJ211dGVNaWMoKScpO1xuXG5cdFx0dGhpcy5fbWljUHJvZHVjZXIucGF1c2UoKTtcblxuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCB0aGlzLl9wcm90b28ucmVxdWVzdChcblx0XHRcdFx0J3BhdXNlUHJvZHVjZXInLCB7IHByb2R1Y2VySWQ6IHRoaXMuX21pY1Byb2R1Y2VyLmlkIH0pO1xuXHRcdH1cblx0XHRjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGxvZ2dlci5lcnJvcignbXV0ZU1pYygpIHwgZmFpbGVkOiAlbycsIGVycm9yKTtcblx0XHR9XG5cdH1cblxuXHRhc3luYyB1bm11dGVNaWMoKSB7XG5cdFx0bG9nZ2VyLmRlYnVnKCd1bm11dGVNaWMoKScpO1xuXG5cdFx0dGhpcy5fbWljUHJvZHVjZXIucmVzdW1lKCk7XG5cblx0XHR0cnkge1xuXHRcdFx0YXdhaXQgdGhpcy5fcHJvdG9vLnJlcXVlc3QoXG5cdFx0XHRcdCdyZXN1bWVQcm9kdWNlcicsIHsgcHJvZHVjZXJJZDogdGhpcy5fbWljUHJvZHVjZXIuaWQgfSk7XG5cdFx0fVxuXHRcdGNhdGNoIChlcnJvcikge1xuXHRcdFx0bG9nZ2VyLmVycm9yKCd1bm11dGVNaWMoKSB8IGZhaWxlZDogJW8nLCBlcnJvcik7XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgcmVxdWVzdE1lZGlhUGVlcihwZWVySWQpIHtcblx0XHRsb2dnZXIuZGVidWcoYHJlcXVlc3QgcGVlcjogJHtwZWVySWR9YCk7XG5cdFx0dGhpcy5fcHJvdG9vLnJlcXVlc3QoJ3JlcXVlc3RQZWVyJywgeyBwZWVySWQgfSlcblx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0RXZlbnRzLnRyaWdnZXJDbGllbnRSZXF1ZXN0TWVkaWFQZWVyUmVzcG9uc2UodGhpcy5yb29tSWQsIHBlZXJJZCwgdHJ1ZSk7XG5cdFx0XHR9KVxuXHRcdFx0LmNhdGNoKChlcnIpID0+IHtcblx0XHRcdFx0Ly8gY29uc29sZS5sb2coZXJyKTtcblx0XHRcdFx0bG9nZ2VyLmVycm9yKCdyZXF1ZXN0Q2xvc2VNZWRpYVBlZXIgLSBlcnJvcicsIHBlZXJJZCwgZXJyKTtcblx0XHRcdFx0RXZlbnRzLnRyaWdnZXJDbGllbnRSZXF1ZXN0TWVkaWFQZWVyUmVzcG9uc2UodGhpcy5yb29tSWQsIHBlZXJJZCwgZmFsc2UpO1xuXHRcdFx0fSk7XG5cdH1cblxuXHRhc3luYyByZXF1ZXN0Q2xvc2VNZWRpYVBlZXIocGVlcklkKSB7XG5cdFx0Ly8gdGhpcy5fcHJvdG9vLnJlcXVlc3QoXG5cdFx0Ly8gXHQncmVxdWVzdENsb3NlUGVlcicsIHsgcGVlcklkIH0pO1xuXG5cdFx0Y29uc3QgY29uc3VtZXJJZCA9IHRoaXMuX3BlZXJzLmdldChwZWVySWQpO1xuXG5cdFx0aWYgKCFjb25zdW1lcklkKSByZXR1cm47XG5cblx0XHRjb25zdCBjb25zdW1lciA9IHRoaXMuX2NvbnN1bWVycy5nZXQoY29uc3VtZXJJZCk7XG5cblx0XHR0aGlzLl9jbG9zZUNvbnN1bWVyKGNvbnN1bWVyLCBwZWVySWQpO1xuXHR9XG5cblx0YXN5bmMgbXV0ZUF1ZGlvKCkge1xuXHRcdGxvZ2dlci5kZWJ1ZygnbXV0ZUF1ZGlvKCknKTtcblx0fVxuXG5cdGFzeW5jIHVubXV0ZUF1ZGlvKCkge1xuXHRcdGxvZ2dlci5kZWJ1ZygndW5tdXRlQXVkaW8oKScpO1xuXHR9XG5cblx0YXN5bmMgcmVzdGFydEljZSgpIHtcblx0XHRsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGlmICh0aGlzLl9zZW5kVHJhbnNwb3J0KSB7XG5cdFx0XHRcdGNvbnN0IGljZVBhcmFtZXRlcnMgPSBhd2FpdCB0aGlzLl9wcm90b28ucmVxdWVzdChcblx0XHRcdFx0XHQncmVzdGFydEljZScsXG5cdFx0XHRcdFx0eyB0cmFuc3BvcnRJZDogdGhpcy5fc2VuZFRyYW5zcG9ydC5pZCB9KTtcblxuXHRcdFx0XHRhd2FpdCB0aGlzLl9zZW5kVHJhbnNwb3J0LnJlc3RhcnRJY2UoeyBpY2VQYXJhbWV0ZXJzIH0pO1xuXHRcdFx0fVxuXG5cdFx0XHRpZiAodGhpcy5fcmVjdlRyYW5zcG9ydCkge1xuXHRcdFx0XHRjb25zdCBpY2VQYXJhbWV0ZXJzID0gYXdhaXQgdGhpcy5fcHJvdG9vLnJlcXVlc3QoXG5cdFx0XHRcdFx0J3Jlc3RhcnRJY2UnLFxuXHRcdFx0XHRcdHsgdHJhbnNwb3J0SWQ6IHRoaXMuX3JlY3ZUcmFuc3BvcnQuaWQgfSk7XG5cblx0XHRcdFx0YXdhaXQgdGhpcy5fcmVjdlRyYW5zcG9ydC5yZXN0YXJ0SWNlKHsgaWNlUGFyYW1ldGVycyB9KTtcblx0XHRcdH1cblxuXHRcdH1cblx0XHRjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGxvZ2dlci5lcnJvcigncmVzdGFydEljZSgpIHwgZmFpbGVkOiVvJywgZXJyb3IpO1xuXG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgc2V0Q29uc3VtZXJQcmVmZXJyZWRMYXllcnMoY29uc3VtZXJJZCwgc3BhdGlhbExheWVyLCB0ZW1wb3JhbExheWVyKSB7XG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J3NldENvbnN1bWVyUHJlZmVycmVkTGF5ZXJzKCkgW2NvbnN1bWVySWQ6JXMsIHNwYXRpYWxMYXllcjolcywgdGVtcG9yYWxMYXllcjolc10nLFxuXHRcdFx0Y29uc3VtZXJJZCwgc3BhdGlhbExheWVyLCB0ZW1wb3JhbExheWVyKTtcblxuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCB0aGlzLl9wcm90b28ucmVxdWVzdChcblx0XHRcdFx0J3NldENvbnN1bWVyUHJlZmVycmVkTGF5ZXJzJywgeyBjb25zdW1lcklkLCBzcGF0aWFsTGF5ZXIsIHRlbXBvcmFsTGF5ZXIgfSk7XG5cdFx0fVxuXHRcdGNhdGNoIChlcnJvcikge1xuXHRcdFx0bG9nZ2VyLmVycm9yKCdzZXRDb25zdW1lclByZWZlcnJlZExheWVycygpIHwgZmFpbGVkOiVvJywgZXJyb3IpO1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIHNldENvbnN1bWVyUHJpb3JpdHkoY29uc3VtZXJJZCwgcHJpb3JpdHkpIHtcblx0XHRsb2dnZXIuZGVidWcoXG5cdFx0XHQnc2V0Q29uc3VtZXJQcmlvcml0eSgpIFtjb25zdW1lcklkOiVzLCBwcmlvcml0eTolZF0nLFxuXHRcdFx0Y29uc3VtZXJJZCwgcHJpb3JpdHkpO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IHRoaXMuX3Byb3Rvby5yZXF1ZXN0KCdzZXRDb25zdW1lclByaW9yaXR5JywgeyBjb25zdW1lcklkLCBwcmlvcml0eSB9KTtcblx0XHR9XG5cdFx0Y2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRsb2dnZXIuZXJyb3IoJ3NldENvbnN1bWVyUHJpb3JpdHkoKSB8IGZhaWxlZDolbycsIGVycm9yKTtcblx0XHR9XG5cdH1cblxuXHRhc3luYyBnZXRTZW5kVHJhbnNwb3J0UmVtb3RlU3RhdHMoKSB7XG5cdFx0bG9nZ2VyLmRlYnVnKCdnZXRTZW5kVHJhbnNwb3J0UmVtb3RlU3RhdHMoKScpO1xuXG5cdFx0aWYgKCF0aGlzLl9zZW5kVHJhbnNwb3J0KVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0cmV0dXJuIHRoaXMuX3Byb3Rvby5yZXF1ZXN0KFxuXHRcdFx0J2dldFRyYW5zcG9ydFN0YXRzJywgeyB0cmFuc3BvcnRJZDogdGhpcy5fc2VuZFRyYW5zcG9ydC5pZCB9KTtcblx0fVxuXG5cdGFzeW5jIGdldFJlY3ZUcmFuc3BvcnRSZW1vdGVTdGF0cygpIHtcblx0XHRsb2dnZXIuZGVidWcoJ2dldFJlY3ZUcmFuc3BvcnRSZW1vdGVTdGF0cygpJyk7XG5cblx0XHRpZiAoIXRoaXMuX3JlY3ZUcmFuc3BvcnQpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRyZXR1cm4gdGhpcy5fcHJvdG9vLnJlcXVlc3QoXG5cdFx0XHQnZ2V0VHJhbnNwb3J0U3RhdHMnLCB7IHRyYW5zcG9ydElkOiB0aGlzLl9yZWN2VHJhbnNwb3J0LmlkIH0pO1xuXHR9XG5cblx0YXN5bmMgZ2V0QXVkaW9SZW1vdGVTdGF0cygpIHtcblx0XHRsb2dnZXIuZGVidWcoJ2dldEF1ZGlvUmVtb3RlU3RhdHMoKScpO1xuXG5cdFx0aWYgKCF0aGlzLl9taWNQcm9kdWNlcilcblx0XHRcdHJldHVybjtcblxuXHRcdHJldHVybiB0aGlzLl9wcm90b28ucmVxdWVzdChcblx0XHRcdCdnZXRQcm9kdWNlclN0YXRzJywgeyBwcm9kdWNlcklkOiB0aGlzLl9taWNQcm9kdWNlci5pZCB9KTtcblx0fVxuXG5cdGFzeW5jIGdldENvbnN1bWVyUmVtb3RlU3RhdHMoY29uc3VtZXJJZCkge1xuXHRcdGxvZ2dlci5kZWJ1ZygnZ2V0Q29uc3VtZXJSZW1vdGVTdGF0cygpJyk7XG5cblx0XHRjb25zdCBjb25zdW1lciA9IHRoaXMuX2NvbnN1bWVycy5nZXQoY29uc3VtZXJJZCk7XG5cblx0XHRpZiAoIWNvbnN1bWVyKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0cmV0dXJuIHRoaXMuX3Byb3Rvby5yZXF1ZXN0KCdnZXRDb25zdW1lclN0YXRzJywgeyBjb25zdW1lcklkIH0pO1xuXHR9XG5cblx0YXN5bmMgZ2V0Qm90RGF0YVByb2R1Y2VyUmVtb3RlU3RhdHMoKSB7XG5cdFx0bG9nZ2VyLmRlYnVnKCdnZXRCb3REYXRhUHJvZHVjZXJSZW1vdGVTdGF0cygpJyk7XG5cblx0XHRjb25zdCBkYXRhUHJvZHVjZXIgPSB0aGlzLl9ib3REYXRhUHJvZHVjZXI7XG5cblx0XHRpZiAoIWRhdGFQcm9kdWNlcilcblx0XHRcdHJldHVybjtcblxuXHRcdHJldHVybiB0aGlzLl9wcm90b28ucmVxdWVzdChcblx0XHRcdCdnZXREYXRhUHJvZHVjZXJTdGF0cycsIHsgZGF0YVByb2R1Y2VySWQ6IGRhdGFQcm9kdWNlci5pZCB9KTtcblx0fVxuXG5cdGFzeW5jIGdldERhdGFDb25zdW1lclJlbW90ZVN0YXRzKGRhdGFDb25zdW1lcklkKSB7XG5cdFx0bG9nZ2VyLmRlYnVnKCdnZXREYXRhQ29uc3VtZXJSZW1vdGVTdGF0cygpJyk7XG5cblx0XHRjb25zdCBkYXRhQ29uc3VtZXIgPSB0aGlzLl9kYXRhQ29uc3VtZXJzLmdldChkYXRhQ29uc3VtZXJJZCk7XG5cblx0XHRpZiAoIWRhdGFDb25zdW1lcilcblx0XHRcdHJldHVybjtcblxuXHRcdHJldHVybiB0aGlzLl9wcm90b28ucmVxdWVzdCgnZ2V0RGF0YUNvbnN1bWVyU3RhdHMnLCB7IGRhdGFDb25zdW1lcklkIH0pO1xuXHR9XG5cblx0YXN5bmMgZ2V0U2VuZFRyYW5zcG9ydExvY2FsU3RhdHMoKSB7XG5cdFx0bG9nZ2VyLmRlYnVnKCdnZXRTZW5kVHJhbnNwb3J0TG9jYWxTdGF0cygpJyk7XG5cblx0XHRpZiAoIXRoaXMuX3NlbmRUcmFuc3BvcnQpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRyZXR1cm4gdGhpcy5fc2VuZFRyYW5zcG9ydC5nZXRTdGF0cygpO1xuXHR9XG5cblx0YXN5bmMgZ2V0UmVjdlRyYW5zcG9ydExvY2FsU3RhdHMoKSB7XG5cdFx0bG9nZ2VyLmRlYnVnKCdnZXRSZWN2VHJhbnNwb3J0TG9jYWxTdGF0cygpJyk7XG5cblx0XHRpZiAoIXRoaXMuX3JlY3ZUcmFuc3BvcnQpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRyZXR1cm4gdGhpcy5fcmVjdlRyYW5zcG9ydC5nZXRTdGF0cygpO1xuXHR9XG5cblx0YXN5bmMgZ2V0QXVkaW9Mb2NhbFN0YXRzKCkge1xuXHRcdGxvZ2dlci5kZWJ1ZygnZ2V0QXVkaW9Mb2NhbFN0YXRzKCknKTtcblxuXHRcdGlmICghdGhpcy5fbWljUHJvZHVjZXIpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRyZXR1cm4gdGhpcy5fbWljUHJvZHVjZXIuZ2V0U3RhdHMoKTtcblx0fVxuXG5cdGFzeW5jIGdldENvbnN1bWVyTG9jYWxTdGF0cyhjb25zdW1lcklkKSB7XG5cdFx0Y29uc3QgY29uc3VtZXIgPSB0aGlzLl9jb25zdW1lcnMuZ2V0KGNvbnN1bWVySWQpO1xuXG5cdFx0aWYgKCFjb25zdW1lcilcblx0XHRcdHJldHVybjtcblxuXHRcdHJldHVybiBjb25zdW1lci5nZXRTdGF0cygpO1xuXHR9XG5cblx0YXN5bmMgYXBwbHlOZXR3b3JrVGhyb3R0bGUoeyB1cGxpbmssIGRvd25saW5rLCBydHQsIHNlY3JldCB9KSB7XG5cdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0J2FwcGx5TmV0d29ya1Rocm90dGxlKCkgW3VwbGluazolcywgZG93bmxpbms6JXMsIHJ0dDolc10nLFxuXHRcdFx0dXBsaW5rLCBkb3dubGluaywgcnR0KTtcblxuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCB0aGlzLl9wcm90b28ucmVxdWVzdChcblx0XHRcdFx0J2FwcGx5TmV0d29ya1Rocm90dGxlJyxcblx0XHRcdFx0eyB1cGxpbmssIGRvd25saW5rLCBydHQsIHNlY3JldCB9KTtcblx0XHR9XG5cdFx0Y2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRsb2dnZXIuZXJyb3IoJ2FwcGx5TmV0d29ya1Rocm90dGxlKCkgfCBmYWlsZWQ6JW8nLCBlcnJvcik7XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgcmVzZXROZXR3b3JrVGhyb3R0bGUoeyBzaWxlbnQgPSBmYWxzZSwgc2VjcmV0IH0pIHtcblx0XHRsb2dnZXIuZGVidWcoJ3Jlc2V0TmV0d29ya1Rocm90dGxlKCknKTtcblxuXHRcdHRyeSB7XG5cdFx0XHRhd2FpdCB0aGlzLl9wcm90b28ucmVxdWVzdCgncmVzZXROZXR3b3JrVGhyb3R0bGUnLCB7IHNlY3JldCB9KTtcblx0XHR9XG5cdFx0Y2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRpZiAoIXNpbGVudCkge1xuXHRcdFx0XHRsb2dnZXIuZXJyb3IoJ3Jlc2V0TmV0d29ya1Rocm90dGxlKCkgfCBmYWlsZWQ6JW8nLCBlcnJvcik7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgX2pvaW5Sb29tKCkge1xuXHRcdGxvZ2dlci5kZWJ1ZygnX2pvaW5Sb29tKCknKTtcblxuXHRcdHRyeSB7XG5cdFx0XHR0aGlzLl9tZWRpYXNvdXBEZXZpY2UgPSBuZXcgbWVkaWFzb3VwQ2xpZW50LkRldmljZShcblx0XHRcdFx0e1xuXHRcdFx0XHRcdGhhbmRsZXJOYW1lOiB0aGlzLl9oYW5kbGVyTmFtZVxuXHRcdFx0XHR9KTtcblxuXHRcdFx0Y29uc3Qgcm91dGVyUnRwQ2FwYWJpbGl0aWVzID1cblx0XHRcdFx0YXdhaXQgdGhpcy5fcHJvdG9vLnJlcXVlc3QoJ2dldFJvdXRlclJ0cENhcGFiaWxpdGllcycpO1xuXG5cdFx0XHRhd2FpdCB0aGlzLl9tZWRpYXNvdXBEZXZpY2UubG9hZCh7IHJvdXRlclJ0cENhcGFiaWxpdGllcyB9KTtcblxuXHRcdFx0Ly8gTk9URTogU3R1ZmYgdG8gcGxheSByZW1vdGUgYXVkaW9zIGR1ZSB0byBicm93c2VycycgbmV3IGF1dG9wbGF5IHBvbGljeS5cblx0XHRcdC8vXG5cdFx0XHQvLyBKdXN0IGdldCBhY2Nlc3MgdG8gdGhlIG1pYyBhbmQgRE8gTk9UIGNsb3NlIHRoZSBtaWMgdHJhY2sgZm9yIGEgd2hpbGUuXG5cdFx0XHQvLyBTdXBlciBoYWNrIVxuXHRcdFx0Y29uc3QgY29uc3RyYWludHMgPSB7XG5cdFx0XHRcdGF1ZGlvOiB7XG5cdFx0XHRcdFx0Ly8gZWNob0NhbmNlbGxhdGlvbjogaXNVc2IgPyBmYWxzZSA6IG51bGwsXG5cdFx0XHRcdFx0ZWNob0NhbmNlbGxhdGlvbjogZmFsc2UsXG5cdFx0XHRcdFx0bm9pc2VTdXBwcmVzc2lvbjogdHJ1ZSxcblx0XHRcdFx0XHRhdXRvR2FpbkNvbnRyb2w6IGZhbHNlXG5cdFx0XHRcdFx0Ly8gZGV2aWNlSWQgOiBkZXZpY2VJZFxuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHRjb25zdCBzdHJlYW0gPSBhd2FpdCBuYXZpZ2F0b3IubWVkaWFEZXZpY2VzLmdldFVzZXJNZWRpYShjb25zdHJhaW50cyk7XG5cdFx0XHRjb25zdCBhdWRpb1RyYWNrID0gc3RyZWFtLmdldEF1ZGlvVHJhY2tzKClbMF07XG5cblx0XHRcdGF1ZGlvVHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuXG5cdFx0XHRzZXRUaW1lb3V0KCgpID0+IGF1ZGlvVHJhY2suc3RvcCgpLCAxMjAwMDApO1xuXHRcdFx0Ly8gQ3JlYXRlIG1lZGlhc291cCBUcmFuc3BvcnQgZm9yIHNlbmRpbmcgKHVubGVzcyB3ZSBkb24ndCB3YW50IHRvIHByb2R1Y2UpLlxuXHRcdFx0aWYgKHRoaXMuX3Byb2R1Y2UpIHtcblx0XHRcdFx0Y29uc3QgdHJhbnNwb3J0SW5mbyA9IGF3YWl0IHRoaXMuX3Byb3Rvby5yZXF1ZXN0KFxuXHRcdFx0XHRcdCdjcmVhdGVXZWJSdGNUcmFuc3BvcnQnLFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGZvcmNlVGNwOiB0aGlzLl9mb3JjZVRjcCxcblx0XHRcdFx0XHRcdHByb2R1Y2luZzogdHJ1ZSxcblx0XHRcdFx0XHRcdGNvbnN1bWluZzogZmFsc2UsXG5cdFx0XHRcdFx0XHRzY3RwQ2FwYWJpbGl0aWVzOiB0aGlzLl91c2VEYXRhQ2hhbm5lbFxuXHRcdFx0XHRcdFx0XHQ/IHRoaXMuX21lZGlhc291cERldmljZS5zY3RwQ2FwYWJpbGl0aWVzXG5cdFx0XHRcdFx0XHRcdDogdW5kZWZpbmVkXG5cdFx0XHRcdFx0fSk7XG5cblx0XHRcdFx0Y29uc3Qge1xuXHRcdFx0XHRcdGlkLFxuXHRcdFx0XHRcdGljZVBhcmFtZXRlcnMsXG5cdFx0XHRcdFx0aWNlQ2FuZGlkYXRlcyxcblx0XHRcdFx0XHRkdGxzUGFyYW1ldGVycyxcblx0XHRcdFx0XHRzY3RwUGFyYW1ldGVyc1xuXHRcdFx0XHR9ID0gdHJhbnNwb3J0SW5mbztcblxuXHRcdFx0XHR0aGlzLl9zZW5kVHJhbnNwb3J0ID0gdGhpcy5fbWVkaWFzb3VwRGV2aWNlLmNyZWF0ZVNlbmRUcmFuc3BvcnQoXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0aWQsXG5cdFx0XHRcdFx0XHRpY2VQYXJhbWV0ZXJzLFxuXHRcdFx0XHRcdFx0aWNlQ2FuZGlkYXRlcyxcblx0XHRcdFx0XHRcdGR0bHNQYXJhbWV0ZXJzLFxuXHRcdFx0XHRcdFx0c2N0cFBhcmFtZXRlcnMsXG5cdFx0XHRcdFx0XHRpY2VTZXJ2ZXJzLFxuXHRcdFx0XHRcdFx0cHJvcHJpZXRhcnlDb25zdHJhaW50czogUENfUFJPUFJJRVRBUllfQ09OU1RSQUlOVFNcblx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHR0aGlzLl9zZW5kVHJhbnNwb3J0Lm9uKFxuXHRcdFx0XHRcdCdjb25uZWN0JywgKHsgZHRsc1BhcmFtZXRlcnMgfSwgY2FsbGJhY2ssIGVycmJhY2spID0+IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tc2hhZG93XG5cdFx0XHRcdHtcblx0XHRcdFx0XHR0aGlzLl9wcm90b28ucmVxdWVzdChcblx0XHRcdFx0XHRcdCdjb25uZWN0V2ViUnRjVHJhbnNwb3J0Jyxcblx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0dHJhbnNwb3J0SWQ6IHRoaXMuX3NlbmRUcmFuc3BvcnQuaWQsXG5cdFx0XHRcdFx0XHRcdGR0bHNQYXJhbWV0ZXJzXG5cdFx0XHRcdFx0XHR9KVxuXHRcdFx0XHRcdFx0LnRoZW4oY2FsbGJhY2spXG5cdFx0XHRcdFx0XHQuY2F0Y2goZXJyYmFjayk7XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHRoaXMuX3NlbmRUcmFuc3BvcnQub24oXG5cdFx0XHRcdFx0J3Byb2R1Y2UnLCBhc3luYyAoeyBraW5kLCBydHBQYXJhbWV0ZXJzLCBhcHBEYXRhIH0sIGNhbGxiYWNrLCBlcnJiYWNrKSA9PiB7XG5cdFx0XHRcdFx0dHJ5IHtcblx0XHRcdFx0XHRcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1zaGFkb3dcblx0XHRcdFx0XHRcdGNvbnN0IHsgaWQgfSA9IGF3YWl0IHRoaXMuX3Byb3Rvby5yZXF1ZXN0KFxuXHRcdFx0XHRcdFx0XHQncHJvZHVjZScsXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHR0cmFuc3BvcnRJZDogdGhpcy5fc2VuZFRyYW5zcG9ydC5pZCxcblx0XHRcdFx0XHRcdFx0XHRraW5kLFxuXHRcdFx0XHRcdFx0XHRcdHJ0cFBhcmFtZXRlcnMsXG5cdFx0XHRcdFx0XHRcdFx0YXBwRGF0YVxuXHRcdFx0XHRcdFx0XHR9KTtcblxuXHRcdFx0XHRcdFx0Y2FsbGJhY2soeyBpZCB9KTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdFx0Y2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRcdFx0XHRlcnJiYWNrKGVycm9yKTtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHRoaXMuX3NlbmRUcmFuc3BvcnQub24oJ3Byb2R1Y2VkYXRhJywgYXN5bmMgKFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHNjdHBTdHJlYW1QYXJhbWV0ZXJzLFxuXHRcdFx0XHRcdFx0bGFiZWwsXG5cdFx0XHRcdFx0XHRwcm90b2NvbCxcblx0XHRcdFx0XHRcdGFwcERhdGFcblx0XHRcdFx0XHR9LFxuXHRcdFx0XHRcdGNhbGxiYWNrLFxuXHRcdFx0XHRcdGVycmJhY2tcblx0XHRcdFx0KSA9PiB7XG5cdFx0XHRcdFx0bG9nZ2VyLmRlYnVnKFxuXHRcdFx0XHRcdFx0J1wicHJvZHVjZWRhdGFcIiBldmVudDogW3NjdHBTdHJlYW1QYXJhbWV0ZXJzOiVvLCBhcHBEYXRhOiVvXScsXG5cdFx0XHRcdFx0XHRzY3RwU3RyZWFtUGFyYW1ldGVycywgYXBwRGF0YSk7XG5cblx0XHRcdFx0XHR0cnkge1xuXHRcdFx0XHRcdFx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXNoYWRvd1xuXHRcdFx0XHRcdFx0Y29uc3QgeyBpZCB9ID0gYXdhaXQgdGhpcy5fcHJvdG9vLnJlcXVlc3QoXG5cdFx0XHRcdFx0XHRcdCdwcm9kdWNlRGF0YScsXG5cdFx0XHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdFx0XHR0cmFuc3BvcnRJZDogdGhpcy5fc2VuZFRyYW5zcG9ydC5pZCxcblx0XHRcdFx0XHRcdFx0XHRzY3RwU3RyZWFtUGFyYW1ldGVycyxcblx0XHRcdFx0XHRcdFx0XHRsYWJlbCxcblx0XHRcdFx0XHRcdFx0XHRwcm90b2NvbCxcblx0XHRcdFx0XHRcdFx0XHRhcHBEYXRhXG5cdFx0XHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdFx0XHRjYWxsYmFjayh7IGlkIH0pO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0XHRjYXRjaCAoZXJyb3IpIHtcblx0XHRcdFx0XHRcdGVycmJhY2soZXJyb3IpO1xuXHRcdFx0XHRcdH1cblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIENyZWF0ZSBtZWRpYXNvdXAgVHJhbnNwb3J0IGZvciBzZW5kaW5nICh1bmxlc3Mgd2UgZG9uJ3Qgd2FudCB0byBjb25zdW1lKS5cblx0XHRcdGlmICh0aGlzLl9jb25zdW1lKSB7XG5cdFx0XHRcdGNvbnN0IHRyYW5zcG9ydEluZm8gPSBhd2FpdCB0aGlzLl9wcm90b28ucmVxdWVzdChcblx0XHRcdFx0XHQnY3JlYXRlV2ViUnRjVHJhbnNwb3J0Jyxcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRmb3JjZVRjcDogdGhpcy5fZm9yY2VUY3AsXG5cdFx0XHRcdFx0XHRwcm9kdWNpbmc6IGZhbHNlLFxuXHRcdFx0XHRcdFx0Y29uc3VtaW5nOiB0cnVlLFxuXHRcdFx0XHRcdFx0c2N0cENhcGFiaWxpdGllczogdGhpcy5fdXNlRGF0YUNoYW5uZWxcblx0XHRcdFx0XHRcdFx0PyB0aGlzLl9tZWRpYXNvdXBEZXZpY2Uuc2N0cENhcGFiaWxpdGllc1xuXHRcdFx0XHRcdFx0XHQ6IHVuZGVmaW5lZFxuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdGNvbnN0IHtcblx0XHRcdFx0XHRpZCxcblx0XHRcdFx0XHRpY2VQYXJhbWV0ZXJzLFxuXHRcdFx0XHRcdGljZUNhbmRpZGF0ZXMsXG5cdFx0XHRcdFx0ZHRsc1BhcmFtZXRlcnMsXG5cdFx0XHRcdFx0c2N0cFBhcmFtZXRlcnNcblx0XHRcdFx0fSA9IHRyYW5zcG9ydEluZm87XG5cblx0XHRcdFx0dGhpcy5fcmVjdlRyYW5zcG9ydCA9IHRoaXMuX21lZGlhc291cERldmljZS5jcmVhdGVSZWN2VHJhbnNwb3J0KFxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGlkLFxuXHRcdFx0XHRcdFx0aWNlUGFyYW1ldGVycyxcblx0XHRcdFx0XHRcdGljZUNhbmRpZGF0ZXMsXG5cdFx0XHRcdFx0XHRkdGxzUGFyYW1ldGVycyxcblx0XHRcdFx0XHRcdHNjdHBQYXJhbWV0ZXJzLFxuXHRcdFx0XHRcdFx0aWNlU2VydmVyc1xuXHRcdFx0XHRcdH0pO1xuXG5cdFx0XHRcdHRoaXMuX3JlY3ZUcmFuc3BvcnQub24oXG5cdFx0XHRcdFx0J2Nvbm5lY3QnLCAoeyBkdGxzUGFyYW1ldGVycyB9LCBjYWxsYmFjaywgZXJyYmFjaykgPT4gLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1zaGFkb3dcblx0XHRcdFx0e1xuXHRcdFx0XHRcdHRoaXMuX3Byb3Rvby5yZXF1ZXN0KFxuXHRcdFx0XHRcdFx0J2Nvbm5lY3RXZWJSdGNUcmFuc3BvcnQnLFxuXHRcdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0XHR0cmFuc3BvcnRJZDogdGhpcy5fcmVjdlRyYW5zcG9ydC5pZCxcblx0XHRcdFx0XHRcdFx0ZHRsc1BhcmFtZXRlcnNcblx0XHRcdFx0XHRcdH0pXG5cdFx0XHRcdFx0XHQudGhlbihjYWxsYmFjaylcblx0XHRcdFx0XHRcdC5jYXRjaChlcnJiYWNrKTtcblx0XHRcdFx0fSk7XG5cdFx0XHR9XG5cblx0XHRcdC8vIEpvaW4gbm93IGludG8gdGhlIHJvb20uXG5cdFx0XHQvLyBOT1RFOiBEb24ndCBzZW5kIG91ciBSVFAgY2FwYWJpbGl0aWVzIGlmIHdlIGRvbid0IHdhbnQgdG8gY29uc3VtZS5cblx0XHRcdGF3YWl0IHRoaXMuX3Byb3Rvby5yZXF1ZXN0KFxuXHRcdFx0XHQnam9pbicsXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRkaXNwbGF5TmFtZTogdGhpcy5wZWVySWQsXG5cdFx0XHRcdFx0ZGV2aWNlOiB0aGlzLl9kZXZpY2UsXG5cdFx0XHRcdFx0cnRwQ2FwYWJpbGl0aWVzOiB0aGlzLl9jb25zdW1lXG5cdFx0XHRcdFx0XHQ/IHRoaXMuX21lZGlhc291cERldmljZS5ydHBDYXBhYmlsaXRpZXNcblx0XHRcdFx0XHRcdDogdW5kZWZpbmVkLFxuXHRcdFx0XHRcdHNjdHBDYXBhYmlsaXRpZXM6IHRoaXMuX3VzZURhdGFDaGFubmVsICYmIHRoaXMuX2NvbnN1bWVcblx0XHRcdFx0XHRcdD8gdGhpcy5fbWVkaWFzb3VwRGV2aWNlLnNjdHBDYXBhYmlsaXRpZXNcblx0XHRcdFx0XHRcdDogdW5kZWZpbmVkXG5cdFx0XHRcdH0pO1xuXG5cdFx0XHQvLyBFbmFibGUgbWljLlxuXHRcdFx0aWYgKHRoaXMuX3Byb2R1Y2UpIHtcblx0XHRcdFx0Ly8gU2V0IG91ciBtZWRpYSBjYXBhYmlsaXRpZXMuXG5cblx0XHRcdFx0dGhpcy5lbmFibGVNaWMoKTtcblxuXHRcdFx0XHQvLyB0aGlzLl9zZW5kVHJhbnNwb3J0Lm9uKCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoY29ubmVjdGlvblN0YXRlKSA9PlxuXHRcdFx0XHQvLyB7XG5cdFx0XHRcdC8vIFx0Ly8gRXZlbnRzLnRyaWdnZXJDbGllbnRDaGFuZ2VTdGF0ZUNvbm5lY3Rpb24oY29ubmVjdGlvblN0YXRlKVxuXHRcdFx0XHQvLyB9KTtcblx0XHRcdH1cblxuXHRcdFx0RXZlbnRzLnRyaWdnZXJDbGllbnRDaGFuZ2VTdGF0ZUNvbm5lY3Rpb24odGhpcy5yb29tSWQsICdjb25uZWN0ZWQnKTtcblxuXHRcdH1cblx0XHRjYXRjaCAoZXJyb3IpIHtcblx0XHRcdGxvZ2dlci5lcnJvcignX2pvaW5Sb29tKCkgZmFpbGVkOiVvJywgZXJyb3IpO1xuXG5cdFx0XHR0aGlzLmNsb3NlKCk7XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgX3BhdXNlQ29uc3VtZXIoY29uc3VtZXIpIHtcblx0XHRpZiAoY29uc3VtZXIucGF1c2VkKVxuXHRcdFx0cmV0dXJuO1xuXG5cdFx0dHJ5IHtcblx0XHRcdGF3YWl0IHRoaXMuX3Byb3Rvby5yZXF1ZXN0KCdwYXVzZUNvbnN1bWVyJywgeyBjb25zdW1lcklkOiBjb25zdW1lci5pZCB9KTtcblxuXHRcdFx0Y29uc3VtZXIucGF1c2UoKTtcblx0XHR9XG5cdFx0Y2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRsb2dnZXIuZXJyb3IoJ19wYXVzZUNvbnN1bWVyKCkgfCBmYWlsZWQ6JW8nLCBlcnJvcik7XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgX3Jlc3VtZUNvbnN1bWVyKGNvbnN1bWVyKSB7XG5cdFx0aWYgKCFjb25zdW1lci5wYXVzZWQpXG5cdFx0XHRyZXR1cm47XG5cblx0XHR0cnkge1xuXHRcdFx0YXdhaXQgdGhpcy5fcHJvdG9vLnJlcXVlc3QoJ3Jlc3VtZUNvbnN1bWVyJywgeyBjb25zdW1lcklkOiBjb25zdW1lci5pZCB9KTtcblxuXHRcdFx0Y29uc3VtZXIucmVzdW1lKCk7XG5cdFx0fVxuXHRcdGNhdGNoIChlcnJvcikge1xuXHRcdFx0bG9nZ2VyLmVycm9yKCdfcmVzdW1lQ29uc3VtZXIoKSB8IGZhaWxlZDolbycsIGVycm9yKTtcblx0XHR9XG5cdH1cblxuXHRhc3luYyBfY2xvc2VDb25zdW1lcihjb25zdW1lciwgcGVlcklkKSB7XG5cdFx0aWYgKCFjb25zdW1lciB8fCBjb25zdW1lci5jbG9zZWQpXG5cdFx0XHRyZXR1cm47XG5cblx0XHR0cnkge1xuXHRcdFx0dGhpcy5fcHJvdG9vLnJlcXVlc3QoJ2Nsb3NlQ29uc3VtZXInLCB7IGNvbnN1bWVySWQ6IGNvbnN1bWVyLmlkIH0pXG5cdFx0XHRcdC50aGVuKCgpID0+IHtcblx0XHRcdFx0XHRFdmVudHMudHJpZ2dlckNsaWVudFJlcXVlc3RDbG9zZU1lZGlhUGVlclJlc3BvbnNlKFxuXHRcdFx0XHRcdFx0dGhpcy5yb29tSWQsXG5cdFx0XHRcdFx0XHRwZWVySWQsXG5cdFx0XHRcdFx0XHR0cnVlXG5cdFx0XHRcdFx0KTtcblx0XHRcdFx0XHRjb25zdW1lci5jbG9zZSgpO1xuXHRcdFx0XHRcdHRoaXMucmVtb3ZlQ29uc3VtZXJBdWRpbyhjb25zdW1lci5pZCk7XG5cdFx0XHRcdFx0dGhpcy5fcGVlcnMuZGVsZXRlKGNvbnN1bWVyLnBlZXJJZCk7XG5cdFx0XHRcdFx0dGhpcy5fY29uc3VtZXJzLmRlbGV0ZShjb25zdW1lci5pZCk7XG5cdFx0XHRcdH0pXG5cdFx0XHRcdC5jYXRjaCgoZXJyKSA9PiB7XG5cdFx0XHRcdFx0Ly8gY29uc29sZS5sb2coZXJyKTtcblx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoJ3JlcXVlc3RDbG9zZU1lZGlhUGVlciAtIGVycm9yJywgcGVlcklkLCBlcnIpO1xuXHRcdFx0XHRcdEV2ZW50cy50cmlnZ2VyQ2xpZW50UmVxdWVzdENsb3NlTWVkaWFQZWVyUmVzcG9uc2UodGhpcy5yb29tSWQsIHBlZXJJZCwgZmFsc2UpO1xuXHRcdFx0XHR9KTtcblx0XHR9XG5cdFx0Y2F0Y2ggKGVycm9yKSB7XG5cdFx0XHRsb2dnZXIuZXJyb3IoJ19jbG9zZUNvbnN1bWVyKCkgfCBmYWlsZWQ6JW8nLCBlcnJvcik7XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgaW5pdENvbnN1bWVyQXVkaW8oY29uc3VtZXJJZCkge1xuXG5cdFx0Y29uc3QgY29uc3VtZXIgPSB0aGlzLl9jb25zdW1lcnMuZ2V0KGNvbnN1bWVySWQpO1xuXHRcdGNvbnN0IHN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbTtcblxuXHRcdGNvbnN0IGF1ZGlvID0gbmV3IEF1ZGlvKCk7XG5cblx0XHRhdWRpby5hdXRvcGxheSA9IGZhbHNlO1xuXHRcdGF1ZGlvLnZvbHVtZSA9IDA7XG5cblx0XHRzdHJlYW0uYWRkVHJhY2soY29uc3VtZXIudHJhY2spO1xuXG5cdFx0YXVkaW8uc3JjT2JqZWN0ID0gc3RyZWFtO1xuXG5cdFx0Y29uc3Qgc291cmNlID0gdGhpcy5hdWRpb0NvbnRleHQuY3JlYXRlTWVkaWFTdHJlYW1Tb3VyY2Uoc3RyZWFtKTtcblxuXHRcdC8vIEdhaW5Ob2RlIChwcm94aW1pdHkpXG5cdFx0Y29uc3VtZXIuZ2Fpbk5vZGUgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVHYWluKCk7XG5cdFx0c291cmNlLmNvbm5lY3QoY29uc3VtZXIuZ2Fpbk5vZGUpO1xuXHRcdC8vIGNvbnN1bWVyLmdhaW5Ob2RlLmNvbm5lY3QodGhpcy5tYWluVm9sdW1lKTtcblx0XHRjb25zdW1lci5nYWluTm9kZS5nYWluLnNldFZhbHVlQXRUaW1lKDAsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKTtcblxuXHRcdC8vIFBhbm5lck5vZGUgKHN0ZXJlbylcblx0XHRjb25zdCBwYW5uZXIgPSB0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVQYW5uZXIoKTtcblxuXHRcdGNvbnN1bWVyLnBhbm5lciA9IHBhbm5lcjtcblx0XHRjb25zdW1lci5nYWluTm9kZS5jb25uZWN0KGNvbnN1bWVyLnBhbm5lcik7XG5cdFx0Y29uc3VtZXIucGFubmVyLmNvbm5lY3QodGhpcy5tYWluVm9sdW1lKTtcblx0XHRjb25zdW1lci5wYW5uZXIuc2V0T3JpZW50YXRpb24oMCwgMCwgMSk7XG5cblx0XHRjb25zdW1lci5zdHJlYW1Tb3VyY2UgPSBzb3VyY2U7XG5cdFx0Y29uc3VtZXIuYXVkaW9Tb3VyY2UgPSBhdWRpbztcblx0XHRjb25zdW1lci5jdXJyZW50QWN0aXZlTm9kZSA9IGNvbnN1bWVyLnBhbm5lcjtcblx0XHRjb25zdW1lci5kZWZhdWx0QWN0aXZlTm9kZSA9IGNvbnN1bWVyLnBhbm5lcjtcblxuXHRcdC8vIGNvbnN1bWVyLmVmZmVjdHMgPSB7fTtcblx0fVxuXG5cdGFzeW5jIHJlbW92ZUNvbnN1bWVyQXVkaW8oY29uc3VtZXJJZCkge1xuXHRcdGNvbnN0IGNvbnN1bWVyID0gdGhpcy5fY29uc3VtZXJzLmdldChjb25zdW1lcklkKTtcblxuXHRcdGlmICghY29uc3VtZXIpIHJldHVybjtcblxuXHRcdGlmIChjb25zdW1lci5zdHJlYW1Tb3VyY2UpIHtcblx0XHRcdGlmIChjb25zdW1lci5zdHJlYW1Tb3VyY2UubnVtYmVyT2ZPdXRwdXRzID4gMCkge1xuXHRcdFx0XHRjb25zdW1lci5zdHJlYW1Tb3VyY2UuZGlzY29ubmVjdChjb25zdW1lci5nYWluTm9kZSk7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29uc3VtZXIuZ2Fpbk5vZGUubnVtYmVyT2ZPdXRwdXRzID4gMCkge1xuXHRcdFx0XHRjb25zdW1lci5nYWluTm9kZS5kaXNjb25uZWN0KGNvbnN1bWVyLnBhbm5lcik7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29uc3VtZXIucGFubmVyLm51bWJlck9mT3V0cHV0cyA+IDApIHtcblx0XHRcdFx0Y29uc3VtZXIucGFubmVyLmRpc2Nvbm5lY3QodGhpcy5tYWluVm9sdW1lKTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRpZiAoY29uc3VtZXIgJiYgY29uc3VtZXIuYXVkaW9FbGVtZW50KSB7XG5cdFx0XHRjb25zdW1lci5hdWRpb0VsZW1lbnQucmVtb3ZlKCk7XG5cdFx0fVxuXHR9XG5cblx0YXN5bmMgY2hhbmdlTWFpblZvbHVtZSh2b2x1bWUpIHtcblx0XHRpZiAoIWlzTmFOKHZvbHVtZSkpXG5cdFx0XHR0aGlzLm1haW5Wb2x1bWUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh2b2x1bWUsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKTtcblx0fVxuXG5cdGFzeW5jIGNoYW5nZUNvbnN1bWVyVm9sdW1lKHBlZXJJZCwgdm9sdW1lLCBiYWxhbmNlKSB7XG5cdFx0Y29uc3QgY29uc3VtZXJJZCA9IHRoaXMuX3BlZXJzLmdldChwZWVySWQpO1xuXG5cdFx0aWYgKCFjb25zdW1lcklkKSByZXR1cm47XG5cblx0XHRjb25zdCBjb25zdW1lciA9IHRoaXMuX2NvbnN1bWVycy5nZXQoY29uc3VtZXJJZCk7XG5cblx0XHRpZiAoIWNvbnN1bWVyKSByZXR1cm47XG5cblx0XHRpZiAoY29uc3VtZXIuYXVkaW9FbGVtZW50KSB7XG5cdFx0XHRjb25zdW1lci5hdWRpb0VsZW1lbnQudm9sdW1lID0gdm9sdW1lO1xuXHRcdH1cblxuXHRcdGlmIChjb25zdW1lci5nYWluTm9kZSAmJiAhaXNOYU4odm9sdW1lKSkge1xuXHRcdFx0Y29uc3VtZXIuZ2Fpbk5vZGUuZ2Fpbi5zZXRWYWx1ZUF0VGltZSh2b2x1bWUsIHRoaXMuYXVkaW9Db250ZXh0LmN1cnJlbnRUaW1lKTtcblx0XHRcdGNvbnN1bWVyLnZvbHVtZSA9IHZvbHVtZTtcblx0XHR9XG5cblx0XHRpZiAoY29uc3VtZXIucGFubmVyICYmICFpc05hTihiYWxhbmNlKSkge1xuXHRcdFx0Y29uc3VtZXIucGFubmVyLnNldFBvc2l0aW9uKGJhbGFuY2UsIDAsICgxIC0gTWF0aC5hYnMoYmFsYW5jZSkpKTtcblx0XHRcdGNvbnN1bWVyLmJhbGFuY2UgPSBiYWxhbmNlO1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIGNoYW5nZUNvbnN1bWVyc1ZvbHVtZShwZWVycykge1xuXHRcdHBlZXJzID0gdHlwZW9mIHBlZXJzID09PSAnc3RyaW5nJyA/IEpTT04ucGFyc2UocGVlcnMpIDogcGVlcnM7XG5cblx0XHRwZWVycy5mb3JFYWNoKChwZWVyKSA9PiB7XG5cdFx0XHRpZiAocGVlcikge1xuXHRcdFx0XHR0aGlzLmNoYW5nZUNvbnN1bWVyVm9sdW1lKHBlZXIubmFtZSwgcGVlci52b2x1bWUsIHBlZXIuYmFsYW5jZSk7XG5cdFx0XHRcdGlmIChwZWVyLmNsZWFyRWZmZWN0cykge1xuXHRcdFx0XHRcdHRoaXMuY2xlYXJDb25zdW1lckF1ZGlvRWZmZWN0cyhwZWVyLm5hbWUpO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGlmIChwZWVyLmVmZmVjdHMpIHtcblx0XHRcdFx0XHR0aGlzLnNldENvbnN1bWVyQXVkaW9FZmZlY3RzKHBlZXIubmFtZSwgcGVlci5lZmZlY3RzKTtcblx0XHRcdFx0fVxuXHRcdFx0fVxuXHRcdH0pO1xuXHR9XG5cblx0YXN5bmMgY2xlYXJDb25zdW1lckF1ZGlvRWZmZWN0cyhwZWVySWQpIHtcblx0XHRjb25zdCBjb25zdW1lcklkID0gdGhpcy5fcGVlcnMuZ2V0KHBlZXJJZCk7XG5cblx0XHRpZiAoIWNvbnN1bWVySWQpIHJldHVybjtcblxuXHRcdGNvbnN0IGNvbnN1bWVyID0gdGhpcy5fY29uc3VtZXJzLmdldChjb25zdW1lcklkKTtcblxuXHRcdGlmICghY29uc3VtZXIpIHJldHVybjtcblxuXHRcdGlmICghY29uc3VtZXIuZWZmZWN0cykgcmV0dXJuO1xuXG5cdFx0aWYgKGNvbnN1bWVyLmN1cnJlbnRBY3RpdmVOb2RlLm51bWJlck9mT3V0cHV0cyA+IDApIHtcblx0XHRcdGNvbnN1bWVyLmN1cnJlbnRBY3RpdmVOb2RlLmRpc2Nvbm5lY3QodGhpcy5tYWluVm9sdW1lKTtcblxuXHRcdFx0Y29uc3VtZXIuY3VycmVudEFjdGl2ZU5vZGUgPSBjb25zdW1lci5kZWZhdWx0QWN0aXZlTm9kZTtcblx0XHRcdGNvbnN1bWVyLmN1cnJlbnRBY3RpdmVOb2RlLmNvbm5lY3QodGhpcy5tYWluVm9sdW1lKTtcblxuXHRcdFx0ZGVsZXRlIGNvbnN1bWVyLmVmZmVjdHM7XG5cdFx0fVxuXHR9XG5cblx0bWFrZURpc3RvcnRpb25DdXJ2ZShhbW91bnQpIHtcblx0XHRjb25zdCBrID0gdHlwZW9mIGFtb3VudCA9PT0gJ251bWJlcicgPyBhbW91bnQgOiA1MDtcblx0XHRjb25zdCBuU2FtcGxlcyA9IDQ0MTAwO1xuXHRcdGNvbnN0IGN1cnZlID0gbmV3IEZsb2F0MzJBcnJheShuU2FtcGxlcyk7XG5cdFx0Y29uc3QgZGVnID0gTWF0aC5QSSAvIDE4MDtcblx0XHRsZXQgaSA9IDA7XG5cdFx0bGV0IHg7XG5cblx0XHRmb3IgKDsgaSA8IG5TYW1wbGVzOyArK2kpIHtcblx0XHRcdHggPSAoaSAqIDIgLyBuU2FtcGxlcykgLSAxO1xuXHRcdFx0Y3VydmVbaV0gPSAoMyArIGspICogeCAqIDIwICogZGVnIC8gKE1hdGguUEkgKyAoayAqIE1hdGguYWJzKHgpKSk7XG5cdFx0fVxuXG5cdFx0cmV0dXJuIGN1cnZlO1xuXHR9XG5cblx0YXN5bmMgc2V0Q29uc3VtZXJBdWRpb0VmZmVjdHMocGVlcklkLCBlZmZlY3RzKSB7XG5cdFx0Y29uc3QgY29uc3VtZXJJZCA9IHRoaXMuX3BlZXJzLmdldChwZWVySWQpO1xuXG5cdFx0aWYgKCFjb25zdW1lcklkKSByZXR1cm47XG5cblx0XHRjb25zdCBjb25zdW1lciA9IHRoaXMuX2NvbnN1bWVycy5nZXQoY29uc3VtZXJJZCk7XG5cblx0XHRpZiAoIWNvbnN1bWVyKSByZXR1cm47XG5cblx0XHRjb25zdCB2YWx1ZXMgPSBPYmplY3QudmFsdWVzKGVmZmVjdHMpO1xuXHRcdGxldCBhZGRlZE5ld0VmZmVjdCA9IGZhbHNlO1xuXG5cdFx0Zm9yIChjb25zdCBlZmZlY3Qgb2YgdmFsdWVzKSB7XG5cdFx0XHRpZiAoIWNvbnN1bWVyLmVmZmVjdHMpIGNvbnN1bWVyLmVmZmVjdHMgPSB7fTtcblx0XHRcdGlmIChjb25zdW1lci5lZmZlY3RzW2VmZmVjdC5uYW1lXSkge1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdHN3aXRjaCAoZWZmZWN0LnR5cGUpIHtcblx0XHRcdFx0Y2FzZSAnYmlxdWFkJzpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCBmaWx0ZXIgPSBjb25zdW1lci5lZmZlY3RzW2VmZmVjdC5uYW1lXSB8fFxuXHRcdFx0XHRcdFx0XHR0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVCaXF1YWRGaWx0ZXIoKTtcblxuXHRcdFx0XHRcdFx0ZmlsdGVyLnR5cGUgPSBlZmZlY3QuZGF0YS50eXBlO1xuXG5cdFx0XHRcdFx0XHRpZiAoIWlzTmFOKGVmZmVjdC5kYXRhLmZyZXF1ZW5jeS52YWx1ZSkpXG5cdFx0XHRcdFx0XHRcdGZpbHRlci5mcmVxdWVuY3kudmFsdWUgPSBlZmZlY3QuZGF0YS5mcmVxdWVuY3kudmFsdWU7XG5cblx0XHRcdFx0XHRcdGNvbnN1bWVyLmVmZmVjdHNbZWZmZWN0Lm5hbWVdID0gZmlsdGVyO1xuXG5cdFx0XHRcdFx0XHRhZGRlZE5ld0VmZmVjdCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRjYXNlICdjb21wcmVzc29yJzpcblx0XHRcdFx0XHR7XG5cdFx0XHRcdFx0XHRjb25zdCBmaWx0ZXIgPSBjb25zdW1lci5lZmZlY3RzW2VmZmVjdC5uYW1lXSB8fFxuXHRcdFx0XHRcdFx0XHR0aGlzLmF1ZGlvQ29udGV4dC5jcmVhdGVEeW5hbWljc0NvbXByZXNzb3IoKTtcblxuXHRcdFx0XHRcdFx0Ly8gZmlsdGVyLnR5cGUgPSBlZmZlY3QuZGF0YS50eXBlO1xuXHRcdFx0XHRcdFx0Ly8gZmlsdGVyLmZyZXF1ZW5jeS52YWx1ZSA9IGVmZmVjdC5kYXRhLmZyZXF1ZW5jeS52YWx1ZTtcblxuXHRcdFx0XHRcdFx0Y29uc3VtZXIuZWZmZWN0c1tlZmZlY3QubmFtZV0gPSBmaWx0ZXI7XG5cblx0XHRcdFx0XHRcdGFkZGVkTmV3RWZmZWN0ID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0YnJlYWs7XG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdGNhc2UgJ2Rpc3RvcnRpb24nOlxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGNvbnN0IGZpbHRlciA9IGNvbnN1bWVyLmVmZmVjdHNbZWZmZWN0Lm5hbWVdIHx8XG5cdFx0XHRcdFx0XHRcdHRoaXMuYXVkaW9Db250ZXh0LmNyZWF0ZVdhdmVTaGFwZXIoKTtcblxuXHRcdFx0XHRcdFx0ZmlsdGVyLmN1cnZlID0gdGhpcy5tYWtlRGlzdG9ydGlvbkN1cnZlKCk7XG5cblx0XHRcdFx0XHRcdC8vIGZpbHRlci50eXBlID0gZWZmZWN0LmRhdGEudHlwZTtcblx0XHRcdFx0XHRcdC8vIGZpbHRlci5mcmVxdWVuY3kudmFsdWUgPSBlZmZlY3QuZGF0YS5mcmVxdWVuY3kudmFsdWU7XG5cblx0XHRcdFx0XHRcdGNvbnN1bWVyLmVmZmVjdHNbZWZmZWN0Lm5hbWVdID0gZmlsdGVyO1xuXG5cdFx0XHRcdFx0XHRhZGRlZE5ld0VmZmVjdCA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGJyZWFrO1xuXHRcdFx0XHRcdH1cblx0XHRcdH1cblx0XHR9XG5cblx0XHQvLyBzaGl0IGNvZGUgaGVyZSAoNjoyNiAyOS4wOC4yMDIwKVxuXG5cdFx0aWYgKCFhZGRlZE5ld0VmZmVjdCkgcmV0dXJuO1xuXG5cdFx0Y29uc3VtZXIuY3VycmVudEFjdGl2ZU5vZGUuZGlzY29ubmVjdCh0aGlzLm1haW5Wb2x1bWUpO1xuXG5cdFx0bGV0IHByZXZpb3VzTm9kZTtcblxuXHRcdGZvciAoY29uc3QgZWZmZWN0IG9mIE9iamVjdC52YWx1ZXMoY29uc3VtZXIuZWZmZWN0cykpIHtcblx0XHRcdGlmICghcHJldmlvdXNOb2RlKSB7XG5cdFx0XHRcdGNvbnN1bWVyLmN1cnJlbnRBY3RpdmVOb2RlLmNvbm5lY3QoZWZmZWN0KTtcblx0XHRcdH1cblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRwcmV2aW91c05vZGUuY29ubmVjdChlZmZlY3QpO1xuXHRcdFx0fVxuXG5cdFx0XHRwcmV2aW91c05vZGUgPSBlZmZlY3Q7XG5cdFx0fVxuXG5cdFx0Y29uc3VtZXIuY3VycmVudEFjdGl2ZU5vZGUgPSBwcmV2aW91c05vZGU7XG5cdFx0Y29uc3VtZXIuY3VycmVudEFjdGl2ZU5vZGUuY29ubmVjdCh0aGlzLm1haW5Wb2x1bWUpO1xuXG5cdFx0Ly8gc2VlbXMgbGlrZSBzaGl0IGNvZGUgZW5kXG5cblx0fVxufVxuIiwiaW1wb3J0IGJvd3NlciBmcm9tICdib3dzZXInO1xuXG4vLyBUT0RPOiBGb3IgdGVzdGluZy5cbndpbmRvdy5CT1dTRVIgPSBib3dzZXI7XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uKClcbntcblx0Y29uc3QgdWEgPSBuYXZpZ2F0b3IudXNlckFnZW50O1xuXHRjb25zdCBicm93c2VyID0gYm93c2VyLmdldFBhcnNlcih1YSk7XG5cdGxldCBmbGFnO1xuXG5cdGlmIChicm93c2VyLnNhdGlzZmllcyh7IGNocm9tZTogJz49MCcsIGNocm9taXVtOiAnPj0wJyB9KSlcblx0XHRmbGFnID0gJ2Nocm9tZSc7XG5cdGVsc2UgaWYgKGJyb3dzZXIuc2F0aXNmaWVzKHsgZmlyZWZveDogJz49MCcgfSkpXG5cdFx0ZmxhZyA9ICdmaXJlZm94Jztcblx0ZWxzZSBpZiAoYnJvd3Nlci5zYXRpc2ZpZXMoeyBzYWZhcmk6ICc+PTAnIH0pKVxuXHRcdGZsYWcgPSAnc2FmYXJpJztcblx0ZWxzZSBpZiAoYnJvd3Nlci5zYXRpc2ZpZXMoeyBvcGVyYTogJz49MCcgfSkpXG5cdFx0ZmxhZyA9ICdvcGVyYSc7XG5cdGVsc2UgaWYgKGJyb3dzZXIuc2F0aXNmaWVzKHsgJ21pY3Jvc29mdCBlZGdlJzogJz49MCcgfSkpXG5cdFx0ZmxhZyA9ICdlZGdlJztcblx0ZWxzZVxuXHRcdGZsYWcgPSAndW5rbm93bic7XG5cblx0cmV0dXJuIHtcblx0XHRmbGFnLFxuXHRcdG5hbWUgICAgOiBicm93c2VyLmdldEJyb3dzZXJOYW1lKCksXG5cdFx0dmVyc2lvbiA6IGJyb3dzZXIuZ2V0QnJvd3NlclZlcnNpb24oKVxuXHR9O1xufVxuIiwiLyoqXG4gKiBAdHlwZSB7TWFwPFN0cmluZywgU2V0PEZ1bmN0aW9uPj59XG4qL1xuY29uc3QgX19ldmVudHMgPSBuZXcgTWFwKCk7XG5cbmNvbnN0IGxpc3RlbkV2ZW50ID0gKGV2ZW50TmFtZSwgZXZlbnRGdW5jdGlvbikgPT5cbntcblx0aWYgKF9fZXZlbnRzLmhhcyhldmVudE5hbWUpKVxuXHR7XG5cdFx0Y29uc3QgZXZlbnQgPSBfX2V2ZW50cy5nZXQoZXZlbnROYW1lKTtcblxuXHRcdGlmICghZXZlbnQuaGFzKGV2ZW50RnVuY3Rpb24pKVxuXHRcdHtcblx0XHRcdGV2ZW50LmFkZChldmVudEZ1bmN0aW9uKTtcblx0XHR9XG5cdH1cblx0ZWxzZVxuXHR7XG5cdFx0X19ldmVudHMuc2V0KGV2ZW50TmFtZSwgbmV3IFNldChbIGV2ZW50RnVuY3Rpb24gXSkpO1xuXHR9XG59O1xuXG5jb25zdCBjYWxsRXZlbnQgPSAoZXZlbnROYW1lLCAuLi5hcmdzKSA9Plxue1xuXHRpZiAoX19ldmVudHMuaGFzKGV2ZW50TmFtZSkpXG5cdHtcblx0XHRjb25zdCBldmVudCA9IF9fZXZlbnRzLmdldChldmVudE5hbWUpO1xuXG5cdFx0ZXZlbnQuZm9yRWFjaCgoZXZlbnRGdW5jdGlvbikgPT5cblx0XHR7XG5cdFx0XHRldmVudEZ1bmN0aW9uKC4uLmFyZ3MpO1xuXHRcdH0pO1xuXHR9XG59O1xuXG5jb25zdCByZW1vdmVFdmVudCA9IChldmVudE5hbWUsIGV2ZW50RnVuY3Rpb24pID0+XG57XG5cdGlmIChfX2V2ZW50cy5oYXMoZXZlbnROYW1lKSlcblx0e1xuXHRcdGNvbnN0IGV2ZW50ID0gX19ldmVudHMuZ2V0KGV2ZW50TmFtZSk7XG5cblx0XHRpZiAoZXZlbnQuaGFzKGV2ZW50RnVuY3Rpb24pKVxuXHRcdHtcblx0XHRcdGV2ZW50LmRlbGV0ZShldmVudEZ1bmN0aW9uKTtcblx0XHR9XG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGV2ZW50LmNsZWFyKCk7XG5cdFx0fVxuXHR9XG59O1xuXG5jb25zdCBldmVudFRvQ2xpZW50ID0gKGV2ZW50TmFtZSwgYXJncykgPT5cbntcblx0YXJncyA9IHsgLi4uYXJncyB9O1xuXG5cdC8vIGZldGNoKGBodHRwOi8vJHtldmVudE5hbWV9YCwge1xuXHQvLyBcdG1ldGhvZCA6ICdQT1NUJyxcblx0Ly8gXHRib2R5ICAgOiBKU09OLnN0cmluZ2lmeShhcmdzKVxuXHQvLyB9KTtcblxuXHQvLyBjb25zdCBuZGF0YSA9IGFyZ3MgPT09IHVuZGVmaW5lZCA/ICd7fScgOiBKU09OLnN0cmluZ2lmeShhcmdzKTtcblx0Ly8gY29uc29sZS5sb2coXCJQSVpEQVwiKVxuXHQvLyBjb25zb2xlLmxvZyhgaHR0cDovLyR7ZXZlbnROYW1lfWApO1xuXHQvLyBjb25zb2xlLmxvZyh0eXBlb2Yod2luZG93LmpRdWVyeS5wb3N0KSk7XG5cdC8vIHdpbmRvdy5qUXVlcnkucG9zdChgaHR0cDovLyR7ZXZlbnROYW1lfWAsIEpTT04uc3RyaW5naWZ5KGFyZ3MpKTtcblxuXHRjb25zdCB4aHIgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcblx0eGhyLm9wZW4oJ1BPU1QnLCBgaHR0cHM6Ly8ke2V2ZW50TmFtZX1gKTtcblx0eGhyLnNlbmQoSlNPTi5zdHJpbmdpZnkoYXJncykpO1xufTtcblxuY29uc3QgdHJpZ2dlckNsaWVudENoYW5nZVN0YXRlQ29ubmVjdGlvbiA9IChyb29tSWQsIHN0YXRlKSA9Plxue1xuXHRldmVudFRvQ2xpZW50KCdwdm9pY2UzL2NoYW5nZVN0YXRlQ29ubmVjdGlvbicsIHsgcm9vbUlkLCBzdGF0ZSB9KTtcbn07XG5cbmNvbnN0IHRyaWdnZXJDbGllbnRSZXF1ZXN0TWVkaWFQZWVyUmVzcG9uc2UgPSAocm9vbUlkLCBwZWVyTmFtZSwgc3RhdHVzKSA9Plxue1xuXHRldmVudFRvQ2xpZW50KCdwdm9pY2UzL3JlcXVlc3RNZWRpYVBlZXJSZXNwb25zZScsIHsgcm9vbUlkLCBwZWVyTmFtZSwgc3RhdHVzIH0pO1xufTtcblxuY29uc3QgdHJpZ2dlckNsaWVudFJlcXVlc3RDbG9zZU1lZGlhUGVlclJlc3BvbnNlID0gKHJvb21JZCwgcGVlck5hbWUsIHN0YXR1cykgPT5cbntcblx0ZXZlbnRUb0NsaWVudCgncHZvaWNlMy9yZXF1ZXN0Q2xvc2VNZWRpYVBlZXJSZXNwb25zZScsIHsgcm9vbUlkLCBwZWVyTmFtZSwgc3RhdHVzIH0pO1xufTtcblxuY29uc3QgdHJpZ2dlckNsaWVudENoYW5nZVByb2R1Y2VyVm9sdW1lID0gKHZvbHVtZSkgPT5cbntcblx0ZXZlbnRUb0NsaWVudCgncHZvaWNlMy9jaGFuZ2VQcm9kdWNlclZvbHVtZScsIHsgdm9sdW1lIH0pO1xufTtcblxuY29uc3QgdHJpZ2dlckNsaWVudENoYW5nZUNvbnN1bWVyVm9sdW1lID0gKHJvb21JZCwgcGVlck5hbWUsIHZvbHVtZSkgPT5cbntcblx0ZXZlbnRUb0NsaWVudCgncHZvaWNlMy9jaGFuZ2VDb25zdW1lclZvbHVtZScsIHsgcm9vbUlkLCBwZWVyTmFtZSwgdm9sdW1lIH0pO1xufTtcblxuY29uc3QgdHJpZ2dlckNsaWVudENoYW5nZUNvbnN1bWVyc1ZvbHVtZSA9IChyb29tSWQsIGNvbnN1bWVycykgPT5cbntcblx0ZXZlbnRUb0NsaWVudCgncHZvaWNlMy9jaGFuZ2VDb25zdW1lcnNWb2x1bWUnLCB7IHJvb21JZCwgY29uc3VtZXJzIH0pO1xufTtcblxuY29uc3QgdHJpZ2dlckNsaWVudE1pY3JvcGhvbmVFbmFibGVkID0gKHJvb21JZCwgcGVlck5hbWUsIGlzRW5hYmxlZCkgPT5cbntcblx0ZXZlbnRUb0NsaWVudCgncHZvaWNlMy90b2dnbGVNaWNyb3Bob25lJywgeyByb29tSWQsIHBlZXJOYW1lLCBpc0VuYWJsZWQgfSk7XG59O1xuXG53aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignbWVzc2FnZScsIChldmVudCkgPT5cbntcblx0Y29uc3QgZGF0YSA9IGV2ZW50LmRhdGE7XG5cblx0aWYgKF9fZXZlbnRzLmhhcyhkYXRhLnR5cGUpKVxuXHR7XG5cdFx0Y29uc3QgYXJncyA9IGRhdGEuYXJncyB8fCBbXTtcblxuXHRcdGNhbGxFdmVudChkYXRhLnR5cGUsIC4uLmFyZ3MpO1xuXHR9XG59KTtcblxuZXhwb3J0IGRlZmF1bHQge1xuXHRvbiAgICAgOiBsaXN0ZW5FdmVudCxcblx0Y2FsbCAgIDogY2FsbEV2ZW50LFxuXHRyZW1vdmUgOiByZW1vdmVFdmVudCxcblx0dHJpZ2dlckNsaWVudENoYW5nZVN0YXRlQ29ubmVjdGlvbixcblx0dHJpZ2dlckNsaWVudFJlcXVlc3RNZWRpYVBlZXJSZXNwb25zZSxcblx0dHJpZ2dlckNsaWVudFJlcXVlc3RDbG9zZU1lZGlhUGVlclJlc3BvbnNlLFxuXHR0cmlnZ2VyQ2xpZW50Q2hhbmdlUHJvZHVjZXJWb2x1bWUsXG5cdHRyaWdnZXJDbGllbnRDaGFuZ2VDb25zdW1lclZvbHVtZSxcblx0dHJpZ2dlckNsaWVudENoYW5nZUNvbnN1bWVyc1ZvbHVtZSxcblx0dHJpZ2dlckNsaWVudE1pY3JvcGhvbmVFbmFibGVkLFxuXHRfX2V2ZW50c1xufTtcbiIsImltcG9ydCBkb21yZWFkeSBmcm9tICdkb21yZWFkeSc7XG5pbXBvcnQgVXJsUGFyc2UgZnJvbSAndXJsLXBhcnNlJztcbi8vIGltcG9ydCB7IGNyZWF0ZUxvZ2dlciBhcyBjcmVhdGVSZWR1eExvZ2dlciB9IGZyb20gJ3JlIGR1eC1sb2dnZXInO1xuaW1wb3J0IExvZ2dlciBmcm9tICcuL0xvZ2dlcic7XG5pbXBvcnQgKiBhcyB1dGlscyBmcm9tICcuL3V0aWxzJztcbmltcG9ydCBkZXZpY2VJbmZvIGZyb20gJy4vZGV2aWNlSW5mbyc7XG5pbXBvcnQgUm9vbUNsaWVudCBmcm9tICcuL1Jvb21DbGllbnQnO1xuaW1wb3J0IEV2ZW50cyBmcm9tICcuL2V2ZW50cyc7XG5pbXBvcnQgeyBzZXRQcm9vdG9vVXJsLCBzZXRQcm9vdG9vUG9ydCB9IGZyb20gJy4vdXJsRmFjdG9yeSc7XG5cbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoKTtcblxuLy8gaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAnZGV2ZWxvcG1lbnQnKVxuLy8ge1xuLy8gXHRjb25zdCByZWR1eExvZ2dlciA9IGNyZWF0ZVJlZHV4TG9nZ2VyKFxuLy8gXHRcdHtcbi8vIFx0XHRcdGR1cmF0aW9uICA6IHRydWUsXG4vLyBcdFx0XHR0aW1lc3RhbXAgOiBmYWxzZSxcbi8vIFx0XHRcdGxldmVsICAgICA6ICdsb2cnLFxuLy8gXHRcdFx0bG9nRXJyb3JzIDogdHJ1ZVxuLy8gXHRcdH0pO1xuXG4vLyBcdHJlZHV4TWlkZGxld2FyZXMucHVzaChyZWR1eExvZ2dlcik7XG4vLyB9XG5cbmNvbnN0IHJvb21zID0ge307XG5cbmRvbXJlYWR5KGFzeW5jICgpID0+XG57XG5cdGxvZ2dlci5kZWJ1ZygnRE9NIHJlYWR5Jyk7XG5cblx0YXdhaXQgdXRpbHMuaW5pdGlhbGl6ZSgpO1xuXG5cdC8vIHJ1bigpO1xufSk7XG5cbmFzeW5jIGZ1bmN0aW9uIHJ1bihyb29tSWQsIHBlZXJJZClcbntcblx0bG9nZ2VyLmRlYnVnKCdydW4oKSBbZW52aXJvbm1lbnQ6JXNdJywgcHJvY2Vzcy5lbnYuTk9ERV9FTlYpO1xuXG5cdGNvbnN0IHVybFBhcnNlciA9IG5ldyBVcmxQYXJzZSh3aW5kb3cubG9jYXRpb24uaHJlZiwgdHJ1ZSk7XG5cdC8vIGNvbnN0IHBlZXJJZCA9IHJhbmRvbVN0cmluZyh7IGxlbmd0aDogOCB9KS50b0xvd2VyQ2FzZSgpIHx8IHBlZXJJZDtcblx0Ly8gbGV0IHJvb21JZCA9IHVybFBhcnNlci5xdWVyeS5yb29tSWQ7XG5cdGNvbnN0IGhhbmRsZXIgPSB1cmxQYXJzZXIucXVlcnkuaGFuZGxlcjtcblx0Y29uc3QgdXNlU2ltdWxjYXN0ID0gdXJsUGFyc2VyLnF1ZXJ5LnNpbXVsY2FzdCAhPT0gJ2ZhbHNlJztcblx0Y29uc3QgZm9yY2VUY3AgPSB1cmxQYXJzZXIucXVlcnkuZm9yY2VUY3AgPT09ICd0cnVlJztcblx0Y29uc3QgcHJvZHVjZSA9IHVybFBhcnNlci5xdWVyeS5wcm9kdWNlICE9PSAnZmFsc2UnO1xuXHRjb25zdCBjb25zdW1lID0gdXJsUGFyc2VyLnF1ZXJ5LmNvbnN1bWUgIT09ICdmYWxzZSc7XG5cdGNvbnN0IGZvcmNlSDI2NCA9IHVybFBhcnNlci5xdWVyeS5mb3JjZUgyNjQgPT09ICd0cnVlJztcblx0Y29uc3QgZm9yY2VWUDkgPSB1cmxQYXJzZXIucXVlcnkuZm9yY2VWUDkgPT09ICd0cnVlJztcblx0Y29uc3QgZGF0YWNoYW5uZWwgPSB1cmxQYXJzZXIucXVlcnkuZGF0YWNoYW5uZWwgIT09ICdmYWxzZSc7XG5cblx0Ly8gR2V0IHRoZSBlZmZlY3RpdmUvc2hhcmVhYmxlIFJvb20gVVJMLlxuXHRjb25zdCByb29tVXJsUGFyc2VyID0gbmV3IFVybFBhcnNlKHdpbmRvdy5sb2NhdGlvbi5ocmVmLCB0cnVlKTtcblxuXHRmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhyb29tVXJsUGFyc2VyLnF1ZXJ5KSlcblx0e1xuXHRcdC8vIERvbid0IGtlZXAgc29tZSBjdXN0b20gcGFyYW1zLlxuXHRcdHN3aXRjaCAoa2V5KVxuXHRcdHtcblx0XHRcdGNhc2UgJ3Jvb21JZCc6XG5cdFx0XHRjYXNlICdoYW5kbGVyJzpcblx0XHRcdGNhc2UgJ3NpbXVsY2FzdCc6XG5cdFx0XHRjYXNlICdzaGFyaW5nU2ltdWxjYXN0Jzpcblx0XHRcdGNhc2UgJ3Byb2R1Y2UnOlxuXHRcdFx0Y2FzZSAnY29uc3VtZSc6XG5cdFx0XHRjYXNlICdmb3JjZUgyNjQnOlxuXHRcdFx0Y2FzZSAnZm9yY2VWUDknOlxuXHRcdFx0Y2FzZSAnZm9yY2VUY3AnOlxuXHRcdFx0Y2FzZSAnc3ZjJzpcblx0XHRcdGNhc2UgJ2RhdGFjaGFubmVsJzpcblx0XHRcdGNhc2UgJ2luZm8nOlxuXHRcdFx0Y2FzZSAnZmFjZURldGVjdGlvbic6XG5cdFx0XHRjYXNlICdleHRlcm5hbFZpZGVvJzpcblx0XHRcdGNhc2UgJ3Rocm90dGxlU2VjcmV0Jzpcblx0XHRcdFx0YnJlYWs7XG5cdFx0XHRkZWZhdWx0OlxuXHRcdFx0XHRkZWxldGUgcm9vbVVybFBhcnNlci5xdWVyeVtrZXldO1xuXHRcdH1cblx0fVxuXHRkZWxldGUgcm9vbVVybFBhcnNlci5oYXNoO1xuXG5cdC8vIEdldCBjdXJyZW50IGRldmljZSBpbmZvLlxuXHRjb25zdCBkZXZpY2UgPSBkZXZpY2VJbmZvKCk7XG5cblx0cm9vbXNbcm9vbUlkXSA9IG5ldyBSb29tQ2xpZW50KFxuXHRcdHtcblx0XHRcdHJvb21JZCxcblx0XHRcdHBlZXJJZCxcblx0XHRcdGRldmljZSxcblx0XHRcdGhhbmRsZXJOYW1lIDogaGFuZGxlcixcblx0XHRcdHVzZVNpbXVsY2FzdCxcblx0XHRcdGZvcmNlVGNwLFxuXHRcdFx0cHJvZHVjZSxcblx0XHRcdGNvbnN1bWUsXG5cdFx0XHRmb3JjZUgyNjQsXG5cdFx0XHRmb3JjZVZQOSxcblx0XHRcdGRhdGFjaGFubmVsXG5cdFx0fSk7XG5cblx0Ly8gc2V0VGltZW91dCgoKSA9PiByb29tQ2xpZW50LmVuYWJsZVNoYXJlKCksIDMwMDApXG5cblx0c2V0VGltZW91dCgoKSA9PiByb29tc1tyb29tSWRdLmpvaW4oKSwgMTAwKTtcbn1cblxuRXZlbnRzLm9uKCdydW4nLCAocm9vbUlkLCBwZWVySWQsIHRva2VuLCBkZXZpY2VJZCwgcHJvZHVjZXJWb2x1bWUsIGlzVXNiLCBpc1Bvc2l0aW9uaW5nKSA9Plxue1xuXHRydW4ocm9vbUlkLCBwZWVySWQsIHRva2VuLCBkZXZpY2VJZCwgcHJvZHVjZXJWb2x1bWUsIGlzVXNiLCBpc1Bvc2l0aW9uaW5nKTtcbn0pO1xuXG5FdmVudHMub24oJ3N0cmVhbUluJywgKHJvb21JZCwgcGVlcklkKSA9Plxue1xuXHRjb25zdCBjdXJyZW50Um9vbSA9IHJvb21zW3Jvb21JZF07XG5cblx0aWYgKGN1cnJlbnRSb29tICYmIGN1cnJlbnRSb29tLl9zdGF0ZUNvbm5lY3Rpb24gIT09ICdjbG9zZWQnKVxuXHR7XG5cdFx0Y3VycmVudFJvb20ucmVxdWVzdE1lZGlhUGVlcihwZWVySWQpO1xuXHR9XG59KTtcblxuRXZlbnRzLm9uKCdzdHJlYW1PdXQnLCAocm9vbUlkLCBwZWVySWQpID0+XG57XG5cdGNvbnN0IGN1cnJlbnRSb29tID0gcm9vbXNbcm9vbUlkXTtcblxuXHRpZiAoY3VycmVudFJvb20gJiYgY3VycmVudFJvb20uX3N0YXRlQ29ubmVjdGlvbiAhPT0gJ2Nsb3NlZCcpXG5cdHtcblx0XHRjdXJyZW50Um9vbS5yZXF1ZXN0Q2xvc2VNZWRpYVBlZXIocGVlcklkKTtcblx0fVxufSk7XG5cbkV2ZW50cy5vbignY2hhbmdlVm9sdW1lQ29uc3VtZXInLCAocm9vbUlkLCBwZWVySWQsIHZvbHVtZSwgYmFsYW5jZSkgPT5cbntcblx0Y29uc3QgY3VycmVudFJvb20gPSByb29tc1tyb29tSWRdO1xuXG5cdGlmIChjdXJyZW50Um9vbSAmJiBjdXJyZW50Um9vbS5fc3RhdGVDb25uZWN0aW9uICE9PSAnY2xvc2VkJylcblx0e1xuXHRcdGN1cnJlbnRSb29tLmNoYW5nZUNvbnN1bWVyVm9sdW1lKHBlZXJJZCwgdm9sdW1lLCBiYWxhbmNlKTtcblx0fVxufSk7XG5cbkV2ZW50cy5vbignY2hhbmdlVm9sdW1lQ29uc3VtZXJzJywgKHJvb21JZCwgcGVlcnMpID0+XG57XG5cdGNvbnN0IGN1cnJlbnRSb29tID0gcm9vbXNbcm9vbUlkXTtcblxuXHRpZiAoY3VycmVudFJvb20gJiYgY3VycmVudFJvb20uX3N0YXRlQ29ubmVjdGlvbiAhPT0gJ2Nsb3NlZCcpXG5cdHtcblx0XHRjdXJyZW50Um9vbS5jaGFuZ2VDb25zdW1lcnNWb2x1bWUocGVlcnMpO1xuXHR9XG59KTtcblxuRXZlbnRzLm9uKCdzZXRDb25zdW1lckF1ZGlvRWZmZWN0cycsIChyb29tSWQsIHBlZXJJZCwgZWZmZWN0cykgPT5cbntcblx0Y29uc3QgY3VycmVudFJvb20gPSByb29tc1tyb29tSWRdO1xuXG5cdGlmIChjdXJyZW50Um9vbSAmJiBjdXJyZW50Um9vbS5fc3RhdGVDb25uZWN0aW9uICE9PSAnY2xvc2VkJylcblx0e1xuXHRcdGN1cnJlbnRSb29tLnNldENvbnN1bWVyQXVkaW9FZmZlY3RzKHBlZXJJZCwgZWZmZWN0cyk7XG5cdH1cbn0pO1xuXG4vLyBFdmVudHMub24oJ2NoYW5nZVByb2R1Y2VyVm9sdW1lJywgKHZvbHVtZSkgPT4ge1xuLy8gXHRpZiAocm9vbUNsaWVudCAmJiByb29tQ2xpZW50Ll9zdGF0ZUNvbm5lY3Rpb24gIT09ICdjbG9zZWQnKSB7XG4vLyBcdFx0cm9vbUNsaWVudC5jaGFuZ2VQcm9kdWNlclZvbHVtZSh2b2x1bWUpO1xuLy8gXHR9XG4vLyB9KTtcblxuRXZlbnRzLm9uKCdjaGFuZ2VNYWluVm9sdW1lJywgKHJvb21JZCwgdm9sdW1lKSA9Plxue1xuXHRjb25zdCBjdXJyZW50Um9vbSA9IHJvb21zW3Jvb21JZF07XG5cblx0aWYgKGN1cnJlbnRSb29tICYmIGN1cnJlbnRSb29tLl9zdGF0ZUNvbm5lY3Rpb24gIT09ICdjbG9zZWQnKVxuXHR7XG5cdFx0Y3VycmVudFJvb20uY2hhbmdlTWFpblZvbHVtZSh2b2x1bWUpO1xuXHR9XG59KTtcblxuLy8gRXZlbnRzLm9uKCdjaGFuZ2VQcm9kdWNlcicsIChkZXZpY2VJZCwgcHJvZHVjZXJWb2x1bWUgPSAxKSA9PiB7XG4vLyBcdGlmIChyb29tQ2xpZW50ICYmIHJvb21DbGllbnQuX3N0YXRlQ29ubmVjdGlvbiAhPT0gJ2Nsb3NlZCcpIHtcbi8vIFx0XHRyb29tQ2xpZW50LmNoYW5nZVByb2R1Y2VyKGRldmljZUlkLCBwcm9kdWNlclZvbHVtZSk7XG4vLyBcdH1cbi8vIH0pO1xuXG4vLyBFdmVudHMub24oJ2NoYW5nZVByb2R1Y2VySXNVc2InLCAoaXNVc2IpID0+IHtcbi8vIFx0aWYgKHJvb21DbGllbnQgJiYgcm9vbUNsaWVudC5fc3RhdGVDb25uZWN0aW9uICE9PSAnY2xvc2VkJykge1xuLy8gXHRcdHJvb21DbGllbnQuY2hhbmdlUHJvZHVjZXJJc1VzYihpc1VzYik7XG4vLyBcdH1cbi8vIH0pO1xuXG4vLyBFdmVudHMub24oJ2NoYW5nZVBvc2l0aW9uaW5nJywgKGlzUG9zaXRpb25pbmcpID0+IHtcbi8vIFx0aWYgKHJvb21DbGllbnQgJiYgcm9vbUNsaWVudC5fc3RhdGVDb25uZWN0aW9uICE9PSAnY2xvc2VkJykge1xuLy8gXHRcdHJvb21DbGllbnQuY2hhbmdlUG9zaXRpb25pbmcoaXNQb3NpdGlvbmluZyk7XG4vLyBcdH1cbi8vIH0pO1xuXG5FdmVudHMub24oJ211dGVNaWMnLCAocm9vbUlkLCBpZHMpID0+XG57XG5cdGNvbnN0IGN1cnJlbnRSb29tID0gcm9vbXNbcm9vbUlkXTtcblxuXHRpZiAoY3VycmVudFJvb20gJiYgY3VycmVudFJvb20uX3N0YXRlQ29ubmVjdGlvbiAhPT0gJ2Nsb3NlZCcpXG5cdHtcblx0XHRjdXJyZW50Um9vbS5tdXRlTWljKGlkcyk7XG5cdH1cbn0pO1xuXG5FdmVudHMub24oJ3VubXV0ZU1pYycsIChyb29tSWQsIGlkcykgPT5cbntcblx0Y29uc3QgY3VycmVudFJvb20gPSByb29tc1tyb29tSWRdO1xuXG5cdGlmIChjdXJyZW50Um9vbSAmJiBjdXJyZW50Um9vbS5fc3RhdGVDb25uZWN0aW9uICE9PSAnY2xvc2VkJylcblx0e1xuXHRcdGN1cnJlbnRSb29tLnVubXV0ZU1pYyhpZHMpO1xuXHR9XG59KTtcblxuLy8gRXZlbnRzLm9uKCd1cGRhdGVSb29tcycsIChyb29tcykgPT4ge1xuLy8gXHRpZiAocm9vbUNsaWVudCAmJiByb29tQ2xpZW50Ll9zdGF0ZUNvbm5lY3Rpb24gIT09ICdjbG9zZWQnKSB7XG4vLyBcdFx0cm9vbUNsaWVudC51cGRhdGVSb29tcyhyb29tcyk7XG4vLyBcdH1cbi8vIH0pO1xuXG5FdmVudHMub24oJ3Jlc3RhcnRJY2VBbGxSb29tcycsICgpID0+XG57XG5cdGZvciAoY29uc3Qgcm9vbSBvZiBPYmplY3QudmFsdWVzKHJvb21zKSlcblx0e1xuXHRcdGlmIChyb29tLl9zdGF0ZUNvbm5lY3Rpb24gIT09ICdjbG9zZWQnKVxuXHRcdHtcblx0XHRcdHJvb20ucmVzdGFydEljZSgpO1xuXHRcdH1cblx0fVxufSk7XG5cbkV2ZW50cy5vbigncmVzdGFydEljZScsIChyb29tSWQpID0+XG57XG5cdGNvbnN0IGN1cnJlbnRSb29tID0gcm9vbXNbcm9vbUlkXTtcblxuXHRpZiAoY3VycmVudFJvb20gJiYgY3VycmVudFJvb20uX3N0YXRlQ29ubmVjdGlvbiAhPT0gJ2Nsb3NlZCcpXG5cdHtcblx0XHRjdXJyZW50Um9vbS5yZXN0YXJ0SWNlKCk7XG5cdH1cbn0pO1xuXG5FdmVudHMub24oJ3F1aXQnLCAocm9vbUlkKSA9Plxue1xuXHRjb25zdCBjdXJyZW50Um9vbSA9IHJvb21zW3Jvb21JZF07XG5cblx0aWYgKGN1cnJlbnRSb29tICYmIGN1cnJlbnRSb29tLl9zdGF0ZUNvbm5lY3Rpb24gIT09ICdjbG9zZWQnKVxuXHR7XG5cdFx0Y3VycmVudFJvb20uY2xvc2UoKTtcblx0XHRpZiAoY3VycmVudFJvb20uX2Nsb3NlZClcblx0XHR7XG5cdFx0XHRkZWxldGUgcm9vbXNbcm9vbUlkXTtcblx0XHR9XG5cdH1cbn0pO1xuXG5FdmVudHMub24oJ3NldFNlcnZlclVybCcsIChzZXJ2ZXJVcmwsIHNlcnZlclBvcnQpID0+XG57XG5cdHNldFByb290b29Vcmwoc2VydmVyVXJsKTtcblx0c2V0UHJvb3Rvb1BvcnQoc2VydmVyUG9ydCk7XHRcbn0pO1xuIiwibGV0IHByb3Rvb1BvcnQgPSA0NDQzO1xubGV0IHByb3Rvb1VybCA9ICdtZWRpYXNvdXAudW1icmVsbGFycC5ydSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBzZXRQcm9vdG9vVXJsKHVybClcbntcblx0cHJvdG9vVXJsID0gdXJsO1xufVxuXG5leHBvcnQgZnVuY3Rpb24gc2V0UHJvb3Rvb1BvcnQocG9ydClcbntcblx0cHJvdG9vUG9ydCA9IE51bWJlcihwb3J0KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFByb3Rvb1VybCh7IHJvb21JZCwgcGVlcklkIH0pXG57XG5cdHJldHVybiBgd3NzOi8vJHtwcm90b29Vcmx9OiR7cHJvdG9vUG9ydH0vP3Jvb21JZD0ke3Jvb21JZH0mcGVlcklkPSR7cGVlcklkfWA7XG59XG4iLCIvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5sZXQgbWVkaWFRdWVyeURldGVjdG9yRWxlbTtcbmxldCB1c2VyTWVkaWE7XG5cbmV4cG9ydCBhc3luYyBmdW5jdGlvbiBnZXRVc2VyTWVkaWEoY29uc3RyYWludHMpXG57XG5cdGNvbnNvbGUubG9nKGBmdWNrIC0gJHt1c2VyTWVkaWF9YCk7XG5cdGlmICghdXNlck1lZGlhKSB7XG5cdFx0dXNlck1lZGlhID0gYXdhaXQgbmF2aWdhdG9yLm1lZGlhRGV2aWNlcy5nZXRVc2VyTWVkaWEoY29uc3RyYWludHMpO1xuXHR9XG5cblx0cmV0dXJuIHVzZXJNZWRpYTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGluaXRpYWxpemUoKVxue1xuXHQvLyBNZWRpYSBxdWVyeSBkZXRlY3RvciBzdHVmZi5cblx0bWVkaWFRdWVyeURldGVjdG9yRWxlbSA9XG5cdFx0ZG9jdW1lbnQuZ2V0RWxlbWVudEJ5SWQoJ21lZGlhc291cC1kZW1vLWFwcC1tZWRpYS1xdWVyeS1kZXRlY3RvcicpO1xuXG5cdHJldHVybiBQcm9taXNlLnJlc29sdmUoKTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzRGVza3RvcCgpXG57XG5cdHJldHVybiBCb29sZWFuKG1lZGlhUXVlcnlEZXRlY3RvckVsZW0ub2Zmc2V0UGFyZW50KTtcbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGlzTW9iaWxlKClcbntcblx0cmV0dXJuICFtZWRpYVF1ZXJ5RGV0ZWN0b3JFbGVtLm9mZnNldFBhcmVudDtcbn1cbiIsImZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gIGlmIChsZW4gPT0gbnVsbCB8fCBsZW4gPiBhcnIubGVuZ3RoKSBsZW4gPSBhcnIubGVuZ3RoO1xuXG4gIGZvciAodmFyIGkgPSAwLCBhcnIyID0gbmV3IEFycmF5KGxlbik7IGkgPCBsZW47IGkrKykge1xuICAgIGFycjJbaV0gPSBhcnJbaV07XG4gIH1cblxuICByZXR1cm4gYXJyMjtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlMaWtlVG9BcnJheTtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYXJyKSkgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfYXJyYXlXaXRob3V0SG9sZXM7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBrZXksIGFyZykge1xuICB0cnkge1xuICAgIHZhciBpbmZvID0gZ2VuW2tleV0oYXJnKTtcbiAgICB2YXIgdmFsdWUgPSBpbmZvLnZhbHVlO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJlamVjdChlcnJvcik7XG4gICAgcmV0dXJuO1xuICB9XG5cbiAgaWYgKGluZm8uZG9uZSkge1xuICAgIHJlc29sdmUodmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIFByb21pc2UucmVzb2x2ZSh2YWx1ZSkudGhlbihfbmV4dCwgX3Rocm93KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBfYXN5bmNUb0dlbmVyYXRvcihmbikge1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIHZhciBzZWxmID0gdGhpcyxcbiAgICAgICAgYXJncyA9IGFyZ3VtZW50cztcbiAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgdmFyIGdlbiA9IGZuLmFwcGx5KHNlbGYsIGFyZ3MpO1xuXG4gICAgICBmdW5jdGlvbiBfbmV4dCh2YWx1ZSkge1xuICAgICAgICBhc3luY0dlbmVyYXRvclN0ZXAoZ2VuLCByZXNvbHZlLCByZWplY3QsIF9uZXh0LCBfdGhyb3csIFwibmV4dFwiLCB2YWx1ZSk7XG4gICAgICB9XG5cbiAgICAgIGZ1bmN0aW9uIF90aHJvdyhlcnIpIHtcbiAgICAgICAgYXN5bmNHZW5lcmF0b3JTdGVwKGdlbiwgcmVzb2x2ZSwgcmVqZWN0LCBfbmV4dCwgX3Rocm93LCBcInRocm93XCIsIGVycik7XG4gICAgICB9XG5cbiAgICAgIF9uZXh0KHVuZGVmaW5lZCk7XG4gICAgfSk7XG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2FzeW5jVG9HZW5lcmF0b3I7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2NsYXNzQ2FsbENoZWNrKGluc3RhbmNlLCBDb25zdHJ1Y3Rvcikge1xuICBpZiAoIShpbnN0YW5jZSBpbnN0YW5jZW9mIENvbnN0cnVjdG9yKSkge1xuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfY2xhc3NDYWxsQ2hlY2s7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2RlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVDbGFzcyhDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgaWYgKHByb3RvUHJvcHMpIF9kZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gIGlmIChzdGF0aWNQcm9wcykgX2RlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgcmV0dXJuIENvbnN0cnVjdG9yO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9jcmVhdGVDbGFzcztcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJmdW5jdGlvbiBfZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHZhbHVlKSB7XG4gIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgd3JpdGFibGU6IHRydWVcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBvYmpba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIG9iajtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfZGVmaW5lUHJvcGVydHk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICBcImRlZmF1bHRcIjogb2JqXG4gIH07XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlRGVmYXVsdDtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgX3R5cGVvZiA9IHJlcXVpcmUoXCJAYmFiZWwvcnVudGltZS9oZWxwZXJzL3R5cGVvZlwiKVtcImRlZmF1bHRcIl07XG5cbmZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgaWYgKHR5cGVvZiBXZWFrTWFwICE9PSBcImZ1bmN0aW9uXCIpIHJldHVybiBudWxsO1xuICB2YXIgY2FjaGUgPSBuZXcgV2Vha01hcCgpO1xuXG4gIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSA9IGZ1bmN0aW9uIF9nZXRSZXF1aXJlV2lsZGNhcmRDYWNoZSgpIHtcbiAgICByZXR1cm4gY2FjaGU7XG4gIH07XG5cbiAgcmV0dXJuIGNhY2hlO1xufVxuXG5mdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVXaWxkY2FyZChvYmopIHtcbiAgaWYgKG9iaiAmJiBvYmouX19lc01vZHVsZSkge1xuICAgIHJldHVybiBvYmo7XG4gIH1cblxuICBpZiAob2JqID09PSBudWxsIHx8IF90eXBlb2Yob2JqKSAhPT0gXCJvYmplY3RcIiAmJiB0eXBlb2Ygb2JqICE9PSBcImZ1bmN0aW9uXCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgXCJkZWZhdWx0XCI6IG9ialxuICAgIH07XG4gIH1cblxuICB2YXIgY2FjaGUgPSBfZ2V0UmVxdWlyZVdpbGRjYXJkQ2FjaGUoKTtcblxuICBpZiAoY2FjaGUgJiYgY2FjaGUuaGFzKG9iaikpIHtcbiAgICByZXR1cm4gY2FjaGUuZ2V0KG9iaik7XG4gIH1cblxuICB2YXIgbmV3T2JqID0ge307XG4gIHZhciBoYXNQcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZGVmaW5lUHJvcGVydHkgJiYgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcblxuICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7XG4gICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhciBkZXNjID0gaGFzUHJvcGVydHlEZXNjcmlwdG9yID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIGtleSkgOiBudWxsO1xuXG4gICAgICBpZiAoZGVzYyAmJiAoZGVzYy5nZXQgfHwgZGVzYy5zZXQpKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuZXdPYmosIGtleSwgZGVzYyk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBuZXdPYmpba2V5XSA9IG9ialtrZXldO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIG5ld09ialtcImRlZmF1bHRcIl0gPSBvYmo7XG5cbiAgaWYgKGNhY2hlKSB7XG4gICAgY2FjaGUuc2V0KG9iaiwgbmV3T2JqKTtcbiAgfVxuXG4gIHJldHVybiBuZXdPYmo7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX2ludGVyb3BSZXF1aXJlV2lsZGNhcmQ7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheShpdGVyKSB7XG4gIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IF9pdGVyYWJsZVRvQXJyYXk7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwiZnVuY3Rpb24gX25vbkl0ZXJhYmxlU3ByZWFkKCkge1xuICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiSW52YWxpZCBhdHRlbXB0IHRvIHNwcmVhZCBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBfbm9uSXRlcmFibGVTcHJlYWQ7XG5tb2R1bGUuZXhwb3J0c1tcImRlZmF1bHRcIl0gPSBtb2R1bGUuZXhwb3J0cywgbW9kdWxlLmV4cG9ydHMuX19lc01vZHVsZSA9IHRydWU7IiwidmFyIGFycmF5V2l0aG91dEhvbGVzID0gcmVxdWlyZShcIi4vYXJyYXlXaXRob3V0SG9sZXMuanNcIik7XG5cbnZhciBpdGVyYWJsZVRvQXJyYXkgPSByZXF1aXJlKFwiLi9pdGVyYWJsZVRvQXJyYXkuanNcIik7XG5cbnZhciB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSA9IHJlcXVpcmUoXCIuL3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5LmpzXCIpO1xuXG52YXIgbm9uSXRlcmFibGVTcHJlYWQgPSByZXF1aXJlKFwiLi9ub25JdGVyYWJsZVNwcmVhZC5qc1wiKTtcblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICByZXR1cm4gYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBpdGVyYWJsZVRvQXJyYXkoYXJyKSB8fCB1bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIpIHx8IG5vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3RvQ29uc3VtYWJsZUFycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsImZ1bmN0aW9uIF90eXBlb2Yob2JqKSB7XG4gIFwiQGJhYmVsL2hlbHBlcnMgLSB0eXBlb2ZcIjtcblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IF90eXBlb2YgPSBmdW5jdGlvbiBfdHlwZW9mKG9iaikge1xuICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcblxuICAgIG1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTtcbiAgfVxuXG4gIHJldHVybiBfdHlwZW9mKG9iaik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3R5cGVvZjtcbm1vZHVsZS5leHBvcnRzW1wiZGVmYXVsdFwiXSA9IG1vZHVsZS5leHBvcnRzLCBtb2R1bGUuZXhwb3J0cy5fX2VzTW9kdWxlID0gdHJ1ZTsiLCJ2YXIgYXJyYXlMaWtlVG9BcnJheSA9IHJlcXVpcmUoXCIuL2FycmF5TGlrZVRvQXJyYXkuanNcIik7XG5cbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcbiAgaWYgKCFvKSByZXR1cm47XG4gIGlmICh0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIGFycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgdmFyIG4gPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwobykuc2xpY2UoOCwgLTEpO1xuICBpZiAobiA9PT0gXCJPYmplY3RcIiAmJiBvLmNvbnN0cnVjdG9yKSBuID0gby5jb25zdHJ1Y3Rvci5uYW1lO1xuICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgaWYgKG4gPT09IFwiQXJndW1lbnRzXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBhcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5O1xubW9kdWxlLmV4cG9ydHNbXCJkZWZhdWx0XCJdID0gbW9kdWxlLmV4cG9ydHMsIG1vZHVsZS5leHBvcnRzLl9fZXNNb2R1bGUgPSB0cnVlOyIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcInJlZ2VuZXJhdG9yLXJ1bnRpbWVcIik7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuY2xhc3MgQXdhaXRRdWV1ZSB7XG4gICAgY29uc3RydWN0b3IoeyBDbG9zZWRFcnJvckNsYXNzID0gRXJyb3IsIFN0b3BwZWRFcnJvckNsYXNzID0gRXJyb3IgfSA9IHtcbiAgICAgICAgQ2xvc2VkRXJyb3JDbGFzczogRXJyb3IsXG4gICAgICAgIFN0b3BwZWRFcnJvckNsYXNzOiBFcnJvclxuICAgIH0pIHtcbiAgICAgICAgLy8gQ2xvc2VkIGZsYWcuXG4gICAgICAgIHRoaXMuY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIC8vIFF1ZXVlIG9mIHBlbmRpbmcgdGFza3MuXG4gICAgICAgIHRoaXMucGVuZGluZ1Rhc2tzID0gW107XG4gICAgICAgIC8vIEVycm9yIGNsYXNzIHVzZWQgd2hlbiByZWplY3RpbmcgYSB0YXNrIGR1ZSB0byBBd2FpdFF1ZXVlIGJlaW5nIGNsb3NlZC5cbiAgICAgICAgdGhpcy5DbG9zZWRFcnJvckNsYXNzID0gRXJyb3I7XG4gICAgICAgIC8vIEVycm9yIGNsYXNzIHVzZWQgd2hlbiByZWplY3RpbmcgYSB0YXNrIGR1ZSB0byBBd2FpdFF1ZXVlIGJlaW5nIHN0b3BwZWQuXG4gICAgICAgIHRoaXMuU3RvcHBlZEVycm9yQ2xhc3MgPSBFcnJvcjtcbiAgICAgICAgdGhpcy5DbG9zZWRFcnJvckNsYXNzID0gQ2xvc2VkRXJyb3JDbGFzcztcbiAgICAgICAgdGhpcy5TdG9wcGVkRXJyb3JDbGFzcyA9IFN0b3BwZWRFcnJvckNsYXNzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgbnVtYmVyIG9mIG9uZ29pbmcgZW5xdWV1ZWQgdGFza3MuXG4gICAgICovXG4gICAgZ2V0IHNpemUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnBlbmRpbmdUYXNrcy5sZW5ndGg7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgQXdhaXRRdWV1ZS4gUGVuZGluZyB0YXNrcyB3aWxsIGJlIHJlamVjdGVkIHdpdGggQ2xvc2VkRXJyb3JDbGFzc1xuICAgICAqIGVycm9yLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5jbG9zZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgZm9yIChjb25zdCBwZW5kaW5nVGFzayBvZiB0aGlzLnBlbmRpbmdUYXNrcykge1xuICAgICAgICAgICAgcGVuZGluZ1Rhc2suc3RvcHBlZCA9IHRydWU7XG4gICAgICAgICAgICBwZW5kaW5nVGFzay5yZWplY3QobmV3IHRoaXMuQ2xvc2VkRXJyb3JDbGFzcygnQXdhaXRRdWV1ZSBjbG9zZWQnKSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW5wdHkgdGhlIHBlbmRpbmcgdGFza3MgYXJyYXkuXG4gICAgICAgIHRoaXMucGVuZGluZ1Rhc2tzLmxlbmd0aCA9IDA7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFjY2VwdHMgYSB0YXNrIGFzIGFyZ3VtZW50IChhbmQgYW4gb3B0aW9uYWwgdGFzayBuYW1lKSBhbmQgZW5xdWV1ZXMgaXQgYWZ0ZXJcbiAgICAgKiBwZW5kaW5nIHRhc2tzLiBPbmNlIHByb2Nlc3NlZCwgdGhlIHB1c2goKSBtZXRob2QgcmVzb2x2ZXMgKG9yIHJlamVjdHMpIHdpdGhcbiAgICAgKiB0aGUgcmVzdWx0IHJldHVybmVkIGJ5IHRoZSBnaXZlbiB0YXNrLlxuICAgICAqXG4gICAgICogVGhlIGdpdmVuIHRhc2sgbXVzdCByZXR1cm4gYSBQcm9taXNlIG9yIGRpcmVjdGx5IGEgdmFsdWUuXG4gICAgICovXG4gICAgcHVzaCh0YXNrLCBuYW1lKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jbG9zZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IHRoaXMuQ2xvc2VkRXJyb3JDbGFzcygnQXdhaXRRdWV1ZSBjbG9zZWQnKTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGFzayAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdnaXZlbiB0YXNrIGlzIG5vdCBhIGZ1bmN0aW9uJyk7XG4gICAgICAgICAgICBpZiAoIXRhc2submFtZSAmJiBuYW1lKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhc2ssICduYW1lJywgeyB2YWx1ZTogbmFtZSB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgcGVuZGluZ1Rhc2sgPSB7XG4gICAgICAgICAgICAgICAgICAgIHRhc2ssXG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHJlc29sdmUsXG4gICAgICAgICAgICAgICAgICAgIHJlamVjdCxcbiAgICAgICAgICAgICAgICAgICAgc3RvcHBlZDogZmFsc2UsXG4gICAgICAgICAgICAgICAgICAgIGVucXVldWVkQXQ6IG5ldyBEYXRlKCksXG4gICAgICAgICAgICAgICAgICAgIGV4ZWN1dGVkQXQ6IHVuZGVmaW5lZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRhc2sgdG8gdGhlIHF1ZXVlLlxuICAgICAgICAgICAgICAgIHRoaXMucGVuZGluZ1Rhc2tzLnB1c2gocGVuZGluZ1Rhc2spO1xuICAgICAgICAgICAgICAgIC8vIEFuZCBydW4gaXQgaWYgdGhpcyBpcyB0aGUgb25seSB0YXNrIGluIHRoZSBxdWV1ZS5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5wZW5kaW5nVGFza3MubGVuZ3RoID09PSAxKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5leHQoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTWFrZSBvbmdvaW5nIHBlbmRpbmcgdGFza3MgcmVqZWN0IHdpdGggdGhlIGdpdmVuIFN0b3BwZWRFcnJvckNsYXNzIGVycm9yLlxuICAgICAqIFRoZSBBd2FpdFF1ZXVlIGluc3RhbmNlIGlzIHN0aWxsIHVzYWJsZSBmb3IgZnV0dXJlIHRhc2tzIGFkZGVkIHZpYSBwdXNoKClcbiAgICAgKiBtZXRob2QuXG4gICAgICovXG4gICAgc3RvcCgpIHtcbiAgICAgICAgaWYgKHRoaXMuY2xvc2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBmb3IgKGNvbnN0IHBlbmRpbmdUYXNrIG9mIHRoaXMucGVuZGluZ1Rhc2tzKSB7XG4gICAgICAgICAgICBwZW5kaW5nVGFzay5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgIHBlbmRpbmdUYXNrLnJlamVjdChuZXcgdGhpcy5TdG9wcGVkRXJyb3JDbGFzcygnQXdhaXRRdWV1ZSBzdG9wcGVkJykpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEVucHR5IHRoZSBwZW5kaW5nIHRhc2tzIGFycmF5LlxuICAgICAgICB0aGlzLnBlbmRpbmdUYXNrcy5sZW5ndGggPSAwO1xuICAgIH1cbiAgICBkdW1wKCkge1xuICAgICAgICBjb25zdCBub3cgPSBuZXcgRGF0ZSgpO1xuICAgICAgICByZXR1cm4gdGhpcy5wZW5kaW5nVGFza3MubWFwKChwZW5kaW5nVGFzaykgPT4ge1xuICAgICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgICAgICB0YXNrOiBwZW5kaW5nVGFzay50YXNrLFxuICAgICAgICAgICAgICAgIG5hbWU6IHBlbmRpbmdUYXNrLm5hbWUsXG4gICAgICAgICAgICAgICAgZW5xdWV1ZWRUaW1lOiBwZW5kaW5nVGFzay5leGVjdXRlZEF0XG4gICAgICAgICAgICAgICAgICAgID8gcGVuZGluZ1Rhc2suZXhlY3V0ZWRBdC5nZXRUaW1lKCkgLSBwZW5kaW5nVGFzay5lbnF1ZXVlZEF0LmdldFRpbWUoKVxuICAgICAgICAgICAgICAgICAgICA6IG5vdy5nZXRUaW1lKCkgLSBwZW5kaW5nVGFzay5lbnF1ZXVlZEF0LmdldFRpbWUoKSxcbiAgICAgICAgICAgICAgICBleGVjdXRpbmdUaW1lOiBwZW5kaW5nVGFzay5leGVjdXRlZEF0XG4gICAgICAgICAgICAgICAgICAgID8gbm93LmdldFRpbWUoKSAtIHBlbmRpbmdUYXNrLmV4ZWN1dGVkQXQuZ2V0VGltZSgpXG4gICAgICAgICAgICAgICAgICAgIDogMFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIG5leHQoKSB7XG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgICAgICAvLyBUYWtlIHRoZSBmaXJzdCBwZW5kaW5nIHRhc2suXG4gICAgICAgICAgICBjb25zdCBwZW5kaW5nVGFzayA9IHRoaXMucGVuZGluZ1Rhc2tzWzBdO1xuICAgICAgICAgICAgaWYgKCFwZW5kaW5nVGFzaylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAvLyBFeGVjdXRlIGl0LlxuICAgICAgICAgICAgeWllbGQgdGhpcy5leGVjdXRlVGFzayhwZW5kaW5nVGFzayk7XG4gICAgICAgICAgICAvLyBSZW1vdmUgdGhlIGZpcnN0IHBlbmRpbmcgdGFzayAodGhlIGNvbXBsZXRlZCBvbmUpIGZyb20gdGhlIHF1ZXVlLlxuICAgICAgICAgICAgdGhpcy5wZW5kaW5nVGFza3Muc2hpZnQoKTtcbiAgICAgICAgICAgIC8vIEFuZCBjb250aW51ZS5cbiAgICAgICAgICAgIHRoaXMubmV4dCgpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgZXhlY3V0ZVRhc2socGVuZGluZ1Rhc2spIHtcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgICAgIC8vIElmIHRoZSB0YXNrIGlzIHN0b3BwZWQsIGlnbm9yZSBpdC5cbiAgICAgICAgICAgIGlmIChwZW5kaW5nVGFzay5zdG9wcGVkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHBlbmRpbmdUYXNrLmV4ZWN1dGVkQXQgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSB5aWVsZCBwZW5kaW5nVGFzay50YXNrKCk7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRhc2sgaXMgc3RvcHBlZCwgaWdub3JlIGl0LlxuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nVGFzay5zdG9wcGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gUmVzb2x2ZSB0aGUgdGFzayB3aXRoIHRoZSByZXR1cm5lZCByZXN1bHQgKGlmIGFueSkuXG4gICAgICAgICAgICAgICAgcGVuZGluZ1Rhc2sucmVzb2x2ZShyZXN1bHQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIHRhc2sgaXMgc3RvcHBlZCwgaWdub3JlIGl0LlxuICAgICAgICAgICAgICAgIGlmIChwZW5kaW5nVGFzay5zdG9wcGVkKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgLy8gUmVqZWN0IHRoZSB0YXNrIHdpdGggaXRzIG93biBlcnJvci5cbiAgICAgICAgICAgICAgICBwZW5kaW5nVGFzay5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLkF3YWl0UXVldWUgPSBBd2FpdFF1ZXVlO1xuIiwiIWZ1bmN0aW9uKGUsdCl7XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHMmJlwib2JqZWN0XCI9PXR5cGVvZiBtb2R1bGU/bW9kdWxlLmV4cG9ydHM9dCgpOlwiZnVuY3Rpb25cIj09dHlwZW9mIGRlZmluZSYmZGVmaW5lLmFtZD9kZWZpbmUoW10sdCk6XCJvYmplY3RcIj09dHlwZW9mIGV4cG9ydHM/ZXhwb3J0cy5ib3dzZXI9dCgpOmUuYm93c2VyPXQoKX0odGhpcywoZnVuY3Rpb24oKXtyZXR1cm4gZnVuY3Rpb24oZSl7dmFyIHQ9e307ZnVuY3Rpb24gcihuKXtpZih0W25dKXJldHVybiB0W25dLmV4cG9ydHM7dmFyIGk9dFtuXT17aTpuLGw6ITEsZXhwb3J0czp7fX07cmV0dXJuIGVbbl0uY2FsbChpLmV4cG9ydHMsaSxpLmV4cG9ydHMsciksaS5sPSEwLGkuZXhwb3J0c31yZXR1cm4gci5tPWUsci5jPXQsci5kPWZ1bmN0aW9uKGUsdCxuKXtyLm8oZSx0KXx8T2JqZWN0LmRlZmluZVByb3BlcnR5KGUsdCx7ZW51bWVyYWJsZTohMCxnZXQ6bn0pfSxyLnI9ZnVuY3Rpb24oZSl7XCJ1bmRlZmluZWRcIiE9dHlwZW9mIFN5bWJvbCYmU3ltYm9sLnRvU3RyaW5nVGFnJiZPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxTeW1ib2wudG9TdHJpbmdUYWcse3ZhbHVlOlwiTW9kdWxlXCJ9KSxPYmplY3QuZGVmaW5lUHJvcGVydHkoZSxcIl9fZXNNb2R1bGVcIix7dmFsdWU6ITB9KX0sci50PWZ1bmN0aW9uKGUsdCl7aWYoMSZ0JiYoZT1yKGUpKSw4JnQpcmV0dXJuIGU7aWYoNCZ0JiZcIm9iamVjdFwiPT10eXBlb2YgZSYmZSYmZS5fX2VzTW9kdWxlKXJldHVybiBlO3ZhciBuPU9iamVjdC5jcmVhdGUobnVsbCk7aWYoci5yKG4pLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShuLFwiZGVmYXVsdFwiLHtlbnVtZXJhYmxlOiEwLHZhbHVlOmV9KSwyJnQmJlwic3RyaW5nXCIhPXR5cGVvZiBlKWZvcih2YXIgaSBpbiBlKXIuZChuLGksZnVuY3Rpb24odCl7cmV0dXJuIGVbdF19LmJpbmQobnVsbCxpKSk7cmV0dXJuIG59LHIubj1mdW5jdGlvbihlKXt2YXIgdD1lJiZlLl9fZXNNb2R1bGU/ZnVuY3Rpb24oKXtyZXR1cm4gZS5kZWZhdWx0fTpmdW5jdGlvbigpe3JldHVybiBlfTtyZXR1cm4gci5kKHQsXCJhXCIsdCksdH0sci5vPWZ1bmN0aW9uKGUsdCl7cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChlLHQpfSxyLnA9XCJcIixyKHIucz05MCl9KHsxNzpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwLHQuZGVmYXVsdD12b2lkIDA7dmFyIG49cigxOCksaT1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9cmV0dXJuIGUuZ2V0Rmlyc3RNYXRjaD1mdW5jdGlvbihlLHQpe3ZhciByPXQubWF0Y2goZSk7cmV0dXJuIHImJnIubGVuZ3RoPjAmJnJbMV18fFwiXCJ9LGUuZ2V0U2Vjb25kTWF0Y2g9ZnVuY3Rpb24oZSx0KXt2YXIgcj10Lm1hdGNoKGUpO3JldHVybiByJiZyLmxlbmd0aD4xJiZyWzJdfHxcIlwifSxlLm1hdGNoQW5kUmV0dXJuQ29uc3Q9ZnVuY3Rpb24oZSx0LHIpe2lmKGUudGVzdCh0KSlyZXR1cm4gcn0sZS5nZXRXaW5kb3dzVmVyc2lvbk5hbWU9ZnVuY3Rpb24oZSl7c3dpdGNoKGUpe2Nhc2VcIk5UXCI6cmV0dXJuXCJOVFwiO2Nhc2VcIlhQXCI6cmV0dXJuXCJYUFwiO2Nhc2VcIk5UIDUuMFwiOnJldHVyblwiMjAwMFwiO2Nhc2VcIk5UIDUuMVwiOnJldHVyblwiWFBcIjtjYXNlXCJOVCA1LjJcIjpyZXR1cm5cIjIwMDNcIjtjYXNlXCJOVCA2LjBcIjpyZXR1cm5cIlZpc3RhXCI7Y2FzZVwiTlQgNi4xXCI6cmV0dXJuXCI3XCI7Y2FzZVwiTlQgNi4yXCI6cmV0dXJuXCI4XCI7Y2FzZVwiTlQgNi4zXCI6cmV0dXJuXCI4LjFcIjtjYXNlXCJOVCAxMC4wXCI6cmV0dXJuXCIxMFwiO2RlZmF1bHQ6cmV0dXJufX0sZS5nZXRNYWNPU1ZlcnNpb25OYW1lPWZ1bmN0aW9uKGUpe3ZhciB0PWUuc3BsaXQoXCIuXCIpLnNwbGljZSgwLDIpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlSW50KGUsMTApfHwwfSkpO2lmKHQucHVzaCgwKSwxMD09PXRbMF0pc3dpdGNoKHRbMV0pe2Nhc2UgNTpyZXR1cm5cIkxlb3BhcmRcIjtjYXNlIDY6cmV0dXJuXCJTbm93IExlb3BhcmRcIjtjYXNlIDc6cmV0dXJuXCJMaW9uXCI7Y2FzZSA4OnJldHVyblwiTW91bnRhaW4gTGlvblwiO2Nhc2UgOTpyZXR1cm5cIk1hdmVyaWNrc1wiO2Nhc2UgMTA6cmV0dXJuXCJZb3NlbWl0ZVwiO2Nhc2UgMTE6cmV0dXJuXCJFbCBDYXBpdGFuXCI7Y2FzZSAxMjpyZXR1cm5cIlNpZXJyYVwiO2Nhc2UgMTM6cmV0dXJuXCJIaWdoIFNpZXJyYVwiO2Nhc2UgMTQ6cmV0dXJuXCJNb2phdmVcIjtjYXNlIDE1OnJldHVyblwiQ2F0YWxpbmFcIjtkZWZhdWx0OnJldHVybn19LGUuZ2V0QW5kcm9pZFZlcnNpb25OYW1lPWZ1bmN0aW9uKGUpe3ZhciB0PWUuc3BsaXQoXCIuXCIpLnNwbGljZSgwLDIpLm1hcCgoZnVuY3Rpb24oZSl7cmV0dXJuIHBhcnNlSW50KGUsMTApfHwwfSkpO2lmKHQucHVzaCgwKSwhKDE9PT10WzBdJiZ0WzFdPDUpKXJldHVybiAxPT09dFswXSYmdFsxXTw2P1wiQ3VwY2FrZVwiOjE9PT10WzBdJiZ0WzFdPj02P1wiRG9udXRcIjoyPT09dFswXSYmdFsxXTwyP1wiRWNsYWlyXCI6Mj09PXRbMF0mJjI9PT10WzFdP1wiRnJveW9cIjoyPT09dFswXSYmdFsxXT4yP1wiR2luZ2VyYnJlYWRcIjozPT09dFswXT9cIkhvbmV5Y29tYlwiOjQ9PT10WzBdJiZ0WzFdPDE/XCJJY2UgQ3JlYW0gU2FuZHdpY2hcIjo0PT09dFswXSYmdFsxXTw0P1wiSmVsbHkgQmVhblwiOjQ9PT10WzBdJiZ0WzFdPj00P1wiS2l0S2F0XCI6NT09PXRbMF0/XCJMb2xsaXBvcFwiOjY9PT10WzBdP1wiTWFyc2htYWxsb3dcIjo3PT09dFswXT9cIk5vdWdhdFwiOjg9PT10WzBdP1wiT3Jlb1wiOjk9PT10WzBdP1wiUGllXCI6dm9pZCAwfSxlLmdldFZlcnNpb25QcmVjaXNpb249ZnVuY3Rpb24oZSl7cmV0dXJuIGUuc3BsaXQoXCIuXCIpLmxlbmd0aH0sZS5jb21wYXJlVmVyc2lvbnM9ZnVuY3Rpb24odCxyLG4pe3ZvaWQgMD09PW4mJihuPSExKTt2YXIgaT1lLmdldFZlcnNpb25QcmVjaXNpb24odCkscz1lLmdldFZlcnNpb25QcmVjaXNpb24ociksYT1NYXRoLm1heChpLHMpLG89MCx1PWUubWFwKFt0LHJdLChmdW5jdGlvbih0KXt2YXIgcj1hLWUuZ2V0VmVyc2lvblByZWNpc2lvbih0KSxuPXQrbmV3IEFycmF5KHIrMSkuam9pbihcIi4wXCIpO3JldHVybiBlLm1hcChuLnNwbGl0KFwiLlwiKSwoZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBBcnJheSgyMC1lLmxlbmd0aCkuam9pbihcIjBcIikrZX0pKS5yZXZlcnNlKCl9KSk7Zm9yKG4mJihvPWEtTWF0aC5taW4oaSxzKSksYS09MTthPj1vOyl7aWYodVswXVthXT51WzFdW2FdKXJldHVybiAxO2lmKHVbMF1bYV09PT11WzFdW2FdKXtpZihhPT09bylyZXR1cm4gMDthLT0xfWVsc2UgaWYodVswXVthXTx1WzFdW2FdKXJldHVybi0xfX0sZS5tYXA9ZnVuY3Rpb24oZSx0KXt2YXIgcixuPVtdO2lmKEFycmF5LnByb3RvdHlwZS5tYXApcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChlLHQpO2ZvcihyPTA7cjxlLmxlbmd0aDtyKz0xKW4ucHVzaCh0KGVbcl0pKTtyZXR1cm4gbn0sZS5maW5kPWZ1bmN0aW9uKGUsdCl7dmFyIHIsbjtpZihBcnJheS5wcm90b3R5cGUuZmluZClyZXR1cm4gQXJyYXkucHJvdG90eXBlLmZpbmQuY2FsbChlLHQpO2ZvcihyPTAsbj1lLmxlbmd0aDtyPG47cis9MSl7dmFyIGk9ZVtyXTtpZih0KGkscikpcmV0dXJuIGl9fSxlLmFzc2lnbj1mdW5jdGlvbihlKXtmb3IodmFyIHQscixuPWUsaT1hcmd1bWVudHMubGVuZ3RoLHM9bmV3IEFycmF5KGk+MT9pLTE6MCksYT0xO2E8aTthKyspc1thLTFdPWFyZ3VtZW50c1thXTtpZihPYmplY3QuYXNzaWduKXJldHVybiBPYmplY3QuYXNzaWduLmFwcGx5KE9iamVjdCxbZV0uY29uY2F0KHMpKTt2YXIgbz1mdW5jdGlvbigpe3ZhciBlPXNbdF07XCJvYmplY3RcIj09dHlwZW9mIGUmJm51bGwhPT1lJiZPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChmdW5jdGlvbih0KXtuW3RdPWVbdF19KSl9O2Zvcih0PTAscj1zLmxlbmd0aDt0PHI7dCs9MSlvKCk7cmV0dXJuIGV9LGUuZ2V0QnJvd3NlckFsaWFzPWZ1bmN0aW9uKGUpe3JldHVybiBuLkJST1dTRVJfQUxJQVNFU19NQVBbZV19LGUuZ2V0QnJvd3NlclR5cGVCeUFsaWFzPWZ1bmN0aW9uKGUpe3JldHVybiBuLkJST1dTRVJfTUFQW2VdfHxcIlwifSxlfSgpO3QuZGVmYXVsdD1pLGUuZXhwb3J0cz10LmRlZmF1bHR9LDE4OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5FTkdJTkVfTUFQPXQuT1NfTUFQPXQuUExBVEZPUk1TX01BUD10LkJST1dTRVJfTUFQPXQuQlJPV1NFUl9BTElBU0VTX01BUD12b2lkIDA7dC5CUk9XU0VSX0FMSUFTRVNfTUFQPXtcIkFtYXpvbiBTaWxrXCI6XCJhbWF6b25fc2lsa1wiLFwiQW5kcm9pZCBCcm93c2VyXCI6XCJhbmRyb2lkXCIsQmFkYTpcImJhZGFcIixCbGFja0JlcnJ5OlwiYmxhY2tiZXJyeVwiLENocm9tZTpcImNocm9tZVwiLENocm9taXVtOlwiY2hyb21pdW1cIixFbGVjdHJvbjpcImVsZWN0cm9uXCIsRXBpcGhhbnk6XCJlcGlwaGFueVwiLEZpcmVmb3g6XCJmaXJlZm94XCIsRm9jdXM6XCJmb2N1c1wiLEdlbmVyaWM6XCJnZW5lcmljXCIsXCJHb29nbGUgU2VhcmNoXCI6XCJnb29nbGVfc2VhcmNoXCIsR29vZ2xlYm90OlwiZ29vZ2xlYm90XCIsXCJJbnRlcm5ldCBFeHBsb3JlclwiOlwiaWVcIixcIkstTWVsZW9uXCI6XCJrX21lbGVvblwiLE1heHRob246XCJtYXh0aG9uXCIsXCJNaWNyb3NvZnQgRWRnZVwiOlwiZWRnZVwiLFwiTVogQnJvd3NlclwiOlwibXpcIixcIk5BVkVSIFdoYWxlIEJyb3dzZXJcIjpcIm5hdmVyXCIsT3BlcmE6XCJvcGVyYVwiLFwiT3BlcmEgQ29hc3RcIjpcIm9wZXJhX2NvYXN0XCIsUGhhbnRvbUpTOlwicGhhbnRvbWpzXCIsUHVmZmluOlwicHVmZmluXCIsUXVwWmlsbGE6XCJxdXB6aWxsYVwiLFFROlwicXFcIixRUUxpdGU6XCJxcWxpdGVcIixTYWZhcmk6XCJzYWZhcmlcIixTYWlsZmlzaDpcInNhaWxmaXNoXCIsXCJTYW1zdW5nIEludGVybmV0IGZvciBBbmRyb2lkXCI6XCJzYW1zdW5nX2ludGVybmV0XCIsU2VhTW9ua2V5Olwic2VhbW9ua2V5XCIsU2xlaXBuaXI6XCJzbGVpcG5pclwiLFN3aW5nOlwic3dpbmdcIixUaXplbjpcInRpemVuXCIsXCJVQyBCcm93c2VyXCI6XCJ1Y1wiLFZpdmFsZGk6XCJ2aXZhbGRpXCIsXCJXZWJPUyBCcm93c2VyXCI6XCJ3ZWJvc1wiLFdlQ2hhdDpcIndlY2hhdFwiLFwiWWFuZGV4IEJyb3dzZXJcIjpcInlhbmRleFwiLFJva3U6XCJyb2t1XCJ9O3QuQlJPV1NFUl9NQVA9e2FtYXpvbl9zaWxrOlwiQW1hem9uIFNpbGtcIixhbmRyb2lkOlwiQW5kcm9pZCBCcm93c2VyXCIsYmFkYTpcIkJhZGFcIixibGFja2JlcnJ5OlwiQmxhY2tCZXJyeVwiLGNocm9tZTpcIkNocm9tZVwiLGNocm9taXVtOlwiQ2hyb21pdW1cIixlbGVjdHJvbjpcIkVsZWN0cm9uXCIsZXBpcGhhbnk6XCJFcGlwaGFueVwiLGZpcmVmb3g6XCJGaXJlZm94XCIsZm9jdXM6XCJGb2N1c1wiLGdlbmVyaWM6XCJHZW5lcmljXCIsZ29vZ2xlYm90OlwiR29vZ2xlYm90XCIsZ29vZ2xlX3NlYXJjaDpcIkdvb2dsZSBTZWFyY2hcIixpZTpcIkludGVybmV0IEV4cGxvcmVyXCIsa19tZWxlb246XCJLLU1lbGVvblwiLG1heHRob246XCJNYXh0aG9uXCIsZWRnZTpcIk1pY3Jvc29mdCBFZGdlXCIsbXo6XCJNWiBCcm93c2VyXCIsbmF2ZXI6XCJOQVZFUiBXaGFsZSBCcm93c2VyXCIsb3BlcmE6XCJPcGVyYVwiLG9wZXJhX2NvYXN0OlwiT3BlcmEgQ29hc3RcIixwaGFudG9tanM6XCJQaGFudG9tSlNcIixwdWZmaW46XCJQdWZmaW5cIixxdXB6aWxsYTpcIlF1cFppbGxhXCIscXE6XCJRUSBCcm93c2VyXCIscXFsaXRlOlwiUVEgQnJvd3NlciBMaXRlXCIsc2FmYXJpOlwiU2FmYXJpXCIsc2FpbGZpc2g6XCJTYWlsZmlzaFwiLHNhbXN1bmdfaW50ZXJuZXQ6XCJTYW1zdW5nIEludGVybmV0IGZvciBBbmRyb2lkXCIsc2VhbW9ua2V5OlwiU2VhTW9ua2V5XCIsc2xlaXBuaXI6XCJTbGVpcG5pclwiLHN3aW5nOlwiU3dpbmdcIix0aXplbjpcIlRpemVuXCIsdWM6XCJVQyBCcm93c2VyXCIsdml2YWxkaTpcIlZpdmFsZGlcIix3ZWJvczpcIldlYk9TIEJyb3dzZXJcIix3ZWNoYXQ6XCJXZUNoYXRcIix5YW5kZXg6XCJZYW5kZXggQnJvd3NlclwifTt0LlBMQVRGT1JNU19NQVA9e3RhYmxldDpcInRhYmxldFwiLG1vYmlsZTpcIm1vYmlsZVwiLGRlc2t0b3A6XCJkZXNrdG9wXCIsdHY6XCJ0dlwifTt0Lk9TX01BUD17V2luZG93c1Bob25lOlwiV2luZG93cyBQaG9uZVwiLFdpbmRvd3M6XCJXaW5kb3dzXCIsTWFjT1M6XCJtYWNPU1wiLGlPUzpcImlPU1wiLEFuZHJvaWQ6XCJBbmRyb2lkXCIsV2ViT1M6XCJXZWJPU1wiLEJsYWNrQmVycnk6XCJCbGFja0JlcnJ5XCIsQmFkYTpcIkJhZGFcIixUaXplbjpcIlRpemVuXCIsTGludXg6XCJMaW51eFwiLENocm9tZU9TOlwiQ2hyb21lIE9TXCIsUGxheVN0YXRpb240OlwiUGxheVN0YXRpb24gNFwiLFJva3U6XCJSb2t1XCJ9O3QuRU5HSU5FX01BUD17RWRnZUhUTUw6XCJFZGdlSFRNTFwiLEJsaW5rOlwiQmxpbmtcIixUcmlkZW50OlwiVHJpZGVudFwiLFByZXN0bzpcIlByZXN0b1wiLEdlY2tvOlwiR2Vja29cIixXZWJLaXQ6XCJXZWJLaXRcIn19LDkwOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgbixpPShuPXIoOTEpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn0scz1yKDE4KTtmdW5jdGlvbiBhKGUsdCl7Zm9yKHZhciByPTA7cjx0Lmxlbmd0aDtyKyspe3ZhciBuPXRbcl07bi5lbnVtZXJhYmxlPW4uZW51bWVyYWJsZXx8ITEsbi5jb25maWd1cmFibGU9ITAsXCJ2YWx1ZVwiaW4gbiYmKG4ud3JpdGFibGU9ITApLE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlLG4ua2V5LG4pfX12YXIgbz1mdW5jdGlvbigpe2Z1bmN0aW9uIGUoKXt9dmFyIHQscixuO3JldHVybiBlLmdldFBhcnNlcj1mdW5jdGlvbihlLHQpe2lmKHZvaWQgMD09PXQmJih0PSExKSxcInN0cmluZ1wiIT10eXBlb2YgZSl0aHJvdyBuZXcgRXJyb3IoXCJVc2VyQWdlbnQgc2hvdWxkIGJlIGEgc3RyaW5nXCIpO3JldHVybiBuZXcgaS5kZWZhdWx0KGUsdCl9LGUucGFyc2U9ZnVuY3Rpb24oZSl7cmV0dXJuIG5ldyBpLmRlZmF1bHQoZSkuZ2V0UmVzdWx0KCl9LHQ9ZSxuPVt7a2V5OlwiQlJPV1NFUl9NQVBcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5CUk9XU0VSX01BUH19LHtrZXk6XCJFTkdJTkVfTUFQXCIsZ2V0OmZ1bmN0aW9uKCl7cmV0dXJuIHMuRU5HSU5FX01BUH19LHtrZXk6XCJPU19NQVBcIixnZXQ6ZnVuY3Rpb24oKXtyZXR1cm4gcy5PU19NQVB9fSx7a2V5OlwiUExBVEZPUk1TX01BUFwiLGdldDpmdW5jdGlvbigpe3JldHVybiBzLlBMQVRGT1JNU19NQVB9fV0sKHI9bnVsbCkmJmEodC5wcm90b3R5cGUsciksbiYmYSh0LG4pLGV9KCk7dC5kZWZhdWx0PW8sZS5leHBvcnRzPXQuZGVmYXVsdH0sOTE6ZnVuY3Rpb24oZSx0LHIpe1widXNlIHN0cmljdFwiO3QuX19lc01vZHVsZT0hMCx0LmRlZmF1bHQ9dm9pZCAwO3ZhciBuPXUocig5MikpLGk9dShyKDkzKSkscz11KHIoOTQpKSxhPXUocig5NSkpLG89dShyKDE3KSk7ZnVuY3Rpb24gdShlKXtyZXR1cm4gZSYmZS5fX2VzTW9kdWxlP2U6e2RlZmF1bHQ6ZX19dmFyIGQ9ZnVuY3Rpb24oKXtmdW5jdGlvbiBlKGUsdCl7aWYodm9pZCAwPT09dCYmKHQ9ITEpLG51bGw9PWV8fFwiXCI9PT1lKXRocm93IG5ldyBFcnJvcihcIlVzZXJBZ2VudCBwYXJhbWV0ZXIgY2FuJ3QgYmUgZW1wdHlcIik7dGhpcy5fdWE9ZSx0aGlzLnBhcnNlZFJlc3VsdD17fSwhMCE9PXQmJnRoaXMucGFyc2UoKX12YXIgdD1lLnByb3RvdHlwZTtyZXR1cm4gdC5nZXRVQT1mdW5jdGlvbigpe3JldHVybiB0aGlzLl91YX0sdC50ZXN0PWZ1bmN0aW9uKGUpe3JldHVybiBlLnRlc3QodGhpcy5fdWEpfSx0LnBhcnNlQnJvd3Nlcj1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5wYXJzZWRSZXN1bHQuYnJvd3Nlcj17fTt2YXIgdD1vLmRlZmF1bHQuZmluZChuLmRlZmF1bHQsKGZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQudGVzdClyZXR1cm4gdC50ZXN0KGUpO2lmKHQudGVzdCBpbnN0YW5jZW9mIEFycmF5KXJldHVybiB0LnRlc3Quc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIGUudGVzdCh0KX0pKTt0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyJ3MgdGVzdCBmdW5jdGlvbiBpcyBub3QgdmFsaWRcIil9KSk7cmV0dXJuIHQmJih0aGlzLnBhcnNlZFJlc3VsdC5icm93c2VyPXQuZGVzY3JpYmUodGhpcy5nZXRVQSgpKSksdGhpcy5wYXJzZWRSZXN1bHQuYnJvd3Nlcn0sdC5nZXRCcm93c2VyPWZ1bmN0aW9uKCl7cmV0dXJuIHRoaXMucGFyc2VkUmVzdWx0LmJyb3dzZXI/dGhpcy5wYXJzZWRSZXN1bHQuYnJvd3Nlcjp0aGlzLnBhcnNlQnJvd3NlcigpfSx0LmdldEJyb3dzZXJOYW1lPWZ1bmN0aW9uKGUpe3JldHVybiBlP1N0cmluZyh0aGlzLmdldEJyb3dzZXIoKS5uYW1lKS50b0xvd2VyQ2FzZSgpfHxcIlwiOnRoaXMuZ2V0QnJvd3NlcigpLm5hbWV8fFwiXCJ9LHQuZ2V0QnJvd3NlclZlcnNpb249ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5nZXRCcm93c2VyKCkudmVyc2lvbn0sdC5nZXRPUz1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcnNlZFJlc3VsdC5vcz90aGlzLnBhcnNlZFJlc3VsdC5vczp0aGlzLnBhcnNlT1MoKX0sdC5wYXJzZU9TPWZ1bmN0aW9uKCl7dmFyIGU9dGhpczt0aGlzLnBhcnNlZFJlc3VsdC5vcz17fTt2YXIgdD1vLmRlZmF1bHQuZmluZChpLmRlZmF1bHQsKGZ1bmN0aW9uKHQpe2lmKFwiZnVuY3Rpb25cIj09dHlwZW9mIHQudGVzdClyZXR1cm4gdC50ZXN0KGUpO2lmKHQudGVzdCBpbnN0YW5jZW9mIEFycmF5KXJldHVybiB0LnRlc3Quc29tZSgoZnVuY3Rpb24odCl7cmV0dXJuIGUudGVzdCh0KX0pKTt0aHJvdyBuZXcgRXJyb3IoXCJCcm93c2VyJ3MgdGVzdCBmdW5jdGlvbiBpcyBub3QgdmFsaWRcIil9KSk7cmV0dXJuIHQmJih0aGlzLnBhcnNlZFJlc3VsdC5vcz10LmRlc2NyaWJlKHRoaXMuZ2V0VUEoKSkpLHRoaXMucGFyc2VkUmVzdWx0Lm9zfSx0LmdldE9TTmFtZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzLmdldE9TKCkubmFtZTtyZXR1cm4gZT9TdHJpbmcodCkudG9Mb3dlckNhc2UoKXx8XCJcIjp0fHxcIlwifSx0LmdldE9TVmVyc2lvbj1mdW5jdGlvbigpe3JldHVybiB0aGlzLmdldE9TKCkudmVyc2lvbn0sdC5nZXRQbGF0Zm9ybT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcnNlZFJlc3VsdC5wbGF0Zm9ybT90aGlzLnBhcnNlZFJlc3VsdC5wbGF0Zm9ybTp0aGlzLnBhcnNlUGxhdGZvcm0oKX0sdC5nZXRQbGF0Zm9ybVR5cGU9ZnVuY3Rpb24oZSl7dm9pZCAwPT09ZSYmKGU9ITEpO3ZhciB0PXRoaXMuZ2V0UGxhdGZvcm0oKS50eXBlO3JldHVybiBlP1N0cmluZyh0KS50b0xvd2VyQ2FzZSgpfHxcIlwiOnR8fFwiXCJ9LHQucGFyc2VQbGF0Zm9ybT1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5wYXJzZWRSZXN1bHQucGxhdGZvcm09e307dmFyIHQ9by5kZWZhdWx0LmZpbmQocy5kZWZhdWx0LChmdW5jdGlvbih0KXtpZihcImZ1bmN0aW9uXCI9PXR5cGVvZiB0LnRlc3QpcmV0dXJuIHQudGVzdChlKTtpZih0LnRlc3QgaW5zdGFuY2VvZiBBcnJheSlyZXR1cm4gdC50ZXN0LnNvbWUoKGZ1bmN0aW9uKHQpe3JldHVybiBlLnRlc3QodCl9KSk7dGhyb3cgbmV3IEVycm9yKFwiQnJvd3NlcidzIHRlc3QgZnVuY3Rpb24gaXMgbm90IHZhbGlkXCIpfSkpO3JldHVybiB0JiYodGhpcy5wYXJzZWRSZXN1bHQucGxhdGZvcm09dC5kZXNjcmliZSh0aGlzLmdldFVBKCkpKSx0aGlzLnBhcnNlZFJlc3VsdC5wbGF0Zm9ybX0sdC5nZXRFbmdpbmU9ZnVuY3Rpb24oKXtyZXR1cm4gdGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lP3RoaXMucGFyc2VkUmVzdWx0LmVuZ2luZTp0aGlzLnBhcnNlRW5naW5lKCl9LHQuZ2V0RW5naW5lTmFtZT1mdW5jdGlvbihlKXtyZXR1cm4gZT9TdHJpbmcodGhpcy5nZXRFbmdpbmUoKS5uYW1lKS50b0xvd2VyQ2FzZSgpfHxcIlwiOnRoaXMuZ2V0RW5naW5lKCkubmFtZXx8XCJcIn0sdC5wYXJzZUVuZ2luZT1mdW5jdGlvbigpe3ZhciBlPXRoaXM7dGhpcy5wYXJzZWRSZXN1bHQuZW5naW5lPXt9O3ZhciB0PW8uZGVmYXVsdC5maW5kKGEuZGVmYXVsdCwoZnVuY3Rpb24odCl7aWYoXCJmdW5jdGlvblwiPT10eXBlb2YgdC50ZXN0KXJldHVybiB0LnRlc3QoZSk7aWYodC50ZXN0IGluc3RhbmNlb2YgQXJyYXkpcmV0dXJuIHQudGVzdC5zb21lKChmdW5jdGlvbih0KXtyZXR1cm4gZS50ZXN0KHQpfSkpO3Rocm93IG5ldyBFcnJvcihcIkJyb3dzZXIncyB0ZXN0IGZ1bmN0aW9uIGlzIG5vdCB2YWxpZFwiKX0pKTtyZXR1cm4gdCYmKHRoaXMucGFyc2VkUmVzdWx0LmVuZ2luZT10LmRlc2NyaWJlKHRoaXMuZ2V0VUEoKSkpLHRoaXMucGFyc2VkUmVzdWx0LmVuZ2luZX0sdC5wYXJzZT1mdW5jdGlvbigpe3JldHVybiB0aGlzLnBhcnNlQnJvd3NlcigpLHRoaXMucGFyc2VPUygpLHRoaXMucGFyc2VQbGF0Zm9ybSgpLHRoaXMucGFyc2VFbmdpbmUoKSx0aGlzfSx0LmdldFJlc3VsdD1mdW5jdGlvbigpe3JldHVybiBvLmRlZmF1bHQuYXNzaWduKHt9LHRoaXMucGFyc2VkUmVzdWx0KX0sdC5zYXRpc2ZpZXM9ZnVuY3Rpb24oZSl7dmFyIHQ9dGhpcyxyPXt9LG49MCxpPXt9LHM9MDtpZihPYmplY3Qua2V5cyhlKS5mb3JFYWNoKChmdW5jdGlvbih0KXt2YXIgYT1lW3RdO1wic3RyaW5nXCI9PXR5cGVvZiBhPyhpW3RdPWEscys9MSk6XCJvYmplY3RcIj09dHlwZW9mIGEmJihyW3RdPWEsbis9MSl9KSksbj4wKXt2YXIgYT1PYmplY3Qua2V5cyhyKSx1PW8uZGVmYXVsdC5maW5kKGEsKGZ1bmN0aW9uKGUpe3JldHVybiB0LmlzT1MoZSl9KSk7aWYodSl7dmFyIGQ9dGhpcy5zYXRpc2ZpZXMoclt1XSk7aWYodm9pZCAwIT09ZClyZXR1cm4gZH12YXIgYz1vLmRlZmF1bHQuZmluZChhLChmdW5jdGlvbihlKXtyZXR1cm4gdC5pc1BsYXRmb3JtKGUpfSkpO2lmKGMpe3ZhciBmPXRoaXMuc2F0aXNmaWVzKHJbY10pO2lmKHZvaWQgMCE9PWYpcmV0dXJuIGZ9fWlmKHM+MCl7dmFyIGw9T2JqZWN0LmtleXMoaSksaD1vLmRlZmF1bHQuZmluZChsLChmdW5jdGlvbihlKXtyZXR1cm4gdC5pc0Jyb3dzZXIoZSwhMCl9KSk7aWYodm9pZCAwIT09aClyZXR1cm4gdGhpcy5jb21wYXJlVmVyc2lvbihpW2hdKX19LHQuaXNCcm93c2VyPWZ1bmN0aW9uKGUsdCl7dm9pZCAwPT09dCYmKHQ9ITEpO3ZhciByPXRoaXMuZ2V0QnJvd3Nlck5hbWUoKS50b0xvd2VyQ2FzZSgpLG49ZS50b0xvd2VyQ2FzZSgpLGk9by5kZWZhdWx0LmdldEJyb3dzZXJUeXBlQnlBbGlhcyhuKTtyZXR1cm4gdCYmaSYmKG49aS50b0xvd2VyQ2FzZSgpKSxuPT09cn0sdC5jb21wYXJlVmVyc2lvbj1mdW5jdGlvbihlKXt2YXIgdD1bMF0scj1lLG49ITEsaT10aGlzLmdldEJyb3dzZXJWZXJzaW9uKCk7aWYoXCJzdHJpbmdcIj09dHlwZW9mIGkpcmV0dXJuXCI+XCI9PT1lWzBdfHxcIjxcIj09PWVbMF0/KHI9ZS5zdWJzdHIoMSksXCI9XCI9PT1lWzFdPyhuPSEwLHI9ZS5zdWJzdHIoMikpOnQ9W10sXCI+XCI9PT1lWzBdP3QucHVzaCgxKTp0LnB1c2goLTEpKTpcIj1cIj09PWVbMF0/cj1lLnN1YnN0cigxKTpcIn5cIj09PWVbMF0mJihuPSEwLHI9ZS5zdWJzdHIoMSkpLHQuaW5kZXhPZihvLmRlZmF1bHQuY29tcGFyZVZlcnNpb25zKGkscixuKSk+LTF9LHQuaXNPUz1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5nZXRPU05hbWUoITApPT09U3RyaW5nKGUpLnRvTG93ZXJDYXNlKCl9LHQuaXNQbGF0Zm9ybT1mdW5jdGlvbihlKXtyZXR1cm4gdGhpcy5nZXRQbGF0Zm9ybVR5cGUoITApPT09U3RyaW5nKGUpLnRvTG93ZXJDYXNlKCl9LHQuaXNFbmdpbmU9ZnVuY3Rpb24oZSl7cmV0dXJuIHRoaXMuZ2V0RW5naW5lTmFtZSghMCk9PT1TdHJpbmcoZSkudG9Mb3dlckNhc2UoKX0sdC5pcz1mdW5jdGlvbihlLHQpe3JldHVybiB2b2lkIDA9PT10JiYodD0hMSksdGhpcy5pc0Jyb3dzZXIoZSx0KXx8dGhpcy5pc09TKGUpfHx0aGlzLmlzUGxhdGZvcm0oZSl9LHQuc29tZT1mdW5jdGlvbihlKXt2YXIgdD10aGlzO3JldHVybiB2b2lkIDA9PT1lJiYoZT1bXSksZS5zb21lKChmdW5jdGlvbihlKXtyZXR1cm4gdC5pcyhlKX0pKX0sZX0oKTt0LmRlZmF1bHQ9ZCxlLmV4cG9ydHM9dC5kZWZhdWx0fSw5MjpmdW5jdGlvbihlLHQscil7XCJ1c2Ugc3RyaWN0XCI7dC5fX2VzTW9kdWxlPSEwLHQuZGVmYXVsdD12b2lkIDA7dmFyIG4saT0obj1yKDE3KSkmJm4uX19lc01vZHVsZT9uOntkZWZhdWx0Om59O3ZhciBzPS92ZXJzaW9uXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGE9W3t0ZXN0OlsvZ29vZ2xlYm90L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiR29vZ2xlYm90XCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2dvb2dsZWJvdFxcLyhcXGQrKFxcLlxcZCspKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL29wZXJhL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiT3BlcmFcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86b3BlcmEpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL29wclxcL3xvcGlvcy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk9wZXJhXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Om9wcnxvcGlvcylbXFxzL10oXFxTKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9TYW1zdW5nQnJvd3Nlci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlNhbXN1bmcgSW50ZXJuZXQgZm9yIEFuZHJvaWRcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86U2Ftc3VuZ0Jyb3dzZXIpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL1doYWxlL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiTkFWRVIgV2hhbGUgQnJvd3NlclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzp3aGFsZSlbXFxzL10oXFxkKyg/OlxcLlxcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9NWkJyb3dzZXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJNWiBCcm93c2VyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Ok1aQnJvd3NlcilbXFxzL10oXFxkKyg/OlxcLlxcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9mb2N1cy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkZvY3VzXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmZvY3VzKVtcXHMvXShcXGQrKD86XFwuXFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3N3aW5nL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU3dpbmdcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86c3dpbmcpW1xccy9dKFxcZCsoPzpcXC5cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvY29hc3QvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJPcGVyYSBDb2FzdFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpjb2FzdClbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvb3B0XFwvXFxkKyg/Oi4/Xz9cXGQrKSsvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJPcGVyYSBUb3VjaFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpvcHQpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3lhYnJvd3Nlci9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIllhbmRleCBCcm93c2VyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnlhYnJvd3NlcilbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvdWNicm93c2VyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiVUMgQnJvd3NlclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzp1Y2Jyb3dzZXIpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL01heHRob258bXhpb3MvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJNYXh0aG9uXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Ok1heHRob258bXhpb3MpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2VwaXBoYW55L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiRXBpcGhhbnlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86ZXBpcGhhbnkpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3B1ZmZpbi9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlB1ZmZpblwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSl8fGkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpwdWZmaW4pW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3NsZWlwbmlyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU2xlaXBuaXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86c2xlaXBuaXIpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2stbWVsZW9uL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiSy1NZWxlb25cIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86ay1tZWxlb24pW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL21pY3JvbWVzc2VuZ2VyL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiV2VDaGF0XCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Om1pY3JvbWVzc2VuZ2VyKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9xcWJyb3dzZXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6L3FxYnJvd3NlcmxpdGUvaS50ZXN0KGUpP1wiUVEgQnJvd3NlciBMaXRlXCI6XCJRUSBCcm93c2VyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OnFxYnJvd3NlcmxpdGV8cXFicm93c2VyKVsvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9tc2llfHRyaWRlbnQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJJbnRlcm5ldCBFeHBsb3JlclwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzptc2llIHxydjopKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL1xcc2VkZ1xcLy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIk1pY3Jvc29mdCBFZGdlXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL1xcc2VkZ1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9lZGcoW2VhXXxpb3MpL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiTWljcm9zb2Z0IEVkZ2VcIn0scj1pLmRlZmF1bHQuZ2V0U2Vjb25kTWF0Y2goL2VkZyhbZWFdfGlvcylcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvdml2YWxkaS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlZpdmFsZGlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvdml2YWxkaVxcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zZWFtb25rZXkvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJTZWFNb25rZXlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvc2VhbW9ua2V5XFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3NhaWxmaXNoL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU2FpbGZpc2hcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvc2FpbGZpc2hcXHM/YnJvd3NlclxcLyhcXGQrKFxcLlxcZCspPykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zaWxrL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiQW1hem9uIFNpbGtcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvc2lsa1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9waGFudG9tL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiUGhhbnRvbUpTXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3BoYW50b21qc1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9zbGltZXJqcy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIlNsaW1lckpTXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3NsaW1lcmpzXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2JsYWNrYmVycnl8XFxiYmJcXGQrL2ksL3JpbVxcc3RhYmxldC9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkJsYWNrQmVycnlcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvYmxhY2tiZXJyeVtcXGRdK1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy8od2VifGhwdylbbzBdcy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIldlYk9TIEJyb3dzZXJcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvdyg/OmViKT9bbzBdc2Jyb3dzZXJcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvYmFkYS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkJhZGFcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvZG9sZmluXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3RpemVuL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiVGl6ZW5cIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86dGl6ZW5cXHM/KT9icm93c2VyXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL3F1cHppbGxhL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiUXVwWmlsbGFcIn0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86cXVwemlsbGEpW1xccy9dKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaChzLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpbL2ZpcmVmb3h8aWNld2Vhc2VsfGZ4aW9zL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiRmlyZWZveFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpmaXJlZm94fGljZXdlYXNlbHxmeGlvcylbXFxzL10oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvZWxlY3Ryb24vaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJFbGVjdHJvblwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzplbGVjdHJvbilcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvTWl1aUJyb3dzZXIvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6XCJNaXVpXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/Ok1pdWlCcm93c2VyKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9jaHJvbWl1bS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkNocm9taXVtXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goLyg/OmNocm9taXVtKVtcXHMvXShcXGQrKFxcLj9fP1xcZCspKykvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9jaHJvbWV8Y3Jpb3N8Y3Jtby9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD17bmFtZTpcIkNocm9tZVwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpjaHJvbWV8Y3Jpb3N8Y3JtbylcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OlsvR1NBL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiR29vZ2xlIFNlYXJjaFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oPzpHU0EpXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpmdW5jdGlvbihlKXt2YXIgdD0hZS50ZXN0KC9saWtlIGFuZHJvaWQvaSkscj1lLnRlc3QoL2FuZHJvaWQvaSk7cmV0dXJuIHQmJnJ9LGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiQW5kcm9pZCBCcm93c2VyXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9wbGF5c3RhdGlvbiA0L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiUGxheVN0YXRpb24gNFwifSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKHMsZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0Olsvc2FmYXJpfGFwcGxld2Via2l0L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PXtuYW1lOlwiU2FmYXJpXCJ9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2gocyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy8uKi9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD0tMSE9PWUuc2VhcmNoKFwiXFxcXChcIik/L14oLiopXFwvKC4qKVsgXFx0XVxcKCguKikvOi9eKC4qKVxcLyguKikgLztyZXR1cm57bmFtZTppLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCh0LGUpLHZlcnNpb246aS5kZWZhdWx0LmdldFNlY29uZE1hdGNoKHQsZSl9fX1dO3QuZGVmYXVsdD1hLGUuZXhwb3J0cz10LmRlZmF1bHR9LDkzOmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgbixpPShuPXIoMTcpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn0scz1yKDE4KTt2YXIgYT1be3Rlc3Q6Wy9Sb2t1XFwvRFZQL10sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL1Jva3VcXC9EVlAtKFxcZCtcXC5cXGQrKS9pLGUpO3JldHVybntuYW1lOnMuT1NfTUFQLlJva3UsdmVyc2lvbjp0fX19LHt0ZXN0Olsvd2luZG93cyBwaG9uZS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvd2luZG93cyBwaG9uZSAoPzpvcyk/XFxzPyhcXGQrKFxcLlxcZCspKikvaSxlKTtyZXR1cm57bmFtZTpzLk9TX01BUC5XaW5kb3dzUGhvbmUsdmVyc2lvbjp0fX19LHt0ZXN0Olsvd2luZG93cyAvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL1dpbmRvd3MgKChOVHxYUCkoIFxcZFxcZD8uXFxkKT8pL2ksZSkscj1pLmRlZmF1bHQuZ2V0V2luZG93c1ZlcnNpb25OYW1lKHQpO3JldHVybntuYW1lOnMuT1NfTUFQLldpbmRvd3MsdmVyc2lvbjp0LHZlcnNpb25OYW1lOnJ9fX0se3Rlc3Q6Wy9NYWNpbnRvc2goLio/KSBGeGlPUyguKj8pXFwvL10sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6cy5PU19NQVAuaU9TfSxyPWkuZGVmYXVsdC5nZXRTZWNvbmRNYXRjaCgvKFZlcnNpb25cXC8pKFxcZFtcXGQuXSspLyxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy9tYWNpbnRvc2gvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL21hYyBvcyB4IChcXGQrKFxcLj9fP1xcZCspKykvaSxlKS5yZXBsYWNlKC9bX1xcc10vZyxcIi5cIikscj1pLmRlZmF1bHQuZ2V0TWFjT1NWZXJzaW9uTmFtZSh0KSxuPXtuYW1lOnMuT1NfTUFQLk1hY09TLHZlcnNpb246dH07cmV0dXJuIHImJihuLnZlcnNpb25OYW1lPXIpLG59fSx7dGVzdDpbLyhpcG9kfGlwaG9uZXxpcGFkKS9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvb3MgKFxcZCsoW19cXHNdXFxkKykqKSBsaWtlIG1hYyBvcyB4L2ksZSkucmVwbGFjZSgvW19cXHNdL2csXCIuXCIpO3JldHVybntuYW1lOnMuT1NfTUFQLmlPUyx2ZXJzaW9uOnR9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7dmFyIHQ9IWUudGVzdCgvbGlrZSBhbmRyb2lkL2kpLHI9ZS50ZXN0KC9hbmRyb2lkL2kpO3JldHVybiB0JiZyfSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvYW5kcm9pZFtcXHMvLV0oXFxkKyhcXC5cXGQrKSopL2ksZSkscj1pLmRlZmF1bHQuZ2V0QW5kcm9pZFZlcnNpb25OYW1lKHQpLG49e25hbWU6cy5PU19NQVAuQW5kcm9pZCx2ZXJzaW9uOnR9O3JldHVybiByJiYobi52ZXJzaW9uTmFtZT1yKSxufX0se3Rlc3Q6Wy8od2VifGhwdylbbzBdcy9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvKD86d2VifGhwdylbbzBdc1xcLyhcXGQrKFxcLlxcZCspKikvaSxlKSxyPXtuYW1lOnMuT1NfTUFQLldlYk9TfTtyZXR1cm4gdCYmdC5sZW5ndGgmJihyLnZlcnNpb249dCkscn19LHt0ZXN0OlsvYmxhY2tiZXJyeXxcXGJiYlxcZCsvaSwvcmltXFxzdGFibGV0L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9yaW1cXHN0YWJsZXRcXHNvc1xccyhcXGQrKFxcLlxcZCspKikvaSxlKXx8aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2JsYWNrYmVycnlcXGQrXFwvKFxcZCsoW19cXHNdXFxkKykqKS9pLGUpfHxpLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvXFxiYmIoXFxkKykvaSxlKTtyZXR1cm57bmFtZTpzLk9TX01BUC5CbGFja0JlcnJ5LHZlcnNpb246dH19fSx7dGVzdDpbL2JhZGEvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2JhZGFcXC8oXFxkKyhcXC5cXGQrKSopL2ksZSk7cmV0dXJue25hbWU6cy5PU19NQVAuQmFkYSx2ZXJzaW9uOnR9fX0se3Rlc3Q6Wy90aXplbi9pXSxkZXNjcmliZTpmdW5jdGlvbihlKXt2YXIgdD1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvdGl6ZW5bL1xcc10oXFxkKyhcXC5cXGQrKSopL2ksZSk7cmV0dXJue25hbWU6cy5PU19NQVAuVGl6ZW4sdmVyc2lvbjp0fX19LHt0ZXN0OlsvbGludXgvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57bmFtZTpzLk9TX01BUC5MaW51eH19fSx7dGVzdDpbL0NyT1MvXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybntuYW1lOnMuT1NfTUFQLkNocm9tZU9TfX19LHt0ZXN0OlsvUGxheVN0YXRpb24gNC9dLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9QbGF5U3RhdGlvbiA0Wy9cXHNdKFxcZCsoXFwuXFxkKykqKS9pLGUpO3JldHVybntuYW1lOnMuT1NfTUFQLlBsYXlTdGF0aW9uNCx2ZXJzaW9uOnR9fX1dO3QuZGVmYXVsdD1hLGUuZXhwb3J0cz10LmRlZmF1bHR9LDk0OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgbixpPShuPXIoMTcpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn0scz1yKDE4KTt2YXIgYT1be3Rlc3Q6Wy9nb29nbGVib3QvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpcImJvdFwiLHZlbmRvcjpcIkdvb2dsZVwifX19LHt0ZXN0OlsvaHVhd2VpL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oY2FuLWwwMSkvaSxlKSYmXCJOb3ZhXCIscj17dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlLHZlbmRvcjpcIkh1YXdlaVwifTtyZXR1cm4gdCYmKHIubW9kZWw9dCkscn19LHt0ZXN0OlsvbmV4dXNcXHMqKD86N3w4fDl8MTApLiovaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0LHZlbmRvcjpcIk5leHVzXCJ9fX0se3Rlc3Q6Wy9pcGFkL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnRhYmxldCx2ZW5kb3I6XCJBcHBsZVwiLG1vZGVsOlwiaVBhZFwifX19LHt0ZXN0OlsvTWFjaW50b3NoKC4qPykgRnhpT1MoLio/KVxcLy9dLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnRhYmxldCx2ZW5kb3I6XCJBcHBsZVwiLG1vZGVsOlwiaVBhZFwifX19LHt0ZXN0Olsva2Z0dCBidWlsZC9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50YWJsZXQsdmVuZG9yOlwiQW1hem9uXCIsbW9kZWw6XCJLaW5kbGUgRmlyZSBIRCA3XCJ9fX0se3Rlc3Q6Wy9zaWxrL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLnRhYmxldCx2ZW5kb3I6XCJBbWF6b25cIn19fSx7dGVzdDpbL3RhYmxldCg/ISBwYykvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0fX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3ZhciB0PWUudGVzdCgvaXBvZHxpcGhvbmUvaSkscj1lLnRlc3QoL2xpa2UgKGlwb2R8aXBob25lKS9pKTtyZXR1cm4gdCYmIXJ9LGRlc2NyaWJlOmZ1bmN0aW9uKGUpe3ZhciB0PWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC8oaXBvZHxpcGhvbmUpL2ksZSk7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZSx2ZW5kb3I6XCJBcHBsZVwiLG1vZGVsOnR9fX0se3Rlc3Q6Wy9uZXh1c1xccypbMC02XS4qL2ksL2dhbGF4eSBuZXh1cy9pXSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGUsdmVuZG9yOlwiTmV4dXNcIn19fSx7dGVzdDpbL1teLV1tb2JpL2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZX19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cImJsYWNrYmVycnlcIj09PWUuZ2V0QnJvd3Nlck5hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGUsdmVuZG9yOlwiQmxhY2tCZXJyeVwifX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwiYmFkYVwiPT09ZS5nZXRCcm93c2VyTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLm1vYmlsZX19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cIndpbmRvd3MgcGhvbmVcIj09PWUuZ2V0QnJvd3Nlck5hbWUoKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAubW9iaWxlLHZlbmRvcjpcIk1pY3Jvc29mdFwifX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3ZhciB0PU51bWJlcihTdHJpbmcoZS5nZXRPU1ZlcnNpb24oKSkuc3BsaXQoXCIuXCIpWzBdKTtyZXR1cm5cImFuZHJvaWRcIj09PWUuZ2V0T1NOYW1lKCEwKSYmdD49M30sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudGFibGV0fX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwiYW5kcm9pZFwiPT09ZS5nZXRPU05hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5tb2JpbGV9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJtYWNvc1wiPT09ZS5nZXRPU05hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5kZXNrdG9wLHZlbmRvcjpcIkFwcGxlXCJ9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJ3aW5kb3dzXCI9PT1lLmdldE9TTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue3R5cGU6cy5QTEFURk9STVNfTUFQLmRlc2t0b3B9fX0se3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJsaW51eFwiPT09ZS5nZXRPU05hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC5kZXNrdG9wfX19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVyblwicGxheXN0YXRpb24gNFwiPT09ZS5nZXRPU05hbWUoITApfSxkZXNjcmliZTpmdW5jdGlvbigpe3JldHVybnt0eXBlOnMuUExBVEZPUk1TX01BUC50dn19fSx7dGVzdDpmdW5jdGlvbihlKXtyZXR1cm5cInJva3VcIj09PWUuZ2V0T1NOYW1lKCEwKX0sZGVzY3JpYmU6ZnVuY3Rpb24oKXtyZXR1cm57dHlwZTpzLlBMQVRGT1JNU19NQVAudHZ9fX1dO3QuZGVmYXVsdD1hLGUuZXhwb3J0cz10LmRlZmF1bHR9LDk1OmZ1bmN0aW9uKGUsdCxyKXtcInVzZSBzdHJpY3RcIjt0Ll9fZXNNb2R1bGU9ITAsdC5kZWZhdWx0PXZvaWQgMDt2YXIgbixpPShuPXIoMTcpKSYmbi5fX2VzTW9kdWxlP246e2RlZmF1bHQ6bn0scz1yKDE4KTt2YXIgYT1be3Rlc3Q6ZnVuY3Rpb24oZSl7cmV0dXJuXCJtaWNyb3NvZnQgZWRnZVwiPT09ZS5nZXRCcm93c2VyTmFtZSghMCl9LGRlc2NyaWJlOmZ1bmN0aW9uKGUpe2lmKC9cXHNlZGdcXC8vaS50ZXN0KGUpKXJldHVybntuYW1lOnMuRU5HSU5FX01BUC5CbGlua307dmFyIHQ9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL2VkZ2VcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJue25hbWU6cy5FTkdJTkVfTUFQLkVkZ2VIVE1MLHZlcnNpb246dH19fSx7dGVzdDpbL3RyaWRlbnQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6cy5FTkdJTkVfTUFQLlRyaWRlbnR9LHI9aS5kZWZhdWx0LmdldEZpcnN0TWF0Y2goL3RyaWRlbnRcXC8oXFxkKyhcXC4/Xz9cXGQrKSspL2ksZSk7cmV0dXJuIHImJih0LnZlcnNpb249ciksdH19LHt0ZXN0OmZ1bmN0aW9uKGUpe3JldHVybiBlLnRlc3QoL3ByZXN0by9pKX0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6cy5FTkdJTkVfTUFQLlByZXN0b30scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvcHJlc3RvXFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fSx7dGVzdDpmdW5jdGlvbihlKXt2YXIgdD1lLnRlc3QoL2dlY2tvL2kpLHI9ZS50ZXN0KC9saWtlIGdlY2tvL2kpO3JldHVybiB0JiYhcn0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6cy5FTkdJTkVfTUFQLkdlY2tvfSxyPWkuZGVmYXVsdC5nZXRGaXJzdE1hdGNoKC9nZWNrb1xcLyhcXGQrKFxcLj9fP1xcZCspKykvaSxlKTtyZXR1cm4gciYmKHQudmVyc2lvbj1yKSx0fX0se3Rlc3Q6Wy8oYXBwbGUpP3dlYmtpdFxcLzUzN1xcLjM2L2ldLGRlc2NyaWJlOmZ1bmN0aW9uKCl7cmV0dXJue25hbWU6cy5FTkdJTkVfTUFQLkJsaW5rfX19LHt0ZXN0OlsvKGFwcGxlKT93ZWJraXQvaV0sZGVzY3JpYmU6ZnVuY3Rpb24oZSl7dmFyIHQ9e25hbWU6cy5FTkdJTkVfTUFQLldlYktpdH0scj1pLmRlZmF1bHQuZ2V0Rmlyc3RNYXRjaCgvd2Via2l0XFwvKFxcZCsoXFwuP18/XFxkKykrKS9pLGUpO3JldHVybiByJiYodC52ZXJzaW9uPXIpLHR9fV07dC5kZWZhdWx0PWEsZS5leHBvcnRzPXQuZGVmYXVsdH19KX0pKTsiLCIvLyBDb3B5cmlnaHQgSm95ZW50LCBJbmMuIGFuZCBvdGhlciBOb2RlIGNvbnRyaWJ1dG9ycy5cbi8vXG4vLyBQZXJtaXNzaW9uIGlzIGhlcmVieSBncmFudGVkLCBmcmVlIG9mIGNoYXJnZSwgdG8gYW55IHBlcnNvbiBvYnRhaW5pbmcgYVxuLy8gY29weSBvZiB0aGlzIHNvZnR3YXJlIGFuZCBhc3NvY2lhdGVkIGRvY3VtZW50YXRpb24gZmlsZXMgKHRoZVxuLy8gXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbCBpbiB0aGUgU29mdHdhcmUgd2l0aG91dCByZXN0cmljdGlvbiwgaW5jbHVkaW5nXG4vLyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0cyB0byB1c2UsIGNvcHksIG1vZGlmeSwgbWVyZ2UsIHB1Ymxpc2gsXG4vLyBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbCBjb3BpZXMgb2YgdGhlIFNvZnR3YXJlLCBhbmQgdG8gcGVybWl0XG4vLyBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzIGZ1cm5pc2hlZCB0byBkbyBzbywgc3ViamVjdCB0byB0aGVcbi8vIGZvbGxvd2luZyBjb25kaXRpb25zOlxuLy9cbi8vIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkXG4vLyBpbiBhbGwgY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbi8vXG4vLyBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTXG4vLyBPUiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GXG4vLyBNRVJDSEFOVEFCSUxJVFksIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOXG4vLyBOTyBFVkVOVCBTSEFMTCBUSEUgQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSxcbi8vIERBTUFHRVMgT1IgT1RIRVIgTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUlxuLy8gT1RIRVJXSVNFLCBBUklTSU5HIEZST00sIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRVxuLy8gVVNFIE9SIE9USEVSIERFQUxJTkdTIElOIFRIRSBTT0ZUV0FSRS5cblxudmFyIG9iamVjdENyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgb2JqZWN0Q3JlYXRlUG9seWZpbGxcbnZhciBvYmplY3RLZXlzID0gT2JqZWN0LmtleXMgfHwgb2JqZWN0S2V5c1BvbHlmaWxsXG52YXIgYmluZCA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGZ1bmN0aW9uQmluZFBvbHlmaWxsXG5cbmZ1bmN0aW9uIEV2ZW50RW1pdHRlcigpIHtcbiAgaWYgKCF0aGlzLl9ldmVudHMgfHwgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbCh0aGlzLCAnX2V2ZW50cycpKSB7XG4gICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgfVxuXG4gIHRoaXMuX21heExpc3RlbmVycyA9IHRoaXMuX21heExpc3RlbmVycyB8fCB1bmRlZmluZWQ7XG59XG5tb2R1bGUuZXhwb3J0cyA9IEV2ZW50RW1pdHRlcjtcblxuLy8gQmFja3dhcmRzLWNvbXBhdCB3aXRoIG5vZGUgMC4xMC54XG5FdmVudEVtaXR0ZXIuRXZlbnRFbWl0dGVyID0gRXZlbnRFbWl0dGVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9ldmVudHMgPSB1bmRlZmluZWQ7XG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLl9tYXhMaXN0ZW5lcnMgPSB1bmRlZmluZWQ7XG5cbi8vIEJ5IGRlZmF1bHQgRXZlbnRFbWl0dGVycyB3aWxsIHByaW50IGEgd2FybmluZyBpZiBtb3JlIHRoYW4gMTAgbGlzdGVuZXJzIGFyZVxuLy8gYWRkZWQgdG8gaXQuIFRoaXMgaXMgYSB1c2VmdWwgZGVmYXVsdCB3aGljaCBoZWxwcyBmaW5kaW5nIG1lbW9yeSBsZWFrcy5cbnZhciBkZWZhdWx0TWF4TGlzdGVuZXJzID0gMTA7XG5cbnZhciBoYXNEZWZpbmVQcm9wZXJ0eTtcbnRyeSB7XG4gIHZhciBvID0ge307XG4gIGlmIChPYmplY3QuZGVmaW5lUHJvcGVydHkpIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCAneCcsIHsgdmFsdWU6IDAgfSk7XG4gIGhhc0RlZmluZVByb3BlcnR5ID0gby54ID09PSAwO1xufSBjYXRjaCAoZXJyKSB7IGhhc0RlZmluZVByb3BlcnR5ID0gZmFsc2UgfVxuaWYgKGhhc0RlZmluZVByb3BlcnR5KSB7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShFdmVudEVtaXR0ZXIsICdkZWZhdWx0TWF4TGlzdGVuZXJzJywge1xuICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgZ2V0OiBmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiBkZWZhdWx0TWF4TGlzdGVuZXJzO1xuICAgIH0sXG4gICAgc2V0OiBmdW5jdGlvbihhcmcpIHtcbiAgICAgIC8vIGNoZWNrIHdoZXRoZXIgdGhlIGlucHV0IGlzIGEgcG9zaXRpdmUgbnVtYmVyICh3aG9zZSB2YWx1ZSBpcyB6ZXJvIG9yXG4gICAgICAvLyBncmVhdGVyIGFuZCBub3QgYSBOYU4pLlxuICAgICAgaWYgKHR5cGVvZiBhcmcgIT09ICdudW1iZXInIHx8IGFyZyA8IDAgfHwgYXJnICE9PSBhcmcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1wiZGVmYXVsdE1heExpc3RlbmVyc1wiIG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInKTtcbiAgICAgIGRlZmF1bHRNYXhMaXN0ZW5lcnMgPSBhcmc7XG4gICAgfVxuICB9KTtcbn0gZWxzZSB7XG4gIEV2ZW50RW1pdHRlci5kZWZhdWx0TWF4TGlzdGVuZXJzID0gZGVmYXVsdE1heExpc3RlbmVycztcbn1cblxuLy8gT2J2aW91c2x5IG5vdCBhbGwgRW1pdHRlcnMgc2hvdWxkIGJlIGxpbWl0ZWQgdG8gMTAuIFRoaXMgZnVuY3Rpb24gYWxsb3dzXG4vLyB0aGF0IHRvIGJlIGluY3JlYXNlZC4gU2V0IHRvIHplcm8gZm9yIHVubGltaXRlZC5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuc2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gc2V0TWF4TGlzdGVuZXJzKG4pIHtcbiAgaWYgKHR5cGVvZiBuICE9PSAnbnVtYmVyJyB8fCBuIDwgMCB8fCBpc05hTihuKSlcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcIm5cIiBhcmd1bWVudCBtdXN0IGJlIGEgcG9zaXRpdmUgbnVtYmVyJyk7XG4gIHRoaXMuX21heExpc3RlbmVycyA9IG47XG4gIHJldHVybiB0aGlzO1xufTtcblxuZnVuY3Rpb24gJGdldE1heExpc3RlbmVycyh0aGF0KSB7XG4gIGlmICh0aGF0Ll9tYXhMaXN0ZW5lcnMgPT09IHVuZGVmaW5lZClcbiAgICByZXR1cm4gRXZlbnRFbWl0dGVyLmRlZmF1bHRNYXhMaXN0ZW5lcnM7XG4gIHJldHVybiB0aGF0Ll9tYXhMaXN0ZW5lcnM7XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZ2V0TWF4TGlzdGVuZXJzID0gZnVuY3Rpb24gZ2V0TWF4TGlzdGVuZXJzKCkge1xuICByZXR1cm4gJGdldE1heExpc3RlbmVycyh0aGlzKTtcbn07XG5cbi8vIFRoZXNlIHN0YW5kYWxvbmUgZW1pdCogZnVuY3Rpb25zIGFyZSB1c2VkIHRvIG9wdGltaXplIGNhbGxpbmcgb2YgZXZlbnRcbi8vIGhhbmRsZXJzIGZvciBmYXN0IGNhc2VzIGJlY2F1c2UgZW1pdCgpIGl0c2VsZiBvZnRlbiBoYXMgYSB2YXJpYWJsZSBudW1iZXIgb2Zcbi8vIGFyZ3VtZW50cyBhbmQgY2FuIGJlIGRlb3B0aW1pemVkIGJlY2F1c2Ugb2YgdGhhdC4gVGhlc2UgZnVuY3Rpb25zIGFsd2F5cyBoYXZlXG4vLyB0aGUgc2FtZSBudW1iZXIgb2YgYXJndW1lbnRzIGFuZCB0aHVzIGRvIG5vdCBnZXQgZGVvcHRpbWl6ZWQsIHNvIHRoZSBjb2RlXG4vLyBpbnNpZGUgdGhlbSBjYW4gZXhlY3V0ZSBmYXN0ZXIuXG5mdW5jdGlvbiBlbWl0Tm9uZShoYW5kbGVyLCBpc0ZuLCBzZWxmKSB7XG4gIGlmIChpc0ZuKVxuICAgIGhhbmRsZXIuY2FsbChzZWxmKTtcbiAgZWxzZSB7XG4gICAgdmFyIGxlbiA9IGhhbmRsZXIubGVuZ3RoO1xuICAgIHZhciBsaXN0ZW5lcnMgPSBhcnJheUNsb25lKGhhbmRsZXIsIGxlbik7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47ICsraSlcbiAgICAgIGxpc3RlbmVyc1tpXS5jYWxsKHNlbGYpO1xuICB9XG59XG5mdW5jdGlvbiBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSk7XG4gIH1cbn1cbmZ1bmN0aW9uIGVtaXRUd28oaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJnMSwgYXJnMikge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmNhbGwoc2VsZiwgYXJnMSwgYXJnMik7XG4gIGVsc2Uge1xuICAgIHZhciBsZW4gPSBoYW5kbGVyLmxlbmd0aDtcbiAgICB2YXIgbGlzdGVuZXJzID0gYXJyYXlDbG9uZShoYW5kbGVyLCBsZW4pO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuOyArK2kpXG4gICAgICBsaXN0ZW5lcnNbaV0uY2FsbChzZWxmLCBhcmcxLCBhcmcyKTtcbiAgfVxufVxuZnVuY3Rpb24gZW1pdFRocmVlKGhhbmRsZXIsIGlzRm4sIHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpIHtcbiAgaWYgKGlzRm4pXG4gICAgaGFuZGxlci5jYWxsKHNlbGYsIGFyZzEsIGFyZzIsIGFyZzMpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmNhbGwoc2VsZiwgYXJnMSwgYXJnMiwgYXJnMyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgc2VsZiwgYXJncykge1xuICBpZiAoaXNGbilcbiAgICBoYW5kbGVyLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICBlbHNlIHtcbiAgICB2YXIgbGVuID0gaGFuZGxlci5sZW5ndGg7XG4gICAgdmFyIGxpc3RlbmVycyA9IGFycmF5Q2xvbmUoaGFuZGxlciwgbGVuKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgKytpKVxuICAgICAgbGlzdGVuZXJzW2ldLmFwcGx5KHNlbGYsIGFyZ3MpO1xuICB9XG59XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUuZW1pdCA9IGZ1bmN0aW9uIGVtaXQodHlwZSkge1xuICB2YXIgZXIsIGhhbmRsZXIsIGxlbiwgYXJncywgaSwgZXZlbnRzO1xuICB2YXIgZG9FcnJvciA9ICh0eXBlID09PSAnZXJyb3InKTtcblxuICBldmVudHMgPSB0aGlzLl9ldmVudHM7XG4gIGlmIChldmVudHMpXG4gICAgZG9FcnJvciA9IChkb0Vycm9yICYmIGV2ZW50cy5lcnJvciA9PSBudWxsKTtcbiAgZWxzZSBpZiAoIWRvRXJyb3IpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIC8vIElmIHRoZXJlIGlzIG5vICdlcnJvcicgZXZlbnQgbGlzdGVuZXIgdGhlbiB0aHJvdy5cbiAgaWYgKGRvRXJyb3IpIHtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpXG4gICAgICBlciA9IGFyZ3VtZW50c1sxXTtcbiAgICBpZiAoZXIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgdGhyb3cgZXI7IC8vIFVuaGFuZGxlZCAnZXJyb3InIGV2ZW50XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIEF0IGxlYXN0IGdpdmUgc29tZSBraW5kIG9mIGNvbnRleHQgdG8gdGhlIHVzZXJcbiAgICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoJ1VuaGFuZGxlZCBcImVycm9yXCIgZXZlbnQuICgnICsgZXIgKyAnKScpO1xuICAgICAgZXJyLmNvbnRleHQgPSBlcjtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgaGFuZGxlciA9IGV2ZW50c1t0eXBlXTtcblxuICBpZiAoIWhhbmRsZXIpXG4gICAgcmV0dXJuIGZhbHNlO1xuXG4gIHZhciBpc0ZuID0gdHlwZW9mIGhhbmRsZXIgPT09ICdmdW5jdGlvbic7XG4gIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gIHN3aXRjaCAobGVuKSB7XG4gICAgICAvLyBmYXN0IGNhc2VzXG4gICAgY2FzZSAxOlxuICAgICAgZW1pdE5vbmUoaGFuZGxlciwgaXNGbiwgdGhpcyk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDI6XG4gICAgICBlbWl0T25lKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSk7XG4gICAgICBicmVhaztcbiAgICBjYXNlIDM6XG4gICAgICBlbWl0VHdvKGhhbmRsZXIsIGlzRm4sIHRoaXMsIGFyZ3VtZW50c1sxXSwgYXJndW1lbnRzWzJdKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgNDpcbiAgICAgIGVtaXRUaHJlZShoYW5kbGVyLCBpc0ZuLCB0aGlzLCBhcmd1bWVudHNbMV0sIGFyZ3VtZW50c1syXSwgYXJndW1lbnRzWzNdKTtcbiAgICAgIGJyZWFrO1xuICAgICAgLy8gc2xvd2VyXG4gICAgZGVmYXVsdDpcbiAgICAgIGFyZ3MgPSBuZXcgQXJyYXkobGVuIC0gMSk7XG4gICAgICBmb3IgKGkgPSAxOyBpIDwgbGVuOyBpKyspXG4gICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgZW1pdE1hbnkoaGFuZGxlciwgaXNGbiwgdGhpcywgYXJncyk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cbmZ1bmN0aW9uIF9hZGRMaXN0ZW5lcih0YXJnZXQsIHR5cGUsIGxpc3RlbmVyLCBwcmVwZW5kKSB7XG4gIHZhciBtO1xuICB2YXIgZXZlbnRzO1xuICB2YXIgZXhpc3Rpbmc7XG5cbiAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG4gIGlmICghZXZlbnRzKSB7XG4gICAgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgdGFyZ2V0Ll9ldmVudHNDb3VudCA9IDA7XG4gIH0gZWxzZSB7XG4gICAgLy8gVG8gYXZvaWQgcmVjdXJzaW9uIGluIHRoZSBjYXNlIHRoYXQgdHlwZSA9PT0gXCJuZXdMaXN0ZW5lclwiISBCZWZvcmVcbiAgICAvLyBhZGRpbmcgaXQgdG8gdGhlIGxpc3RlbmVycywgZmlyc3QgZW1pdCBcIm5ld0xpc3RlbmVyXCIuXG4gICAgaWYgKGV2ZW50cy5uZXdMaXN0ZW5lcikge1xuICAgICAgdGFyZ2V0LmVtaXQoJ25ld0xpc3RlbmVyJywgdHlwZSxcbiAgICAgICAgICBsaXN0ZW5lci5saXN0ZW5lciA/IGxpc3RlbmVyLmxpc3RlbmVyIDogbGlzdGVuZXIpO1xuXG4gICAgICAvLyBSZS1hc3NpZ24gYGV2ZW50c2AgYmVjYXVzZSBhIG5ld0xpc3RlbmVyIGhhbmRsZXIgY291bGQgaGF2ZSBjYXVzZWQgdGhlXG4gICAgICAvLyB0aGlzLl9ldmVudHMgdG8gYmUgYXNzaWduZWQgdG8gYSBuZXcgb2JqZWN0XG4gICAgICBldmVudHMgPSB0YXJnZXQuX2V2ZW50cztcbiAgICB9XG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV07XG4gIH1cblxuICBpZiAoIWV4aXN0aW5nKSB7XG4gICAgLy8gT3B0aW1pemUgdGhlIGNhc2Ugb2Ygb25lIGxpc3RlbmVyLiBEb24ndCBuZWVkIHRoZSBleHRyYSBhcnJheSBvYmplY3QuXG4gICAgZXhpc3RpbmcgPSBldmVudHNbdHlwZV0gPSBsaXN0ZW5lcjtcbiAgICArK3RhcmdldC5fZXZlbnRzQ291bnQ7XG4gIH0gZWxzZSB7XG4gICAgaWYgKHR5cGVvZiBleGlzdGluZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgLy8gQWRkaW5nIHRoZSBzZWNvbmQgZWxlbWVudCwgbmVlZCB0byBjaGFuZ2UgdG8gYXJyYXkuXG4gICAgICBleGlzdGluZyA9IGV2ZW50c1t0eXBlXSA9XG4gICAgICAgICAgcHJlcGVuZCA/IFtsaXN0ZW5lciwgZXhpc3RpbmddIDogW2V4aXN0aW5nLCBsaXN0ZW5lcl07XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIElmIHdlJ3ZlIGFscmVhZHkgZ290IGFuIGFycmF5LCBqdXN0IGFwcGVuZC5cbiAgICAgIGlmIChwcmVwZW5kKSB7XG4gICAgICAgIGV4aXN0aW5nLnVuc2hpZnQobGlzdGVuZXIpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZXhpc3RpbmcucHVzaChsaXN0ZW5lcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQ2hlY2sgZm9yIGxpc3RlbmVyIGxlYWtcbiAgICBpZiAoIWV4aXN0aW5nLndhcm5lZCkge1xuICAgICAgbSA9ICRnZXRNYXhMaXN0ZW5lcnModGFyZ2V0KTtcbiAgICAgIGlmIChtICYmIG0gPiAwICYmIGV4aXN0aW5nLmxlbmd0aCA+IG0pIHtcbiAgICAgICAgZXhpc3Rpbmcud2FybmVkID0gdHJ1ZTtcbiAgICAgICAgdmFyIHcgPSBuZXcgRXJyb3IoJ1Bvc3NpYmxlIEV2ZW50RW1pdHRlciBtZW1vcnkgbGVhayBkZXRlY3RlZC4gJyArXG4gICAgICAgICAgICBleGlzdGluZy5sZW5ndGggKyAnIFwiJyArIFN0cmluZyh0eXBlKSArICdcIiBsaXN0ZW5lcnMgJyArXG4gICAgICAgICAgICAnYWRkZWQuIFVzZSBlbWl0dGVyLnNldE1heExpc3RlbmVycygpIHRvICcgK1xuICAgICAgICAgICAgJ2luY3JlYXNlIGxpbWl0LicpO1xuICAgICAgICB3Lm5hbWUgPSAnTWF4TGlzdGVuZXJzRXhjZWVkZWRXYXJuaW5nJztcbiAgICAgICAgdy5lbWl0dGVyID0gdGFyZ2V0O1xuICAgICAgICB3LnR5cGUgPSB0eXBlO1xuICAgICAgICB3LmNvdW50ID0gZXhpc3RpbmcubGVuZ3RoO1xuICAgICAgICBpZiAodHlwZW9mIGNvbnNvbGUgPT09ICdvYmplY3QnICYmIGNvbnNvbGUud2Fybikge1xuICAgICAgICAgIGNvbnNvbGUud2FybignJXM6ICVzJywgdy5uYW1lLCB3Lm1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIHRhcmdldDtcbn1cblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5hZGRMaXN0ZW5lciA9IGZ1bmN0aW9uIGFkZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gIHJldHVybiBfYWRkTGlzdGVuZXIodGhpcywgdHlwZSwgbGlzdGVuZXIsIGZhbHNlKTtcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUub24gPSBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmFkZExpc3RlbmVyO1xuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLnByZXBlbmRMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyKSB7XG4gICAgICByZXR1cm4gX2FkZExpc3RlbmVyKHRoaXMsIHR5cGUsIGxpc3RlbmVyLCB0cnVlKTtcbiAgICB9O1xuXG5mdW5jdGlvbiBvbmNlV3JhcHBlcigpIHtcbiAgaWYgKCF0aGlzLmZpcmVkKSB7XG4gICAgdGhpcy50YXJnZXQucmVtb3ZlTGlzdGVuZXIodGhpcy50eXBlLCB0aGlzLndyYXBGbik7XG4gICAgdGhpcy5maXJlZCA9IHRydWU7XG4gICAgc3dpdGNoIChhcmd1bWVudHMubGVuZ3RoKSB7XG4gICAgICBjYXNlIDA6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQpO1xuICAgICAgY2FzZSAxOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0pO1xuICAgICAgY2FzZSAyOlxuICAgICAgICByZXR1cm4gdGhpcy5saXN0ZW5lci5jYWxsKHRoaXMudGFyZ2V0LCBhcmd1bWVudHNbMF0sIGFyZ3VtZW50c1sxXSk7XG4gICAgICBjYXNlIDM6XG4gICAgICAgIHJldHVybiB0aGlzLmxpc3RlbmVyLmNhbGwodGhpcy50YXJnZXQsIGFyZ3VtZW50c1swXSwgYXJndW1lbnRzWzFdLFxuICAgICAgICAgICAgYXJndW1lbnRzWzJdKTtcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyArK2kpXG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpXTtcbiAgICAgICAgdGhpcy5saXN0ZW5lci5hcHBseSh0aGlzLnRhcmdldCwgYXJncyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIF9vbmNlV3JhcCh0YXJnZXQsIHR5cGUsIGxpc3RlbmVyKSB7XG4gIHZhciBzdGF0ZSA9IHsgZmlyZWQ6IGZhbHNlLCB3cmFwRm46IHVuZGVmaW5lZCwgdGFyZ2V0OiB0YXJnZXQsIHR5cGU6IHR5cGUsIGxpc3RlbmVyOiBsaXN0ZW5lciB9O1xuICB2YXIgd3JhcHBlZCA9IGJpbmQuY2FsbChvbmNlV3JhcHBlciwgc3RhdGUpO1xuICB3cmFwcGVkLmxpc3RlbmVyID0gbGlzdGVuZXI7XG4gIHN0YXRlLndyYXBGbiA9IHdyYXBwZWQ7XG4gIHJldHVybiB3cmFwcGVkO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uY2UgPSBmdW5jdGlvbiBvbmNlKHR5cGUsIGxpc3RlbmVyKSB7XG4gIGlmICh0eXBlb2YgbGlzdGVuZXIgIT09ICdmdW5jdGlvbicpXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICB0aGlzLm9uKHR5cGUsIF9vbmNlV3JhcCh0aGlzLCB0eXBlLCBsaXN0ZW5lcikpO1xuICByZXR1cm4gdGhpcztcbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUucHJlcGVuZE9uY2VMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcHJlcGVuZE9uY2VMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcikge1xuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignXCJsaXN0ZW5lclwiIGFyZ3VtZW50IG11c3QgYmUgYSBmdW5jdGlvbicpO1xuICAgICAgdGhpcy5wcmVwZW5kTGlzdGVuZXIodHlwZSwgX29uY2VXcmFwKHRoaXMsIHR5cGUsIGxpc3RlbmVyKSk7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9O1xuXG4vLyBFbWl0cyBhICdyZW1vdmVMaXN0ZW5lcicgZXZlbnQgaWYgYW5kIG9ubHkgaWYgdGhlIGxpc3RlbmVyIHdhcyByZW1vdmVkLlxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVMaXN0ZW5lciA9XG4gICAgZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodHlwZSwgbGlzdGVuZXIpIHtcbiAgICAgIHZhciBsaXN0LCBldmVudHMsIHBvc2l0aW9uLCBpLCBvcmlnaW5hbExpc3RlbmVyO1xuXG4gICAgICBpZiAodHlwZW9mIGxpc3RlbmVyICE9PSAnZnVuY3Rpb24nKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RlbmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIGZ1bmN0aW9uJyk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgbGlzdCA9IGV2ZW50c1t0eXBlXTtcbiAgICAgIGlmICghbGlzdClcbiAgICAgICAgcmV0dXJuIHRoaXM7XG5cbiAgICAgIGlmIChsaXN0ID09PSBsaXN0ZW5lciB8fCBsaXN0Lmxpc3RlbmVyID09PSBsaXN0ZW5lcikge1xuICAgICAgICBpZiAoLS10aGlzLl9ldmVudHNDb3VudCA9PT0gMClcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgICAgaWYgKGV2ZW50cy5yZW1vdmVMaXN0ZW5lcilcbiAgICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBsaXN0Lmxpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmICh0eXBlb2YgbGlzdCAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBwb3NpdGlvbiA9IC0xO1xuXG4gICAgICAgIGZvciAoaSA9IGxpc3QubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICBpZiAobGlzdFtpXSA9PT0gbGlzdGVuZXIgfHwgbGlzdFtpXS5saXN0ZW5lciA9PT0gbGlzdGVuZXIpIHtcbiAgICAgICAgICAgIG9yaWdpbmFsTGlzdGVuZXIgPSBsaXN0W2ldLmxpc3RlbmVyO1xuICAgICAgICAgICAgcG9zaXRpb24gPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKHBvc2l0aW9uIDwgMClcbiAgICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgICBpZiAocG9zaXRpb24gPT09IDApXG4gICAgICAgICAgbGlzdC5zaGlmdCgpO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgc3BsaWNlT25lKGxpc3QsIHBvc2l0aW9uKTtcblxuICAgICAgICBpZiAobGlzdC5sZW5ndGggPT09IDEpXG4gICAgICAgICAgZXZlbnRzW3R5cGVdID0gbGlzdFswXTtcblxuICAgICAgICBpZiAoZXZlbnRzLnJlbW92ZUxpc3RlbmVyKVxuICAgICAgICAgIHRoaXMuZW1pdCgncmVtb3ZlTGlzdGVuZXInLCB0eXBlLCBvcmlnaW5hbExpc3RlbmVyIHx8IGxpc3RlbmVyKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yZW1vdmVBbGxMaXN0ZW5lcnMgPVxuICAgIGZ1bmN0aW9uIHJlbW92ZUFsbExpc3RlbmVycyh0eXBlKSB7XG4gICAgICB2YXIgbGlzdGVuZXJzLCBldmVudHMsIGk7XG5cbiAgICAgIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcbiAgICAgIGlmICghZXZlbnRzKVxuICAgICAgICByZXR1cm4gdGhpcztcblxuICAgICAgLy8gbm90IGxpc3RlbmluZyBmb3IgcmVtb3ZlTGlzdGVuZXIsIG5vIG5lZWQgdG8gZW1pdFxuICAgICAgaWYgKCFldmVudHMucmVtb3ZlTGlzdGVuZXIpIHtcbiAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgICAgdGhpcy5fZXZlbnRzQ291bnQgPSAwO1xuICAgICAgICB9IGVsc2UgaWYgKGV2ZW50c1t0eXBlXSkge1xuICAgICAgICAgIGlmICgtLXRoaXMuX2V2ZW50c0NvdW50ID09PSAwKVxuICAgICAgICAgICAgdGhpcy5fZXZlbnRzID0gb2JqZWN0Q3JlYXRlKG51bGwpO1xuICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgIGRlbGV0ZSBldmVudHNbdHlwZV07XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIC8vIGVtaXQgcmVtb3ZlTGlzdGVuZXIgZm9yIGFsbCBsaXN0ZW5lcnMgb24gYWxsIGV2ZW50c1xuICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgdmFyIGtleXMgPSBvYmplY3RLZXlzKGV2ZW50cyk7XG4gICAgICAgIHZhciBrZXk7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgICAga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICBpZiAoa2V5ID09PSAncmVtb3ZlTGlzdGVuZXInKSBjb250aW51ZTtcbiAgICAgICAgICB0aGlzLnJlbW92ZUFsbExpc3RlbmVycyhrZXkpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMucmVtb3ZlQWxsTGlzdGVuZXJzKCdyZW1vdmVMaXN0ZW5lcicpO1xuICAgICAgICB0aGlzLl9ldmVudHMgPSBvYmplY3RDcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuX2V2ZW50c0NvdW50ID0gMDtcbiAgICAgICAgcmV0dXJuIHRoaXM7XG4gICAgICB9XG5cbiAgICAgIGxpc3RlbmVycyA9IGV2ZW50c1t0eXBlXTtcblxuICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcnMgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgdGhpcy5yZW1vdmVMaXN0ZW5lcih0eXBlLCBsaXN0ZW5lcnMpO1xuICAgICAgfSBlbHNlIGlmIChsaXN0ZW5lcnMpIHtcbiAgICAgICAgLy8gTElGTyBvcmRlclxuICAgICAgICBmb3IgKGkgPSBsaXN0ZW5lcnMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICAgICAgICB0aGlzLnJlbW92ZUxpc3RlbmVyKHR5cGUsIGxpc3RlbmVyc1tpXSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfTtcblxuZnVuY3Rpb24gX2xpc3RlbmVycyh0YXJnZXQsIHR5cGUsIHVud3JhcCkge1xuICB2YXIgZXZlbnRzID0gdGFyZ2V0Ll9ldmVudHM7XG5cbiAgaWYgKCFldmVudHMpXG4gICAgcmV0dXJuIFtdO1xuXG4gIHZhciBldmxpc3RlbmVyID0gZXZlbnRzW3R5cGVdO1xuICBpZiAoIWV2bGlzdGVuZXIpXG4gICAgcmV0dXJuIFtdO1xuXG4gIGlmICh0eXBlb2YgZXZsaXN0ZW5lciA9PT0gJ2Z1bmN0aW9uJylcbiAgICByZXR1cm4gdW53cmFwID8gW2V2bGlzdGVuZXIubGlzdGVuZXIgfHwgZXZsaXN0ZW5lcl0gOiBbZXZsaXN0ZW5lcl07XG5cbiAgcmV0dXJuIHVud3JhcCA/IHVud3JhcExpc3RlbmVycyhldmxpc3RlbmVyKSA6IGFycmF5Q2xvbmUoZXZsaXN0ZW5lciwgZXZsaXN0ZW5lci5sZW5ndGgpO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmxpc3RlbmVycyA9IGZ1bmN0aW9uIGxpc3RlbmVycyh0eXBlKSB7XG4gIHJldHVybiBfbGlzdGVuZXJzKHRoaXMsIHR5cGUsIHRydWUpO1xufTtcblxuRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5yYXdMaXN0ZW5lcnMgPSBmdW5jdGlvbiByYXdMaXN0ZW5lcnModHlwZSkge1xuICByZXR1cm4gX2xpc3RlbmVycyh0aGlzLCB0eXBlLCBmYWxzZSk7XG59O1xuXG5FdmVudEVtaXR0ZXIubGlzdGVuZXJDb3VudCA9IGZ1bmN0aW9uKGVtaXR0ZXIsIHR5cGUpIHtcbiAgaWYgKHR5cGVvZiBlbWl0dGVyLmxpc3RlbmVyQ291bnQgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gZW1pdHRlci5saXN0ZW5lckNvdW50KHR5cGUpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBsaXN0ZW5lckNvdW50LmNhbGwoZW1pdHRlciwgdHlwZSk7XG4gIH1cbn07XG5cbkV2ZW50RW1pdHRlci5wcm90b3R5cGUubGlzdGVuZXJDb3VudCA9IGxpc3RlbmVyQ291bnQ7XG5mdW5jdGlvbiBsaXN0ZW5lckNvdW50KHR5cGUpIHtcbiAgdmFyIGV2ZW50cyA9IHRoaXMuX2V2ZW50cztcblxuICBpZiAoZXZlbnRzKSB7XG4gICAgdmFyIGV2bGlzdGVuZXIgPSBldmVudHNbdHlwZV07XG5cbiAgICBpZiAodHlwZW9mIGV2bGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHJldHVybiAxO1xuICAgIH0gZWxzZSBpZiAoZXZsaXN0ZW5lcikge1xuICAgICAgcmV0dXJuIGV2bGlzdGVuZXIubGVuZ3RoO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiAwO1xufVxuXG5FdmVudEVtaXR0ZXIucHJvdG90eXBlLmV2ZW50TmFtZXMgPSBmdW5jdGlvbiBldmVudE5hbWVzKCkge1xuICByZXR1cm4gdGhpcy5fZXZlbnRzQ291bnQgPiAwID8gUmVmbGVjdC5vd25LZXlzKHRoaXMuX2V2ZW50cykgOiBbXTtcbn07XG5cbi8vIEFib3V0IDEuNXggZmFzdGVyIHRoYW4gdGhlIHR3by1hcmcgdmVyc2lvbiBvZiBBcnJheSNzcGxpY2UoKS5cbmZ1bmN0aW9uIHNwbGljZU9uZShsaXN0LCBpbmRleCkge1xuICBmb3IgKHZhciBpID0gaW5kZXgsIGsgPSBpICsgMSwgbiA9IGxpc3QubGVuZ3RoOyBrIDwgbjsgaSArPSAxLCBrICs9IDEpXG4gICAgbGlzdFtpXSA9IGxpc3Rba107XG4gIGxpc3QucG9wKCk7XG59XG5cbmZ1bmN0aW9uIGFycmF5Q2xvbmUoYXJyLCBuKSB7XG4gIHZhciBjb3B5ID0gbmV3IEFycmF5KG4pO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IG47ICsraSlcbiAgICBjb3B5W2ldID0gYXJyW2ldO1xuICByZXR1cm4gY29weTtcbn1cblxuZnVuY3Rpb24gdW53cmFwTGlzdGVuZXJzKGFycikge1xuICB2YXIgcmV0ID0gbmV3IEFycmF5KGFyci5sZW5ndGgpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHJldC5sZW5ndGg7ICsraSkge1xuICAgIHJldFtpXSA9IGFycltpXS5saXN0ZW5lciB8fCBhcnJbaV07XG4gIH1cbiAgcmV0dXJuIHJldDtcbn1cblxuZnVuY3Rpb24gb2JqZWN0Q3JlYXRlUG9seWZpbGwocHJvdG8pIHtcbiAgdmFyIEYgPSBmdW5jdGlvbigpIHt9O1xuICBGLnByb3RvdHlwZSA9IHByb3RvO1xuICByZXR1cm4gbmV3IEY7XG59XG5mdW5jdGlvbiBvYmplY3RLZXlzUG9seWZpbGwob2JqKSB7XG4gIHZhciBrZXlzID0gW107XG4gIGZvciAodmFyIGsgaW4gb2JqKSBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwgaykpIHtcbiAgICBrZXlzLnB1c2goayk7XG4gIH1cbiAgcmV0dXJuIGs7XG59XG5mdW5jdGlvbiBmdW5jdGlvbkJpbmRQb2x5ZmlsbChjb250ZXh0KSB7XG4gIHZhciBmbiA9IHRoaXM7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIGZuLmFwcGx5KGNvbnRleHQsIGFyZ3VtZW50cyk7XG4gIH07XG59XG4iLCIvKiBlc2xpbnQtZW52IGJyb3dzZXIgKi9cblxuLyoqXG4gKiBUaGlzIGlzIHRoZSB3ZWIgYnJvd3NlciBpbXBsZW1lbnRhdGlvbiBvZiBgZGVidWcoKWAuXG4gKi9cblxuZXhwb3J0cy5mb3JtYXRBcmdzID0gZm9ybWF0QXJncztcbmV4cG9ydHMuc2F2ZSA9IHNhdmU7XG5leHBvcnRzLmxvYWQgPSBsb2FkO1xuZXhwb3J0cy51c2VDb2xvcnMgPSB1c2VDb2xvcnM7XG5leHBvcnRzLnN0b3JhZ2UgPSBsb2NhbHN0b3JhZ2UoKTtcbmV4cG9ydHMuZGVzdHJveSA9ICgoKSA9PiB7XG5cdGxldCB3YXJuZWQgPSBmYWxzZTtcblxuXHRyZXR1cm4gKCkgPT4ge1xuXHRcdGlmICghd2FybmVkKSB7XG5cdFx0XHR3YXJuZWQgPSB0cnVlO1xuXHRcdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdFx0fVxuXHR9O1xufSkoKTtcblxuLyoqXG4gKiBDb2xvcnMuXG4gKi9cblxuZXhwb3J0cy5jb2xvcnMgPSBbXG5cdCcjMDAwMENDJyxcblx0JyMwMDAwRkYnLFxuXHQnIzAwMzNDQycsXG5cdCcjMDAzM0ZGJyxcblx0JyMwMDY2Q0MnLFxuXHQnIzAwNjZGRicsXG5cdCcjMDA5OUNDJyxcblx0JyMwMDk5RkYnLFxuXHQnIzAwQ0MwMCcsXG5cdCcjMDBDQzMzJyxcblx0JyMwMENDNjYnLFxuXHQnIzAwQ0M5OScsXG5cdCcjMDBDQ0NDJyxcblx0JyMwMENDRkYnLFxuXHQnIzMzMDBDQycsXG5cdCcjMzMwMEZGJyxcblx0JyMzMzMzQ0MnLFxuXHQnIzMzMzNGRicsXG5cdCcjMzM2NkNDJyxcblx0JyMzMzY2RkYnLFxuXHQnIzMzOTlDQycsXG5cdCcjMzM5OUZGJyxcblx0JyMzM0NDMDAnLFxuXHQnIzMzQ0MzMycsXG5cdCcjMzNDQzY2Jyxcblx0JyMzM0NDOTknLFxuXHQnIzMzQ0NDQycsXG5cdCcjMzNDQ0ZGJyxcblx0JyM2NjAwQ0MnLFxuXHQnIzY2MDBGRicsXG5cdCcjNjYzM0NDJyxcblx0JyM2NjMzRkYnLFxuXHQnIzY2Q0MwMCcsXG5cdCcjNjZDQzMzJyxcblx0JyM5OTAwQ0MnLFxuXHQnIzk5MDBGRicsXG5cdCcjOTkzM0NDJyxcblx0JyM5OTMzRkYnLFxuXHQnIzk5Q0MwMCcsXG5cdCcjOTlDQzMzJyxcblx0JyNDQzAwMDAnLFxuXHQnI0NDMDAzMycsXG5cdCcjQ0MwMDY2Jyxcblx0JyNDQzAwOTknLFxuXHQnI0NDMDBDQycsXG5cdCcjQ0MwMEZGJyxcblx0JyNDQzMzMDAnLFxuXHQnI0NDMzMzMycsXG5cdCcjQ0MzMzY2Jyxcblx0JyNDQzMzOTknLFxuXHQnI0NDMzNDQycsXG5cdCcjQ0MzM0ZGJyxcblx0JyNDQzY2MDAnLFxuXHQnI0NDNjYzMycsXG5cdCcjQ0M5OTAwJyxcblx0JyNDQzk5MzMnLFxuXHQnI0NDQ0MwMCcsXG5cdCcjQ0NDQzMzJyxcblx0JyNGRjAwMDAnLFxuXHQnI0ZGMDAzMycsXG5cdCcjRkYwMDY2Jyxcblx0JyNGRjAwOTknLFxuXHQnI0ZGMDBDQycsXG5cdCcjRkYwMEZGJyxcblx0JyNGRjMzMDAnLFxuXHQnI0ZGMzMzMycsXG5cdCcjRkYzMzY2Jyxcblx0JyNGRjMzOTknLFxuXHQnI0ZGMzNDQycsXG5cdCcjRkYzM0ZGJyxcblx0JyNGRjY2MDAnLFxuXHQnI0ZGNjYzMycsXG5cdCcjRkY5OTAwJyxcblx0JyNGRjk5MzMnLFxuXHQnI0ZGQ0MwMCcsXG5cdCcjRkZDQzMzJ1xuXTtcblxuLyoqXG4gKiBDdXJyZW50bHkgb25seSBXZWJLaXQtYmFzZWQgV2ViIEluc3BlY3RvcnMsIEZpcmVmb3ggPj0gdjMxLFxuICogYW5kIHRoZSBGaXJlYnVnIGV4dGVuc2lvbiAoYW55IEZpcmVmb3ggdmVyc2lvbikgYXJlIGtub3duXG4gKiB0byBzdXBwb3J0IFwiJWNcIiBDU1MgY3VzdG9taXphdGlvbnMuXG4gKlxuICogVE9ETzogYWRkIGEgYGxvY2FsU3RvcmFnZWAgdmFyaWFibGUgdG8gZXhwbGljaXRseSBlbmFibGUvZGlzYWJsZSBjb2xvcnNcbiAqL1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29tcGxleGl0eVxuZnVuY3Rpb24gdXNlQ29sb3JzKCkge1xuXHQvLyBOQjogSW4gYW4gRWxlY3Ryb24gcHJlbG9hZCBzY3JpcHQsIGRvY3VtZW50IHdpbGwgYmUgZGVmaW5lZCBidXQgbm90IGZ1bGx5XG5cdC8vIGluaXRpYWxpemVkLiBTaW5jZSB3ZSBrbm93IHdlJ3JlIGluIENocm9tZSwgd2UnbGwganVzdCBkZXRlY3QgdGhpcyBjYXNlXG5cdC8vIGV4cGxpY2l0bHlcblx0aWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5wcm9jZXNzICYmICh3aW5kb3cucHJvY2Vzcy50eXBlID09PSAncmVuZGVyZXInIHx8IHdpbmRvdy5wcm9jZXNzLl9fbndqcykpIHtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fVxuXG5cdC8vIEludGVybmV0IEV4cGxvcmVyIGFuZCBFZGdlIGRvIG5vdCBzdXBwb3J0IGNvbG9ycy5cblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC8oZWRnZXx0cmlkZW50KVxcLyhcXGQrKS8pKSB7XG5cdFx0cmV0dXJuIGZhbHNlO1xuXHR9XG5cblx0Ly8gSXMgd2Via2l0PyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8xNjQ1OTYwNi8zNzY3NzNcblx0Ly8gZG9jdW1lbnQgaXMgdW5kZWZpbmVkIGluIHJlYWN0LW5hdGl2ZTogaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0LW5hdGl2ZS9wdWxsLzE2MzJcblx0cmV0dXJuICh0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCAmJiBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuc3R5bGUgJiYgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnN0eWxlLldlYmtpdEFwcGVhcmFuY2UpIHx8XG5cdFx0Ly8gSXMgZmlyZWJ1Zz8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMzk4MTIwLzM3Njc3M1xuXHRcdCh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY29uc29sZSAmJiAod2luZG93LmNvbnNvbGUuZmlyZWJ1ZyB8fCAod2luZG93LmNvbnNvbGUuZXhjZXB0aW9uICYmIHdpbmRvdy5jb25zb2xlLnRhYmxlKSkpIHx8XG5cdFx0Ly8gSXMgZmlyZWZveCA+PSB2MzE/XG5cdFx0Ly8gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9Ub29scy9XZWJfQ29uc29sZSNTdHlsaW5nX21lc3NhZ2VzXG5cdFx0KHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci51c2VyQWdlbnQgJiYgbmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpLm1hdGNoKC9maXJlZm94XFwvKFxcZCspLykgJiYgcGFyc2VJbnQoUmVnRXhwLiQxLCAxMCkgPj0gMzEpIHx8XG5cdFx0Ly8gRG91YmxlIGNoZWNrIHdlYmtpdCBpbiB1c2VyQWdlbnQganVzdCBpbiBjYXNlIHdlIGFyZSBpbiBhIHdvcmtlclxuXHRcdCh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IudXNlckFnZW50ICYmIG5hdmlnYXRvci51c2VyQWdlbnQudG9Mb3dlckNhc2UoKS5tYXRjaCgvYXBwbGV3ZWJraXRcXC8oXFxkKykvKSk7XG59XG5cbi8qKlxuICogQ29sb3JpemUgbG9nIGFyZ3VtZW50cyBpZiBlbmFibGVkLlxuICpcbiAqIEBhcGkgcHVibGljXG4gKi9cblxuZnVuY3Rpb24gZm9ybWF0QXJncyhhcmdzKSB7XG5cdGFyZ3NbMF0gPSAodGhpcy51c2VDb2xvcnMgPyAnJWMnIDogJycpICtcblx0XHR0aGlzLm5hbWVzcGFjZSArXG5cdFx0KHRoaXMudXNlQ29sb3JzID8gJyAlYycgOiAnICcpICtcblx0XHRhcmdzWzBdICtcblx0XHQodGhpcy51c2VDb2xvcnMgPyAnJWMgJyA6ICcgJykgK1xuXHRcdCcrJyArIG1vZHVsZS5leHBvcnRzLmh1bWFuaXplKHRoaXMuZGlmZik7XG5cblx0aWYgKCF0aGlzLnVzZUNvbG9ycykge1xuXHRcdHJldHVybjtcblx0fVxuXG5cdGNvbnN0IGMgPSAnY29sb3I6ICcgKyB0aGlzLmNvbG9yO1xuXHRhcmdzLnNwbGljZSgxLCAwLCBjLCAnY29sb3I6IGluaGVyaXQnKTtcblxuXHQvLyBUaGUgZmluYWwgXCIlY1wiIGlzIHNvbWV3aGF0IHRyaWNreSwgYmVjYXVzZSB0aGVyZSBjb3VsZCBiZSBvdGhlclxuXHQvLyBhcmd1bWVudHMgcGFzc2VkIGVpdGhlciBiZWZvcmUgb3IgYWZ0ZXIgdGhlICVjLCBzbyB3ZSBuZWVkIHRvXG5cdC8vIGZpZ3VyZSBvdXQgdGhlIGNvcnJlY3QgaW5kZXggdG8gaW5zZXJ0IHRoZSBDU1MgaW50b1xuXHRsZXQgaW5kZXggPSAwO1xuXHRsZXQgbGFzdEMgPSAwO1xuXHRhcmdzWzBdLnJlcGxhY2UoLyVbYS16QS1aJV0vZywgbWF0Y2ggPT4ge1xuXHRcdGlmIChtYXRjaCA9PT0gJyUlJykge1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRpbmRleCsrO1xuXHRcdGlmIChtYXRjaCA9PT0gJyVjJykge1xuXHRcdFx0Ly8gV2Ugb25seSBhcmUgaW50ZXJlc3RlZCBpbiB0aGUgKmxhc3QqICVjXG5cdFx0XHQvLyAodGhlIHVzZXIgbWF5IGhhdmUgcHJvdmlkZWQgdGhlaXIgb3duKVxuXHRcdFx0bGFzdEMgPSBpbmRleDtcblx0XHR9XG5cdH0pO1xuXG5cdGFyZ3Muc3BsaWNlKGxhc3RDLCAwLCBjKTtcbn1cblxuLyoqXG4gKiBJbnZva2VzIGBjb25zb2xlLmRlYnVnKClgIHdoZW4gYXZhaWxhYmxlLlxuICogTm8tb3Agd2hlbiBgY29uc29sZS5kZWJ1Z2AgaXMgbm90IGEgXCJmdW5jdGlvblwiLlxuICogSWYgYGNvbnNvbGUuZGVidWdgIGlzIG5vdCBhdmFpbGFibGUsIGZhbGxzIGJhY2tcbiAqIHRvIGBjb25zb2xlLmxvZ2AuXG4gKlxuICogQGFwaSBwdWJsaWNcbiAqL1xuZXhwb3J0cy5sb2cgPSBjb25zb2xlLmRlYnVnIHx8IGNvbnNvbGUubG9nIHx8ICgoKSA9PiB7fSk7XG5cbi8qKlxuICogU2F2ZSBgbmFtZXNwYWNlc2AuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IG5hbWVzcGFjZXNcbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBzYXZlKG5hbWVzcGFjZXMpIHtcblx0dHJ5IHtcblx0XHRpZiAobmFtZXNwYWNlcykge1xuXHRcdFx0ZXhwb3J0cy5zdG9yYWdlLnNldEl0ZW0oJ2RlYnVnJywgbmFtZXNwYWNlcyk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdGV4cG9ydHMuc3RvcmFnZS5yZW1vdmVJdGVtKCdkZWJ1ZycpO1xuXHRcdH1cblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBTd2FsbG93XG5cdFx0Ly8gWFhYIChAUWl4LSkgc2hvdWxkIHdlIGJlIGxvZ2dpbmcgdGhlc2U/XG5cdH1cbn1cblxuLyoqXG4gKiBMb2FkIGBuYW1lc3BhY2VzYC5cbiAqXG4gKiBAcmV0dXJuIHtTdHJpbmd9IHJldHVybnMgdGhlIHByZXZpb3VzbHkgcGVyc2lzdGVkIGRlYnVnIG1vZGVzXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gbG9hZCgpIHtcblx0bGV0IHI7XG5cdHRyeSB7XG5cdFx0ciA9IGV4cG9ydHMuc3RvcmFnZS5nZXRJdGVtKCdkZWJ1ZycpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdC8vIFN3YWxsb3dcblx0XHQvLyBYWFggKEBRaXgtKSBzaG91bGQgd2UgYmUgbG9nZ2luZyB0aGVzZT9cblx0fVxuXG5cdC8vIElmIGRlYnVnIGlzbid0IHNldCBpbiBMUywgYW5kIHdlJ3JlIGluIEVsZWN0cm9uLCB0cnkgdG8gbG9hZCAkREVCVUdcblx0aWYgKCFyICYmIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAnZW52JyBpbiBwcm9jZXNzKSB7XG5cdFx0ciA9IHByb2Nlc3MuZW52LkRFQlVHO1xuXHR9XG5cblx0cmV0dXJuIHI7XG59XG5cbi8qKlxuICogTG9jYWxzdG9yYWdlIGF0dGVtcHRzIHRvIHJldHVybiB0aGUgbG9jYWxzdG9yYWdlLlxuICpcbiAqIFRoaXMgaXMgbmVjZXNzYXJ5IGJlY2F1c2Ugc2FmYXJpIHRocm93c1xuICogd2hlbiBhIHVzZXIgZGlzYWJsZXMgY29va2llcy9sb2NhbHN0b3JhZ2VcbiAqIGFuZCB5b3UgYXR0ZW1wdCB0byBhY2Nlc3MgaXQuXG4gKlxuICogQHJldHVybiB7TG9jYWxTdG9yYWdlfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gbG9jYWxzdG9yYWdlKCkge1xuXHR0cnkge1xuXHRcdC8vIFRWTUxLaXQgKEFwcGxlIFRWIEpTIFJ1bnRpbWUpIGRvZXMgbm90IGhhdmUgYSB3aW5kb3cgb2JqZWN0LCBqdXN0IGxvY2FsU3RvcmFnZSBpbiB0aGUgZ2xvYmFsIGNvbnRleHRcblx0XHQvLyBUaGUgQnJvd3NlciBhbHNvIGhhcyBsb2NhbFN0b3JhZ2UgaW4gdGhlIGdsb2JhbCBjb250ZXh0LlxuXHRcdHJldHVybiBsb2NhbFN0b3JhZ2U7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdFx0Ly8gU3dhbGxvd1xuXHRcdC8vIFhYWCAoQFFpeC0pIHNob3VsZCB3ZSBiZSBsb2dnaW5nIHRoZXNlP1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9jb21tb24nKShleHBvcnRzKTtcblxuY29uc3Qge2Zvcm1hdHRlcnN9ID0gbW9kdWxlLmV4cG9ydHM7XG5cbi8qKlxuICogTWFwICVqIHRvIGBKU09OLnN0cmluZ2lmeSgpYCwgc2luY2Ugbm8gV2ViIEluc3BlY3RvcnMgZG8gdGhhdCBieSBkZWZhdWx0LlxuICovXG5cbmZvcm1hdHRlcnMuaiA9IGZ1bmN0aW9uICh2KSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIEpTT04uc3RyaW5naWZ5KHYpO1xuXHR9IGNhdGNoIChlcnJvcikge1xuXHRcdHJldHVybiAnW1VuZXhwZWN0ZWRKU09OUGFyc2VFcnJvcl06ICcgKyBlcnJvci5tZXNzYWdlO1xuXHR9XG59O1xuIiwiXG4vKipcbiAqIFRoaXMgaXMgdGhlIGNvbW1vbiBsb2dpYyBmb3IgYm90aCB0aGUgTm9kZS5qcyBhbmQgd2ViIGJyb3dzZXJcbiAqIGltcGxlbWVudGF0aW9ucyBvZiBgZGVidWcoKWAuXG4gKi9cblxuZnVuY3Rpb24gc2V0dXAoZW52KSB7XG5cdGNyZWF0ZURlYnVnLmRlYnVnID0gY3JlYXRlRGVidWc7XG5cdGNyZWF0ZURlYnVnLmRlZmF1bHQgPSBjcmVhdGVEZWJ1Zztcblx0Y3JlYXRlRGVidWcuY29lcmNlID0gY29lcmNlO1xuXHRjcmVhdGVEZWJ1Zy5kaXNhYmxlID0gZGlzYWJsZTtcblx0Y3JlYXRlRGVidWcuZW5hYmxlID0gZW5hYmxlO1xuXHRjcmVhdGVEZWJ1Zy5lbmFibGVkID0gZW5hYmxlZDtcblx0Y3JlYXRlRGVidWcuaHVtYW5pemUgPSByZXF1aXJlKCdtcycpO1xuXHRjcmVhdGVEZWJ1Zy5kZXN0cm95ID0gZGVzdHJveTtcblxuXHRPYmplY3Qua2V5cyhlbnYpLmZvckVhY2goa2V5ID0+IHtcblx0XHRjcmVhdGVEZWJ1Z1trZXldID0gZW52W2tleV07XG5cdH0pO1xuXG5cdC8qKlxuXHQqIFRoZSBjdXJyZW50bHkgYWN0aXZlIGRlYnVnIG1vZGUgbmFtZXMsIGFuZCBuYW1lcyB0byBza2lwLlxuXHQqL1xuXG5cdGNyZWF0ZURlYnVnLm5hbWVzID0gW107XG5cdGNyZWF0ZURlYnVnLnNraXBzID0gW107XG5cblx0LyoqXG5cdCogTWFwIG9mIHNwZWNpYWwgXCIlblwiIGhhbmRsaW5nIGZ1bmN0aW9ucywgZm9yIHRoZSBkZWJ1ZyBcImZvcm1hdFwiIGFyZ3VtZW50LlxuXHQqXG5cdCogVmFsaWQga2V5IG5hbWVzIGFyZSBhIHNpbmdsZSwgbG93ZXIgb3IgdXBwZXItY2FzZSBsZXR0ZXIsIGkuZS4gXCJuXCIgYW5kIFwiTlwiLlxuXHQqL1xuXHRjcmVhdGVEZWJ1Zy5mb3JtYXR0ZXJzID0ge307XG5cblx0LyoqXG5cdCogU2VsZWN0cyBhIGNvbG9yIGZvciBhIGRlYnVnIG5hbWVzcGFjZVxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2UgVGhlIG5hbWVzcGFjZSBzdHJpbmcgZm9yIHRoZSBmb3IgdGhlIGRlYnVnIGluc3RhbmNlIHRvIGJlIGNvbG9yZWRcblx0KiBAcmV0dXJuIHtOdW1iZXJ8U3RyaW5nfSBBbiBBTlNJIGNvbG9yIGNvZGUgZm9yIHRoZSBnaXZlbiBuYW1lc3BhY2Vcblx0KiBAYXBpIHByaXZhdGVcblx0Ki9cblx0ZnVuY3Rpb24gc2VsZWN0Q29sb3IobmFtZXNwYWNlKSB7XG5cdFx0bGV0IGhhc2ggPSAwO1xuXG5cdFx0Zm9yIChsZXQgaSA9IDA7IGkgPCBuYW1lc3BhY2UubGVuZ3RoOyBpKyspIHtcblx0XHRcdGhhc2ggPSAoKGhhc2ggPDwgNSkgLSBoYXNoKSArIG5hbWVzcGFjZS5jaGFyQ29kZUF0KGkpO1xuXHRcdFx0aGFzaCB8PSAwOyAvLyBDb252ZXJ0IHRvIDMyYml0IGludGVnZXJcblx0XHR9XG5cblx0XHRyZXR1cm4gY3JlYXRlRGVidWcuY29sb3JzW01hdGguYWJzKGhhc2gpICUgY3JlYXRlRGVidWcuY29sb3JzLmxlbmd0aF07XG5cdH1cblx0Y3JlYXRlRGVidWcuc2VsZWN0Q29sb3IgPSBzZWxlY3RDb2xvcjtcblxuXHQvKipcblx0KiBDcmVhdGUgYSBkZWJ1Z2dlciB3aXRoIHRoZSBnaXZlbiBgbmFtZXNwYWNlYC5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2Vcblx0KiBAcmV0dXJuIHtGdW5jdGlvbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBjcmVhdGVEZWJ1ZyhuYW1lc3BhY2UpIHtcblx0XHRsZXQgcHJldlRpbWU7XG5cdFx0bGV0IGVuYWJsZU92ZXJyaWRlID0gbnVsbDtcblxuXHRcdGZ1bmN0aW9uIGRlYnVnKC4uLmFyZ3MpIHtcblx0XHRcdC8vIERpc2FibGVkP1xuXHRcdFx0aWYgKCFkZWJ1Zy5lbmFibGVkKSB7XG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0Y29uc3Qgc2VsZiA9IGRlYnVnO1xuXG5cdFx0XHQvLyBTZXQgYGRpZmZgIHRpbWVzdGFtcFxuXHRcdFx0Y29uc3QgY3VyciA9IE51bWJlcihuZXcgRGF0ZSgpKTtcblx0XHRcdGNvbnN0IG1zID0gY3VyciAtIChwcmV2VGltZSB8fCBjdXJyKTtcblx0XHRcdHNlbGYuZGlmZiA9IG1zO1xuXHRcdFx0c2VsZi5wcmV2ID0gcHJldlRpbWU7XG5cdFx0XHRzZWxmLmN1cnIgPSBjdXJyO1xuXHRcdFx0cHJldlRpbWUgPSBjdXJyO1xuXG5cdFx0XHRhcmdzWzBdID0gY3JlYXRlRGVidWcuY29lcmNlKGFyZ3NbMF0pO1xuXG5cdFx0XHRpZiAodHlwZW9mIGFyZ3NbMF0gIT09ICdzdHJpbmcnKSB7XG5cdFx0XHRcdC8vIEFueXRoaW5nIGVsc2UgbGV0J3MgaW5zcGVjdCB3aXRoICVPXG5cdFx0XHRcdGFyZ3MudW5zaGlmdCgnJU8nKTtcblx0XHRcdH1cblxuXHRcdFx0Ly8gQXBwbHkgYW55IGBmb3JtYXR0ZXJzYCB0cmFuc2Zvcm1hdGlvbnNcblx0XHRcdGxldCBpbmRleCA9IDA7XG5cdFx0XHRhcmdzWzBdID0gYXJnc1swXS5yZXBsYWNlKC8lKFthLXpBLVolXSkvZywgKG1hdGNoLCBmb3JtYXQpID0+IHtcblx0XHRcdFx0Ly8gSWYgd2UgZW5jb3VudGVyIGFuIGVzY2FwZWQgJSB0aGVuIGRvbid0IGluY3JlYXNlIHRoZSBhcnJheSBpbmRleFxuXHRcdFx0XHRpZiAobWF0Y2ggPT09ICclJScpIHtcblx0XHRcdFx0XHRyZXR1cm4gJyUnO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGluZGV4Kys7XG5cdFx0XHRcdGNvbnN0IGZvcm1hdHRlciA9IGNyZWF0ZURlYnVnLmZvcm1hdHRlcnNbZm9ybWF0XTtcblx0XHRcdFx0aWYgKHR5cGVvZiBmb3JtYXR0ZXIgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdFx0XHRjb25zdCB2YWwgPSBhcmdzW2luZGV4XTtcblx0XHRcdFx0XHRtYXRjaCA9IGZvcm1hdHRlci5jYWxsKHNlbGYsIHZhbCk7XG5cblx0XHRcdFx0XHQvLyBOb3cgd2UgbmVlZCB0byByZW1vdmUgYGFyZ3NbaW5kZXhdYCBzaW5jZSBpdCdzIGlubGluZWQgaW4gdGhlIGBmb3JtYXRgXG5cdFx0XHRcdFx0YXJncy5zcGxpY2UoaW5kZXgsIDEpO1xuXHRcdFx0XHRcdGluZGV4LS07XG5cdFx0XHRcdH1cblx0XHRcdFx0cmV0dXJuIG1hdGNoO1xuXHRcdFx0fSk7XG5cblx0XHRcdC8vIEFwcGx5IGVudi1zcGVjaWZpYyBmb3JtYXR0aW5nIChjb2xvcnMsIGV0Yy4pXG5cdFx0XHRjcmVhdGVEZWJ1Zy5mb3JtYXRBcmdzLmNhbGwoc2VsZiwgYXJncyk7XG5cblx0XHRcdGNvbnN0IGxvZ0ZuID0gc2VsZi5sb2cgfHwgY3JlYXRlRGVidWcubG9nO1xuXHRcdFx0bG9nRm4uYXBwbHkoc2VsZiwgYXJncyk7XG5cdFx0fVxuXG5cdFx0ZGVidWcubmFtZXNwYWNlID0gbmFtZXNwYWNlO1xuXHRcdGRlYnVnLnVzZUNvbG9ycyA9IGNyZWF0ZURlYnVnLnVzZUNvbG9ycygpO1xuXHRcdGRlYnVnLmNvbG9yID0gY3JlYXRlRGVidWcuc2VsZWN0Q29sb3IobmFtZXNwYWNlKTtcblx0XHRkZWJ1Zy5leHRlbmQgPSBleHRlbmQ7XG5cdFx0ZGVidWcuZGVzdHJveSA9IGNyZWF0ZURlYnVnLmRlc3Ryb3k7IC8vIFhYWCBUZW1wb3JhcnkuIFdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciByZWxlYXNlLlxuXG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGRlYnVnLCAnZW5hYmxlZCcsIHtcblx0XHRcdGVudW1lcmFibGU6IHRydWUsXG5cdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuXHRcdFx0Z2V0OiAoKSA9PiBlbmFibGVPdmVycmlkZSA9PT0gbnVsbCA/IGNyZWF0ZURlYnVnLmVuYWJsZWQobmFtZXNwYWNlKSA6IGVuYWJsZU92ZXJyaWRlLFxuXHRcdFx0c2V0OiB2ID0+IHtcblx0XHRcdFx0ZW5hYmxlT3ZlcnJpZGUgPSB2O1xuXHRcdFx0fVxuXHRcdH0pO1xuXG5cdFx0Ly8gRW52LXNwZWNpZmljIGluaXRpYWxpemF0aW9uIGxvZ2ljIGZvciBkZWJ1ZyBpbnN0YW5jZXNcblx0XHRpZiAodHlwZW9mIGNyZWF0ZURlYnVnLmluaXQgPT09ICdmdW5jdGlvbicpIHtcblx0XHRcdGNyZWF0ZURlYnVnLmluaXQoZGVidWcpO1xuXHRcdH1cblxuXHRcdHJldHVybiBkZWJ1Zztcblx0fVxuXG5cdGZ1bmN0aW9uIGV4dGVuZChuYW1lc3BhY2UsIGRlbGltaXRlcikge1xuXHRcdGNvbnN0IG5ld0RlYnVnID0gY3JlYXRlRGVidWcodGhpcy5uYW1lc3BhY2UgKyAodHlwZW9mIGRlbGltaXRlciA9PT0gJ3VuZGVmaW5lZCcgPyAnOicgOiBkZWxpbWl0ZXIpICsgbmFtZXNwYWNlKTtcblx0XHRuZXdEZWJ1Zy5sb2cgPSB0aGlzLmxvZztcblx0XHRyZXR1cm4gbmV3RGVidWc7XG5cdH1cblxuXHQvKipcblx0KiBFbmFibGVzIGEgZGVidWcgbW9kZSBieSBuYW1lc3BhY2VzLiBUaGlzIGNhbiBpbmNsdWRlIG1vZGVzXG5cdCogc2VwYXJhdGVkIGJ5IGEgY29sb24gYW5kIHdpbGRjYXJkcy5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZW5hYmxlKG5hbWVzcGFjZXMpIHtcblx0XHRjcmVhdGVEZWJ1Zy5zYXZlKG5hbWVzcGFjZXMpO1xuXG5cdFx0Y3JlYXRlRGVidWcubmFtZXMgPSBbXTtcblx0XHRjcmVhdGVEZWJ1Zy5za2lwcyA9IFtdO1xuXG5cdFx0bGV0IGk7XG5cdFx0Y29uc3Qgc3BsaXQgPSAodHlwZW9mIG5hbWVzcGFjZXMgPT09ICdzdHJpbmcnID8gbmFtZXNwYWNlcyA6ICcnKS5zcGxpdCgvW1xccyxdKy8pO1xuXHRcdGNvbnN0IGxlbiA9IHNwbGl0Lmxlbmd0aDtcblxuXHRcdGZvciAoaSA9IDA7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKCFzcGxpdFtpXSkge1xuXHRcdFx0XHQvLyBpZ25vcmUgZW1wdHkgc3RyaW5nc1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblxuXHRcdFx0bmFtZXNwYWNlcyA9IHNwbGl0W2ldLnJlcGxhY2UoL1xcKi9nLCAnLio/Jyk7XG5cblx0XHRcdGlmIChuYW1lc3BhY2VzWzBdID09PSAnLScpIHtcblx0XHRcdFx0Y3JlYXRlRGVidWcuc2tpcHMucHVzaChuZXcgUmVnRXhwKCdeJyArIG5hbWVzcGFjZXMuc3Vic3RyKDEpICsgJyQnKSk7XG5cdFx0XHR9IGVsc2Uge1xuXHRcdFx0XHRjcmVhdGVEZWJ1Zy5uYW1lcy5wdXNoKG5ldyBSZWdFeHAoJ14nICsgbmFtZXNwYWNlcyArICckJykpO1xuXHRcdFx0fVxuXHRcdH1cblx0fVxuXG5cdC8qKlxuXHQqIERpc2FibGUgZGVidWcgb3V0cHV0LlxuXHQqXG5cdCogQHJldHVybiB7U3RyaW5nfSBuYW1lc3BhY2VzXG5cdCogQGFwaSBwdWJsaWNcblx0Ki9cblx0ZnVuY3Rpb24gZGlzYWJsZSgpIHtcblx0XHRjb25zdCBuYW1lc3BhY2VzID0gW1xuXHRcdFx0Li4uY3JlYXRlRGVidWcubmFtZXMubWFwKHRvTmFtZXNwYWNlKSxcblx0XHRcdC4uLmNyZWF0ZURlYnVnLnNraXBzLm1hcCh0b05hbWVzcGFjZSkubWFwKG5hbWVzcGFjZSA9PiAnLScgKyBuYW1lc3BhY2UpXG5cdFx0XS5qb2luKCcsJyk7XG5cdFx0Y3JlYXRlRGVidWcuZW5hYmxlKCcnKTtcblx0XHRyZXR1cm4gbmFtZXNwYWNlcztcblx0fVxuXG5cdC8qKlxuXHQqIFJldHVybnMgdHJ1ZSBpZiB0aGUgZ2l2ZW4gbW9kZSBuYW1lIGlzIGVuYWJsZWQsIGZhbHNlIG90aGVyd2lzZS5cblx0KlxuXHQqIEBwYXJhbSB7U3RyaW5nfSBuYW1lXG5cdCogQHJldHVybiB7Qm9vbGVhbn1cblx0KiBAYXBpIHB1YmxpY1xuXHQqL1xuXHRmdW5jdGlvbiBlbmFibGVkKG5hbWUpIHtcblx0XHRpZiAobmFtZVtuYW1lLmxlbmd0aCAtIDFdID09PSAnKicpIHtcblx0XHRcdHJldHVybiB0cnVlO1xuXHRcdH1cblxuXHRcdGxldCBpO1xuXHRcdGxldCBsZW47XG5cblx0XHRmb3IgKGkgPSAwLCBsZW4gPSBjcmVhdGVEZWJ1Zy5za2lwcy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuXHRcdFx0aWYgKGNyZWF0ZURlYnVnLnNraXBzW2ldLnRlc3QobmFtZSkpIHtcblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXHRcdFx0fVxuXHRcdH1cblxuXHRcdGZvciAoaSA9IDAsIGxlbiA9IGNyZWF0ZURlYnVnLm5hbWVzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG5cdFx0XHRpZiAoY3JlYXRlRGVidWcubmFtZXNbaV0udGVzdChuYW1lKSkge1xuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblx0XHRcdH1cblx0XHR9XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cdH1cblxuXHQvKipcblx0KiBDb252ZXJ0IHJlZ2V4cCB0byBuYW1lc3BhY2Vcblx0KlxuXHQqIEBwYXJhbSB7UmVnRXhwfSByZWd4ZXBcblx0KiBAcmV0dXJuIHtTdHJpbmd9IG5hbWVzcGFjZVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiB0b05hbWVzcGFjZShyZWdleHApIHtcblx0XHRyZXR1cm4gcmVnZXhwLnRvU3RyaW5nKClcblx0XHRcdC5zdWJzdHJpbmcoMiwgcmVnZXhwLnRvU3RyaW5nKCkubGVuZ3RoIC0gMilcblx0XHRcdC5yZXBsYWNlKC9cXC5cXCpcXD8kLywgJyonKTtcblx0fVxuXG5cdC8qKlxuXHQqIENvZXJjZSBgdmFsYC5cblx0KlxuXHQqIEBwYXJhbSB7TWl4ZWR9IHZhbFxuXHQqIEByZXR1cm4ge01peGVkfVxuXHQqIEBhcGkgcHJpdmF0ZVxuXHQqL1xuXHRmdW5jdGlvbiBjb2VyY2UodmFsKSB7XG5cdFx0aWYgKHZhbCBpbnN0YW5jZW9mIEVycm9yKSB7XG5cdFx0XHRyZXR1cm4gdmFsLnN0YWNrIHx8IHZhbC5tZXNzYWdlO1xuXHRcdH1cblx0XHRyZXR1cm4gdmFsO1xuXHR9XG5cblx0LyoqXG5cdCogWFhYIERPIE5PVCBVU0UuIFRoaXMgaXMgYSB0ZW1wb3Jhcnkgc3R1YiBmdW5jdGlvbi5cblx0KiBYWFggSXQgV0lMTCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHJlbGVhc2UuXG5cdCovXG5cdGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG5cdFx0Y29uc29sZS53YXJuKCdJbnN0YW5jZSBtZXRob2QgYGRlYnVnLmRlc3Ryb3koKWAgaXMgZGVwcmVjYXRlZCBhbmQgbm8gbG9uZ2VyIGRvZXMgYW55dGhpbmcuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uIG9mIGBkZWJ1Z2AuJyk7XG5cdH1cblxuXHRjcmVhdGVEZWJ1Zy5lbmFibGUoY3JlYXRlRGVidWcubG9hZCgpKTtcblxuXHRyZXR1cm4gY3JlYXRlRGVidWc7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2V0dXA7XG4iLCIvKiFcbiAgKiBkb21yZWFkeSAoYykgRHVzdGluIERpYXogMjAxNCAtIExpY2Vuc2UgTUlUXG4gICovXG4hZnVuY3Rpb24gKG5hbWUsIGRlZmluaXRpb24pIHtcblxuICBpZiAodHlwZW9mIG1vZHVsZSAhPSAndW5kZWZpbmVkJykgbW9kdWxlLmV4cG9ydHMgPSBkZWZpbml0aW9uKClcbiAgZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBkZWZpbmUuYW1kID09ICdvYmplY3QnKSBkZWZpbmUoZGVmaW5pdGlvbilcbiAgZWxzZSB0aGlzW25hbWVdID0gZGVmaW5pdGlvbigpXG5cbn0oJ2RvbXJlYWR5JywgZnVuY3Rpb24gKCkge1xuXG4gIHZhciBmbnMgPSBbXSwgbGlzdGVuZXJcbiAgICAsIGRvYyA9IGRvY3VtZW50XG4gICAgLCBoYWNrID0gZG9jLmRvY3VtZW50RWxlbWVudC5kb1Njcm9sbFxuICAgICwgZG9tQ29udGVudExvYWRlZCA9ICdET01Db250ZW50TG9hZGVkJ1xuICAgICwgbG9hZGVkID0gKGhhY2sgPyAvXmxvYWRlZHxeYy8gOiAvXmxvYWRlZHxeaXxeYy8pLnRlc3QoZG9jLnJlYWR5U3RhdGUpXG5cblxuICBpZiAoIWxvYWRlZClcbiAgZG9jLmFkZEV2ZW50TGlzdGVuZXIoZG9tQ29udGVudExvYWRlZCwgbGlzdGVuZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgZG9jLnJlbW92ZUV2ZW50TGlzdGVuZXIoZG9tQ29udGVudExvYWRlZCwgbGlzdGVuZXIpXG4gICAgbG9hZGVkID0gMVxuICAgIHdoaWxlIChsaXN0ZW5lciA9IGZucy5zaGlmdCgpKSBsaXN0ZW5lcigpXG4gIH0pXG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChmbikge1xuICAgIGxvYWRlZCA/IHNldFRpbWVvdXQoZm4sIDApIDogZm5zLnB1c2goZm4pXG4gIH1cblxufSk7XG4iLCJ2YXIgbmFpdmVGYWxsYmFjayA9IGZ1bmN0aW9uICgpIHtcblx0aWYgKHR5cGVvZiBzZWxmID09PSBcIm9iamVjdFwiICYmIHNlbGYpIHJldHVybiBzZWxmO1xuXHRpZiAodHlwZW9mIHdpbmRvdyA9PT0gXCJvYmplY3RcIiAmJiB3aW5kb3cpIHJldHVybiB3aW5kb3c7XG5cdHRocm93IG5ldyBFcnJvcihcIlVuYWJsZSB0byByZXNvbHZlIGdsb2JhbCBgdGhpc2BcIik7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IChmdW5jdGlvbiAoKSB7XG5cdGlmICh0aGlzKSByZXR1cm4gdGhpcztcblxuXHQvLyBVbmV4cGVjdGVkIHN0cmljdCBtb2RlIChtYXkgaGFwcGVuIGlmIGUuZy4gYnVuZGxlZCBpbnRvIEVTTSBtb2R1bGUpXG5cblx0Ly8gRmFsbGJhY2sgdG8gc3RhbmRhcmQgZ2xvYmFsVGhpcyBpZiBhdmFpbGFibGVcblx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSBcIm9iamVjdFwiICYmIGdsb2JhbFRoaXMpIHJldHVybiBnbG9iYWxUaGlzO1xuXG5cdC8vIFRoYW5rcyBAbWF0aGlhc2J5bmVucyAtPiBodHRwczovL21hdGhpYXNieW5lbnMuYmUvbm90ZXMvZ2xvYmFsdGhpc1xuXHQvLyBJbiBhbGwgRVM1KyBlbmdpbmVzIGdsb2JhbCBvYmplY3QgaW5oZXJpdHMgZnJvbSBPYmplY3QucHJvdG90eXBlXG5cdC8vIChpZiB5b3UgYXBwcm9hY2hlZCBvbmUgdGhhdCBkb2Vzbid0IHBsZWFzZSByZXBvcnQpXG5cdHRyeSB7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KE9iamVjdC5wcm90b3R5cGUsIFwiX19nbG9iYWxfX1wiLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sXG5cdFx0XHRjb25maWd1cmFibGU6IHRydWVcblx0XHR9KTtcblx0fSBjYXRjaCAoZXJyb3IpIHtcblx0XHQvLyBVbmZvcnR1bmF0ZSBjYXNlIG9mIHVwZGF0ZXMgdG8gT2JqZWN0LnByb3RvdHlwZSBiZWluZyByZXN0cmljdGVkXG5cdFx0Ly8gdmlhIHByZXZlbnRFeHRlbnNpb25zLCBzZWFsIG9yIGZyZWV6ZVxuXHRcdHJldHVybiBuYWl2ZUZhbGxiYWNrKCk7XG5cdH1cblx0dHJ5IHtcblx0XHQvLyBTYWZhcmkgY2FzZSAod2luZG93Ll9fZ2xvYmFsX18gd29ya3MsIGJ1dCBfX2dsb2JhbF9fIGRvZXMgbm90KVxuXHRcdGlmICghX19nbG9iYWxfXykgcmV0dXJuIG5haXZlRmFsbGJhY2soKTtcblx0XHRyZXR1cm4gX19nbG9iYWxfXztcblx0fSBmaW5hbGx5IHtcblx0XHRkZWxldGUgT2JqZWN0LnByb3RvdHlwZS5fX2dsb2JhbF9fO1xuXHR9XG59KSgpO1xuIiwiY29uc3QgZGVidWcgPSByZXF1aXJlKCdkZWJ1ZycpKCdoMjY0LXByb2ZpbGUtbGV2ZWwtaWQnKTtcblxuLyogZXNsaW50LWRpc2FibGUgbm8tY29uc29sZSAqL1xuZGVidWcubG9nID0gY29uc29sZS5pbmZvLmJpbmQoY29uc29sZSk7XG4vKiBlc2xpbnQtZW5hYmxlIG5vLWNvbnNvbGUgKi9cblxuY29uc3QgUHJvZmlsZUNvbnN0cmFpbmVkQmFzZWxpbmUgPSAxO1xuY29uc3QgUHJvZmlsZUJhc2VsaW5lID0gMjtcbmNvbnN0IFByb2ZpbGVNYWluID0gMztcbmNvbnN0IFByb2ZpbGVDb25zdHJhaW5lZEhpZ2ggPSA0O1xuY29uc3QgUHJvZmlsZUhpZ2ggPSA1O1xuXG5leHBvcnRzLlByb2ZpbGVDb25zdHJhaW5lZEJhc2VsaW5lID0gUHJvZmlsZUNvbnN0cmFpbmVkQmFzZWxpbmU7XG5leHBvcnRzLlByb2ZpbGVCYXNlbGluZSA9IFByb2ZpbGVCYXNlbGluZTtcbmV4cG9ydHMuUHJvZmlsZU1haW4gPSBQcm9maWxlTWFpbjtcbmV4cG9ydHMuUHJvZmlsZUNvbnN0cmFpbmVkSGlnaCA9IFByb2ZpbGVDb25zdHJhaW5lZEhpZ2g7XG5leHBvcnRzLlByb2ZpbGVIaWdoID0gUHJvZmlsZUhpZ2g7XG5cbi8vIEFsbCB2YWx1ZXMgYXJlIGVxdWFsIHRvIHRlbiB0aW1lcyB0aGUgbGV2ZWwgbnVtYmVyLCBleGNlcHQgbGV2ZWwgMWIgd2hpY2ggaXNcbi8vIHNwZWNpYWwuXG5jb25zdCBMZXZlbDFfYiA9IDA7XG5jb25zdCBMZXZlbDEgPSAxMDtcbmNvbnN0IExldmVsMV8xID0gMTE7XG5jb25zdCBMZXZlbDFfMiA9IDEyO1xuY29uc3QgTGV2ZWwxXzMgPSAxMztcbmNvbnN0IExldmVsMiA9IDIwO1xuY29uc3QgTGV2ZWwyXzEgPSAyMTtcbmNvbnN0IExldmVsMl8yID0gMjI7XG5jb25zdCBMZXZlbDMgPSAzMDtcbmNvbnN0IExldmVsM18xID0gMzE7XG5jb25zdCBMZXZlbDNfMiA9IDMyO1xuY29uc3QgTGV2ZWw0ID0gNDA7XG5jb25zdCBMZXZlbDRfMSA9IDQxO1xuY29uc3QgTGV2ZWw0XzIgPSA0MjtcbmNvbnN0IExldmVsNSA9IDUwO1xuY29uc3QgTGV2ZWw1XzEgPSA1MTtcbmNvbnN0IExldmVsNV8yID0gNTI7XG5cbmV4cG9ydHMuTGV2ZWwxX2IgPSBMZXZlbDFfYjtcbmV4cG9ydHMuTGV2ZWwxID0gTGV2ZWwxO1xuZXhwb3J0cy5MZXZlbDFfMSA9IExldmVsMV8xO1xuZXhwb3J0cy5MZXZlbDFfMiA9IExldmVsMV8yO1xuZXhwb3J0cy5MZXZlbDFfMyA9IExldmVsMV8zO1xuZXhwb3J0cy5MZXZlbDIgPSBMZXZlbDI7XG5leHBvcnRzLkxldmVsMl8xID0gTGV2ZWwyXzE7XG5leHBvcnRzLkxldmVsMl8yID0gTGV2ZWwyXzI7XG5leHBvcnRzLkxldmVsMyA9IExldmVsMztcbmV4cG9ydHMuTGV2ZWwzXzEgPSBMZXZlbDNfMTtcbmV4cG9ydHMuTGV2ZWwzXzIgPSBMZXZlbDNfMjtcbmV4cG9ydHMuTGV2ZWw0ID0gTGV2ZWw0O1xuZXhwb3J0cy5MZXZlbDRfMSA9IExldmVsNF8xO1xuZXhwb3J0cy5MZXZlbDRfMiA9IExldmVsNF8yO1xuZXhwb3J0cy5MZXZlbDUgPSBMZXZlbDU7XG5leHBvcnRzLkxldmVsNV8xID0gTGV2ZWw1XzE7XG5leHBvcnRzLkxldmVsNV8yID0gTGV2ZWw1XzI7XG5cbmNsYXNzIFByb2ZpbGVMZXZlbElkXG57XG5cdGNvbnN0cnVjdG9yKHByb2ZpbGUsIGxldmVsKVxuXHR7XG5cdFx0dGhpcy5wcm9maWxlID0gcHJvZmlsZTtcblx0XHR0aGlzLmxldmVsID0gbGV2ZWw7XG5cdH1cbn1cblxuZXhwb3J0cy5Qcm9maWxlTGV2ZWxJZCA9IFByb2ZpbGVMZXZlbElkO1xuXG4vLyBEZWZhdWx0IFByb2ZpbGVMZXZlbElkLlxuLy9cbi8vIFRPRE86IFRoZSBkZWZhdWx0IHNob3VsZCByZWFsbHkgYmUgcHJvZmlsZSBCYXNlbGluZSBhbmQgbGV2ZWwgMSBhY2NvcmRpbmcgdG9cbi8vIHRoZSBzcGVjOiBodHRwczovL3Rvb2xzLmlldGYub3JnL2h0bWwvcmZjNjE4NCNzZWN0aW9uLTguMS4gSW4gb3JkZXIgdG8gbm90XG4vLyBicmVhayBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSB3aXRoIG9sZGVyIHZlcnNpb25zIG9mIFdlYlJUQyB3aGVyZSBleHRlcm5hbFxuLy8gY29kZWNzIGRvbid0IGhhdmUgYW55IHBhcmFtZXRlcnMsIHVzZSBwcm9maWxlIENvbnN0cmFpbmVkQmFzZWxpbmUgbGV2ZWwgM18xXG4vLyBpbnN0ZWFkLiBUaGlzIHdvcmthcm91bmQgd2lsbCBvbmx5IGJlIGRvbmUgaW4gYW4gaW50ZXJpbSBwZXJpb2QgdG8gYWxsb3dcbi8vIGV4dGVybmFsIGNsaWVudHMgdG8gdXBkYXRlIHRoZWlyIGNvZGUuXG4vL1xuLy8gaHR0cDovL2NyYnVnL3dlYnJ0Yy82MzM3LlxuY29uc3QgRGVmYXVsdFByb2ZpbGVMZXZlbElkID1cblx0bmV3IFByb2ZpbGVMZXZlbElkKFByb2ZpbGVDb25zdHJhaW5lZEJhc2VsaW5lLCBMZXZlbDNfMSk7XG5cbi8vIEZvciBsZXZlbF9pZGM9MTEgYW5kIHByb2ZpbGVfaWRjPTB4NDIsIDB4NEQsIG9yIDB4NTgsIHRoZSBjb25zdHJhaW50IHNldDNcbi8vIGZsYWcgc3BlY2lmaWVzIGlmIGxldmVsIDFiIG9yIGxldmVsIDEuMSBpcyB1c2VkLlxuY29uc3QgQ29uc3RyYWludFNldDNGbGFnID0gMHgxMDtcblxuLy8gQ2xhc3MgZm9yIG1hdGNoaW5nIGJpdCBwYXR0ZXJucyBzdWNoIGFzIFwieDF4eDAwMDBcIiB3aGVyZSAneCcgaXMgYWxsb3dlZCB0byBiZVxuLy8gZWl0aGVyIDAgb3IgMS5cbmNsYXNzIEJpdFBhdHRlcm5cbntcblx0Y29uc3RydWN0b3Ioc3RyKVxuXHR7XG5cdFx0dGhpcy5fbWFzayA9IH5ieXRlTWFza1N0cmluZygneCcsIHN0cik7XG5cdFx0dGhpcy5fbWFza2VkVmFsdWUgPSBieXRlTWFza1N0cmluZygnMScsIHN0cik7XG5cdH1cblxuXHRpc01hdGNoKHZhbHVlKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX21hc2tlZFZhbHVlID09PSAodmFsdWUgJiB0aGlzLl9tYXNrKTtcblx0fVxufVxuXG4vLyBDbGFzcyBmb3IgY29udmVydGluZyBiZXR3ZWVuIHByb2ZpbGVfaWRjL3Byb2ZpbGVfaW9wIHRvIFByb2ZpbGUuXG5jbGFzcyBQcm9maWxlUGF0dGVyblxue1xuXHRjb25zdHJ1Y3Rvcihwcm9maWxlX2lkYywgcHJvZmlsZV9pb3AsIHByb2ZpbGUpXG5cdHtcblx0XHR0aGlzLnByb2ZpbGVfaWRjID0gcHJvZmlsZV9pZGM7XG5cdFx0dGhpcy5wcm9maWxlX2lvcCA9IHByb2ZpbGVfaW9wO1xuXHRcdHRoaXMucHJvZmlsZSA9IHByb2ZpbGU7XG5cdH1cbn1cblxuLy8gVGhpcyBpcyBmcm9tIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9yZmM2MTg0I3NlY3Rpb24tOC4xLlxuY29uc3QgUHJvZmlsZVBhdHRlcm5zID1cbltcblx0bmV3IFByb2ZpbGVQYXR0ZXJuKDB4NDIsIG5ldyBCaXRQYXR0ZXJuKCd4MXh4MDAwMCcpLCBQcm9maWxlQ29uc3RyYWluZWRCYXNlbGluZSksXG5cdG5ldyBQcm9maWxlUGF0dGVybigweDRELCBuZXcgQml0UGF0dGVybignMXh4eDAwMDAnKSwgUHJvZmlsZUNvbnN0cmFpbmVkQmFzZWxpbmUpLFxuXHRuZXcgUHJvZmlsZVBhdHRlcm4oMHg1OCwgbmV3IEJpdFBhdHRlcm4oJzExeHgwMDAwJyksIFByb2ZpbGVDb25zdHJhaW5lZEJhc2VsaW5lKSxcblx0bmV3IFByb2ZpbGVQYXR0ZXJuKDB4NDIsIG5ldyBCaXRQYXR0ZXJuKCd4MHh4MDAwMCcpLCBQcm9maWxlQmFzZWxpbmUpLFxuXHRuZXcgUHJvZmlsZVBhdHRlcm4oMHg1OCwgbmV3IEJpdFBhdHRlcm4oJzEweHgwMDAwJyksIFByb2ZpbGVCYXNlbGluZSksXG5cdG5ldyBQcm9maWxlUGF0dGVybigweDRELCBuZXcgQml0UGF0dGVybignMHgweDAwMDAnKSwgUHJvZmlsZU1haW4pLFxuXHRuZXcgUHJvZmlsZVBhdHRlcm4oMHg2NCwgbmV3IEJpdFBhdHRlcm4oJzAwMDAwMDAwJyksIFByb2ZpbGVIaWdoKSxcblx0bmV3IFByb2ZpbGVQYXR0ZXJuKDB4NjQsIG5ldyBCaXRQYXR0ZXJuKCcwMDAwMTEwMCcpLCBQcm9maWxlQ29uc3RyYWluZWRIaWdoKVxuXTtcblxuLyoqXG4gKiBQYXJzZSBwcm9maWxlIGxldmVsIGlkIHRoYXQgaXMgcmVwcmVzZW50ZWQgYXMgYSBzdHJpbmcgb2YgMyBoZXggYnl0ZXMuXG4gKiBOb3RoaW5nIHdpbGwgYmUgcmV0dXJuZWQgaWYgdGhlIHN0cmluZyBpcyBub3QgYSByZWNvZ25pemVkIEgyNjQgcHJvZmlsZVxuICogbGV2ZWwgaWQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHN0ciAtIHByb2ZpbGUtbGV2ZWwtaWQgdmFsdWUgYXMgYSBzdHJpbmcgb2YgMyBoZXggYnl0ZXMuXG4gKlxuICogQHJldHVybnMge1Byb2ZpbGVMZXZlbElkfVxuICovXG5leHBvcnRzLnBhcnNlUHJvZmlsZUxldmVsSWQgPSBmdW5jdGlvbihzdHIpXG57XG5cdC8vIFRoZSBzdHJpbmcgc2hvdWxkIGNvbnNpc3Qgb2YgMyBieXRlcyBpbiBoZXhhZGVjaW1hbCBmb3JtYXQuXG5cdGlmICh0eXBlb2Ygc3RyICE9PSAnc3RyaW5nJyB8fCBzdHIubGVuZ3RoICE9PSA2KVxuXHRcdHJldHVybiBudWxsO1xuXG5cdGNvbnN0IHByb2ZpbGVfbGV2ZWxfaWRfbnVtZXJpYyA9IHBhcnNlSW50KHN0ciwgMTYpO1xuXG5cdGlmIChwcm9maWxlX2xldmVsX2lkX251bWVyaWMgPT09IDApXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0Ly8gU2VwYXJhdGUgaW50byB0aHJlZSBieXRlcy5cblx0Y29uc3QgbGV2ZWxfaWRjID0gcHJvZmlsZV9sZXZlbF9pZF9udW1lcmljICYgMHhGRjtcblx0Y29uc3QgcHJvZmlsZV9pb3AgPSAocHJvZmlsZV9sZXZlbF9pZF9udW1lcmljID4+IDgpICYgMHhGRjtcblx0Y29uc3QgcHJvZmlsZV9pZGMgPSAocHJvZmlsZV9sZXZlbF9pZF9udW1lcmljID4+IDE2KSAmIDB4RkY7XG5cblx0Ly8gUGFyc2UgbGV2ZWwgYmFzZWQgb24gbGV2ZWxfaWRjIGFuZCBjb25zdHJhaW50IHNldCAzIGZsYWcuXG5cdGxldCBsZXZlbDtcblxuXHRzd2l0Y2ggKGxldmVsX2lkYylcblx0e1xuXHRcdGNhc2UgTGV2ZWwxXzE6XG5cdFx0e1xuXHRcdFx0bGV2ZWwgPSAocHJvZmlsZV9pb3AgJiBDb25zdHJhaW50U2V0M0ZsYWcpICE9PSAwID8gTGV2ZWwxX2IgOiBMZXZlbDFfMTtcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRjYXNlIExldmVsMTpcblx0XHRjYXNlIExldmVsMV8yOlxuXHRcdGNhc2UgTGV2ZWwxXzM6XG5cdFx0Y2FzZSBMZXZlbDI6XG5cdFx0Y2FzZSBMZXZlbDJfMTpcblx0XHRjYXNlIExldmVsMl8yOlxuXHRcdGNhc2UgTGV2ZWwzOlxuXHRcdGNhc2UgTGV2ZWwzXzE6XG5cdFx0Y2FzZSBMZXZlbDNfMjpcblx0XHRjYXNlIExldmVsNDpcblx0XHRjYXNlIExldmVsNF8xOlxuXHRcdGNhc2UgTGV2ZWw0XzI6XG5cdFx0Y2FzZSBMZXZlbDU6XG5cdFx0Y2FzZSBMZXZlbDVfMTpcblx0XHRjYXNlIExldmVsNV8yOlxuXHRcdHtcblx0XHRcdGxldmVsID0gbGV2ZWxfaWRjO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdC8vIFVucmVjb2duaXplZCBsZXZlbF9pZGMuXG5cdFx0ZGVmYXVsdDpcblx0XHR7XG5cdFx0XHRkZWJ1ZygncGFyc2VQcm9maWxlTGV2ZWxJZCgpIHwgdW5yZWNvZ25pemVkIGxldmVsX2lkYzolcycsIGxldmVsX2lkYyk7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXG5cdC8vIFBhcnNlIHByb2ZpbGVfaWRjL3Byb2ZpbGVfaW9wIGludG8gYSBQcm9maWxlIGVudW0uXG5cdGZvciAoY29uc3QgcGF0dGVybiBvZiBQcm9maWxlUGF0dGVybnMpXG5cdHtcblx0XHRpZiAoXG5cdFx0XHRwcm9maWxlX2lkYyA9PT0gcGF0dGVybi5wcm9maWxlX2lkYyAmJlxuXHRcdFx0cGF0dGVybi5wcm9maWxlX2lvcC5pc01hdGNoKHByb2ZpbGVfaW9wKVxuXHRcdClcblx0XHR7XG5cdFx0XHRyZXR1cm4gbmV3IFByb2ZpbGVMZXZlbElkKHBhdHRlcm4ucHJvZmlsZSwgbGV2ZWwpO1xuXHRcdH1cblx0fVxuXG5cdGRlYnVnKCdwYXJzZVByb2ZpbGVMZXZlbElkKCkgfCB1bnJlY29nbml6ZWQgcHJvZmlsZV9pZGMvcHJvZmlsZV9pb3AgY29tYmluYXRpb24nKTtcblxuXHRyZXR1cm4gbnVsbDtcbn07XG5cbi8qKlxuICogUmV0dXJucyBjYW5vbmljYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uIGFzIHRocmVlIGhleCBieXRlcyBvZiB0aGUgcHJvZmlsZVxuICogbGV2ZWwgaWQsIG9yIHJldHVybnMgbm90aGluZyBmb3IgaW52YWxpZCBwcm9maWxlIGxldmVsIGlkcy5cbiAqXG4gKiBAcGFyYW0ge1Byb2ZpbGVMZXZlbElkfSBwcm9maWxlX2xldmVsX2lkXG4gKlxuICogQHJldHVybnMge1N0cmluZ31cbiAqL1xuZXhwb3J0cy5wcm9maWxlTGV2ZWxJZFRvU3RyaW5nID0gZnVuY3Rpb24ocHJvZmlsZV9sZXZlbF9pZClcbntcblx0Ly8gSGFuZGxlIHNwZWNpYWwgY2FzZSBsZXZlbCA9PSAxYi5cblx0aWYgKHByb2ZpbGVfbGV2ZWxfaWQubGV2ZWwgPT0gTGV2ZWwxX2IpXG5cdHtcblx0XHRzd2l0Y2ggKHByb2ZpbGVfbGV2ZWxfaWQucHJvZmlsZSlcblx0XHR7XG5cdFx0XHRjYXNlIFByb2ZpbGVDb25zdHJhaW5lZEJhc2VsaW5lOlxuXHRcdFx0e1xuXHRcdFx0XHRyZXR1cm4gJzQyZjAwYic7XG5cdFx0XHR9XG5cdFx0XHRjYXNlIFByb2ZpbGVCYXNlbGluZTpcblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuICc0MjEwMGInO1xuXHRcdFx0fVxuXHRcdFx0Y2FzZSBQcm9maWxlTWFpbjpcblx0XHRcdHtcblx0XHRcdFx0cmV0dXJuICc0ZDEwMGInO1xuXHRcdFx0fVxuXHRcdFx0Ly8gTGV2ZWwgMV9iIGlzIG5vdCBhbGxvd2VkIGZvciBvdGhlciBwcm9maWxlcy5cblx0XHRcdGRlZmF1bHQ6XG5cdFx0XHR7XG5cdFx0XHRcdGRlYnVnKFxuXHRcdFx0XHRcdCdwcm9maWxlTGV2ZWxJZFRvU3RyaW5nKCkgfCBMZXZlbCAxX2Igbm90IGlzIGFsbG93ZWQgZm9yIHByb2ZpbGU6JXMnLFxuXHRcdFx0XHRcdHByb2ZpbGVfbGV2ZWxfaWQucHJvZmlsZSk7XG5cblx0XHRcdFx0cmV0dXJuIG51bGw7XG5cdFx0XHR9XG5cdFx0fVxuXHR9XG5cblx0bGV0IHByb2ZpbGVfaWRjX2lvcF9zdHJpbmc7XG5cblx0c3dpdGNoIChwcm9maWxlX2xldmVsX2lkLnByb2ZpbGUpXG5cdHtcblx0XHRjYXNlIFByb2ZpbGVDb25zdHJhaW5lZEJhc2VsaW5lOlxuXHRcdHtcblx0XHRcdHByb2ZpbGVfaWRjX2lvcF9zdHJpbmcgPSAnNDJlMCc7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0Y2FzZSBQcm9maWxlQmFzZWxpbmU6XG5cdFx0e1xuXHRcdFx0cHJvZmlsZV9pZGNfaW9wX3N0cmluZyA9ICc0MjAwJztcblx0XHRcdGJyZWFrO1xuXHRcdH1cblx0XHRjYXNlIFByb2ZpbGVNYWluOlxuXHRcdHtcblx0XHRcdHByb2ZpbGVfaWRjX2lvcF9zdHJpbmcgPSAnNGQwMCc7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0Y2FzZSBQcm9maWxlQ29uc3RyYWluZWRIaWdoOlxuXHRcdHtcblx0XHRcdHByb2ZpbGVfaWRjX2lvcF9zdHJpbmcgPSAnNjQwYyc7XG5cdFx0XHRicmVhaztcblx0XHR9XG5cdFx0Y2FzZSBQcm9maWxlSGlnaDpcblx0XHR7XG5cdFx0XHRwcm9maWxlX2lkY19pb3Bfc3RyaW5nID0gJzY0MDAnO1xuXHRcdFx0YnJlYWs7XG5cdFx0fVxuXHRcdGRlZmF1bHQ6XG5cdFx0e1xuXHRcdFx0ZGVidWcoXG5cdFx0XHRcdCdwcm9maWxlTGV2ZWxJZFRvU3RyaW5nKCkgfCB1bnJlY29nbml6ZWQgcHJvZmlsZTolcycsXG5cdFx0XHRcdHByb2ZpbGVfbGV2ZWxfaWQucHJvZmlsZSk7XG5cblx0XHRcdHJldHVybiBudWxsO1xuXHRcdH1cblx0fVxuXG5cdGxldCBsZXZlbFN0ciA9IChwcm9maWxlX2xldmVsX2lkLmxldmVsKS50b1N0cmluZygxNik7XG5cblx0aWYgKGxldmVsU3RyLmxlbmd0aCA9PT0gMSlcblx0XHRsZXZlbFN0ciA9IGAwJHtsZXZlbFN0cn1gO1xuXG5cdHJldHVybiBgJHtwcm9maWxlX2lkY19pb3Bfc3RyaW5nfSR7bGV2ZWxTdHJ9YDtcbn07XG5cbi8qKlxuICogUGFyc2UgcHJvZmlsZSBsZXZlbCBpZCB0aGF0IGlzIHJlcHJlc2VudGVkIGFzIGEgc3RyaW5nIG9mIDMgaGV4IGJ5dGVzXG4gKiBjb250YWluZWQgaW4gYW4gU0RQIGtleS12YWx1ZSBtYXAuIEEgZGVmYXVsdCBwcm9maWxlIGxldmVsIGlkIHdpbGwgYmVcbiAqIHJldHVybmVkIGlmIHRoZSBwcm9maWxlLWxldmVsLWlkIGtleSBpcyBtaXNzaW5nLiBOb3RoaW5nIHdpbGwgYmUgcmV0dXJuZWQgaWZcbiAqIHRoZSBrZXkgaXMgcHJlc2VudCBidXQgdGhlIHN0cmluZyBpcyBpbnZhbGlkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcGFyYW1zPXt9XSAtIENvZGVjIHBhcmFtZXRlcnMgb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIHtQcm9maWxlTGV2ZWxJZH1cbiAqL1xuZXhwb3J0cy5wYXJzZVNkcFByb2ZpbGVMZXZlbElkID0gZnVuY3Rpb24ocGFyYW1zID0ge30pXG57XG5cdGNvbnN0IHByb2ZpbGVfbGV2ZWxfaWQgPSBwYXJhbXNbJ3Byb2ZpbGUtbGV2ZWwtaWQnXTtcblxuXHRyZXR1cm4gIXByb2ZpbGVfbGV2ZWxfaWRcblx0XHQ/IERlZmF1bHRQcm9maWxlTGV2ZWxJZFxuXHRcdDogZXhwb3J0cy5wYXJzZVByb2ZpbGVMZXZlbElkKHByb2ZpbGVfbGV2ZWxfaWQpO1xufTtcblxuLyoqXG4gKiBSZXR1cm5zIHRydWUgaWYgdGhlIHBhcmFtZXRlcnMgaGF2ZSB0aGUgc2FtZSBIMjY0IHByb2ZpbGUsIGkuZS4gdGhlIHNhbWVcbiAqIEgyNjQgcHJvZmlsZSAoQmFzZWxpbmUsIEhpZ2gsIGV0YykuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXMxPXt9XSAtIENvZGVjIHBhcmFtZXRlcnMgb2JqZWN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtwYXJhbXMyPXt9XSAtIENvZGVjIHBhcmFtZXRlcnMgb2JqZWN0LlxuICpcbiAqIEByZXR1cm5zIHtCb29sZWFufVxuICovXG5leHBvcnRzLmlzU2FtZVByb2ZpbGUgPSBmdW5jdGlvbihwYXJhbXMxID0ge30sIHBhcmFtczIgPSB7fSlcbntcblx0Y29uc3QgcHJvZmlsZV9sZXZlbF9pZF8xID0gZXhwb3J0cy5wYXJzZVNkcFByb2ZpbGVMZXZlbElkKHBhcmFtczEpO1xuXHRjb25zdCBwcm9maWxlX2xldmVsX2lkXzIgPSBleHBvcnRzLnBhcnNlU2RwUHJvZmlsZUxldmVsSWQocGFyYW1zMik7XG5cblx0Ly8gQ29tcGFyZSBIMjY0IHByb2ZpbGVzLCBidXQgbm90IGxldmVscy5cblx0cmV0dXJuIEJvb2xlYW4oXG5cdFx0cHJvZmlsZV9sZXZlbF9pZF8xICYmXG5cdFx0cHJvZmlsZV9sZXZlbF9pZF8yICYmXG5cdFx0cHJvZmlsZV9sZXZlbF9pZF8xLnByb2ZpbGUgPT09IHByb2ZpbGVfbGV2ZWxfaWRfMi5wcm9maWxlXG5cdCk7XG59O1xuXG4vKipcbiAqIEdlbmVyYXRlIGNvZGVjIHBhcmFtZXRlcnMgdGhhdCB3aWxsIGJlIHVzZWQgYXMgYW5zd2VyIGluIGFuIFNEUCBuZWdvdGlhdGlvblxuICogYmFzZWQgb24gbG9jYWwgc3VwcG9ydGVkIHBhcmFtZXRlcnMgYW5kIHJlbW90ZSBvZmZlcmVkIHBhcmFtZXRlcnMuIEJvdGhcbiAqIGxvY2FsX3N1cHBvcnRlZF9wYXJhbXMgYW5kIHJlbW90ZV9vZmZlcmVkX3BhcmFtcyByZXByZXNlbnQgc2VuZHJlY3YgbWVkaWFcbiAqIGRlc2NyaXB0aW9ucywgaS5lIHRoZXkgYXJlIGEgbWl4IG9mIGJvdGggZW5jb2RlIGFuZCBkZWNvZGUgY2FwYWJpbGl0aWVzLiBJblxuICogdGhlb3J5LCB3aGVuIHRoZSBwcm9maWxlIGluIGxvY2FsX3N1cHBvcnRlZF9wYXJhbXMgcmVwcmVzZW50IGEgc3RyaWN0IHN1cGVyc2V0XG4gKiBvZiB0aGUgcHJvZmlsZSBpbiByZW1vdGVfb2ZmZXJlZF9wYXJhbXMsIHdlIGNvdWxkIGxpbWl0IHRoZSBwcm9maWxlIGluIHRoZVxuICogYW5zd2VyIHRvIHRoZSBwcm9maWxlIGluIHJlbW90ZV9vZmZlcmVkX3BhcmFtcy5cbiAqXG4gKiBIb3dldmVyLCB0byBzaW1wbGlmeSB0aGUgY29kZSwgZWFjaCBzdXBwb3J0ZWQgSDI2NCBwcm9maWxlIHNob3VsZCBiZSBsaXN0ZWRcbiAqIGV4cGxpY2l0bHkgaW4gdGhlIGxpc3Qgb2YgbG9jYWwgc3VwcG9ydGVkIGNvZGVjcywgZXZlbiBpZiB0aGV5IGFyZSByZWR1bmRhbnQuXG4gKiBUaGVuIGVhY2ggbG9jYWwgY29kZWMgaW4gdGhlIGxpc3Qgc2hvdWxkIGJlIHRlc3RlZCBvbmUgYXQgYSB0aW1lIGFnYWluc3QgdGhlXG4gKiByZW1vdGUgY29kZWMsIGFuZCBvbmx5IHdoZW4gdGhlIHByb2ZpbGVzIGFyZSBlcXVhbCBzaG91bGQgdGhpcyBmdW5jdGlvbiBiZVxuICogY2FsbGVkLiBUaGVyZWZvcmUsIHRoaXMgZnVuY3Rpb24gZG9lcyBub3QgbmVlZCB0byBoYW5kbGUgcHJvZmlsZSBpbnRlcnNlY3Rpb24sXG4gKiBhbmQgdGhlIHByb2ZpbGUgb2YgbG9jYWxfc3VwcG9ydGVkX3BhcmFtcyBhbmQgcmVtb3RlX29mZmVyZWRfcGFyYW1zIG11c3QgYmVcbiAqIGVxdWFsIGJlZm9yZSBjYWxsaW5nIHRoaXMgZnVuY3Rpb24uIFRoZSBwYXJhbWV0ZXJzIHRoYXQgYXJlIHVzZWQgd2hlblxuICogbmVnb3RpYXRpbmcgYXJlIHRoZSBsZXZlbCBwYXJ0IG9mIHByb2ZpbGUtbGV2ZWwtaWQgYW5kIGxldmVsLWFzeW1tZXRyeS1hbGxvd2VkLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBbbG9jYWxfc3VwcG9ydGVkX3BhcmFtcz17fV1cbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVtb3RlX29mZmVyZWRfcGFyYW1zPXt9XVxuICpcbiAqIEByZXR1cm5zIHtTdHJpbmd9IENhbm9uaWNhbCBzdHJpbmcgcmVwcmVzZW50YXRpb24gYXMgdGhyZWUgaGV4IGJ5dGVzIG9mIHRoZVxuICogICBwcm9maWxlIGxldmVsIGlkLCBvciBudWxsIGlmIG5vIG9uZSBvZiB0aGUgcGFyYW1zIGhhdmUgcHJvZmlsZS1sZXZlbC1pZC5cbiAqXG4gKiBAdGhyb3dzIHtUeXBlRXJyb3J9IElmIFByb2ZpbGUgbWlzbWF0Y2ggb3IgaW52YWxpZCBwYXJhbXMuXG4gKi9cbmV4cG9ydHMuZ2VuZXJhdGVQcm9maWxlTGV2ZWxJZEZvckFuc3dlciA9IGZ1bmN0aW9uKFxuXHRsb2NhbF9zdXBwb3J0ZWRfcGFyYW1zID0ge30sXG5cdHJlbW90ZV9vZmZlcmVkX3BhcmFtcyA9IHt9XG4pXG57XG5cdC8vIElmIGJvdGggbG9jYWwgYW5kIHJlbW90ZSBwYXJhbXMgZG8gbm90IGNvbnRhaW4gcHJvZmlsZS1sZXZlbC1pZCwgdGhleSBhcmVcblx0Ly8gYm90aCB1c2luZyB0aGUgZGVmYXVsdCBwcm9maWxlLiBJbiB0aGlzIGNhc2UsIGRvbid0IHJldHVybiBhbnl0aGluZy5cblx0aWYgKFxuXHRcdCFsb2NhbF9zdXBwb3J0ZWRfcGFyYW1zWydwcm9maWxlLWxldmVsLWlkJ10gJiZcblx0XHQhcmVtb3RlX29mZmVyZWRfcGFyYW1zWydwcm9maWxlLWxldmVsLWlkJ11cblx0KVxuXHR7XG5cdFx0ZGVidWcoXG5cdFx0XHQnZ2VuZXJhdGVQcm9maWxlTGV2ZWxJZEZvckFuc3dlcigpIHwgbm8gcHJvZmlsZS1sZXZlbC1pZCBpbiBsb2NhbCBhbmQgcmVtb3RlIHBhcmFtcycpO1xuXG5cdFx0cmV0dXJuIG51bGw7XG5cdH1cblxuXHQvLyBQYXJzZSBwcm9maWxlLWxldmVsLWlkcy5cblx0Y29uc3QgbG9jYWxfcHJvZmlsZV9sZXZlbF9pZCA9XG5cdFx0ZXhwb3J0cy5wYXJzZVNkcFByb2ZpbGVMZXZlbElkKGxvY2FsX3N1cHBvcnRlZF9wYXJhbXMpO1xuXHRjb25zdCByZW1vdGVfcHJvZmlsZV9sZXZlbF9pZCA9XG5cdFx0ZXhwb3J0cy5wYXJzZVNkcFByb2ZpbGVMZXZlbElkKHJlbW90ZV9vZmZlcmVkX3BhcmFtcyk7XG5cblx0Ly8gVGhlIGxvY2FsIGFuZCByZW1vdGUgY29kZWMgbXVzdCBoYXZlIHZhbGlkIGFuZCBlcXVhbCBIMjY0IFByb2ZpbGVzLlxuXHRpZiAoIWxvY2FsX3Byb2ZpbGVfbGV2ZWxfaWQpXG5cdFx0dGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBsb2NhbF9wcm9maWxlX2xldmVsX2lkJyk7XG5cblx0aWYgKCFyZW1vdGVfcHJvZmlsZV9sZXZlbF9pZClcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHJlbW90ZV9wcm9maWxlX2xldmVsX2lkJyk7XG5cblx0aWYgKGxvY2FsX3Byb2ZpbGVfbGV2ZWxfaWQucHJvZmlsZSAhPT0gcmVtb3RlX3Byb2ZpbGVfbGV2ZWxfaWQucHJvZmlsZSlcblx0XHR0aHJvdyBuZXcgVHlwZUVycm9yKCdIMjY0IFByb2ZpbGUgbWlzbWF0Y2gnKTtcblxuXHQvLyBQYXJzZSBsZXZlbCBpbmZvcm1hdGlvbi5cblx0Y29uc3QgbGV2ZWxfYXN5bW1ldHJ5X2FsbG93ZWQgPSAoXG5cdFx0aXNMZXZlbEFzeW1tZXRyeUFsbG93ZWQobG9jYWxfc3VwcG9ydGVkX3BhcmFtcykgJiZcblx0XHRpc0xldmVsQXN5bW1ldHJ5QWxsb3dlZChyZW1vdGVfb2ZmZXJlZF9wYXJhbXMpXG5cdCk7XG5cblx0Y29uc3QgbG9jYWxfbGV2ZWwgPSBsb2NhbF9wcm9maWxlX2xldmVsX2lkLmxldmVsO1xuXHRjb25zdCByZW1vdGVfbGV2ZWwgPSByZW1vdGVfcHJvZmlsZV9sZXZlbF9pZC5sZXZlbDtcblx0Y29uc3QgbWluX2xldmVsID0gbWluTGV2ZWwobG9jYWxfbGV2ZWwsIHJlbW90ZV9sZXZlbCk7XG5cblx0Ly8gRGV0ZXJtaW5lIGFuc3dlciBsZXZlbC4gV2hlbiBsZXZlbCBhc3ltbWV0cnkgaXMgbm90IGFsbG93ZWQsIGxldmVsIHVwZ3JhZGVcblx0Ly8gaXMgbm90IGFsbG93ZWQsIGkuZS4sIHRoZSBsZXZlbCBpbiB0aGUgYW5zd2VyIG11c3QgYmUgZXF1YWwgdG8gb3IgbG93ZXJcblx0Ly8gdGhhbiB0aGUgbGV2ZWwgaW4gdGhlIG9mZmVyLlxuXHRjb25zdCBhbnN3ZXJfbGV2ZWwgPSBsZXZlbF9hc3ltbWV0cnlfYWxsb3dlZCA/IGxvY2FsX2xldmVsIDogbWluX2xldmVsO1xuXG5cdGRlYnVnKFxuXHRcdCdnZW5lcmF0ZVByb2ZpbGVMZXZlbElkRm9yQW5zd2VyKCkgfCByZXN1bHQ6IFtwcm9maWxlOiVzLCBsZXZlbDolc10nLFxuXHRcdGxvY2FsX3Byb2ZpbGVfbGV2ZWxfaWQucHJvZmlsZSwgYW5zd2VyX2xldmVsKTtcblxuXHQvLyBSZXR1cm4gdGhlIHJlc3VsdGluZyBwcm9maWxlLWxldmVsLWlkIGZvciB0aGUgYW5zd2VyIHBhcmFtZXRlcnMuXG5cdHJldHVybiBleHBvcnRzLnByb2ZpbGVMZXZlbElkVG9TdHJpbmcoXG5cdFx0bmV3IFByb2ZpbGVMZXZlbElkKGxvY2FsX3Byb2ZpbGVfbGV2ZWxfaWQucHJvZmlsZSwgYW5zd2VyX2xldmVsKSk7XG59O1xuXG4vLyBDb252ZXJ0IGEgc3RyaW5nIG9mIDggY2hhcmFjdGVycyBpbnRvIGEgYnl0ZSB3aGVyZSB0aGUgcG9zaXRpb25zIGNvbnRhaW5pbmdcbi8vIGNoYXJhY3RlciBjIHdpbGwgaGF2ZSB0aGVpciBiaXQgc2V0LiBGb3IgZXhhbXBsZSwgYyA9ICd4Jywgc3RyID0gXCJ4MXh4MDAwMFwiXG4vLyB3aWxsIHJldHVybiAwYjEwMTEwMDAwLlxuZnVuY3Rpb24gYnl0ZU1hc2tTdHJpbmcoYywgc3RyKVxue1xuXHRyZXR1cm4gKFxuXHRcdCgoc3RyWzBdID09PSBjKSA8PCA3KSB8ICgoc3RyWzFdID09PSBjKSA8PCA2KSB8ICgoc3RyWzJdID09PSBjKSA8PCA1KSB8XG5cdFx0KChzdHJbM10gPT09IGMpIDw8IDQpXHR8ICgoc3RyWzRdID09PSBjKSA8PCAzKVx0fCAoKHN0cls1XSA9PT0gYykgPDwgMilcdHxcblx0XHQoKHN0cls2XSA9PT0gYykgPDwgMSlcdHwgKChzdHJbN10gPT09IGMpIDw8IDApXG5cdCk7XG59XG5cbi8vIENvbXBhcmUgSDI2NCBsZXZlbHMgYW5kIGhhbmRsZSB0aGUgbGV2ZWwgMWIgY2FzZS5cbmZ1bmN0aW9uIGlzTGVzc0xldmVsKGEsIGIpXG57XG5cdGlmIChhID09PSBMZXZlbDFfYilcblx0XHRyZXR1cm4gYiAhPT0gTGV2ZWwxICYmIGIgIT09IExldmVsMV9iO1xuXG5cdGlmIChiID09PSBMZXZlbDFfYilcblx0XHRyZXR1cm4gYSAhPT0gTGV2ZWwxO1xuXG5cdHJldHVybiBhIDwgYjtcbn1cblxuZnVuY3Rpb24gbWluTGV2ZWwoYSwgYilcbntcblx0cmV0dXJuIGlzTGVzc0xldmVsKGEsIGIpID8gYSA6IGI7XG59XG5cbmZ1bmN0aW9uIGlzTGV2ZWxBc3ltbWV0cnlBbGxvd2VkKHBhcmFtcyA9IHt9KVxue1xuXHRjb25zdCBsZXZlbF9hc3ltbWV0cnlfYWxsb3dlZCA9IHBhcmFtc1snbGV2ZWwtYXN5bW1ldHJ5LWFsbG93ZWQnXTtcblxuXHRyZXR1cm4gKFxuXHRcdGxldmVsX2FzeW1tZXRyeV9hbGxvd2VkID09PSAxIHx8XG5cdFx0bGV2ZWxfYXN5bW1ldHJ5X2FsbG93ZWQgPT09ICcxJ1xuXHQpO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNvbnN1bWVyID0gdm9pZCAwO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XG5jb25zdCBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xID0gcmVxdWlyZShcIi4vRW5oYW5jZWRFdmVudEVtaXR0ZXJcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ0NvbnN1bWVyJyk7XG5jbGFzcyBDb25zdW1lciBleHRlbmRzIEVuaGFuY2VkRXZlbnRFbWl0dGVyXzEuRW5oYW5jZWRFdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIEBlbWl0cyB0cmFuc3BvcnRjbG9zZVxuICAgICAqIEBlbWl0cyB0cmFja2VuZGVkXG4gICAgICogQGVtaXRzIEBnZXRzdGF0c1xuICAgICAqIEBlbWl0cyBAY2xvc2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGlkLCBsb2NhbElkLCBwcm9kdWNlcklkLCBydHBSZWNlaXZlciwgdHJhY2ssIHJ0cFBhcmFtZXRlcnMsIGFwcERhdGEgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBDbG9zZWQgZmxhZy5cbiAgICAgICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIC8vIE9ic2VydmVyIGluc3RhbmNlLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xLkVuaGFuY2VkRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKScpO1xuICAgICAgICB0aGlzLl9pZCA9IGlkO1xuICAgICAgICB0aGlzLl9sb2NhbElkID0gbG9jYWxJZDtcbiAgICAgICAgdGhpcy5fcHJvZHVjZXJJZCA9IHByb2R1Y2VySWQ7XG4gICAgICAgIHRoaXMuX3J0cFJlY2VpdmVyID0gcnRwUmVjZWl2ZXI7XG4gICAgICAgIHRoaXMuX3RyYWNrID0gdHJhY2s7XG4gICAgICAgIHRoaXMuX3J0cFBhcmFtZXRlcnMgPSBydHBQYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLl9wYXVzZWQgPSAhdHJhY2suZW5hYmxlZDtcbiAgICAgICAgdGhpcy5fYXBwRGF0YSA9IGFwcERhdGE7XG4gICAgICAgIHRoaXMuX29uVHJhY2tFbmRlZCA9IHRoaXMuX29uVHJhY2tFbmRlZC5iaW5kKHRoaXMpO1xuICAgICAgICB0aGlzLl9oYW5kbGVUcmFjaygpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25zdW1lciBpZC5cbiAgICAgKi9cbiAgICBnZXQgaWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9pZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogTG9jYWwgaWQuXG4gICAgICovXG4gICAgZ2V0IGxvY2FsSWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9sb2NhbElkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NvY2lhdGVkIFByb2R1Y2VyIGlkLlxuICAgICAqL1xuICAgIGdldCBwcm9kdWNlcklkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcHJvZHVjZXJJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgQ29uc3VtZXIgaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1lZGlhIGtpbmQuXG4gICAgICovXG4gICAgZ2V0IGtpbmQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFjay5raW5kO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NvY2lhdGVkIFJUQ1J0cFJlY2VpdmVyLlxuICAgICAqL1xuICAgIGdldCBydHBSZWNlaXZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J0cFJlY2VpdmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUaGUgYXNzb2NpYXRlZCB0cmFjay5cbiAgICAgKi9cbiAgICBnZXQgdHJhY2soKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl90cmFjaztcbiAgICB9XG4gICAgLyoqXG4gICAgICogUlRQIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgZ2V0IHJ0cFBhcmFtZXRlcnMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9ydHBQYXJhbWV0ZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBDb25zdW1lciBpcyBwYXVzZWQuXG4gICAgICovXG4gICAgZ2V0IHBhdXNlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BhdXNlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwIGN1c3RvbSBkYXRhLlxuICAgICAqL1xuICAgIGdldCBhcHBEYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwRGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52YWxpZCBzZXR0ZXIuXG4gICAgICovXG4gICAgc2V0IGFwcERhdGEoYXBwRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBvdmVycmlkZSBhcHBEYXRhIG9iamVjdCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKlxuICAgICAqIEBlbWl0cyBjbG9zZVxuICAgICAqIEBlbWl0cyBwYXVzZVxuICAgICAqIEBlbWl0cyByZXN1bWVcbiAgICAgKiBAZW1pdHMgdHJhY2tlbmRlZFxuICAgICAqL1xuICAgIGdldCBvYnNlcnZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29ic2VydmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIENvbnN1bWVyLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGVzdHJveVRyYWNrKCk7XG4gICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCdjbG9zZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgd2FzIGNsb3NlZC5cbiAgICAgKi9cbiAgICB0cmFuc3BvcnRDbG9zZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndHJhbnNwb3J0Q2xvc2VkKCknKTtcbiAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGVzdHJveVRyYWNrKCk7XG4gICAgICAgIHRoaXMuc2FmZUVtaXQoJ3RyYW5zcG9ydGNsb3NlJyk7XG4gICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCdjbG9zZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZXQgYXNzb2NpYXRlZCBSVENSdHBSZWNlaXZlciBzdGF0cy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTdGF0cygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignY2xvc2VkJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVFbWl0QXNQcm9taXNlKCdAZ2V0c3RhdHMnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2VzIHJlY2VpdmluZyBtZWRpYS5cbiAgICAgKi9cbiAgICBwYXVzZSgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdwYXVzZSgpJyk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcigncGF1c2UoKSB8IENvbnN1bWVyIGNsb3NlZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX3RyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ3BhdXNlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgcmVjZWl2aW5nIG1lZGlhLlxuICAgICAqL1xuICAgIHJlc3VtZSgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN1bWUoKScpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ3Jlc3VtZSgpIHwgQ29uc3VtZXIgY2xvc2VkJyk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuX3RyYWNrLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAvLyBFbWl0IG9ic2VydmVyIGV2ZW50LlxuICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgncmVzdW1lJyk7XG4gICAgfVxuICAgIF9vblRyYWNrRW5kZWQoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndHJhY2sgXCJlbmRlZFwiIGV2ZW50Jyk7XG4gICAgICAgIHRoaXMuc2FmZUVtaXQoJ3RyYWNrZW5kZWQnKTtcbiAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ3RyYWNrZW5kZWQnKTtcbiAgICB9XG4gICAgX2hhbmRsZVRyYWNrKCkge1xuICAgICAgICB0aGlzLl90cmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuX29uVHJhY2tFbmRlZCk7XG4gICAgfVxuICAgIF9kZXN0cm95VHJhY2soKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl90cmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuX29uVHJhY2tFbmRlZCk7XG4gICAgICAgICAgICB0aGlzLl90cmFjay5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICB9XG59XG5leHBvcnRzLkNvbnN1bWVyID0gQ29uc3VtZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGF0YUNvbnN1bWVyID0gdm9pZCAwO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XG5jb25zdCBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xID0gcmVxdWlyZShcIi4vRW5oYW5jZWRFdmVudEVtaXR0ZXJcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdEYXRhQ29uc3VtZXInKTtcbmNsYXNzIERhdGFDb25zdW1lciBleHRlbmRzIEVuaGFuY2VkRXZlbnRFbWl0dGVyXzEuRW5oYW5jZWRFdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIEBlbWl0cyB0cmFuc3BvcnRjbG9zZVxuICAgICAqIEBlbWl0cyBvcGVuXG4gICAgICogQGVtaXRzIGVycm9yIC0gKGVycm9yOiBFcnJvcilcbiAgICAgKiBAZW1pdHMgY2xvc2VcbiAgICAgKiBAZW1pdHMgbWVzc2FnZSAtIChtZXNzYWdlOiBhbnkpXG4gICAgICogQGVtaXRzIEBjbG9zZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgaWQsIGRhdGFQcm9kdWNlcklkLCBkYXRhQ2hhbm5lbCwgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGFwcERhdGEgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBDbG9zZWQgZmxhZy5cbiAgICAgICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIC8vIE9ic2VydmVyIGluc3RhbmNlLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xLkVuaGFuY2VkRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKScpO1xuICAgICAgICB0aGlzLl9pZCA9IGlkO1xuICAgICAgICB0aGlzLl9kYXRhUHJvZHVjZXJJZCA9IGRhdGFQcm9kdWNlcklkO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbCA9IGRhdGFDaGFubmVsO1xuICAgICAgICB0aGlzLl9zY3RwU3RyZWFtUGFyYW1ldGVycyA9IHNjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLl9hcHBEYXRhID0gYXBwRGF0YTtcbiAgICAgICAgdGhpcy5faGFuZGxlRGF0YUNoYW5uZWwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGF0YUNvbnN1bWVyIGlkLlxuICAgICAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBc3NvY2lhdGVkIERhdGFQcm9kdWNlciBpZC5cbiAgICAgKi9cbiAgICBnZXQgZGF0YVByb2R1Y2VySWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhUHJvZHVjZXJJZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgRGF0YUNvbnN1bWVyIGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTQ1RQIHN0cmVhbSBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIGdldCBzY3RwU3RyZWFtUGFyYW1ldGVycygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3NjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEYXRhQ2hhbm5lbCByZWFkeVN0YXRlLlxuICAgICAqL1xuICAgIGdldCByZWFkeVN0YXRlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUNoYW5uZWwucmVhZHlTdGF0ZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGF0YUNoYW5uZWwgbGFiZWwuXG4gICAgICovXG4gICAgZ2V0IGxhYmVsKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUNoYW5uZWwubGFiZWw7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERhdGFDaGFubmVsIHByb3RvY29sLlxuICAgICAqL1xuICAgIGdldCBwcm90b2NvbCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFDaGFubmVsLnByb3RvY29sO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEYXRhQ2hhbm5lbCBiaW5hcnlUeXBlLlxuICAgICAqL1xuICAgIGdldCBiaW5hcnlUeXBlKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUNoYW5uZWwuYmluYXJ5VHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IERhdGFDaGFubmVsIGJpbmFyeVR5cGUuXG4gICAgICovXG4gICAgc2V0IGJpbmFyeVR5cGUoYmluYXJ5VHlwZSkge1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5iaW5hcnlUeXBlID0gYmluYXJ5VHlwZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXBwIGN1c3RvbSBkYXRhLlxuICAgICAqL1xuICAgIGdldCBhcHBEYXRhKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fYXBwRGF0YTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogSW52YWxpZCBzZXR0ZXIuXG4gICAgICovXG4gICAgc2V0IGFwcERhdGEoYXBwRGF0YSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Nhbm5vdCBvdmVycmlkZSBhcHBEYXRhIG9iamVjdCcpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPYnNlcnZlci5cbiAgICAgKlxuICAgICAqIEBlbWl0cyBjbG9zZVxuICAgICAqL1xuICAgIGdldCBvYnNlcnZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29ic2VydmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZXMgdGhlIERhdGFDb25zdW1lci5cbiAgICAgKi9cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IHRydWU7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmNsb3NlKCk7XG4gICAgICAgIHRoaXMuZW1pdCgnQGNsb3NlJyk7XG4gICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCdjbG9zZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBUcmFuc3BvcnQgd2FzIGNsb3NlZC5cbiAgICAgKi9cbiAgICB0cmFuc3BvcnRDbG9zZWQoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndHJhbnNwb3J0Q2xvc2VkKCknKTtcbiAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5zYWZlRW1pdCgndHJhbnNwb3J0Y2xvc2UnKTtcbiAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ2Nsb3NlJyk7XG4gICAgfVxuICAgIF9oYW5kbGVEYXRhQ2hhbm5lbCgpIHtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdEYXRhQ2hhbm5lbCBcIm9wZW5cIiBldmVudCcpO1xuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnb3BlbicpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHsgZXJyb3IgfSA9IGV2ZW50O1xuICAgICAgICAgICAgaWYgKCFlcnJvcilcbiAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcigndW5rbm93biBEYXRhQ2hhbm5lbCBlcnJvcicpO1xuICAgICAgICAgICAgaWYgKGVycm9yLmVycm9yRGV0YWlsID09PSAnc2N0cC1mYWlsdXJlJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcignRGF0YUNoYW5uZWwgU0NUUCBlcnJvciBbc2N0cENhdXNlQ29kZTolc106ICVzJywgZXJyb3Iuc2N0cENhdXNlQ29kZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0RhdGFDaGFubmVsIFwiZXJyb3JcIiBldmVudDogJW8nLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsb2dnZXIud2FybignRGF0YUNoYW5uZWwgXCJjbG9zZVwiIGV2ZW50Jyk7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdAY2xvc2UnKTtcbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ2Nsb3NlJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ21lc3NhZ2UnLCBldmVudC5kYXRhKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5EYXRhQ29uc3VtZXIgPSBEYXRhQ29uc3VtZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGF0YVByb2R1Y2VyID0gdm9pZCAwO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi9Mb2dnZXJcIik7XG5jb25zdCBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xID0gcmVxdWlyZShcIi4vRW5oYW5jZWRFdmVudEVtaXR0ZXJcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuL2Vycm9yc1wiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ0RhdGFQcm9kdWNlcicpO1xuY2xhc3MgRGF0YVByb2R1Y2VyIGV4dGVuZHMgRW5oYW5jZWRFdmVudEVtaXR0ZXJfMS5FbmhhbmNlZEV2ZW50RW1pdHRlciB7XG4gICAgLyoqXG4gICAgICogQGVtaXRzIHRyYW5zcG9ydGNsb3NlXG4gICAgICogQGVtaXRzIG9wZW5cbiAgICAgKiBAZW1pdHMgZXJyb3IgLSAoZXJyb3I6IEVycm9yKVxuICAgICAqIEBlbWl0cyBjbG9zZVxuICAgICAqIEBlbWl0cyBidWZmZXJlZGFtb3VudGxvd1xuICAgICAqIEBlbWl0cyBAY2xvc2VcbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGlkLCBkYXRhQ2hhbm5lbCwgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGFwcERhdGEgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBDbG9zZWQgZmxhZy5cbiAgICAgICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIC8vIE9ic2VydmVyIGluc3RhbmNlLlxuICAgICAgICB0aGlzLl9vYnNlcnZlciA9IG5ldyBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xLkVuaGFuY2VkRXZlbnRFbWl0dGVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKScpO1xuICAgICAgICB0aGlzLl9pZCA9IGlkO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbCA9IGRhdGFDaGFubmVsO1xuICAgICAgICB0aGlzLl9zY3RwU3RyZWFtUGFyYW1ldGVycyA9IHNjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLl9hcHBEYXRhID0gYXBwRGF0YTtcbiAgICAgICAgdGhpcy5faGFuZGxlRGF0YUNoYW5uZWwoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGF0YVByb2R1Y2VyIGlkLlxuICAgICAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBEYXRhUHJvZHVjZXIgaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFNDVFAgc3RyZWFtIHBhcmFtZXRlcnMuXG4gICAgICovXG4gICAgZ2V0IHNjdHBTdHJlYW1QYXJhbWV0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERhdGFDaGFubmVsIHJlYWR5U3RhdGUuXG4gICAgICovXG4gICAgZ2V0IHJlYWR5U3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhQ2hhbm5lbC5yZWFkeVN0YXRlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEYXRhQ2hhbm5lbCBsYWJlbC5cbiAgICAgKi9cbiAgICBnZXQgbGFiZWwoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhQ2hhbm5lbC5sYWJlbDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogRGF0YUNoYW5uZWwgcHJvdG9jb2wuXG4gICAgICovXG4gICAgZ2V0IHByb3RvY29sKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZGF0YUNoYW5uZWwucHJvdG9jb2w7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIERhdGFDaGFubmVsIGJ1ZmZlcmVkQW1vdW50LlxuICAgICAqL1xuICAgIGdldCBidWZmZXJlZEFtb3VudCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RhdGFDaGFubmVsLmJ1ZmZlcmVkQW1vdW50O1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBEYXRhQ2hhbm5lbCBidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZC5cbiAgICAgKi9cbiAgICBnZXQgYnVmZmVyZWRBbW91bnRMb3dUaHJlc2hvbGQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kYXRhQ2hhbm5lbC5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0IERhdGFDaGFubmVsIGJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkLlxuICAgICAqL1xuICAgIHNldCBidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZChidWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCkge1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5idWZmZXJlZEFtb3VudExvd1RocmVzaG9sZCA9IGJ1ZmZlcmVkQW1vdW50TG93VGhyZXNob2xkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHAgY3VzdG9tIGRhdGEuXG4gICAgICovXG4gICAgZ2V0IGFwcERhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBEYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkIHNldHRlci5cbiAgICAgKi9cbiAgICBzZXQgYXBwRGF0YShhcHBEYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IG92ZXJyaWRlIGFwcERhdGEgb2JqZWN0Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ic2VydmVyLlxuICAgICAqXG4gICAgICogQGVtaXRzIGNsb3NlXG4gICAgICovXG4gICAgZ2V0IG9ic2VydmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2JzZXJ2ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgRGF0YVByb2R1Y2VyLlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuY2xvc2UoKTtcbiAgICAgICAgdGhpcy5lbWl0KCdAY2xvc2UnKTtcbiAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ2Nsb3NlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zcG9ydCB3YXMgY2xvc2VkLlxuICAgICAqL1xuICAgIHRyYW5zcG9ydENsb3NlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd0cmFuc3BvcnRDbG9zZWQoKScpO1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5jbG9zZSgpO1xuICAgICAgICB0aGlzLnNhZmVFbWl0KCd0cmFuc3BvcnRjbG9zZScpO1xuICAgICAgICAvLyBFbWl0IG9ic2VydmVyIGV2ZW50LlxuICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgnY2xvc2UnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2VuZCBhIG1lc3NhZ2UuXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge1N0cmluZ3xCbG9ifEFycmF5QnVmZmVyfEFycmF5QnVmZmVyVmlld30gZGF0YS5cbiAgICAgKi9cbiAgICBzZW5kKGRhdGEpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignY2xvc2VkJyk7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLnNlbmQoZGF0YSk7XG4gICAgfVxuICAgIF9oYW5kbGVEYXRhQ2hhbm5lbCgpIHtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcignb3BlbicsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdEYXRhQ2hhbm5lbCBcIm9wZW5cIiBldmVudCcpO1xuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnb3BlbicpO1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fZGF0YUNoYW5uZWwuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgbGV0IHsgZXJyb3IgfSA9IGV2ZW50O1xuICAgICAgICAgICAgaWYgKCFlcnJvcilcbiAgICAgICAgICAgICAgICBlcnJvciA9IG5ldyBFcnJvcigndW5rbm93biBEYXRhQ2hhbm5lbCBlcnJvcicpO1xuICAgICAgICAgICAgaWYgKGVycm9yLmVycm9yRGV0YWlsID09PSAnc2N0cC1mYWlsdXJlJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcignRGF0YUNoYW5uZWwgU0NUUCBlcnJvciBbc2N0cENhdXNlQ29kZTolc106ICVzJywgZXJyb3Iuc2N0cENhdXNlQ29kZSwgZXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ0RhdGFDaGFubmVsIFwiZXJyb3JcIiBldmVudDogJW8nLCBlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdlcnJvcicsIGVycm9yKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2RhdGFDaGFubmVsLmFkZEV2ZW50TGlzdGVuZXIoJ2Nsb3NlJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsb2dnZXIud2FybignRGF0YUNoYW5uZWwgXCJjbG9zZVwiIGV2ZW50Jyk7XG4gICAgICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5lbWl0KCdAY2xvc2UnKTtcbiAgICAgICAgICAgIHRoaXMuc2FmZUVtaXQoJ2Nsb3NlJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKCdtZXNzYWdlJywgKCkgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsb2dnZXIud2FybignRGF0YUNoYW5uZWwgXCJtZXNzYWdlXCIgZXZlbnQgaW4gYSBEYXRhUHJvZHVjZXIsIG1lc3NhZ2UgZGlzY2FyZGVkJyk7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9kYXRhQ2hhbm5lbC5hZGRFdmVudExpc3RlbmVyKCdidWZmZXJlZGFtb3VudGxvdycsICgpID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnYnVmZmVyZWRhbW91bnRsb3cnKTtcbiAgICAgICAgfSk7XG4gICAgfVxufVxuZXhwb3J0cy5EYXRhUHJvZHVjZXIgPSBEYXRhUHJvZHVjZXI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbi8qIGdsb2JhbCBSVENSdHBUcmFuc2NlaXZlciAqL1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbnZhciBfX2ltcG9ydERlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0RGVmYXVsdCkgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgXCJkZWZhdWx0XCI6IG1vZCB9O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRGV2aWNlID0gZXhwb3J0cy5kZXRlY3REZXZpY2UgPSB2b2lkIDA7XG5jb25zdCBib3dzZXJfMSA9IF9faW1wb3J0RGVmYXVsdChyZXF1aXJlKFwiYm93c2VyXCIpKTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vTG9nZ2VyXCIpO1xuY29uc3QgRW5oYW5jZWRFdmVudEVtaXR0ZXJfMSA9IHJlcXVpcmUoXCIuL0VuaGFuY2VkRXZlbnRFbWl0dGVyXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi91dGlsc1wiKSk7XG5jb25zdCBvcnRjID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL29ydGNcIikpO1xuY29uc3QgVHJhbnNwb3J0XzEgPSByZXF1aXJlKFwiLi9UcmFuc3BvcnRcIik7XG5jb25zdCBDaHJvbWU3NF8xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvQ2hyb21lNzRcIik7XG5jb25zdCBDaHJvbWU3MF8xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvQ2hyb21lNzBcIik7XG5jb25zdCBDaHJvbWU2N18xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvQ2hyb21lNjdcIik7XG5jb25zdCBDaHJvbWU1NV8xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvQ2hyb21lNTVcIik7XG5jb25zdCBGaXJlZm94NjBfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL0ZpcmVmb3g2MFwiKTtcbmNvbnN0IFNhZmFyaTEyXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9TYWZhcmkxMlwiKTtcbmNvbnN0IFNhZmFyaTExXzEgPSByZXF1aXJlKFwiLi9oYW5kbGVycy9TYWZhcmkxMVwiKTtcbmNvbnN0IEVkZ2UxMV8xID0gcmVxdWlyZShcIi4vaGFuZGxlcnMvRWRnZTExXCIpO1xuY29uc3QgUmVhY3ROYXRpdmVfMSA9IHJlcXVpcmUoXCIuL2hhbmRsZXJzL1JlYWN0TmF0aXZlXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignRGV2aWNlJyk7XG5mdW5jdGlvbiBkZXRlY3REZXZpY2UoKSB7XG4gICAgLy8gUmVhY3QtTmF0aXZlLlxuICAgIC8vIE5PVEU6IHJlYWN0LW5hdGl2ZS13ZWJydGMgPj0gMS43NS4wIGlzIHJlcXVpcmVkLlxuICAgIGlmICh0eXBlb2YgbmF2aWdhdG9yID09PSAnb2JqZWN0JyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAgICAgICBpZiAodHlwZW9mIFJUQ1BlZXJDb25uZWN0aW9uID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3RoaXMuX2RldGVjdERldmljZSgpIHwgdW5zdXBwb3J0ZWQgUmVhY3ROYXRpdmUgd2l0aG91dCBSVENQZWVyQ29ubmVjdGlvbicpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3RoaXMuX2RldGVjdERldmljZSgpIHwgUmVhY3ROYXRpdmUgaGFuZGxlciBjaG9zZW4nKTtcbiAgICAgICAgcmV0dXJuICdSZWFjdE5hdGl2ZSc7XG4gICAgfVxuICAgIC8vIEJyb3dzZXIuXG4gICAgZWxzZSBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG5hdmlnYXRvci51c2VyQWdlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgIGNvbnN0IHVhID0gbmF2aWdhdG9yLnVzZXJBZ2VudDtcbiAgICAgICAgY29uc3QgYnJvd3NlciA9IGJvd3Nlcl8xLmRlZmF1bHQuZ2V0UGFyc2VyKHVhKTtcbiAgICAgICAgY29uc3QgZW5naW5lID0gYnJvd3Nlci5nZXRFbmdpbmUoKTtcbiAgICAgICAgLy8gQ2hyb21lIGFuZCBDaHJvbWl1bS5cbiAgICAgICAgaWYgKGJyb3dzZXIuc2F0aXNmaWVzKHsgY2hyb21lOiAnPj03NCcsIGNocm9taXVtOiAnPj03NCcgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2hyb21lNzQnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJyb3dzZXIuc2F0aXNmaWVzKHsgY2hyb21lOiAnPj03MCcsIGNocm9taXVtOiAnPj03MCcgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2hyb21lNzAnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJyb3dzZXIuc2F0aXNmaWVzKHsgY2hyb21lOiAnPj02NycsIGNocm9taXVtOiAnPj02NycgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2hyb21lNjcnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJyb3dzZXIuc2F0aXNmaWVzKHsgY2hyb21lOiAnPj01NScsIGNocm9taXVtOiAnPj01NScgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnQ2hyb21lNTUnO1xuICAgICAgICB9XG4gICAgICAgIC8vIEZpcmVmb3guXG4gICAgICAgIGVsc2UgaWYgKGJyb3dzZXIuc2F0aXNmaWVzKHsgZmlyZWZveDogJz49NjAnIH0pKSB7XG4gICAgICAgICAgICByZXR1cm4gJ0ZpcmVmb3g2MCc7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2FmYXJpIHdpdGggVW5pZmllZC1QbGFuIHN1cHBvcnQgZW5hYmxlZC5cbiAgICAgICAgZWxzZSBpZiAoYnJvd3Nlci5zYXRpc2ZpZXMoeyBzYWZhcmk6ICc+PTEyLjAnIH0pICYmXG4gICAgICAgICAgICB0eXBlb2YgUlRDUnRwVHJhbnNjZWl2ZXIgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICBSVENSdHBUcmFuc2NlaXZlci5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkoJ2N1cnJlbnREaXJlY3Rpb24nKSkge1xuICAgICAgICAgICAgcmV0dXJuICdTYWZhcmkxMic7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2FmYXJpIHdpdGggUGxhYi1CIHN1cHBvcnQuXG4gICAgICAgIGVsc2UgaWYgKGJyb3dzZXIuc2F0aXNmaWVzKHsgc2FmYXJpOiAnPj0xMScgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnU2FmYXJpMTEnO1xuICAgICAgICB9XG4gICAgICAgIC8vIE9sZCBFZGdlIHdpdGggT1JUQyBzdXBwb3J0LlxuICAgICAgICBlbHNlIGlmIChicm93c2VyLnNhdGlzZmllcyh7ICdtaWNyb3NvZnQgZWRnZSc6ICc+PTExJyB9KSAmJlxuICAgICAgICAgICAgYnJvd3Nlci5zYXRpc2ZpZXMoeyAnbWljcm9zb2Z0IGVkZ2UnOiAnPD0xOCcgfSkpIHtcbiAgICAgICAgICAgIHJldHVybiAnRWRnZTExJztcbiAgICAgICAgfVxuICAgICAgICAvLyBCZXN0IGVmZm9ydCBmb3IgQ2hyb21pdW0gYmFzZWQgYnJvd3NlcnMuXG4gICAgICAgIGVsc2UgaWYgKGVuZ2luZS5uYW1lICYmIGVuZ2luZS5uYW1lLnRvTG93ZXJDYXNlKCkgPT09ICdibGluaycpIHtcbiAgICAgICAgICAgIGNvbnN0IG1hdGNoID0gdWEubWF0Y2goLyg/Oig/OkNocm9tZXxDaHJvbWl1bSkpWyAvXShcXHcrKS9pKTtcbiAgICAgICAgICAgIGlmIChtYXRjaCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZlcnNpb24gPSBOdW1iZXIobWF0Y2hbMV0pO1xuICAgICAgICAgICAgICAgIGlmICh2ZXJzaW9uID49IDc0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnQ2hyb21lNzQnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2ZXJzaW9uID49IDcwKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnQ2hyb21lNzAnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh2ZXJzaW9uID49IDY3KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAnQ2hyb21lNjcnO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuICdDaHJvbWU1NSc7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuICdDaHJvbWU3NCc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gVW5zdXBwb3J0ZWQgYnJvd3Nlci5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIud2FybigndGhpcy5fZGV0ZWN0RGV2aWNlKCkgfCBicm93c2VyIG5vdCBzdXBwb3J0ZWQgW25hbWU6JXMsIHZlcnNpb246JXNdJywgYnJvd3Nlci5nZXRCcm93c2VyTmFtZSgpLCBicm93c2VyLmdldEJyb3dzZXJWZXJzaW9uKCkpO1xuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvLyBVbmtub3duIGRldmljZS5cbiAgICBlbHNlIHtcbiAgICAgICAgbG9nZ2VyLndhcm4oJ3RoaXMuX2RldGVjdERldmljZSgpIHwgdW5rbm93biBkZXZpY2UnKTtcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG59XG5leHBvcnRzLmRldGVjdERldmljZSA9IGRldGVjdERldmljZTtcbmNsYXNzIERldmljZSB7XG4gICAgLyoqXG4gICAgICogQ3JlYXRlIGEgbmV3IERldmljZSB0byBjb25uZWN0IHRvIG1lZGlhc291cCBzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtVbnN1cHBvcnRlZEVycm9yfSBpZiBkZXZpY2UgaXMgbm90IHN1cHBvcnRlZC5cbiAgICAgKi9cbiAgICBjb25zdHJ1Y3Rvcih7IGhhbmRsZXJOYW1lLCBoYW5kbGVyRmFjdG9yeSwgSGFuZGxlciB9ID0ge30pIHtcbiAgICAgICAgLy8gTG9hZGVkIGZsYWcuXG4gICAgICAgIHRoaXMuX2xvYWRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBPYnNlcnZlciBpbnN0YW5jZS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgRW5oYW5jZWRFdmVudEVtaXR0ZXJfMS5FbmhhbmNlZEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2NvbnN0cnVjdG9yKCknKTtcbiAgICAgICAgLy8gSGFuZGxlIGRlcHJlY2F0ZWQgb3B0aW9uLlxuICAgICAgICBpZiAoSGFuZGxlcikge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ2NvbnN0cnVjdG9yKCkgfCBIYW5kbGVyIG9wdGlvbiBpcyBERVBSRUNBVEVELCB1c2UgaGFuZGxlck5hbWUgb3IgaGFuZGxlckZhY3RvcnkgaW5zdGVhZCcpO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBIYW5kbGVyID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICBoYW5kbGVyTmFtZSA9IEhhbmRsZXI7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm9uIHN0cmluZyBIYW5kbGVyIG9wdGlvbiBubyBsb25nZXIgc3VwcG9ydGVkLCB1c2UgaGFuZGxlckZhY3RvcnkgaW5zdGVhZCcpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChoYW5kbGVyTmFtZSAmJiBoYW5kbGVyRmFjdG9yeSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignanVzdCBvbmUgb2YgaGFuZGxlck5hbWUgb3IgaGFuZGxlckludGVyZmFjZSBjYW4gYmUgZ2l2ZW4nKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGFuZGxlckZhY3RvcnkpIHtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJGYWN0b3J5ID0gaGFuZGxlckZhY3Rvcnk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAoaGFuZGxlck5hbWUpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2NvbnN0cnVjdG9yKCkgfCBoYW5kbGVyIGdpdmVuOiAlcycsIGhhbmRsZXJOYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGhhbmRsZXJOYW1lID0gZGV0ZWN0RGV2aWNlKCk7XG4gICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJOYW1lKVxuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2NvbnN0cnVjdG9yKCkgfCBkZXRlY3RlZCBoYW5kbGVyOiAlcycsIGhhbmRsZXJOYW1lKTtcbiAgICAgICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdkZXZpY2Ugbm90IHN1cHBvcnRlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc3dpdGNoIChoYW5kbGVyTmFtZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ0Nocm9tZTc0JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlckZhY3RvcnkgPSBDaHJvbWU3NF8xLkNocm9tZTc0LmNyZWF0ZUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnQ2hyb21lNzAnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9oYW5kbGVyRmFjdG9yeSA9IENocm9tZTcwXzEuQ2hyb21lNzAuY3JlYXRlRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdDaHJvbWU2Nyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJGYWN0b3J5ID0gQ2hyb21lNjdfMS5DaHJvbWU2Ny5jcmVhdGVGYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ0Nocm9tZTU1JzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlckZhY3RvcnkgPSBDaHJvbWU1NV8xLkNocm9tZTU1LmNyZWF0ZUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnRmlyZWZveDYwJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlckZhY3RvcnkgPSBGaXJlZm94NjBfMS5GaXJlZm94NjAuY3JlYXRlRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdTYWZhcmkxMic6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJGYWN0b3J5ID0gU2FmYXJpMTJfMS5TYWZhcmkxMi5jcmVhdGVGYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ1NhZmFyaTExJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlckZhY3RvcnkgPSBTYWZhcmkxMV8xLlNhZmFyaTExLmNyZWF0ZUZhY3RvcnkoKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnRWRnZTExJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlckZhY3RvcnkgPSBFZGdlMTFfMS5FZGdlMTEuY3JlYXRlRmFjdG9yeSgpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdSZWFjdE5hdGl2ZSc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXJGYWN0b3J5ID0gUmVhY3ROYXRpdmVfMS5SZWFjdE5hdGl2ZS5jcmVhdGVGYWN0b3J5KCk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYHVua25vd24gaGFuZGxlck5hbWUgXCIke2hhbmRsZXJOYW1lfVwiYCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ3JlYXRlIGEgdGVtcG9yYWwgaGFuZGxlciB0byBnZXQgaXRzIG5hbWUuXG4gICAgICAgIGNvbnN0IGhhbmRsZXIgPSB0aGlzLl9oYW5kbGVyRmFjdG9yeSgpO1xuICAgICAgICB0aGlzLl9oYW5kbGVyTmFtZSA9IGhhbmRsZXIubmFtZTtcbiAgICAgICAgaGFuZGxlci5jbG9zZSgpO1xuICAgICAgICB0aGlzLl9leHRlbmRlZFJ0cENhcGFiaWxpdGllcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fcmVjdlJ0cENhcGFiaWxpdGllcyA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5fY2FuUHJvZHVjZUJ5S2luZCA9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXVkaW86IGZhbHNlLFxuICAgICAgICAgICAgICAgIHZpZGVvOiBmYWxzZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2N0cENhcGFiaWxpdGllcyA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIFJUQyBoYW5kbGVyIG5hbWUuXG4gICAgICovXG4gICAgZ2V0IGhhbmRsZXJOYW1lKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFuZGxlck5hbWU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIERldmljZSBpcyBsb2FkZWQuXG4gICAgICovXG4gICAgZ2V0IGxvYWRlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvYWRlZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUlRQIGNhcGFiaWxpdGllcyBvZiB0aGUgRGV2aWNlIGZvciByZWNlaXZpbmcgbWVkaWEuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkU3RhdGVFcnJvcn0gaWYgbm90IGxvYWRlZC5cbiAgICAgKi9cbiAgICBnZXQgcnRwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvYWRlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignbm90IGxvYWRlZCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5fcmVjdlJ0cENhcGFiaWxpdGllcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogU0NUUCBjYXBhYmlsaXRpZXMgb2YgdGhlIERldmljZS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRTdGF0ZUVycm9yfSBpZiBub3QgbG9hZGVkLlxuICAgICAqL1xuICAgIGdldCBzY3RwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvYWRlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignbm90IGxvYWRlZCcpO1xuICAgICAgICByZXR1cm4gdGhpcy5fc2N0cENhcGFiaWxpdGllcztcbiAgICB9XG4gICAgLyoqXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAZW1pdHMgbmV3dHJhbnNwb3J0IC0gKHRyYW5zcG9ydDogVHJhbnNwb3J0KVxuICAgICAqL1xuICAgIGdldCBvYnNlcnZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29ic2VydmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbml0aWFsaXplIHRoZSBEZXZpY2UuXG4gICAgICovXG4gICAgYXN5bmMgbG9hZCh7IHJvdXRlclJ0cENhcGFiaWxpdGllcyB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnbG9hZCgpIFtyb3V0ZXJSdHBDYXBhYmlsaXRpZXM6JW9dJywgcm91dGVyUnRwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgcm91dGVyUnRwQ2FwYWJpbGl0aWVzID0gdXRpbHMuY2xvbmUocm91dGVyUnRwQ2FwYWJpbGl0aWVzLCB1bmRlZmluZWQpO1xuICAgICAgICAvLyBUZW1wb3JhbCBoYW5kbGVyIHRvIGdldCBpdHMgY2FwYWJpbGl0aWVzLlxuICAgICAgICBsZXQgaGFuZGxlcjtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9sb2FkZWQpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdhbHJlYWR5IGxvYWRlZCcpO1xuICAgICAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgICAgICBvcnRjLnZhbGlkYXRlUnRwQ2FwYWJpbGl0aWVzKHJvdXRlclJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICBoYW5kbGVyID0gdGhpcy5faGFuZGxlckZhY3RvcnkoKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IGF3YWl0IGhhbmRsZXIuZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2xvYWQoKSB8IGdvdCBuYXRpdmUgUlRQIGNhcGFiaWxpdGllczolbycsIG5hdGl2ZVJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgICAgIG9ydGMudmFsaWRhdGVSdHBDYXBhYmlsaXRpZXMobmF0aXZlUnRwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIC8vIEdldCBleHRlbmRlZCBSVFAgY2FwYWJpbGl0aWVzLlxuICAgICAgICAgICAgdGhpcy5fZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMgPSBvcnRjLmdldEV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKG5hdGl2ZVJ0cENhcGFiaWxpdGllcywgcm91dGVyUnRwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygnbG9hZCgpIHwgZ290IGV4dGVuZGVkIFJUUCBjYXBhYmlsaXRpZXM6JW8nLCB0aGlzLl9leHRlbmRlZFJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHdlIGNhbiBwcm9kdWNlIGF1ZGlvL3ZpZGVvLlxuICAgICAgICAgICAgdGhpcy5fY2FuUHJvZHVjZUJ5S2luZC5hdWRpbyA9XG4gICAgICAgICAgICAgICAgb3J0Yy5jYW5TZW5kKCdhdWRpbycsIHRoaXMuX2V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKTtcbiAgICAgICAgICAgIHRoaXMuX2NhblByb2R1Y2VCeUtpbmQudmlkZW8gPVxuICAgICAgICAgICAgICAgIG9ydGMuY2FuU2VuZCgndmlkZW8nLCB0aGlzLl9leHRlbmRlZFJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICAvLyBHZW5lcmF0ZSBvdXIgcmVjZWl2aW5nIFJUUCBjYXBhYmlsaXRpZXMgZm9yIHJlY2VpdmluZyBtZWRpYS5cbiAgICAgICAgICAgIHRoaXMuX3JlY3ZSdHBDYXBhYmlsaXRpZXMgPVxuICAgICAgICAgICAgICAgIG9ydGMuZ2V0UmVjdlJ0cENhcGFiaWxpdGllcyh0aGlzLl9leHRlbmRlZFJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgICAgIG9ydGMudmFsaWRhdGVSdHBDYXBhYmlsaXRpZXModGhpcy5fcmVjdlJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2xvYWQoKSB8IGdvdCByZWNlaXZpbmcgUlRQIGNhcGFiaWxpdGllczolbycsIHRoaXMuX3JlY3ZSdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgLy8gR2VuZXJhdGUgb3VyIFNDVFAgY2FwYWJpbGl0aWVzLlxuICAgICAgICAgICAgdGhpcy5fc2N0cENhcGFiaWxpdGllcyA9IGF3YWl0IGhhbmRsZXIuZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdsb2FkKCkgfCBnb3QgbmF0aXZlIFNDVFAgY2FwYWJpbGl0aWVzOiVvJywgdGhpcy5fc2N0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgICAgIG9ydGMudmFsaWRhdGVTY3RwQ2FwYWJpbGl0aWVzKHRoaXMuX3NjdHBDYXBhYmlsaXRpZXMpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdsb2FkKCkgc3VjY2VlZGVkJyk7XG4gICAgICAgICAgICB0aGlzLl9sb2FkZWQgPSB0cnVlO1xuICAgICAgICAgICAgaGFuZGxlci5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgaWYgKGhhbmRsZXIpXG4gICAgICAgICAgICAgICAgaGFuZGxlci5jbG9zZSgpO1xuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB3ZSBjYW4gcHJvZHVjZSBhdWRpby92aWRlby5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRTdGF0ZUVycm9yfSBpZiBub3QgbG9hZGVkLlxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgd3JvbmcgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGNhblByb2R1Y2Uoa2luZCkge1xuICAgICAgICBpZiAoIXRoaXMuX2xvYWRlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignbm90IGxvYWRlZCcpO1xuICAgICAgICBlbHNlIGlmIChraW5kICE9PSAnYXVkaW8nICYmIGtpbmQgIT09ICd2aWRlbycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGtpbmQgXCIke2tpbmR9XCJgKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NhblByb2R1Y2VCeUtpbmRba2luZF07XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBUcmFuc3BvcnQgZm9yIHNlbmRpbmcgbWVkaWEuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIHtJbnZhbGlkU3RhdGVFcnJvcn0gaWYgbm90IGxvYWRlZC5cbiAgICAgKiBAdGhyb3dzIHtUeXBlRXJyb3J9IGlmIHdyb25nIGFyZ3VtZW50cy5cbiAgICAgKi9cbiAgICBjcmVhdGVTZW5kVHJhbnNwb3J0KHsgaWQsIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGFwcERhdGEgPSB7fSB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY3JlYXRlU2VuZFRyYW5zcG9ydCgpJyk7XG4gICAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVUcmFuc3BvcnQoe1xuICAgICAgICAgICAgZGlyZWN0aW9uOiAnc2VuZCcsXG4gICAgICAgICAgICBpZDogaWQsXG4gICAgICAgICAgICBpY2VQYXJhbWV0ZXJzOiBpY2VQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgaWNlQ2FuZGlkYXRlczogaWNlQ2FuZGlkYXRlcyxcbiAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzOiBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzOiBzY3RwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IGljZVNlcnZlcnMsXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6IGljZVRyYW5zcG9ydFBvbGljeSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxTZXR0aW5nczogYWRkaXRpb25hbFNldHRpbmdzLFxuICAgICAgICAgICAgcHJvcHJpZXRhcnlDb25zdHJhaW50czogcHJvcHJpZXRhcnlDb25zdHJhaW50cyxcbiAgICAgICAgICAgIGFwcERhdGE6IGFwcERhdGFcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBUcmFuc3BvcnQgZm9yIHJlY2VpdmluZyBtZWRpYS5cbiAgICAgKlxuICAgICAqIEB0aHJvd3Mge0ludmFsaWRTdGF0ZUVycm9yfSBpZiBub3QgbG9hZGVkLlxuICAgICAqIEB0aHJvd3Mge1R5cGVFcnJvcn0gaWYgd3JvbmcgYXJndW1lbnRzLlxuICAgICAqL1xuICAgIGNyZWF0ZVJlY3ZUcmFuc3BvcnQoeyBpZCwgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3ksIGFkZGl0aW9uYWxTZXR0aW5ncywgcHJvcHJpZXRhcnlDb25zdHJhaW50cywgYXBwRGF0YSA9IHt9IH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjcmVhdGVSZWN2VHJhbnNwb3J0KCknKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVRyYW5zcG9ydCh7XG4gICAgICAgICAgICBkaXJlY3Rpb246ICdyZWN2JyxcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnM6IGljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzOiBpY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnM6IGR0bHNQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc2N0cFBhcmFtZXRlcnM6IHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgaWNlU2VydmVyczogaWNlU2VydmVycyxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogaWNlVHJhbnNwb3J0UG9saWN5LFxuICAgICAgICAgICAgYWRkaXRpb25hbFNldHRpbmdzOiBhZGRpdGlvbmFsU2V0dGluZ3MsXG4gICAgICAgICAgICBwcm9wcmlldGFyeUNvbnN0cmFpbnRzOiBwcm9wcmlldGFyeUNvbnN0cmFpbnRzLFxuICAgICAgICAgICAgYXBwRGF0YTogYXBwRGF0YVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2NyZWF0ZVRyYW5zcG9ydCh7IGRpcmVjdGlvbiwgaWQsIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGFwcERhdGEgPSB7fSB9KSB7XG4gICAgICAgIGlmICghdGhpcy5fbG9hZGVkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdub3QgbG9hZGVkJyk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpZCAhPT0gJ3N0cmluZycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGlkJyk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBpY2VQYXJhbWV0ZXJzICE9PSAnb2JqZWN0JylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgaWNlUGFyYW1ldGVycycpO1xuICAgICAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShpY2VDYW5kaWRhdGVzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgaWNlQ2FuZGlkYXRlcycpO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZHRsc1BhcmFtZXRlcnMgIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBkdGxzUGFyYW1ldGVycycpO1xuICAgICAgICBlbHNlIGlmIChzY3RwUGFyYW1ldGVycyAmJiB0eXBlb2Ygc2N0cFBhcmFtZXRlcnMgIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignd3Jvbmcgc2N0cFBhcmFtZXRlcnMnKTtcbiAgICAgICAgZWxzZSBpZiAoYXBwRGF0YSAmJiB0eXBlb2YgYXBwRGF0YSAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpZiBnaXZlbiwgYXBwRGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAvLyBDcmVhdGUgYSBuZXcgVHJhbnNwb3J0LlxuICAgICAgICBjb25zdCB0cmFuc3BvcnQgPSBuZXcgVHJhbnNwb3J0XzEuVHJhbnNwb3J0KHtcbiAgICAgICAgICAgIGRpcmVjdGlvbixcbiAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgaWNlU2VydmVycyxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxTZXR0aW5ncyxcbiAgICAgICAgICAgIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsXG4gICAgICAgICAgICBhcHBEYXRhLFxuICAgICAgICAgICAgaGFuZGxlckZhY3Rvcnk6IHRoaXMuX2hhbmRsZXJGYWN0b3J5LFxuICAgICAgICAgICAgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXM6IHRoaXMuX2V4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLFxuICAgICAgICAgICAgY2FuUHJvZHVjZUJ5S2luZDogdGhpcy5fY2FuUHJvZHVjZUJ5S2luZFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ25ld3RyYW5zcG9ydCcsIHRyYW5zcG9ydCk7XG4gICAgICAgIHJldHVybiB0cmFuc3BvcnQ7XG4gICAgfVxufVxuZXhwb3J0cy5EZXZpY2UgPSBEZXZpY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuRW5oYW5jZWRFdmVudEVtaXR0ZXIgPSB2b2lkIDA7XG5jb25zdCBldmVudHNfMSA9IHJlcXVpcmUoXCJldmVudHNcIik7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlclwiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ0VuaGFuY2VkRXZlbnRFbWl0dGVyJyk7XG5jbGFzcyBFbmhhbmNlZEV2ZW50RW1pdHRlciBleHRlbmRzIGV2ZW50c18xLkV2ZW50RW1pdHRlciB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIHRoaXMuc2V0TWF4TGlzdGVuZXJzKEluZmluaXR5KTtcbiAgICB9XG4gICAgc2FmZUVtaXQoZXZlbnQsIC4uLmFyZ3MpIHtcbiAgICAgICAgY29uc3QgbnVtTGlzdGVuZXJzID0gdGhpcy5saXN0ZW5lckNvdW50KGV2ZW50KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmVtaXQoZXZlbnQsIC4uLmFyZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdzYWZlRW1pdCgpIHwgZXZlbnQgbGlzdGVuZXIgdGhyZXcgYW4gZXJyb3IgW2V2ZW50OiVzXTolbycsIGV2ZW50LCBlcnJvcik7XG4gICAgICAgICAgICByZXR1cm4gQm9vbGVhbihudW1MaXN0ZW5lcnMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNhZmVFbWl0QXNQcm9taXNlKGV2ZW50LCAuLi5hcmdzKSB7XG4gICAgICAgIHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdChldmVudCwgLi4uYXJncywgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIGxvZ2dlci5lcnJvcignc2FmZUVtaXRBc1Byb21pc2UoKSB8IGV2ZW50IGxpc3RlbmVyIHRocmV3IGFuIGVycm9yIFtldmVudDolc106JW8nLCBldmVudCwgZXJyb3IpO1xuICAgICAgICAgICAgICAgIHJlamVjdChlcnJvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuRW5oYW5jZWRFdmVudEVtaXR0ZXIgPSBFbmhhbmNlZEV2ZW50RW1pdHRlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9faW1wb3J0RGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnREZWZhdWx0KSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgcmV0dXJuIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpID8gbW9kIDogeyBcImRlZmF1bHRcIjogbW9kIH07XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Mb2dnZXIgPSB2b2lkIDA7XG5jb25zdCBkZWJ1Z18xID0gX19pbXBvcnREZWZhdWx0KHJlcXVpcmUoXCJkZWJ1Z1wiKSk7XG5jb25zdCBBUFBfTkFNRSA9ICdtZWRpYXNvdXAtY2xpZW50JztcbmNsYXNzIExvZ2dlciB7XG4gICAgY29uc3RydWN0b3IocHJlZml4KSB7XG4gICAgICAgIGlmIChwcmVmaXgpIHtcbiAgICAgICAgICAgIHRoaXMuX2RlYnVnID0gZGVidWdfMS5kZWZhdWx0KGAke0FQUF9OQU1FfToke3ByZWZpeH1gKTtcbiAgICAgICAgICAgIHRoaXMuX3dhcm4gPSBkZWJ1Z18xLmRlZmF1bHQoYCR7QVBQX05BTUV9OldBUk46JHtwcmVmaXh9YCk7XG4gICAgICAgICAgICB0aGlzLl9lcnJvciA9IGRlYnVnXzEuZGVmYXVsdChgJHtBUFBfTkFNRX06RVJST1I6JHtwcmVmaXh9YCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9kZWJ1ZyA9IGRlYnVnXzEuZGVmYXVsdChBUFBfTkFNRSk7XG4gICAgICAgICAgICB0aGlzLl93YXJuID0gZGVidWdfMS5kZWZhdWx0KGAke0FQUF9OQU1FfTpXQVJOYCk7XG4gICAgICAgICAgICB0aGlzLl9lcnJvciA9IGRlYnVnXzEuZGVmYXVsdChgJHtBUFBfTkFNRX06RVJST1JgKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG4gICAgICAgIHRoaXMuX2RlYnVnLmxvZyA9IGNvbnNvbGUuaW5mby5iaW5kKGNvbnNvbGUpO1xuICAgICAgICB0aGlzLl93YXJuLmxvZyA9IGNvbnNvbGUud2Fybi5iaW5kKGNvbnNvbGUpO1xuICAgICAgICB0aGlzLl9lcnJvci5sb2cgPSBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7XG4gICAgICAgIC8qIGVzbGludC1lbmFibGUgbm8tY29uc29sZSAqL1xuICAgIH1cbiAgICBnZXQgZGVidWcoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9kZWJ1ZztcbiAgICB9XG4gICAgZ2V0IHdhcm4oKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl93YXJuO1xuICAgIH1cbiAgICBnZXQgZXJyb3IoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9lcnJvcjtcbiAgICB9XG59XG5leHBvcnRzLkxvZ2dlciA9IExvZ2dlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5Qcm9kdWNlciA9IHZvaWQgMDtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4vTG9nZ2VyXCIpO1xuY29uc3QgRW5oYW5jZWRFdmVudEVtaXR0ZXJfMSA9IHJlcXVpcmUoXCIuL0VuaGFuY2VkRXZlbnRFbWl0dGVyXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi9lcnJvcnNcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdQcm9kdWNlcicpO1xuY2xhc3MgUHJvZHVjZXIgZXh0ZW5kcyBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xLkVuaGFuY2VkRXZlbnRFbWl0dGVyIHtcbiAgICAvKipcbiAgICAgKiBAZW1pdHMgdHJhbnNwb3J0Y2xvc2VcbiAgICAgKiBAZW1pdHMgdHJhY2tlbmRlZFxuICAgICAqIEBlbWl0cyBAcmVwbGFjZXRyYWNrIC0gKHRyYWNrOiBNZWRpYVN0cmVhbVRyYWNrIHwgbnVsbClcbiAgICAgKiBAZW1pdHMgQHNldG1heHNwYXRpYWxsYXllciAtIChzcGF0aWFsTGF5ZXI6IHN0cmluZylcbiAgICAgKiBAZW1pdHMgQHNldHJ0cGVuY29kaW5ncGFyYW1ldGVycyAtIChwYXJhbXM6IGFueSlcbiAgICAgKiBAZW1pdHMgQGdldHN0YXRzXG4gICAgICogQGVtaXRzIEBjbG9zZVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKHsgaWQsIGxvY2FsSWQsIHJ0cFNlbmRlciwgdHJhY2ssIHJ0cFBhcmFtZXRlcnMsIHN0b3BUcmFja3MsIGRpc2FibGVUcmFja09uUGF1c2UsIHplcm9SdHBPblBhdXNlLCBhcHBEYXRhIH0pIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gQ2xvc2VkIGZsYWcuXG4gICAgICAgIHRoaXMuX2Nsb3NlZCA9IGZhbHNlO1xuICAgICAgICAvLyBPYnNlcnZlciBpbnN0YW5jZS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgRW5oYW5jZWRFdmVudEVtaXR0ZXJfMS5FbmhhbmNlZEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2NvbnN0cnVjdG9yKCknKTtcbiAgICAgICAgdGhpcy5faWQgPSBpZDtcbiAgICAgICAgdGhpcy5fbG9jYWxJZCA9IGxvY2FsSWQ7XG4gICAgICAgIHRoaXMuX3J0cFNlbmRlciA9IHJ0cFNlbmRlcjtcbiAgICAgICAgdGhpcy5fdHJhY2sgPSB0cmFjaztcbiAgICAgICAgdGhpcy5fa2luZCA9IHRyYWNrLmtpbmQ7XG4gICAgICAgIHRoaXMuX3J0cFBhcmFtZXRlcnMgPSBydHBQYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLl9wYXVzZWQgPSBkaXNhYmxlVHJhY2tPblBhdXNlID8gIXRyYWNrLmVuYWJsZWQgOiBmYWxzZTtcbiAgICAgICAgdGhpcy5fbWF4U3BhdGlhbExheWVyID0gdW5kZWZpbmVkO1xuICAgICAgICB0aGlzLl9zdG9wVHJhY2tzID0gc3RvcFRyYWNrcztcbiAgICAgICAgdGhpcy5fZGlzYWJsZVRyYWNrT25QYXVzZSA9IGRpc2FibGVUcmFja09uUGF1c2U7XG4gICAgICAgIHRoaXMuX3plcm9SdHBPblBhdXNlID0gemVyb1J0cE9uUGF1c2U7XG4gICAgICAgIHRoaXMuX2FwcERhdGEgPSBhcHBEYXRhO1xuICAgICAgICB0aGlzLl9vblRyYWNrRW5kZWQgPSB0aGlzLl9vblRyYWNrRW5kZWQuYmluZCh0aGlzKTtcbiAgICAgICAgLy8gTk9URTogTWlub3IgaXNzdWUuIElmIHplcm9SdHBPblBhdXNlIGlzIHRydWUsIHdlIGNhbm5vdCBlbWl0IHRoZVxuICAgICAgICAvLyAnQHJlcGxhY2V0cmFjaycgZXZlbnQgaGVyZSwgc28gUlRDUnRwU2VuZGVyLnRyYWNrIHdvbid0IGJlIG51bGwuXG4gICAgICAgIHRoaXMuX2hhbmRsZVRyYWNrKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFByb2R1Y2VyIGlkLlxuICAgICAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBMb2NhbCBpZC5cbiAgICAgKi9cbiAgICBnZXQgbG9jYWxJZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2xvY2FsSWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFdoZXRoZXIgdGhlIFByb2R1Y2VyIGlzIGNsb3NlZC5cbiAgICAgKi9cbiAgICBnZXQgY2xvc2VkKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fY2xvc2VkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBNZWRpYSBraW5kLlxuICAgICAqL1xuICAgIGdldCBraW5kKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fa2luZDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQXNzb2NpYXRlZCBSVENSdHBTZW5kZXIuXG4gICAgICovXG4gICAgZ2V0IHJ0cFNlbmRlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3J0cFNlbmRlcjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVGhlIGFzc29jaWF0ZWQgdHJhY2suXG4gICAgICovXG4gICAgZ2V0IHRyYWNrKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fdHJhY2s7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJUUCBwYXJhbWV0ZXJzLlxuICAgICAqL1xuICAgIGdldCBydHBQYXJhbWV0ZXJzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcnRwUGFyYW1ldGVycztcbiAgICB9XG4gICAgLyoqXG4gICAgICogV2hldGhlciB0aGUgUHJvZHVjZXIgaXMgcGF1c2VkLlxuICAgICAqL1xuICAgIGdldCBwYXVzZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYXVzZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE1heCBzcGF0aWFsIGxheWVyLlxuICAgICAqXG4gICAgICogQHR5cGUge051bWJlciB8IHVuZGVmaW5lZH1cbiAgICAgKi9cbiAgICBnZXQgbWF4U3BhdGlhbExheWVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fbWF4U3BhdGlhbExheWVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBBcHAgY3VzdG9tIGRhdGEuXG4gICAgICovXG4gICAgZ2V0IGFwcERhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9hcHBEYXRhO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBJbnZhbGlkIHNldHRlci5cbiAgICAgKi9cbiAgICBzZXQgYXBwRGF0YShhcHBEYXRhKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignY2Fubm90IG92ZXJyaWRlIGFwcERhdGEgb2JqZWN0Jyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIE9ic2VydmVyLlxuICAgICAqXG4gICAgICogQGVtaXRzIGNsb3NlXG4gICAgICogQGVtaXRzIHBhdXNlXG4gICAgICogQGVtaXRzIHJlc3VtZVxuICAgICAqIEBlbWl0cyB0cmFja2VuZGVkXG4gICAgICovXG4gICAgZ2V0IG9ic2VydmVyKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fb2JzZXJ2ZXI7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENsb3NlcyB0aGUgUHJvZHVjZXIuXG4gICAgICovXG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kZXN0cm95VHJhY2soKTtcbiAgICAgICAgdGhpcy5lbWl0KCdAY2xvc2UnKTtcbiAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ2Nsb3NlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zcG9ydCB3YXMgY2xvc2VkLlxuICAgICAqL1xuICAgIHRyYW5zcG9ydENsb3NlZCgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd0cmFuc3BvcnRDbG9zZWQoKScpO1xuICAgICAgICB0aGlzLl9jbG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLl9kZXN0cm95VHJhY2soKTtcbiAgICAgICAgdGhpcy5zYWZlRW1pdCgndHJhbnNwb3J0Y2xvc2UnKTtcbiAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ2Nsb3NlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlciBzdGF0cy5cbiAgICAgKi9cbiAgICBhc3luYyBnZXRTdGF0cygpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignY2xvc2VkJyk7XG4gICAgICAgIHJldHVybiB0aGlzLnNhZmVFbWl0QXNQcm9taXNlKCdAZ2V0c3RhdHMnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUGF1c2VzIHNlbmRpbmcgbWVkaWEuXG4gICAgICovXG4gICAgcGF1c2UoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncGF1c2UoKScpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ3BhdXNlKCkgfCBQcm9kdWNlciBjbG9zZWQnKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xuICAgICAgICBpZiAodGhpcy5fdHJhY2sgJiYgdGhpcy5fZGlzYWJsZVRyYWNrT25QYXVzZSkge1xuICAgICAgICAgICAgdGhpcy5fdHJhY2suZW5hYmxlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl96ZXJvUnRwT25QYXVzZSkge1xuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdEFzUHJvbWlzZSgnQHJlcGxhY2V0cmFjaycsIG51bGwpXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ3BhdXNlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFJlc3VtZXMgc2VuZGluZyBtZWRpYS5cbiAgICAgKi9cbiAgICByZXN1bWUoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdW1lKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdyZXN1bWUoKSB8IFByb2R1Y2VyIGNsb3NlZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xuICAgICAgICBpZiAodGhpcy5fdHJhY2sgJiYgdGhpcy5fZGlzYWJsZVRyYWNrT25QYXVzZSkge1xuICAgICAgICAgICAgdGhpcy5fdHJhY2suZW5hYmxlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3plcm9SdHBPblBhdXNlKSB7XG4gICAgICAgICAgICB0aGlzLnNhZmVFbWl0QXNQcm9taXNlKCdAcmVwbGFjZXRyYWNrJywgdGhpcy5fdHJhY2spXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ3Jlc3VtZScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXBsYWNlcyB0aGUgY3VycmVudCB0cmFjayB3aXRoIGEgbmV3IG9uZSBvciBudWxsLlxuICAgICAqL1xuICAgIGFzeW5jIHJlcGxhY2VUcmFjayh7IHRyYWNrIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbdHJhY2s6JW9dJywgdHJhY2spO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKSB7XG4gICAgICAgICAgICAvLyBUaGlzIG11c3QgYmUgZG9uZSBoZXJlLiBPdGhlcndpc2UgdGhlcmUgaXMgbm8gY2hhbmNlIHRvIHN0b3AgdGhlIGdpdmVuXG4gICAgICAgICAgICAvLyB0cmFjay5cbiAgICAgICAgICAgIGlmICh0cmFjayAmJiB0aGlzLl9zdG9wVHJhY2tzKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdHJhY2suc3RvcCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0cmFjayAmJiB0cmFjay5yZWFkeVN0YXRlID09PSAnZW5kZWQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ3RyYWNrIGVuZGVkJyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gRG8gbm90aGluZyBpZiB0aGlzIGlzIHRoZSBzYW1lIHRyYWNrIGFzIHRoZSBjdXJyZW50IGhhbmRsZWQgb25lLlxuICAgICAgICBpZiAodHJhY2sgPT09IHRoaXMuX3RyYWNrKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIHwgc2FtZSB0cmFjaywgaWdub3JlZCcpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5femVyb1J0cE9uUGF1c2UgfHwgIXRoaXMuX3BhdXNlZCkge1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5zYWZlRW1pdEFzUHJvbWlzZSgnQHJlcGxhY2V0cmFjaycsIHRyYWNrKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBEZXN0cm95IHRoZSBwcmV2aW91cyB0cmFjay5cbiAgICAgICAgdGhpcy5fZGVzdHJveVRyYWNrKCk7XG4gICAgICAgIC8vIFNldCB0aGUgbmV3IHRyYWNrLlxuICAgICAgICB0aGlzLl90cmFjayA9IHRyYWNrO1xuICAgICAgICAvLyBJZiB0aGlzIFByb2R1Y2VyIHdhcyBwYXVzZWQvcmVzdW1lZCBhbmQgdGhlIHN0YXRlIG9mIHRoZSBuZXdcbiAgICAgICAgLy8gdHJhY2sgZG9lcyBub3QgbWF0Y2gsIGZpeCBpdC5cbiAgICAgICAgaWYgKHRoaXMuX3RyYWNrICYmIHRoaXMuX2Rpc2FibGVUcmFja09uUGF1c2UpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5fcGF1c2VkKVxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNrLmVuYWJsZWQgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5fcGF1c2VkKVxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNrLmVuYWJsZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBIYW5kbGUgdGhlIGVmZmVjdGl2ZSB0cmFjay5cbiAgICAgICAgdGhpcy5faGFuZGxlVHJhY2soKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogU2V0cyB0aGUgdmlkZW8gbWF4IHNwYXRpYWwgbGF5ZXIgdG8gYmUgc2VudC5cbiAgICAgKi9cbiAgICBhc3luYyBzZXRNYXhTcGF0aWFsTGF5ZXIoc3BhdGlhbExheWVyKSB7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLl9raW5kICE9PSAndmlkZW8nKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBhIHZpZGVvIFByb2R1Y2VyJyk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBzcGF0aWFsTGF5ZXIgIT09ICdudW1iZXInKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBzcGF0aWFsTGF5ZXInKTtcbiAgICAgICAgaWYgKHNwYXRpYWxMYXllciA9PT0gdGhpcy5fbWF4U3BhdGlhbExheWVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBhd2FpdCB0aGlzLnNhZmVFbWl0QXNQcm9taXNlKCdAc2V0bWF4c3BhdGlhbGxheWVyJywgc3BhdGlhbExheWVyKTtcbiAgICAgICAgdGhpcy5fbWF4U3BhdGlhbExheWVyID0gc3BhdGlhbExheWVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBTZXRzIHRoZSBEU0NQIHZhbHVlLlxuICAgICAqL1xuICAgIGFzeW5jIHNldFJ0cEVuY29kaW5nUGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignY2xvc2VkJyk7XG4gICAgICAgIGVsc2UgaWYgKHR5cGVvZiBwYXJhbXMgIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXJhbXMnKTtcbiAgICAgICAgYXdhaXQgdGhpcy5zYWZlRW1pdEFzUHJvbWlzZSgnQHNldHJ0cGVuY29kaW5ncGFyYW1ldGVycycsIHBhcmFtcyk7XG4gICAgfVxuICAgIF9vblRyYWNrRW5kZWQoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndHJhY2sgXCJlbmRlZFwiIGV2ZW50Jyk7XG4gICAgICAgIHRoaXMuc2FmZUVtaXQoJ3RyYWNrZW5kZWQnKTtcbiAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ3RyYWNrZW5kZWQnKTtcbiAgICB9XG4gICAgX2hhbmRsZVRyYWNrKCkge1xuICAgICAgICBpZiAoIXRoaXMuX3RyYWNrKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLl90cmFjay5hZGRFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuX29uVHJhY2tFbmRlZCk7XG4gICAgfVxuICAgIF9kZXN0cm95VHJhY2soKSB7XG4gICAgICAgIGlmICghdGhpcy5fdHJhY2spXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl90cmFjay5yZW1vdmVFdmVudExpc3RlbmVyKCdlbmRlZCcsIHRoaXMuX29uVHJhY2tFbmRlZCk7XG4gICAgICAgICAgICAvLyBKdXN0IHN0b3AgdGhlIHRyYWNrIHVubGVzcyB0aGUgYXBwIHNldCBzdG9wVHJhY2tzOiBmYWxzZS5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zdG9wVHJhY2tzKVxuICAgICAgICAgICAgICAgIHRoaXMuX3RyYWNrLnN0b3AoKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgIH1cbn1cbmV4cG9ydHMuUHJvZHVjZXIgPSBQcm9kdWNlcjtcbiIsIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiBUaGUgUlRQIGNhcGFiaWxpdGllcyBkZWZpbmUgd2hhdCBtZWRpYXNvdXAgb3IgYW4gZW5kcG9pbnQgY2FuIHJlY2VpdmUgYXRcbiAqIG1lZGlhIGxldmVsLlxuICovXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG4iLCJcInVzZSBzdHJpY3RcIjtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhbnNwb3J0ID0gdm9pZCAwO1xuY29uc3QgYXdhaXRxdWV1ZV8xID0gcmVxdWlyZShcImF3YWl0cXVldWVcIik7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuL0xvZ2dlclwiKTtcbmNvbnN0IEVuaGFuY2VkRXZlbnRFbWl0dGVyXzEgPSByZXF1aXJlKFwiLi9FbmhhbmNlZEV2ZW50RW1pdHRlclwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4vZXJyb3JzXCIpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vdXRpbHNcIikpO1xuY29uc3Qgb3J0YyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9vcnRjXCIpKTtcbmNvbnN0IFByb2R1Y2VyXzEgPSByZXF1aXJlKFwiLi9Qcm9kdWNlclwiKTtcbmNvbnN0IENvbnN1bWVyXzEgPSByZXF1aXJlKFwiLi9Db25zdW1lclwiKTtcbmNvbnN0IERhdGFQcm9kdWNlcl8xID0gcmVxdWlyZShcIi4vRGF0YVByb2R1Y2VyXCIpO1xuY29uc3QgRGF0YUNvbnN1bWVyXzEgPSByZXF1aXJlKFwiLi9EYXRhQ29uc3VtZXJcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdUcmFuc3BvcnQnKTtcbmNsYXNzIFRyYW5zcG9ydCBleHRlbmRzIEVuaGFuY2VkRXZlbnRFbWl0dGVyXzEuRW5oYW5jZWRFdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIEBlbWl0cyBjb25uZWN0IC0gKHRyYW5zcG9ydExvY2FsUGFyYW1ldGVyczogYW55LCBjYWxsYmFjazogRnVuY3Rpb24sIGVycmJhY2s6IEZ1bmN0aW9uKVxuICAgICAqIEBlbWl0cyBjb25uZWN0aW9uc3RhdGVjaGFuZ2UgLSAoY29ubmVjdGlvblN0YXRlOiBDb25uZWN0aW9uU3RhdGUpXG4gICAgICogQGVtaXRzIHByb2R1Y2UgLSAocHJvZHVjZXJMb2NhbFBhcmFtZXRlcnM6IGFueSwgY2FsbGJhY2s6IEZ1bmN0aW9uLCBlcnJiYWNrOiBGdW5jdGlvbilcbiAgICAgKiBAZW1pdHMgcHJvZHVjZWRhdGEgLSAoZGF0YVByb2R1Y2VyTG9jYWxQYXJhbWV0ZXJzOiBhbnksIGNhbGxiYWNrOiBGdW5jdGlvbiwgZXJyYmFjazogRnVuY3Rpb24pXG4gICAgICovXG4gICAgY29uc3RydWN0b3IoeyBkaXJlY3Rpb24sIGlkLCBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgc2N0cFBhcmFtZXRlcnMsIGljZVNlcnZlcnMsIGljZVRyYW5zcG9ydFBvbGljeSwgYWRkaXRpb25hbFNldHRpbmdzLCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzLCBhcHBEYXRhLCBoYW5kbGVyRmFjdG9yeSwgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMsIGNhblByb2R1Y2VCeUtpbmQgfSkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBDbG9zZWQgZmxhZy5cbiAgICAgICAgdGhpcy5fY2xvc2VkID0gZmFsc2U7XG4gICAgICAgIC8vIFRyYW5zcG9ydCBjb25uZWN0aW9uIHN0YXRlLlxuICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdGUgPSAnbmV3JztcbiAgICAgICAgLy8gTWFwIG9mIFByb2R1Y2VycyBpbmRleGVkIGJ5IGlkLlxuICAgICAgICB0aGlzLl9wcm9kdWNlcnMgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE1hcCBvZiBDb25zdW1lcnMgaW5kZXhlZCBieSBpZC5cbiAgICAgICAgdGhpcy5fY29uc3VtZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBNYXAgb2YgRGF0YVByb2R1Y2VycyBpbmRleGVkIGJ5IGlkLlxuICAgICAgICB0aGlzLl9kYXRhUHJvZHVjZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBNYXAgb2YgRGF0YUNvbnN1bWVycyBpbmRleGVkIGJ5IGlkLlxuICAgICAgICB0aGlzLl9kYXRhQ29uc3VtZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBXaGV0aGVyIHRoZSBDb25zdW1lciBmb3IgUlRQIHByb2JhdGlvbiBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICB0aGlzLl9wcm9iYXRvckNvbnN1bWVyQ3JlYXRlZCA9IGZhbHNlO1xuICAgICAgICAvLyBBd2FpdFF1ZXVlIGluc3RhbmNlIHRvIG1ha2UgYXN5bmMgdGFza3MgaGFwcGVuIHNlcXVlbnRpYWxseS5cbiAgICAgICAgdGhpcy5fYXdhaXRRdWV1ZSA9IG5ldyBhd2FpdHF1ZXVlXzEuQXdhaXRRdWV1ZSh7IENsb3NlZEVycm9yQ2xhc3M6IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yIH0pO1xuICAgICAgICAvLyBPYnNlcnZlciBpbnN0YW5jZS5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIgPSBuZXcgRW5oYW5jZWRFdmVudEVtaXR0ZXJfMS5FbmhhbmNlZEV2ZW50RW1pdHRlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2NvbnN0cnVjdG9yKCkgW2lkOiVzLCBkaXJlY3Rpb246JXNdJywgaWQsIGRpcmVjdGlvbik7XG4gICAgICAgIHRoaXMuX2lkID0gaWQ7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgdGhpcy5fZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMgPSBleHRlbmRlZFJ0cENhcGFiaWxpdGllcztcbiAgICAgICAgdGhpcy5fY2FuUHJvZHVjZUJ5S2luZCA9IGNhblByb2R1Y2VCeUtpbmQ7XG4gICAgICAgIHRoaXMuX21heFNjdHBNZXNzYWdlU2l6ZSA9XG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVycyA/IHNjdHBQYXJhbWV0ZXJzLm1heE1lc3NhZ2VTaXplIDogbnVsbDtcbiAgICAgICAgLy8gQ2xvbmUgYW5kIHNhbml0aXplIGFkZGl0aW9uYWxTZXR0aW5ncy5cbiAgICAgICAgYWRkaXRpb25hbFNldHRpbmdzID0gdXRpbHMuY2xvbmUoYWRkaXRpb25hbFNldHRpbmdzLCB7fSk7XG4gICAgICAgIGRlbGV0ZSBhZGRpdGlvbmFsU2V0dGluZ3MuaWNlU2VydmVycztcbiAgICAgICAgZGVsZXRlIGFkZGl0aW9uYWxTZXR0aW5ncy5pY2VUcmFuc3BvcnRQb2xpY3k7XG4gICAgICAgIGRlbGV0ZSBhZGRpdGlvbmFsU2V0dGluZ3MuYnVuZGxlUG9saWN5O1xuICAgICAgICBkZWxldGUgYWRkaXRpb25hbFNldHRpbmdzLnJ0Y3BNdXhQb2xpY3k7XG4gICAgICAgIGRlbGV0ZSBhZGRpdGlvbmFsU2V0dGluZ3Muc2RwU2VtYW50aWNzO1xuICAgICAgICB0aGlzLl9oYW5kbGVyID0gaGFuZGxlckZhY3RvcnkoKTtcbiAgICAgICAgdGhpcy5faGFuZGxlci5ydW4oe1xuICAgICAgICAgICAgZGlyZWN0aW9uLFxuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgaWNlU2VydmVycyxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeSxcbiAgICAgICAgICAgIGFkZGl0aW9uYWxTZXR0aW5ncyxcbiAgICAgICAgICAgIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsXG4gICAgICAgICAgICBleHRlbmRlZFJ0cENhcGFiaWxpdGllc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fYXBwRGF0YSA9IGFwcERhdGE7XG4gICAgICAgIHRoaXMuX2hhbmRsZUhhbmRsZXIoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogVHJhbnNwb3J0IGlkLlxuICAgICAqL1xuICAgIGdldCBpZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2lkO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBXaGV0aGVyIHRoZSBUcmFuc3BvcnQgaXMgY2xvc2VkLlxuICAgICAqL1xuICAgIGdldCBjbG9zZWQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jbG9zZWQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIFRyYW5zcG9ydCBkaXJlY3Rpb24uXG4gICAgICovXG4gICAgZ2V0IGRpcmVjdGlvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2RpcmVjdGlvbjtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUlRDIGhhbmRsZXIgaW5zdGFuY2UuXG4gICAgICovXG4gICAgZ2V0IGhhbmRsZXIoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9oYW5kbGVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDb25uZWN0aW9uIHN0YXRlLlxuICAgICAqL1xuICAgIGdldCBjb25uZWN0aW9uU3RhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9jb25uZWN0aW9uU3RhdGU7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEFwcCBjdXN0b20gZGF0YS5cbiAgICAgKi9cbiAgICBnZXQgYXBwRGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2FwcERhdGE7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEludmFsaWQgc2V0dGVyLlxuICAgICAqL1xuICAgIHNldCBhcHBEYXRhKGFwcERhdGEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdjYW5ub3Qgb3ZlcnJpZGUgYXBwRGF0YSBvYmplY3QnKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogT2JzZXJ2ZXIuXG4gICAgICpcbiAgICAgKiBAZW1pdHMgY2xvc2VcbiAgICAgKiBAZW1pdHMgbmV3cHJvZHVjZXIgLSAocHJvZHVjZXI6IFByb2R1Y2VyKVxuICAgICAqIEBlbWl0cyBuZXdjb25zdW1lciAtIChwcm9kdWNlcjogUHJvZHVjZXIpXG4gICAgICogQGVtaXRzIG5ld2RhdGFwcm9kdWNlciAtIChkYXRhUHJvZHVjZXI6IERhdGFQcm9kdWNlcilcbiAgICAgKiBAZW1pdHMgbmV3ZGF0YWNvbnN1bWVyIC0gKGRhdGFQcm9kdWNlcjogRGF0YVByb2R1Y2VyKVxuICAgICAqL1xuICAgIGdldCBvYnNlcnZlcigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX29ic2VydmVyO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDbG9zZSB0aGUgVHJhbnNwb3J0LlxuICAgICAqL1xuICAgIGNsb3NlKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgdGhpcy5fY2xvc2VkID0gdHJ1ZTtcbiAgICAgICAgLy8gQ2xvc2UgdGhlIEF3YWl0UXVldWUuXG4gICAgICAgIHRoaXMuX2F3YWl0UXVldWUuY2xvc2UoKTtcbiAgICAgICAgLy8gQ2xvc2UgdGhlIGhhbmRsZXIuXG4gICAgICAgIHRoaXMuX2hhbmRsZXIuY2xvc2UoKTtcbiAgICAgICAgLy8gQ2xvc2UgYWxsIFByb2R1Y2Vycy5cbiAgICAgICAgZm9yIChjb25zdCBwcm9kdWNlciBvZiB0aGlzLl9wcm9kdWNlcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHByb2R1Y2VyLnRyYW5zcG9ydENsb3NlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3Byb2R1Y2Vycy5jbGVhcigpO1xuICAgICAgICAvLyBDbG9zZSBhbGwgQ29uc3VtZXJzLlxuICAgICAgICBmb3IgKGNvbnN0IGNvbnN1bWVyIG9mIHRoaXMuX2NvbnN1bWVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgY29uc3VtZXIudHJhbnNwb3J0Q2xvc2VkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fY29uc3VtZXJzLmNsZWFyKCk7XG4gICAgICAgIC8vIENsb3NlIGFsbCBEYXRhUHJvZHVjZXJzLlxuICAgICAgICBmb3IgKGNvbnN0IGRhdGFQcm9kdWNlciBvZiB0aGlzLl9kYXRhUHJvZHVjZXJzLnZhbHVlcygpKSB7XG4gICAgICAgICAgICBkYXRhUHJvZHVjZXIudHJhbnNwb3J0Q2xvc2VkKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZGF0YVByb2R1Y2Vycy5jbGVhcigpO1xuICAgICAgICAvLyBDbG9zZSBhbGwgRGF0YUNvbnN1bWVycy5cbiAgICAgICAgZm9yIChjb25zdCBkYXRhQ29uc3VtZXIgb2YgdGhpcy5fZGF0YUNvbnN1bWVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgZGF0YUNvbnN1bWVyLnRyYW5zcG9ydENsb3NlZCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2RhdGFDb25zdW1lcnMuY2xlYXIoKTtcbiAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ2Nsb3NlJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdldCBhc3NvY2lhdGVkIFRyYW5zcG9ydCAoUlRDUGVlckNvbm5lY3Rpb24pIHN0YXRzLlxuICAgICAqXG4gICAgICogQHJldHVybnMge1JUQ1N0YXRzUmVwb3J0fVxuICAgICAqL1xuICAgIGFzeW5jIGdldFN0YXRzKCkge1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hhbmRsZXIuZ2V0VHJhbnNwb3J0U3RhdHMoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVzdGFydCBJQ0UgY29ubmVjdGlvbi5cbiAgICAgKi9cbiAgICBhc3luYyByZXN0YXJ0SWNlKHsgaWNlUGFyYW1ldGVycyB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpO1xuICAgICAgICBlbHNlIGlmICghaWNlUGFyYW1ldGVycylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgaWNlUGFyYW1ldGVycycpO1xuICAgICAgICAvLyBFbnF1ZXVlIGNvbW1hbmQuXG4gICAgICAgIHJldHVybiB0aGlzLl9hd2FpdFF1ZXVlLnB1c2goYXN5bmMgKCkgPT4gdGhpcy5faGFuZGxlci5yZXN0YXJ0SWNlKGljZVBhcmFtZXRlcnMpLCAndHJhbnNwb3J0LnJlc3RhcnRJY2UoKScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBVcGRhdGUgSUNFIHNlcnZlcnMuXG4gICAgICovXG4gICAgYXN5bmMgdXBkYXRlSWNlU2VydmVycyh7IGljZVNlcnZlcnMgfSA9IHt9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlSWNlU2VydmVycygpJyk7XG4gICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuSW52YWxpZFN0YXRlRXJyb3IoJ2Nsb3NlZCcpO1xuICAgICAgICBlbHNlIGlmICghQXJyYXkuaXNBcnJheShpY2VTZXJ2ZXJzKSlcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgaWNlU2VydmVycycpO1xuICAgICAgICAvLyBFbnF1ZXVlIGNvbW1hbmQuXG4gICAgICAgIHJldHVybiB0aGlzLl9hd2FpdFF1ZXVlLnB1c2goYXN5bmMgKCkgPT4gdGhpcy5faGFuZGxlci51cGRhdGVJY2VTZXJ2ZXJzKGljZVNlcnZlcnMpLCAndHJhbnNwb3J0LnVwZGF0ZUljZVNlcnZlcnMoKScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBQcm9kdWNlci5cbiAgICAgKi9cbiAgICBhc3luYyBwcm9kdWNlKHsgdHJhY2ssIGVuY29kaW5ncywgY29kZWNPcHRpb25zLCBjb2RlYywgc3RvcFRyYWNrcyA9IHRydWUsIGRpc2FibGVUcmFja09uUGF1c2UgPSB0cnVlLCB6ZXJvUnRwT25QYXVzZSA9IGZhbHNlLCBhcHBEYXRhID0ge30gfSA9IHt9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncHJvZHVjZSgpIFt0cmFjazolb10nLCB0cmFjayk7XG4gICAgICAgIGlmICghdHJhY2spXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIHRyYWNrJyk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3NlbmQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBhIHNlbmRpbmcgVHJhbnNwb3J0Jyk7XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9jYW5Qcm9kdWNlQnlLaW5kW3RyYWNrLmtpbmRdKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoYGNhbm5vdCBwcm9kdWNlICR7dHJhY2sua2luZH1gKTtcbiAgICAgICAgZWxzZSBpZiAodHJhY2sucmVhZHlTdGF0ZSA9PT0gJ2VuZGVkJylcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcigndHJhY2sgZW5kZWQnKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5saXN0ZW5lckNvdW50KCdjb25uZWN0JykgPT09IDAgJiYgdGhpcy5fY29ubmVjdGlvblN0YXRlID09PSAnbmV3JylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIFwiY29ubmVjdFwiIGxpc3RlbmVyIHNldCBpbnRvIHRoaXMgdHJhbnNwb3J0Jyk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgncHJvZHVjZScpID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gXCJwcm9kdWNlXCIgbGlzdGVuZXIgc2V0IGludG8gdGhpcyB0cmFuc3BvcnQnKTtcbiAgICAgICAgZWxzZSBpZiAoYXBwRGF0YSAmJiB0eXBlb2YgYXBwRGF0YSAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpZiBnaXZlbiwgYXBwRGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAvLyBFbnF1ZXVlIGNvbW1hbmQuXG4gICAgICAgIHJldHVybiB0aGlzLl9hd2FpdFF1ZXVlLnB1c2goYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgbGV0IG5vcm1hbGl6ZWRFbmNvZGluZ3M7XG4gICAgICAgICAgICBpZiAoZW5jb2RpbmdzICYmICFBcnJheS5pc0FycmF5KGVuY29kaW5ncykpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBUeXBlRXJyb3IoJ2VuY29kaW5ncyBtdXN0IGJlIGFuIGFycmF5Jyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmNvZGluZ3MgJiYgZW5jb2RpbmdzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRFbmNvZGluZ3MgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBub3JtYWxpemVkRW5jb2RpbmdzID0gZW5jb2RpbmdzXG4gICAgICAgICAgICAgICAgICAgIC5tYXAoKGVuY29kaW5nKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vcm1hbGl6ZWRFbmNvZGluZyA9IHsgYWN0aXZlOiB0cnVlIH07XG4gICAgICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZy5hY3RpdmUgPT09IGZhbHNlKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nLmR0eCA9PT0gJ2Jvb2xlYW4nKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nLmR0eCA9IGVuY29kaW5nLmR0eDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9IGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZy5zY2FsZVJlc29sdXRpb25Eb3duQnkgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeSA9IGVuY29kaW5nLnNjYWxlUmVzb2x1dGlvbkRvd25CeTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZy5tYXhCaXRyYXRlID09PSAnbnVtYmVyJylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRFbmNvZGluZy5tYXhCaXRyYXRlID0gZW5jb2RpbmcubWF4Qml0cmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZy5tYXhGcmFtZXJhdGUgPT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nLm1heEZyYW1lcmF0ZSA9IGVuY29kaW5nLm1heEZyYW1lcmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBlbmNvZGluZy5hZGFwdGl2ZVB0aW1lID09PSAnYm9vbGVhbicpXG4gICAgICAgICAgICAgICAgICAgICAgICBub3JtYWxpemVkRW5jb2RpbmcuYWRhcHRpdmVQdGltZSA9IGVuY29kaW5nLmFkYXB0aXZlUHRpbWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcucHJpb3JpdHkgPT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgICAgICAgICAgICAgbm9ybWFsaXplZEVuY29kaW5nLnByaW9yaXR5ID0gZW5jb2RpbmcucHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZW5jb2RpbmcubmV0d29ya1ByaW9yaXR5ID09PSAnc3RyaW5nJylcbiAgICAgICAgICAgICAgICAgICAgICAgIG5vcm1hbGl6ZWRFbmNvZGluZy5uZXR3b3JrUHJpb3JpdHkgPSBlbmNvZGluZy5uZXR3b3JrUHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBub3JtYWxpemVkRW5jb2Rpbmc7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjb25zdCB7IGxvY2FsSWQsIHJ0cFBhcmFtZXRlcnMsIHJ0cFNlbmRlciB9ID0gYXdhaXQgdGhpcy5faGFuZGxlci5zZW5kKHtcbiAgICAgICAgICAgICAgICB0cmFjayxcbiAgICAgICAgICAgICAgICBlbmNvZGluZ3M6IG5vcm1hbGl6ZWRFbmNvZGluZ3MsXG4gICAgICAgICAgICAgICAgY29kZWNPcHRpb25zLFxuICAgICAgICAgICAgICAgIGNvZGVjXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGZpbGwgcnRwUGFyYW1ldGVycydzIG1pc3NpbmcgZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gICAgICAgICAgICAgICAgb3J0Yy52YWxpZGF0ZVJ0cFBhcmFtZXRlcnMocnRwUGFyYW1ldGVycyk7XG4gICAgICAgICAgICAgICAgY29uc3QgeyBpZCB9ID0gYXdhaXQgdGhpcy5zYWZlRW1pdEFzUHJvbWlzZSgncHJvZHVjZScsIHtcbiAgICAgICAgICAgICAgICAgICAga2luZDogdHJhY2sua2luZCxcbiAgICAgICAgICAgICAgICAgICAgcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgYXBwRGF0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGNvbnN0IHByb2R1Y2VyID0gbmV3IFByb2R1Y2VyXzEuUHJvZHVjZXIoe1xuICAgICAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICAgICAgbG9jYWxJZCxcbiAgICAgICAgICAgICAgICAgICAgcnRwU2VuZGVyLFxuICAgICAgICAgICAgICAgICAgICB0cmFjayxcbiAgICAgICAgICAgICAgICAgICAgcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICAgICAgc3RvcFRyYWNrcyxcbiAgICAgICAgICAgICAgICAgICAgZGlzYWJsZVRyYWNrT25QYXVzZSxcbiAgICAgICAgICAgICAgICAgICAgemVyb1J0cE9uUGF1c2UsXG4gICAgICAgICAgICAgICAgICAgIGFwcERhdGFcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB0aGlzLl9wcm9kdWNlcnMuc2V0KHByb2R1Y2VyLmlkLCBwcm9kdWNlcik7XG4gICAgICAgICAgICAgICAgdGhpcy5faGFuZGxlUHJvZHVjZXIocHJvZHVjZXIpO1xuICAgICAgICAgICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgICAgICAgICAgdGhpcy5fb2JzZXJ2ZXIuc2FmZUVtaXQoJ25ld3Byb2R1Y2VyJywgcHJvZHVjZXIpO1xuICAgICAgICAgICAgICAgIHJldHVybiBwcm9kdWNlcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgIHRoaXMuX2hhbmRsZXIuc3RvcFNlbmRpbmcobG9jYWxJZClcbiAgICAgICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sICd0cmFuc3BvcnQucHJvZHVjZSgpJylcbiAgICAgICAgICAgIC8vIFRoaXMgY2F0Y2ggaXMgbmVlZGVkIHRvIHN0b3AgdGhlIGdpdmVuIHRyYWNrIGlmIHRoZSBjb21tYW5kIGFib3ZlXG4gICAgICAgICAgICAvLyBmYWlsZWQgZHVlIHRvIGNsb3NlZCBUcmFuc3BvcnQuXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICBpZiAoc3RvcFRyYWNrcykge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYWNrLnN0b3AoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yMikgeyB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIENvbnN1bWVyIHRvIGNvbnN1bWUgYSByZW1vdGUgUHJvZHVjZXIuXG4gICAgICovXG4gICAgYXN5bmMgY29uc3VtZSh7IGlkLCBwcm9kdWNlcklkLCBraW5kLCBydHBQYXJhbWV0ZXJzLCBhcHBEYXRhID0ge30gfSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2NvbnN1bWUoKScpO1xuICAgICAgICBydHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUocnRwUGFyYW1ldGVycywgdW5kZWZpbmVkKTtcbiAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignY2xvc2VkJyk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3JlY3YnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBhIHJlY2VpdmluZyBUcmFuc3BvcnQnKTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgaWQnKTtcbiAgICAgICAgZWxzZSBpZiAodHlwZW9mIHByb2R1Y2VySWQgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBwcm9kdWNlcklkJyk7XG4gICAgICAgIGVsc2UgaWYgKGtpbmQgIT09ICdhdWRpbycgJiYga2luZCAhPT0gJ3ZpZGVvJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQga2luZCAnJHtraW5kfSdgKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5saXN0ZW5lckNvdW50KCdjb25uZWN0JykgPT09IDAgJiYgdGhpcy5fY29ubmVjdGlvblN0YXRlID09PSAnbmV3JylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ25vIFwiY29ubmVjdFwiIGxpc3RlbmVyIHNldCBpbnRvIHRoaXMgdHJhbnNwb3J0Jyk7XG4gICAgICAgIGVsc2UgaWYgKGFwcERhdGEgJiYgdHlwZW9mIGFwcERhdGEgIT09ICdvYmplY3QnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaWYgZ2l2ZW4sIGFwcERhdGEgbXVzdCBiZSBhbiBvYmplY3QnKTtcbiAgICAgICAgLy8gRW5xdWV1ZSBjb21tYW5kLlxuICAgICAgICByZXR1cm4gdGhpcy5fYXdhaXRRdWV1ZS5wdXNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIC8vIEVuc3VyZSB0aGUgZGV2aWNlIGNhbiBjb25zdW1lIGl0LlxuICAgICAgICAgICAgY29uc3QgY2FuQ29uc3VtZSA9IG9ydGMuY2FuUmVjZWl2ZShydHBQYXJhbWV0ZXJzLCB0aGlzLl9leHRlbmRlZFJ0cENhcGFiaWxpdGllcyk7XG4gICAgICAgICAgICBpZiAoIWNhbkNvbnN1bWUpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ2Nhbm5vdCBjb25zdW1lIHRoaXMgUHJvZHVjZXInKTtcbiAgICAgICAgICAgIGNvbnN0IHsgbG9jYWxJZCwgcnRwUmVjZWl2ZXIsIHRyYWNrIH0gPSBhd2FpdCB0aGlzLl9oYW5kbGVyLnJlY2VpdmUoeyB0cmFja0lkOiBpZCwga2luZCwgcnRwUGFyYW1ldGVycyB9KTtcbiAgICAgICAgICAgIGNvbnN0IGNvbnN1bWVyID0gbmV3IENvbnN1bWVyXzEuQ29uc3VtZXIoe1xuICAgICAgICAgICAgICAgIGlkLFxuICAgICAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICAgICAgcHJvZHVjZXJJZCxcbiAgICAgICAgICAgICAgICBydHBSZWNlaXZlcixcbiAgICAgICAgICAgICAgICB0cmFjayxcbiAgICAgICAgICAgICAgICBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGFwcERhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdGhpcy5fY29uc3VtZXJzLnNldChjb25zdW1lci5pZCwgY29uc3VtZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlQ29uc3VtZXIoY29uc3VtZXIpO1xuICAgICAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgdmlkZW8gQ29uc3VtZXIgYW5kIHRoZSBDb25zdW1lciBmb3IgUlRQIHByb2JhdGlvblxuICAgICAgICAgICAgLy8gaGFzIG5vdCB5ZXQgYmVlbiBjcmVhdGVkLCBjcmVhdGUgaXQgbm93LlxuICAgICAgICAgICAgaWYgKCF0aGlzLl9wcm9iYXRvckNvbnN1bWVyQ3JlYXRlZCAmJiBraW5kID09PSAndmlkZW8nKSB7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvYmF0b3JSdHBQYXJhbWV0ZXJzID0gb3J0Yy5nZW5lcmF0ZVByb2JhdG9yUnRwUGFyYW1ldGVycyhjb25zdW1lci5ydHBQYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5faGFuZGxlci5yZWNlaXZlKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRyYWNrSWQ6ICdwcm9iYXRvcicsXG4gICAgICAgICAgICAgICAgICAgICAgICBraW5kOiAndmlkZW8nLFxuICAgICAgICAgICAgICAgICAgICAgICAgcnRwUGFyYW1ldGVyczogcHJvYmF0b3JSdHBQYXJhbWV0ZXJzXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2NvbnN1bWUoKSB8IENvbnN1bWVyIGZvciBSVFAgcHJvYmF0aW9uIGNyZWF0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fcHJvYmF0b3JDb25zdW1lckNyZWF0ZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyLmVycm9yKCdjb25zdW1lKCkgfCBmYWlsZWQgdG8gY3JlYXRlIENvbnN1bWVyIGZvciBSVFAgcHJvYmF0aW9uOiVvJywgZXJyb3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgnbmV3Y29uc3VtZXInLCBjb25zdW1lcik7XG4gICAgICAgICAgICByZXR1cm4gY29uc3VtZXI7XG4gICAgICAgIH0sICd0cmFuc3BvcnQuY29uc3VtZSgpJyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZSBhIERhdGFQcm9kdWNlclxuICAgICAqL1xuICAgIGFzeW5jIHByb2R1Y2VEYXRhKHsgb3JkZXJlZCA9IHRydWUsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cywgbGFiZWwgPSAnJywgcHJvdG9jb2wgPSAnJywgYXBwRGF0YSA9IHt9IH0gPSB7fSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Byb2R1Y2VEYXRhKCknKTtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3NlbmQnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBhIHNlbmRpbmcgVHJhbnNwb3J0Jyk7XG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9tYXhTY3RwTWVzc2FnZVNpemUpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignU0NUUCBub3QgZW5hYmxlZCBieSByZW1vdGUgVHJhbnNwb3J0Jyk7XG4gICAgICAgIGVsc2UgaWYgKHRoaXMubGlzdGVuZXJDb3VudCgnY29ubmVjdCcpID09PSAwICYmIHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZSA9PT0gJ25ldycpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdubyBcImNvbm5lY3RcIiBsaXN0ZW5lciBzZXQgaW50byB0aGlzIHRyYW5zcG9ydCcpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ3Byb2R1Y2VkYXRhJykgPT09IDApXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdubyBcInByb2R1Y2VkYXRhXCIgbGlzdGVuZXIgc2V0IGludG8gdGhpcyB0cmFuc3BvcnQnKTtcbiAgICAgICAgZWxzZSBpZiAoYXBwRGF0YSAmJiB0eXBlb2YgYXBwRGF0YSAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpZiBnaXZlbiwgYXBwRGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICBpZiAobWF4UGFja2V0TGlmZVRpbWUgfHwgbWF4UmV0cmFuc21pdHMpXG4gICAgICAgICAgICBvcmRlcmVkID0gZmFsc2U7XG4gICAgICAgIC8vIEVucXVldWUgY29tbWFuZC5cbiAgICAgICAgcmV0dXJuIHRoaXMuX2F3YWl0UXVldWUucHVzaChhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICBjb25zdCB7IGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycyB9ID0gYXdhaXQgdGhpcy5faGFuZGxlci5zZW5kRGF0YUNoYW5uZWwoe1xuICAgICAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICAgICAgbGFiZWwsXG4gICAgICAgICAgICAgICAgcHJvdG9jb2xcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gVGhpcyB3aWxsIGZpbGwgc2N0cFN0cmVhbVBhcmFtZXRlcnMncyBtaXNzaW5nIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICAgICAgICAgICAgb3J0Yy52YWxpZGF0ZVNjdHBTdHJlYW1QYXJhbWV0ZXJzKHNjdHBTdHJlYW1QYXJhbWV0ZXJzKTtcbiAgICAgICAgICAgIGNvbnN0IHsgaWQgfSA9IGF3YWl0IHRoaXMuc2FmZUVtaXRBc1Byb21pc2UoJ3Byb2R1Y2VkYXRhJywge1xuICAgICAgICAgICAgICAgIHNjdHBTdHJlYW1QYXJhbWV0ZXJzLFxuICAgICAgICAgICAgICAgIGxhYmVsLFxuICAgICAgICAgICAgICAgIHByb3RvY29sLFxuICAgICAgICAgICAgICAgIGFwcERhdGFcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3QgZGF0YVByb2R1Y2VyID0gbmV3IERhdGFQcm9kdWNlcl8xLkRhdGFQcm9kdWNlcih7IGlkLCBkYXRhQ2hhbm5lbCwgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGFwcERhdGEgfSk7XG4gICAgICAgICAgICB0aGlzLl9kYXRhUHJvZHVjZXJzLnNldChkYXRhUHJvZHVjZXIuaWQsIGRhdGFQcm9kdWNlcik7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVEYXRhUHJvZHVjZXIoZGF0YVByb2R1Y2VyKTtcbiAgICAgICAgICAgIC8vIEVtaXQgb2JzZXJ2ZXIgZXZlbnQuXG4gICAgICAgICAgICB0aGlzLl9vYnNlcnZlci5zYWZlRW1pdCgnbmV3ZGF0YXByb2R1Y2VyJywgZGF0YVByb2R1Y2VyKTtcbiAgICAgICAgICAgIHJldHVybiBkYXRhUHJvZHVjZXI7XG4gICAgICAgIH0sICd0cmFuc3BvcnQucHJvZHVjZURhdGEoKScpO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYSBEYXRhQ29uc3VtZXJcbiAgICAgKi9cbiAgICBhc3luYyBjb25zdW1lRGF0YSh7IGlkLCBkYXRhUHJvZHVjZXJJZCwgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGxhYmVsID0gJycsIHByb3RvY29sID0gJycsIGFwcERhdGEgPSB7fSB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY29uc3VtZURhdGEoKScpO1xuICAgICAgICBzY3RwU3RyZWFtUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHNjdHBTdHJlYW1QYXJhbWV0ZXJzLCB1bmRlZmluZWQpO1xuICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKTtcbiAgICAgICAgZWxzZSBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAncmVjdicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGEgcmVjZWl2aW5nIFRyYW5zcG9ydCcpO1xuICAgICAgICBlbHNlIGlmICghdGhpcy5fbWF4U2N0cE1lc3NhZ2VTaXplKVxuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ1NDVFAgbm90IGVuYWJsZWQgYnkgcmVtb3RlIFRyYW5zcG9ydCcpO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgaWQgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBpZCcpO1xuICAgICAgICBlbHNlIGlmICh0eXBlb2YgZGF0YVByb2R1Y2VySWQgIT09ICdzdHJpbmcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBkYXRhUHJvZHVjZXJJZCcpO1xuICAgICAgICBlbHNlIGlmICh0aGlzLmxpc3RlbmVyQ291bnQoJ2Nvbm5lY3QnKSA9PT0gMCAmJiB0aGlzLl9jb25uZWN0aW9uU3RhdGUgPT09ICduZXcnKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gXCJjb25uZWN0XCIgbGlzdGVuZXIgc2V0IGludG8gdGhpcyB0cmFuc3BvcnQnKTtcbiAgICAgICAgZWxzZSBpZiAoYXBwRGF0YSAmJiB0eXBlb2YgYXBwRGF0YSAhPT0gJ29iamVjdCcpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpZiBnaXZlbiwgYXBwRGF0YSBtdXN0IGJlIGFuIG9iamVjdCcpO1xuICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgb3J0Yy52YWxpZGF0ZVNjdHBTdHJlYW1QYXJhbWV0ZXJzKHNjdHBTdHJlYW1QYXJhbWV0ZXJzKTtcbiAgICAgICAgLy8gRW5xdWV1ZSBjb21tYW5kLlxuICAgICAgICByZXR1cm4gdGhpcy5fYXdhaXRRdWV1ZS5wdXNoKGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IHsgZGF0YUNoYW5uZWwgfSA9IGF3YWl0IHRoaXMuX2hhbmRsZXIucmVjZWl2ZURhdGFDaGFubmVsKHtcbiAgICAgICAgICAgICAgICBzY3RwU3RyZWFtUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBsYWJlbCxcbiAgICAgICAgICAgICAgICBwcm90b2NvbFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBkYXRhQ29uc3VtZXIgPSBuZXcgRGF0YUNvbnN1bWVyXzEuRGF0YUNvbnN1bWVyKHtcbiAgICAgICAgICAgICAgICBpZCxcbiAgICAgICAgICAgICAgICBkYXRhUHJvZHVjZXJJZCxcbiAgICAgICAgICAgICAgICBkYXRhQ2hhbm5lbCxcbiAgICAgICAgICAgICAgICBzY3RwU3RyZWFtUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBhcHBEYXRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuX2RhdGFDb25zdW1lcnMuc2V0KGRhdGFDb25zdW1lci5pZCwgZGF0YUNvbnN1bWVyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhbmRsZURhdGFDb25zdW1lcihkYXRhQ29uc3VtZXIpO1xuICAgICAgICAgICAgLy8gRW1pdCBvYnNlcnZlciBldmVudC5cbiAgICAgICAgICAgIHRoaXMuX29ic2VydmVyLnNhZmVFbWl0KCduZXdkYXRhY29uc3VtZXInLCBkYXRhQ29uc3VtZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGRhdGFDb25zdW1lcjtcbiAgICAgICAgfSwgJ3RyYW5zcG9ydC5jb25zdW1lRGF0YSgpJyk7XG4gICAgfVxuICAgIF9oYW5kbGVIYW5kbGVyKCkge1xuICAgICAgICBjb25zdCBoYW5kbGVyID0gdGhpcy5faGFuZGxlcjtcbiAgICAgICAgaGFuZGxlci5vbignQGNvbm5lY3QnLCAoeyBkdGxzUGFyYW1ldGVycyB9LCBjYWxsYmFjaywgZXJyYmFjaykgPT4ge1xuICAgICAgICAgICAgaWYgKHRoaXMuX2Nsb3NlZCkge1xuICAgICAgICAgICAgICAgIGVycmJhY2sobmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5zYWZlRW1pdCgnY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSwgY2FsbGJhY2ssIGVycmJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgaGFuZGxlci5vbignQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsIChjb25uZWN0aW9uU3RhdGUpID0+IHtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uU3RhdGUgPT09IHRoaXMuX2Nvbm5lY3Rpb25TdGF0ZSlcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2Nvbm5lY3Rpb24gc3RhdGUgY2hhbmdlZCB0byAlcycsIGNvbm5lY3Rpb25TdGF0ZSk7XG4gICAgICAgICAgICB0aGlzLl9jb25uZWN0aW9uU3RhdGUgPSBjb25uZWN0aW9uU3RhdGU7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX2Nsb3NlZClcbiAgICAgICAgICAgICAgICB0aGlzLnNhZmVFbWl0KCdjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCBjb25uZWN0aW9uU3RhdGUpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2hhbmRsZVByb2R1Y2VyKHByb2R1Y2VyKSB7XG4gICAgICAgIHByb2R1Y2VyLm9uKCdAY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9wcm9kdWNlcnMuZGVsZXRlKHByb2R1Y2VyLmlkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5fYXdhaXRRdWV1ZS5wdXNoKGFzeW5jICgpID0+IHRoaXMuX2hhbmRsZXIuc3RvcFNlbmRpbmcocHJvZHVjZXIubG9jYWxJZCksICdwcm9kdWNlciBAY2xvc2UgZXZlbnQnKVxuICAgICAgICAgICAgICAgIC5jYXRjaCgoZXJyb3IpID0+IGxvZ2dlci53YXJuKCdwcm9kdWNlci5jbG9zZSgpIGZhaWxlZDolbycsIGVycm9yKSk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9kdWNlci5vbignQHJlcGxhY2V0cmFjaycsICh0cmFjaywgY2FsbGJhY2ssIGVycmJhY2spID0+IHtcbiAgICAgICAgICAgIHRoaXMuX2F3YWl0UXVldWUucHVzaChhc3luYyAoKSA9PiB0aGlzLl9oYW5kbGVyLnJlcGxhY2VUcmFjayhwcm9kdWNlci5sb2NhbElkLCB0cmFjayksICdwcm9kdWNlciBAcmVwbGFjZXRyYWNrIGV2ZW50JylcbiAgICAgICAgICAgICAgICAudGhlbihjYWxsYmFjaylcbiAgICAgICAgICAgICAgICAuY2F0Y2goZXJyYmFjayk7XG4gICAgICAgIH0pO1xuICAgICAgICBwcm9kdWNlci5vbignQHNldG1heHNwYXRpYWxsYXllcicsIChzcGF0aWFsTGF5ZXIsIGNhbGxiYWNrLCBlcnJiYWNrKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9hd2FpdFF1ZXVlLnB1c2goYXN5bmMgKCkgPT4gKHRoaXMuX2hhbmRsZXIuc2V0TWF4U3BhdGlhbExheWVyKHByb2R1Y2VyLmxvY2FsSWQsIHNwYXRpYWxMYXllcikpLCAncHJvZHVjZXIgQHNldG1heHNwYXRpYWxsYXllciBldmVudCcpXG4gICAgICAgICAgICAgICAgLnRoZW4oY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVycmJhY2spO1xuICAgICAgICB9KTtcbiAgICAgICAgcHJvZHVjZXIub24oJ0BzZXRydHBlbmNvZGluZ3BhcmFtZXRlcnMnLCAocGFyYW1zLCBjYWxsYmFjaywgZXJyYmFjaykgPT4ge1xuICAgICAgICAgICAgdGhpcy5fYXdhaXRRdWV1ZS5wdXNoKGFzeW5jICgpID0+ICh0aGlzLl9oYW5kbGVyLnNldFJ0cEVuY29kaW5nUGFyYW1ldGVycyhwcm9kdWNlci5sb2NhbElkLCBwYXJhbXMpKSwgJ3Byb2R1Y2VyIEBzZXRydHBlbmNvZGluZ3BhcmFtZXRlcnMgZXZlbnQnKVxuICAgICAgICAgICAgICAgIC50aGVuKGNhbGxiYWNrKVxuICAgICAgICAgICAgICAgIC5jYXRjaChlcnJiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHByb2R1Y2VyLm9uKCdAZ2V0c3RhdHMnLCAoY2FsbGJhY2ssIGVycmJhY2spID0+IHtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycmJhY2sobmV3IGVycm9yc18xLkludmFsaWRTdGF0ZUVycm9yKCdjbG9zZWQnKSk7XG4gICAgICAgICAgICB0aGlzLl9oYW5kbGVyLmdldFNlbmRlclN0YXRzKHByb2R1Y2VyLmxvY2FsSWQpXG4gICAgICAgICAgICAgICAgLnRoZW4oY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVycmJhY2spO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2hhbmRsZUNvbnN1bWVyKGNvbnN1bWVyKSB7XG4gICAgICAgIGNvbnN1bWVyLm9uKCdAY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9jb25zdW1lcnMuZGVsZXRlKGNvbnN1bWVyLmlkKTtcbiAgICAgICAgICAgIGlmICh0aGlzLl9jbG9zZWQpXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgdGhpcy5fYXdhaXRRdWV1ZS5wdXNoKGFzeW5jICgpID0+IHRoaXMuX2hhbmRsZXIuc3RvcFJlY2VpdmluZyhjb25zdW1lci5sb2NhbElkKSwgJ2NvbnN1bWVyIEBjbG9zZSBldmVudCcpXG4gICAgICAgICAgICAgICAgLmNhdGNoKCgpID0+IHsgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdW1lci5vbignQGdldHN0YXRzJywgKGNhbGxiYWNrLCBlcnJiYWNrKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5fY2xvc2VkKVxuICAgICAgICAgICAgICAgIHJldHVybiBlcnJiYWNrKG5ldyBlcnJvcnNfMS5JbnZhbGlkU3RhdGVFcnJvcignY2xvc2VkJykpO1xuICAgICAgICAgICAgdGhpcy5faGFuZGxlci5nZXRSZWNlaXZlclN0YXRzKGNvbnN1bWVyLmxvY2FsSWQpXG4gICAgICAgICAgICAgICAgLnRoZW4oY2FsbGJhY2spXG4gICAgICAgICAgICAgICAgLmNhdGNoKGVycmJhY2spO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2hhbmRsZURhdGFQcm9kdWNlcihkYXRhUHJvZHVjZXIpIHtcbiAgICAgICAgZGF0YVByb2R1Y2VyLm9uKCdAY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhUHJvZHVjZXJzLmRlbGV0ZShkYXRhUHJvZHVjZXIuaWQpO1xuICAgICAgICB9KTtcbiAgICB9XG4gICAgX2hhbmRsZURhdGFDb25zdW1lcihkYXRhQ29uc3VtZXIpIHtcbiAgICAgICAgZGF0YUNvbnN1bWVyLm9uKCdAY2xvc2UnLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGlzLl9kYXRhQ29uc3VtZXJzLmRlbGV0ZShkYXRhQ29uc3VtZXIuaWQpO1xuICAgICAgICB9KTtcbiAgICB9XG59XG5leHBvcnRzLlRyYW5zcG9ydCA9IFRyYW5zcG9ydDtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5JbnZhbGlkU3RhdGVFcnJvciA9IGV4cG9ydHMuVW5zdXBwb3J0ZWRFcnJvciA9IHZvaWQgMDtcbi8qKlxuICogRXJyb3IgaW5kaWNhdGluZyBub3Qgc3VwcG9ydCBmb3Igc29tZXRoaW5nLlxuICovXG5jbGFzcyBVbnN1cHBvcnRlZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xuICAgIGNvbnN0cnVjdG9yKG1lc3NhZ2UpIHtcbiAgICAgICAgc3VwZXIobWVzc2FnZSk7XG4gICAgICAgIHRoaXMubmFtZSA9ICdVbnN1cHBvcnRlZEVycm9yJztcbiAgICAgICAgaWYgKEVycm9yLmhhc093blByb3BlcnR5KCdjYXB0dXJlU3RhY2tUcmFjZScpKSAvLyBKdXN0IGluIFY4LlxuICAgICAgICAge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgVW5zdXBwb3J0ZWRFcnJvcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnN0YWNrID0gKG5ldyBFcnJvcihtZXNzYWdlKSkuc3RhY2s7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlVuc3VwcG9ydGVkRXJyb3IgPSBVbnN1cHBvcnRlZEVycm9yO1xuLyoqXG4gKiBFcnJvciBwcm9kdWNlZCB3aGVuIGNhbGxpbmcgYSBtZXRob2QgaW4gYW4gaW52YWxpZCBzdGF0ZS5cbiAqL1xuY2xhc3MgSW52YWxpZFN0YXRlRXJyb3IgZXh0ZW5kcyBFcnJvciB7XG4gICAgY29uc3RydWN0b3IobWVzc2FnZSkge1xuICAgICAgICBzdXBlcihtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5uYW1lID0gJ0ludmFsaWRTdGF0ZUVycm9yJztcbiAgICAgICAgaWYgKEVycm9yLmhhc093blByb3BlcnR5KCdjYXB0dXJlU3RhY2tUcmFjZScpKSAvLyBKdXN0IGluIFY4LlxuICAgICAgICAge1xuICAgICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UodGhpcywgSW52YWxpZFN0YXRlRXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdGFjayA9IChuZXcgRXJyb3IobWVzc2FnZSkpLnN0YWNrO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5JbnZhbGlkU3RhdGVFcnJvciA9IEludmFsaWRTdGF0ZUVycm9yO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaHJvbWU1NSA9IHZvaWQgMDtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwic2RwLXRyYW5zZm9ybVwiKSk7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vdXRpbHNcIikpO1xuY29uc3Qgb3J0YyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vb3J0Y1wiKSk7XG5jb25zdCBzZHBDb21tb25VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvY29tbW9uVXRpbHNcIikpO1xuY29uc3Qgc2RwUGxhbkJVdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvcGxhbkJVdGlsc1wiKSk7XG5jb25zdCBIYW5kbGVySW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9IYW5kbGVySW50ZXJmYWNlXCIpO1xuY29uc3QgUmVtb3RlU2RwXzEgPSByZXF1aXJlKFwiLi9zZHAvUmVtb3RlU2RwXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignQ2hyb21lNTUnKTtcbmNvbnN0IFNDVFBfTlVNX1NUUkVBTVMgPSB7IE9TOiAxMDI0LCBNSVM6IDEwMjQgfTtcbmNsYXNzIENocm9tZTU1IGV4dGVuZHMgSGFuZGxlckludGVyZmFjZV8xLkhhbmRsZXJJbnRlcmZhY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBMb2NhbCBzdHJlYW0gZm9yIHNlbmRpbmcuXG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgLy8gTWFwIG9mIHNlbmRpbmcgTWVkaWFTdHJlYW1UcmFja3MgaW5kZXhlZCBieSBsb2NhbElkLlxuICAgICAgICB0aGlzLl9tYXBTZW5kTG9jYWxJZFRyYWNrID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBOZXh0IHNlbmRpbmcgbG9jYWxJZC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRMb2NhbElkID0gMDtcbiAgICAgICAgLy8gTWFwIG9mIE1JRCwgUlRQIHBhcmFtZXRlcnMgYW5kIFJUQ1J0cFJlY2VpdmVyIGluZGV4ZWQgYnkgbG9jYWwgaWQuXG4gICAgICAgIC8vIFZhbHVlIGlzIGFuIE9iamVjdCB3aXRoIG1pZCwgcnRwUGFyYW1ldGVycyBhbmQgcnRwUmVjZWl2ZXIuXG4gICAgICAgIHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mbyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gV2hldGhlciBhIERhdGFDaGFubmVsIG09YXBwbGljYXRpb24gc2VjdGlvbiBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IGZhbHNlO1xuICAgICAgICAvLyBTZW5kaW5nIERhdGFDaGFubmVsIGlkIHZhbHVlIGNvdW50ZXIuIEluY3JlbWVudGVkIGZvciBlYWNoIG5ldyBEYXRhQ2hhbm5lbC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPSAwO1xuICAgICAgICAvLyBHb3QgdHJhbnNwb3J0IGxvY2FsIGFuZCByZW1vdGUgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBuZXcgQ2hyb21lNTUoKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnQ2hyb21lNTUnO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIC8vIENsb3NlIFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgICAgICBpZiAodGhpcy5fcGMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiAnYWxsJyxcbiAgICAgICAgICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICAgICAgICAgICAgcnRjcE11eFBvbGljeTogJ3JlcXVpcmUnLFxuICAgICAgICAgICAgc2RwU2VtYW50aWNzOiAncGxhbi1iJ1xuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgcGMuY3JlYXRlT2ZmZXIoe1xuICAgICAgICAgICAgICAgIG9mZmVyVG9SZWNlaXZlQXVkaW86IHRydWUsXG4gICAgICAgICAgICAgICAgb2ZmZXJUb1JlY2VpdmVWaWRlbzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgY29uc3Qgc2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVSdHBDYXBhYmlsaXRpZXMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0UnRwQ2FwYWJpbGl0aWVzKHsgc2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZVJ0cENhcGFiaWxpdGllcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG51bVN0cmVhbXM6IFNDVFBfTlVNX1NUUkVBTVNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcnVuKHsgZGlyZWN0aW9uLCBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgc2N0cFBhcmFtZXRlcnMsIGljZVNlcnZlcnMsIGljZVRyYW5zcG9ydFBvbGljeSwgYWRkaXRpb25hbFNldHRpbmdzLCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncnVuKCknKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAgPSBuZXcgUmVtb3RlU2RwXzEuUmVtb3RlU2RwKHtcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHBsYW5COiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZCA9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmQgPVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKE9iamVjdC5hc3NpZ24oeyBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzIHx8IFtdLCBpY2VUcmFuc3BvcnRQb2xpY3k6IGljZVRyYW5zcG9ydFBvbGljeSB8fCAnYWxsJywgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJywgc2RwU2VtYW50aWNzOiAncGxhbi1iJyB9LCBhZGRpdGlvbmFsU2V0dGluZ3MpLCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzKTtcbiAgICAgICAgLy8gSGFuZGxlIFJUQ1BlZXJDb25uZWN0aW9uIGNvbm5lY3Rpb24gc3RhdHVzLlxuICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNraW5nJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlSWNlU2VydmVycyhpY2VTZXJ2ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlSWNlU2VydmVycygpJyk7XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLl9wYy5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uaWNlU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgIHRoaXMuX3BjLnNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3RhcnRJY2UoaWNlUGFyYW1ldGVycykge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuICAgICAgICAvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCBuZXcgcmVtb3RlIElDRSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlSWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zcG9ydFN0YXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZCh7IHRyYWNrLCBlbmNvZGluZ3MsIGNvZGVjT3B0aW9ucywgY29kZWMgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIFtraW5kOiVzLCB0cmFjay5pZDolc10nLCB0cmFjay5raW5kLCB0cmFjay5pZCk7XG4gICAgICAgIGlmIChjb2RlYykge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3NlbmQoKSB8IGNvZGVjIHNlbGVjdGlvbiBpcyBub3QgYXZhaWxhYmxlIGluICVzIGhhbmRsZXInLCB0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuICAgICAgICB0aGlzLl9wYy5hZGRTdHJlYW0odGhpcy5fc2VuZFN0cmVhbSk7XG4gICAgICAgIGxldCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxldCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICBsZXQgb2ZmZXJNZWRpYU9iamVjdDtcbiAgICAgICAgY29uc3Qgc2VuZGluZ1J0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSwge30pO1xuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MgPVxuICAgICAgICAgICAgb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzKTtcbiAgICAgICAgY29uc3Qgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSwge30pO1xuICAgICAgICBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MgPVxuICAgICAgICAgICAgb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ3NlcnZlcicsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ3ZpZGVvJyAmJiBlbmNvZGluZ3MgJiYgZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgZW5hYmxpbmcgc2ltdWxjYXN0Jyk7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ3ZpZGVvJyk7XG4gICAgICAgICAgICBzZHBQbGFuQlV0aWxzLmFkZExlZ2FjeVNpbXVsY2FzdCh7XG4gICAgICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgICAgICB0cmFjayxcbiAgICAgICAgICAgICAgICBudW1TdHJlYW1zOiBlbmNvZGluZ3MubGVuZ3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gdHJhY2sua2luZCk7XG4gICAgICAgIC8vIFNldCBSVENQIENOQU1FLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lID1cbiAgICAgICAgICAgIHNkcENvbW1vblV0aWxzLmdldENuYW1lKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9XG4gICAgICAgICAgICBzZHBQbGFuQlV0aWxzLmdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QsIHRyYWNrIH0pO1xuICAgICAgICAvLyBDb21wbGV0ZSBlbmNvZGluZ3Mgd2l0aCBnaXZlbiB2YWx1ZXMuXG4gICAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nc1tpZHhdKVxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdLCBlbmNvZGluZ3NbaWR4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgVlA4IGFuZCB0aGVyZSBpcyBlZmZlY3RpdmUgc2ltdWxjYXN0LCBhZGQgc2NhbGFiaWxpdHlNb2RlIHRvIGVhY2hcbiAgICAgICAgLy8gZW5jb2RpbmcuXG4gICAgICAgIGlmIChzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby92cDgnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVuY29kaW5nIG9mIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncykge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9ICdTMVQzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZCh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGFuc3dlclJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgY29kZWNPcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSBTdHJpbmcodGhpcy5fbmV4dFNlbmRMb2NhbElkKTtcbiAgICAgICAgdGhpcy5fbmV4dFNlbmRMb2NhbElkKys7XG4gICAgICAgIC8vIEluc2VydCBpbnRvIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcFNlbmRMb2NhbElkVHJhY2suc2V0KGxvY2FsSWQsIHRyYWNrKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvY2FsSWQ6IGxvY2FsSWQsXG4gICAgICAgICAgICBydHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVyc1xuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFjayA9IHRoaXMuX21hcFNlbmRMb2NhbElkVHJhY2suZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYWNrKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCd0cmFjayBub3QgZm91bmQnKTtcbiAgICAgICAgdGhpcy5fbWFwU2VuZExvY2FsSWRUcmFjay5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0ucmVtb3ZlVHJhY2sodHJhY2spO1xuICAgICAgICB0aGlzLl9wYy5hZGRTdHJlYW0odGhpcy5fc2VuZFN0cmVhbSk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gTk9URTogSWYgdGhlcmUgYXJlIG5vIHNlbmRpbmcgdHJhY2tzLCBzZXRMb2NhbERlc2NyaXB0aW9uKCkgd2lsbCBmYWlsIHdpdGhcbiAgICAgICAgICAgIC8vIFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFubmVsc1wiLiBJZiBzbywgaWdub3JlIGl0LlxuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbmRTdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3N0b3BTZW5kaW5nKCkgfCBpZ25vcmluZyBleHBlY3RlZCBlcnJvciBkdWUgbm8gc2VuZGluZyB0cmFja3M6ICVzJywgZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlID09PSAnc3RhYmxlJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgcmVwbGFjZVRyYWNrKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBsb2NhbElkLCB0cmFjaykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyBzZXRNYXhTcGF0aWFsTGF5ZXIobG9jYWxJZCwgc3BhdGlhbExheWVyKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCcgbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyBzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMobG9jYWxJZCwgcGFyYW1zKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3Qgc3VwcG9ydGVkJyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyBnZXRTZW5kZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZERhdGFDaGFubmVsKHsgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCBsYWJlbCwgcHJvdG9jb2wgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdFRpbWU6IG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSW5jcmVhc2UgbmV4dCBpZC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPVxuICAgICAgICAgICAgKyt0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCAlIFNDVFBfTlVNX1NUUkVBTVMuTUlTO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIGFuc3dlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgICAgIC5maW5kKChtKSA9PiBtLnR5cGUgPT09ICdhcHBsaWNhdGlvbicpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdzZXJ2ZXInLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZFNjdHBBc3NvY2lhdGlvbih7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjdHBTdHJlYW1QYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgc3RyZWFtSWQ6IG9wdGlvbnMuaWQsXG4gICAgICAgICAgICBvcmRlcmVkOiBvcHRpb25zLm9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZTogb3B0aW9ucy5tYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzOiBvcHRpb25zLm1heFJldHJhbnNtaXRzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycyB9O1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlKHsgdHJhY2tJZCwga2luZCwgcnRwUGFyYW1ldGVycyB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgW3RyYWNrSWQ6JXMsIGtpbmQ6JXNdJywgdHJhY2tJZCwga2luZCk7XG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSB0cmFja0lkO1xuICAgICAgICBjb25zdCBtaWQgPSBraW5kO1xuICAgICAgICBjb25zdCBzdHJlYW1JZCA9IHJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmUoe1xuICAgICAgICAgICAgbWlkLFxuICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHN0cmVhbUlkLFxuICAgICAgICAgICAgdHJhY2tJZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgbGV0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgY29uc3QgYW5zd2VyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgLmZpbmQoKG0pID0+IFN0cmluZyhtLm1pZCkgPT09IG1pZCk7XG4gICAgICAgIC8vIE1heSBuZWVkIHRvIG1vZGlmeSBjb2RlYyBwYXJhbWV0ZXJzIGluIHRoZSBhbnN3ZXIgYmFzZWQgb24gY29kZWNcbiAgICAgICAgLy8gcGFyYW1ldGVycyBpbiB0aGUgb2ZmZXIuXG4gICAgICAgIHNkcENvbW1vblV0aWxzLmFwcGx5Q29kZWNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBjb25zdCBzdHJlYW0gPSB0aGlzLl9wYy5nZXRSZW1vdGVTdHJlYW1zKClcbiAgICAgICAgICAgIC5maW5kKChzKSA9PiBzLmlkID09PSBzdHJlYW1JZCk7XG4gICAgICAgIGNvbnN0IHRyYWNrID0gc3RyZWFtLmdldFRyYWNrQnlJZChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFjaylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigncmVtb3RlIHRyYWNrIG5vdCBmb3VuZCcpO1xuICAgICAgICAvLyBJbnNlcnQgaW50byB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8uc2V0KGxvY2FsSWQsIHsgbWlkLCBydHBQYXJhbWV0ZXJzIH0pO1xuICAgICAgICByZXR1cm4geyBsb2NhbElkLCB0cmFjayB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgeyBtaWQsIHJ0cFBhcmFtZXRlcnMgfSA9IHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5nZXQobG9jYWxJZCkgfHwge307XG4gICAgICAgIC8vIFJlbW92ZSBmcm9tIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5wbGFuQlN0b3BSZWNlaXZpbmcoeyBtaWQ6IG1pZCwgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzIH0pO1xuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIGdldFJlY2VpdmVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVEYXRhQ2hhbm5lbCh7IHNjdHBTdHJlYW1QYXJhbWV0ZXJzLCBsYWJlbCwgcHJvdG9jb2wgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtSWQsIG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cyB9ID0gc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdFRpbWU6IG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBvZmZlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmVTY3RwQXNzb2NpYXRpb24oeyBvbGREYXRhQ2hhbm5lbFNwZWM6IHRydWUgfSk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwgfTtcbiAgICB9XG4gICAgYXN5bmMgX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZSwgbG9jYWxTZHBPYmplY3QgfSkge1xuICAgICAgICBpZiAoIWxvY2FsU2RwT2JqZWN0KVxuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cbiAgICAgICAgY29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoeyBzZHBPYmplY3Q6IGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAvLyBTZXQgb3VyIERUTFMgcm9sZS5cbiAgICAgICAgZHRsc1BhcmFtZXRlcnMucm9sZSA9IGxvY2FsRHRsc1JvbGU7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtb3RlIERUTFMgcm9sZSBpbiB0aGUgU0RQLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlRHRsc1JvbGUobG9jYWxEdGxzUm9sZSA9PT0gJ2NsaWVudCcgPyAnc2VydmVyJyA6ICdjbGllbnQnKTtcbiAgICAgICAgLy8gTmVlZCB0byB0ZWxsIHRoZSByZW1vdGUgdHJhbnNwb3J0IGFib3V0IG91ciBwYXJhbWV0ZXJzLlxuICAgICAgICBhd2FpdCB0aGlzLnNhZmVFbWl0QXNQcm9taXNlKCdAY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgX2Fzc2VydFNlbmREaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdzZW5kJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwic2VuZFwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hc3NlcnRSZWN2RGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAncmVjdicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInJlY3ZcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQ2hyb21lNTUgPSBDaHJvbWU1NTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuQ2hyb21lNjcgPSB2b2lkIDA7XG5jb25zdCBzZHBUcmFuc2Zvcm0gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInNkcC10cmFuc2Zvcm1cIikpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyXCIpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3V0aWxzXCIpKTtcbmNvbnN0IG9ydGMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL29ydGNcIikpO1xuY29uc3Qgc2RwQ29tbW9uVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL2NvbW1vblV0aWxzXCIpKTtcbmNvbnN0IHNkcFBsYW5CVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL3BsYW5CVXRpbHNcIikpO1xuY29uc3QgSGFuZGxlckludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vSGFuZGxlckludGVyZmFjZVwiKTtcbmNvbnN0IFJlbW90ZVNkcF8xID0gcmVxdWlyZShcIi4vc2RwL1JlbW90ZVNkcFwiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ0Nocm9tZTY3Jyk7XG5jb25zdCBTQ1RQX05VTV9TVFJFQU1TID0geyBPUzogMTAyNCwgTUlTOiAxMDI0IH07XG5jbGFzcyBDaHJvbWU2NyBleHRlbmRzIEhhbmRsZXJJbnRlcmZhY2VfMS5IYW5kbGVySW50ZXJmYWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gTG9jYWwgc3RyZWFtIGZvciBzZW5kaW5nLlxuICAgICAgICB0aGlzLl9zZW5kU3RyZWFtID0gbmV3IE1lZGlhU3RyZWFtKCk7XG4gICAgICAgIC8vIE1hcCBvZiBSVENSdHBTZW5kZXIgaW5kZXhlZCBieSBsb2NhbElkLlxuICAgICAgICB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlciA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTmV4dCBzZW5kaW5nIGxvY2FsSWQuXG4gICAgICAgIHRoaXMuX25leHRTZW5kTG9jYWxJZCA9IDA7XG4gICAgICAgIC8vIE1hcCBvZiBNSUQsIFJUUCBwYXJhbWV0ZXJzIGFuZCBSVENSdHBSZWNlaXZlciBpbmRleGVkIGJ5IGxvY2FsIGlkLlxuICAgICAgICAvLyBWYWx1ZSBpcyBhbiBPYmplY3Qgd2l0aCBtaWQsIHJ0cFBhcmFtZXRlcnMgYW5kIHJ0cFJlY2VpdmVyLlxuICAgICAgICB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8gPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIFdoZXRoZXIgYSBEYXRhQ2hhbm5lbCBtPWFwcGxpY2F0aW9uIHNlY3Rpb24gaGFzIGJlZW4gY3JlYXRlZC5cbiAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSBmYWxzZTtcbiAgICAgICAgLy8gU2VuZGluZyBEYXRhQ2hhbm5lbCBpZCB2YWx1ZSBjb3VudGVyLiBJbmNyZW1lbnRlZCBmb3IgZWFjaCBuZXcgRGF0YUNoYW5uZWwuXG4gICAgICAgIHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkID0gMDtcbiAgICAgICAgLy8gR290IHRyYW5zcG9ydCBsb2NhbCBhbmQgcmVtb3RlIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGYWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gbmV3IENocm9tZTY3KCk7XG4gICAgfVxuICAgIGdldCBuYW1lKCkge1xuICAgICAgICByZXR1cm4gJ0Nocm9tZTY3JztcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICAvLyBDbG9zZSBSVENQZWVyQ29ubmVjdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuX3BjKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICBjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyxcbiAgICAgICAgICAgIHNkcFNlbWFudGljczogJ3BsYW4tYidcbiAgICAgICAgfSk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHBjLmNyZWF0ZU9mZmVyKHtcbiAgICAgICAgICAgICAgICBvZmZlclRvUmVjZWl2ZUF1ZGlvOiB0cnVlLFxuICAgICAgICAgICAgICAgIG9mZmVyVG9SZWNlaXZlVmlkZW86IHRydWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIGNvbnN0IHNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3QgbmF0aXZlUnRwQ2FwYWJpbGl0aWVzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdFJ0cENhcGFiaWxpdGllcyh7IHNkcE9iamVjdCB9KTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVSdHBDYXBhYmlsaXRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IyKSB7IH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBudW1TdHJlYW1zOiBTQ1RQX05VTV9TVFJFQU1TXG4gICAgICAgIH07XG4gICAgfVxuICAgIHJ1bih7IGRpcmVjdGlvbiwgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3ksIGFkZGl0aW9uYWxTZXR0aW5ncywgcHJvcHJpZXRhcnlDb25zdHJhaW50cywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMgfSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3J1bigpJyk7XG4gICAgICAgIHRoaXMuX2RpcmVjdGlvbiA9IGRpcmVjdGlvbjtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwID0gbmV3IFJlbW90ZVNkcF8xLlJlbW90ZVNkcCh7XG4gICAgICAgICAgICBpY2VQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgaWNlQ2FuZGlkYXRlcyxcbiAgICAgICAgICAgIGR0bHNQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc2N0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBwbGFuQjogdHJ1ZVxuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmQgPVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kID1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG4gICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihPYmplY3QuYXNzaWduKHsgaWNlU2VydmVyczogaWNlU2VydmVycyB8fCBbXSwgaWNlVHJhbnNwb3J0UG9saWN5OiBpY2VUcmFuc3BvcnRQb2xpY3kgfHwgJ2FsbCcsIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLCBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsIHNkcFNlbWFudGljczogJ3BsYW4tYicgfSwgYWRkaXRpb25hbFNldHRpbmdzKSwgcHJvcHJpZXRhcnlDb25zdHJhaW50cyk7XG4gICAgICAgIC8vIEhhbmRsZSBSVENQZWVyQ29ubmVjdGlvbiBjb25uZWN0aW9uIHN0YXR1cy5cbiAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wYy5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjaGVja2luZyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUljZVNlcnZlcnMoaWNlU2VydmVycykge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3VwZGF0ZUljZVNlcnZlcnMoKScpO1xuICAgICAgICBjb25zdCBjb25maWd1cmF0aW9uID0gdGhpcy5fcGMuZ2V0Q29uZmlndXJhdGlvbigpO1xuICAgICAgICBjb25maWd1cmF0aW9uLmljZVNlcnZlcnMgPSBpY2VTZXJ2ZXJzO1xuICAgICAgICB0aGlzLl9wYy5zZXRDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgICBhc3luYyByZXN0YXJ0SWNlKGljZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCknKTtcbiAgICAgICAgLy8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggbmV3IHJlbW90ZSBJQ0UgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUljZVBhcmFtZXRlcnMoaWNlUGFyYW1ldGVycyk7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gPT09ICdzZW5kJykge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcih7IGljZVJlc3RhcnQ6IHRydWUgfSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc3BvcnRTdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQoeyB0cmFjaywgZW5jb2RpbmdzLCBjb2RlY09wdGlvbnMsIGNvZGVjIH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSBba2luZDolcywgdHJhY2suaWQ6JXNdJywgdHJhY2sua2luZCwgdHJhY2suaWQpO1xuICAgICAgICBpZiAoY29kZWMpIHtcbiAgICAgICAgICAgIGxvZ2dlci53YXJuKCdzZW5kKCkgfCBjb2RlYyBzZWxlY3Rpb24gaXMgbm90IGF2YWlsYWJsZSBpbiAlcyBoYW5kbGVyJywgdGhpcy5uYW1lKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9zZW5kU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgICAgICAgdGhpcy5fcGMuYWRkVHJhY2sodHJhY2ssIHRoaXMuX3NlbmRTdHJlYW0pO1xuICAgICAgICBsZXQgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsZXQgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgbGV0IG9mZmVyTWVkaWFPYmplY3Q7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0sIHt9KTtcbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzID1cbiAgICAgICAgICAgIG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyk7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0sIHt9KTtcbiAgICAgICAgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzID1cbiAgICAgICAgICAgIG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcyk7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdzZXJ2ZXInLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgaWYgKHRyYWNrLmtpbmQgPT09ICd2aWRlbycgJiYgZW5jb2RpbmdzICYmIGVuY29kaW5ncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGVuYWJsaW5nIHNpbXVsY2FzdCcpO1xuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgICAgIC5maW5kKChtKSA9PiBtLnR5cGUgPT09ICd2aWRlbycpO1xuICAgICAgICAgICAgc2RwUGxhbkJVdGlscy5hZGRMZWdhY3lTaW11bGNhc3Qoe1xuICAgICAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICAgICAgdHJhY2ssXG4gICAgICAgICAgICAgICAgbnVtU3RyZWFtczogZW5jb2RpbmdzLmxlbmd0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWFcbiAgICAgICAgICAgIC5maW5kKChtKSA9PiBtLnR5cGUgPT09IHRyYWNrLmtpbmQpO1xuICAgICAgICAvLyBTZXQgUlRDUCBDTkFNRS5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSA9XG4gICAgICAgICAgICBzZHBDb21tb25VdGlscy5nZXRDbmFtZSh7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgIC8vIFNldCBSVFAgZW5jb2RpbmdzLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPVxuICAgICAgICAgICAgc2RwUGxhbkJVdGlscy5nZXRSdHBFbmNvZGluZ3MoeyBvZmZlck1lZGlhT2JqZWN0LCB0cmFjayB9KTtcbiAgICAgICAgLy8gQ29tcGxldGUgZW5jb2RpbmdzIHdpdGggZ2l2ZW4gdmFsdWVzLlxuICAgICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MubGVuZ3RoOyArK2lkeCkge1xuICAgICAgICAgICAgICAgIGlmIChlbmNvZGluZ3NbaWR4XSlcbiAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmFzc2lnbihzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3NbaWR4XSwgZW5jb2RpbmdzW2lkeF0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIElmIFZQOCBhbmQgdGhlcmUgaXMgZWZmZWN0aXZlIHNpbXVsY2FzdCwgYWRkIHNjYWxhYmlsaXR5TW9kZSB0byBlYWNoXG4gICAgICAgIC8vIGVuY29kaW5nLlxuICAgICAgICBpZiAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjc1swXS5taW1lVHlwZS50b0xvd2VyQ2FzZSgpID09PSAndmlkZW8vdnA4Jykge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSAnUzFUMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmQoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvZGVjT3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBjb25zdCBsb2NhbElkID0gU3RyaW5nKHRoaXMuX25leHRTZW5kTG9jYWxJZCk7XG4gICAgICAgIHRoaXMuX25leHRTZW5kTG9jYWxJZCsrO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9wYy5nZXRTZW5kZXJzKClcbiAgICAgICAgICAgIC5maW5kKChzKSA9PiBzLnRyYWNrID09PSB0cmFjayk7XG4gICAgICAgIC8vIEluc2VydCBpbnRvIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLnNldChsb2NhbElkLCBydHBTZW5kZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYWxJZDogbG9jYWxJZCxcbiAgICAgICAgICAgIHJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcnRwU2VuZGVyXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHN0b3BTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB0aGlzLl9wYy5yZW1vdmVUcmFjayhydHBTZW5kZXIpO1xuICAgICAgICBpZiAocnRwU2VuZGVyLnRyYWNrKVxuICAgICAgICAgICAgdGhpcy5fc2VuZFN0cmVhbS5yZW1vdmVUcmFjayhydHBTZW5kZXIudHJhY2spO1xuICAgICAgICB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gTk9URTogSWYgdGhlcmUgYXJlIG5vIHNlbmRpbmcgdHJhY2tzLCBzZXRMb2NhbERlc2NyaXB0aW9uKCkgd2lsbCBmYWlsIHdpdGhcbiAgICAgICAgICAgIC8vIFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFubmVsc1wiLiBJZiBzbywgaWdub3JlIGl0LlxuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbmRTdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3N0b3BTZW5kaW5nKCkgfCBpZ25vcmluZyBleHBlY3RlZCBlcnJvciBkdWUgbm8gc2VuZGluZyB0cmFja3M6ICVzJywgZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlID09PSAnc3RhYmxlJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgcmVwbGFjZVRyYWNrKGxvY2FsSWQsIHRyYWNrKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCB0cmFjay5pZDolc10nLCBsb2NhbElkLCB0cmFjay5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCBubyB0cmFja10nLCBsb2NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgY29uc3Qgb2xkVHJhY2sgPSBydHBTZW5kZXIudHJhY2s7XG4gICAgICAgIGF3YWl0IHJ0cFNlbmRlci5yZXBsYWNlVHJhY2sodHJhY2spO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIG9sZCB0cmFjayBmcm9tIHRoZSBsb2NhbCBzdHJlYW0uXG4gICAgICAgIGlmIChvbGRUcmFjaylcbiAgICAgICAgICAgIHRoaXMuX3NlbmRTdHJlYW0ucmVtb3ZlVHJhY2sob2xkVHJhY2spO1xuICAgICAgICAvLyBBZGQgdGhlIG5ldyB0cmFjayB0byB0aGUgbG9jYWwgc3RyZWFtLlxuICAgICAgICBpZiAodHJhY2spXG4gICAgICAgICAgICB0aGlzLl9zZW5kU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0TWF4U3BhdGlhbExheWVyKGxvY2FsSWQsIHNwYXRpYWxMYXllcikge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgW2xvY2FsSWQ6JXMsIHNwYXRpYWxMYXllcjolc10nLCBsb2NhbElkLCBzcGF0aWFsTGF5ZXIpO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHJ0cFNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmIChpZHggPD0gc3BhdGlhbExheWVyKVxuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBydHBTZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKGxvY2FsSWQsIHBhcmFtcykge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgW2xvY2FsSWQ6JXMsIHBhcmFtczolb10nLCBsb2NhbElkLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHJ0cFNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVuY29kaW5nKSwgcGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJ0cFNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTZW5kZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fbWFwU2VuZExvY2FsSWRSdHBTZW5kZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFNlbmRlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBTZW5kZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiBydHBTZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZERhdGFDaGFubmVsKHsgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCBsYWJlbCwgcHJvdG9jb2wgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdFRpbWU6IG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSW5jcmVhc2UgbmV4dCBpZC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPVxuICAgICAgICAgICAgKyt0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCAlIFNDVFBfTlVNX1NUUkVBTVMuTUlTO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIGFuc3dlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgICAgIC5maW5kKChtKSA9PiBtLnR5cGUgPT09ICdhcHBsaWNhdGlvbicpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdzZXJ2ZXInLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZFNjdHBBc3NvY2lhdGlvbih7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjdHBTdHJlYW1QYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgc3RyZWFtSWQ6IG9wdGlvbnMuaWQsXG4gICAgICAgICAgICBvcmRlcmVkOiBvcHRpb25zLm9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZTogb3B0aW9ucy5tYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzOiBvcHRpb25zLm1heFJldHJhbnNtaXRzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycyB9O1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlKHsgdHJhY2tJZCwga2luZCwgcnRwUGFyYW1ldGVycyB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgW3RyYWNrSWQ6JXMsIGtpbmQ6JXNdJywgdHJhY2tJZCwga2luZCk7XG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSB0cmFja0lkO1xuICAgICAgICBjb25zdCBtaWQgPSBraW5kO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZSh7XG4gICAgICAgICAgICBtaWQsXG4gICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc3RyZWFtSWQ6IHJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSxcbiAgICAgICAgICAgIHRyYWNrSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGxldCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UoYW5zd2VyLnNkcCk7XG4gICAgICAgIGNvbnN0IGFuc3dlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWFcbiAgICAgICAgICAgIC5maW5kKChtKSA9PiBTdHJpbmcobS5taWQpID09PSBtaWQpO1xuICAgICAgICAvLyBNYXkgbmVlZCB0byBtb2RpZnkgY29kZWMgcGFyYW1ldGVycyBpbiB0aGUgYW5zd2VyIGJhc2VkIG9uIGNvZGVjXG4gICAgICAgIC8vIHBhcmFtZXRlcnMgaW4gdGhlIG9mZmVyLlxuICAgICAgICBzZHBDb21tb25VdGlscy5hcHBseUNvZGVjUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJNZWRpYU9iamVjdFxuICAgICAgICB9KTtcbiAgICAgICAgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdjbGllbnQnLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgY29uc3QgcnRwUmVjZWl2ZXIgPSB0aGlzLl9wYy5nZXRSZWNlaXZlcnMoKVxuICAgICAgICAgICAgLmZpbmQoKHIpID0+IHIudHJhY2sgJiYgci50cmFjay5pZCA9PT0gbG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwUmVjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25ldyBSVENSdHBSZWNlaXZlciBub3QnKTtcbiAgICAgICAgLy8gSW5zZXJ0IGludG8gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvLnNldChsb2NhbElkLCB7IG1pZCwgcnRwUGFyYW1ldGVycywgcnRwUmVjZWl2ZXIgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgdHJhY2s6IHJ0cFJlY2VpdmVyLnRyYWNrLFxuICAgICAgICAgICAgcnRwUmVjZWl2ZXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcFJlY2VpdmluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHsgbWlkLCBydHBQYXJhbWV0ZXJzIH0gPSB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8uZ2V0KGxvY2FsSWQpIHx8IHt9O1xuICAgICAgICAvLyBSZW1vdmUgZnJvbSB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8uZGVsZXRlKGxvY2FsSWQpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAucGxhbkJTdG9wUmVjZWl2aW5nKHsgbWlkOiBtaWQsIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyB9KTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlY2VpdmVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgcnRwUmVjZWl2ZXIgfSA9IHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5nZXQobG9jYWxJZCkgfHwge307XG4gICAgICAgIGlmICghcnRwUmVjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwUmVjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiBydHBSZWNlaXZlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlRGF0YUNoYW5uZWwoeyBzY3RwU3RyZWFtUGFyYW1ldGVycywgbGFiZWwsIHByb3RvY29sIH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB7IHN0cmVhbUlkLCBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMgfSA9IHNjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRUaW1lOiBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2xcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgb2ZmZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlU2N0cEFzc29jaWF0aW9uKHsgb2xkRGF0YUNoYW5uZWxTcGVjOiB0cnVlIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdjbGllbnQnLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsIH07XG4gICAgfVxuICAgIGFzeW5jIF9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGUsIGxvY2FsU2RwT2JqZWN0IH0pIHtcbiAgICAgICAgaWYgKCFsb2NhbFNkcE9iamVjdClcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgLy8gR2V0IG91ciBsb2NhbCBEVExTIHBhcmFtZXRlcnMuXG4gICAgICAgIGNvbnN0IGR0bHNQYXJhbWV0ZXJzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdER0bHNQYXJhbWV0ZXJzKHsgc2RwT2JqZWN0OiBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgLy8gU2V0IG91ciBEVExTIHJvbGUuXG4gICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPSBsb2NhbER0bHNSb2xlO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbW90ZSBEVExTIHJvbGUgaW4gdGhlIFNEUC5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUR0bHNSb2xlKGxvY2FsRHRsc1JvbGUgPT09ICdjbGllbnQnID8gJ3NlcnZlcicgOiAnY2xpZW50Jyk7XG4gICAgICAgIC8vIE5lZWQgdG8gdGVsbCB0aGUgcmVtb3RlIHRyYW5zcG9ydCBhYm91dCBvdXIgcGFyYW1ldGVycy5cbiAgICAgICAgYXdhaXQgdGhpcy5zYWZlRW1pdEFzUHJvbWlzZSgnQGNvbm5lY3QnLCB7IGR0bHNQYXJhbWV0ZXJzIH0pO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IHRydWU7XG4gICAgfVxuICAgIF9hc3NlcnRTZW5kRGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInNlbmRcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYXNzZXJ0UmVjdkRpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3JlY3YnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJyZWN2XCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLkNocm9tZTY3ID0gQ2hyb21lNjc7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkNocm9tZTcwID0gdm9pZCAwO1xuY29uc3Qgc2RwVHJhbnNmb3JtID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJzZHAtdHJhbnNmb3JtXCIpKTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4uL0xvZ2dlclwiKTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi91dGlsc1wiKSk7XG5jb25zdCBvcnRjID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9vcnRjXCIpKTtcbmNvbnN0IHNkcENvbW1vblV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NkcC9jb21tb25VdGlsc1wiKSk7XG5jb25zdCBzZHBVbmlmaWVkUGxhblV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NkcC91bmlmaWVkUGxhblV0aWxzXCIpKTtcbmNvbnN0IEhhbmRsZXJJbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL0hhbmRsZXJJbnRlcmZhY2VcIik7XG5jb25zdCBSZW1vdGVTZHBfMSA9IHJlcXVpcmUoXCIuL3NkcC9SZW1vdGVTZHBcIik7XG5jb25zdCBzY2FsYWJpbGl0eU1vZGVzXzEgPSByZXF1aXJlKFwiLi4vc2NhbGFiaWxpdHlNb2Rlc1wiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ0Nocm9tZTcwJyk7XG5jb25zdCBTQ1RQX05VTV9TVFJFQU1TID0geyBPUzogMTAyNCwgTUlTOiAxMDI0IH07XG5jbGFzcyBDaHJvbWU3MCBleHRlbmRzIEhhbmRsZXJJbnRlcmZhY2VfMS5IYW5kbGVySW50ZXJmYWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gTWFwIG9mIFJUQ1RyYW5zY2VpdmVycyBpbmRleGVkIGJ5IE1JRC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExvY2FsIHN0cmVhbSBmb3Igc2VuZGluZy5cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAvLyBXaGV0aGVyIGEgRGF0YUNoYW5uZWwgbT1hcHBsaWNhdGlvbiBzZWN0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFNlbmRpbmcgRGF0YUNoYW5uZWwgaWQgdmFsdWUgY291bnRlci4gSW5jcmVtZW50ZWQgZm9yIGVhY2ggbmV3IERhdGFDaGFubmVsLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9IDA7XG4gICAgICAgIC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBDaHJvbWU3MCgpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdDaHJvbWU3MCc7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgLy8gQ2xvc2UgUlRDUGVlckNvbm5lY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLl9wYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICd1bmlmaWVkLXBsYW4nXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJyk7XG4gICAgICAgICAgICBwYy5hZGRUcmFuc2NlaXZlcigndmlkZW8nKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICBjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoeyBzZHBPYmplY3QgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlUnRwQ2FwYWJpbGl0aWVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yMikgeyB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbnVtU3RyZWFtczogU0NUUF9OVU1fU1RSRUFNU1xuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZCA9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmQgPVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKE9iamVjdC5hc3NpZ24oeyBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzIHx8IFtdLCBpY2VUcmFuc3BvcnRQb2xpY3k6IGljZVRyYW5zcG9ydFBvbGljeSB8fCAnYWxsJywgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJywgc2RwU2VtYW50aWNzOiAndW5pZmllZC1wbGFuJyB9LCBhZGRpdGlvbmFsU2V0dGluZ3MpLCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzKTtcbiAgICAgICAgLy8gSGFuZGxlIFJUQ1BlZXJDb25uZWN0aW9uIGNvbm5lY3Rpb24gc3RhdHVzLlxuICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNraW5nJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlSWNlU2VydmVycyhpY2VTZXJ2ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlSWNlU2VydmVycygpJyk7XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLl9wYy5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uaWNlU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgIHRoaXMuX3BjLnNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3RhcnRJY2UoaWNlUGFyYW1ldGVycykge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuICAgICAgICAvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCBuZXcgcmVtb3RlIElDRSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlSWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zcG9ydFN0YXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZCh7IHRyYWNrLCBlbmNvZGluZ3MsIGNvZGVjT3B0aW9ucywgY29kZWMgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIFtraW5kOiVzLCB0cmFjay5pZDolc10nLCB0cmFjay5raW5kLCB0cmFjay5pZCk7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0sIHt9KTtcbiAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9XG4gICAgICAgICAgICBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MsIGNvZGVjKTtcbiAgICAgICAgY29uc3Qgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSwge30pO1xuICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzID1cbiAgICAgICAgICAgIG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb25JZHggPSB0aGlzLl9yZW1vdGVTZHAuZ2V0TmV4dE1lZGlhU2VjdGlvbklkeCgpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX3BjLmFkZFRyYW5zY2VpdmVyKHRyYWNrLCB7IGRpcmVjdGlvbjogJ3NlbmRvbmx5Jywgc3RyZWFtczogW3RoaXMuX3NlbmRTdHJlYW1dIH0pO1xuICAgICAgICBsZXQgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsZXQgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgbGV0IG9mZmVyTWVkaWFPYmplY3Q7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdzZXJ2ZXInLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgaWYgKGVuY29kaW5ncyAmJiBlbmNvZGluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBlbmFibGluZyBsZWdhY3kgc2ltdWxjYXN0Jyk7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW21lZGlhU2VjdGlvbklkeC5pZHhdO1xuICAgICAgICAgICAgc2RwVW5pZmllZFBsYW5VdGlscy5hZGRMZWdhY3lTaW11bGNhc3Qoe1xuICAgICAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICAgICAgbnVtU3RyZWFtczogZW5jb2RpbmdzLmxlbmd0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BlY2lhbCBjYXNlIGZvciBWUDkgd2l0aCBTVkMuXG4gICAgICAgIGxldCBoYWNrVnA5U3ZjID0gZmFsc2U7XG4gICAgICAgIGNvbnN0IGxheWVycyA9IHNjYWxhYmlsaXR5TW9kZXNfMS5wYXJzZSgoZW5jb2RpbmdzIHx8IFt7fV0pWzBdLnNjYWxhYmlsaXR5TW9kZSk7XG4gICAgICAgIGlmIChlbmNvZGluZ3MgJiZcbiAgICAgICAgICAgIGVuY29kaW5ncy5sZW5ndGggPT09IDEgJiZcbiAgICAgICAgICAgIGxheWVycy5zcGF0aWFsTGF5ZXJzID4gMSAmJlxuICAgICAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby92cDknKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGVuYWJsaW5nIGxlZ2FjeSBzaW11bGNhc3QgZm9yIFZQOSBTVkMnKTtcbiAgICAgICAgICAgIGhhY2tWcDlTdmMgPSB0cnVlO1xuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVttZWRpYVNlY3Rpb25JZHguaWR4XTtcbiAgICAgICAgICAgIHNkcFVuaWZpZWRQbGFuVXRpbHMuYWRkTGVnYWN5U2ltdWxjYXN0KHtcbiAgICAgICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgICAgIG51bVN0cmVhbXM6IGxheWVycy5zcGF0aWFsTGF5ZXJzXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAvLyBJZiBlbmNvZGluZ3MgYXJlIGdpdmVuLCBhcHBseSB0aGVtIG5vdy5cbiAgICAgICAgaWYgKGVuY29kaW5ncykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBhcHBseWluZyBnaXZlbiBlbmNvZGluZ3MnKTtcbiAgICAgICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgKHBhcmFtZXRlcnMuZW5jb2RpbmdzIHx8IFtdKS5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZW5jb2RpbmcgPSBwYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdO1xuICAgICAgICAgICAgICAgIGNvbnN0IGRlc2lyZWRFbmNvZGluZyA9IGVuY29kaW5nc1tpZHhdO1xuICAgICAgICAgICAgICAgIC8vIFNob3VsZCBub3QgaGFwcGVuIGJ1dCBqdXN0IGluIGNhc2UuXG4gICAgICAgICAgICAgICAgaWYgKCFkZXNpcmVkRW5jb2RpbmcpXG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0gPSBPYmplY3QuYXNzaWduKGVuY29kaW5nLCBkZXNpcmVkRW5jb2RpbmcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gV2UgY2FuIG5vdyBnZXQgdGhlIHRyYW5zY2VpdmVyLm1pZC5cbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IHRyYW5zY2VpdmVyLm1pZDtcbiAgICAgICAgLy8gU2V0IE1JRC5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMubWlkID0gbG9jYWxJZDtcbiAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWFbbWVkaWFTZWN0aW9uSWR4LmlkeF07XG4gICAgICAgIC8vIFNldCBSVENQIENOQU1FLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lID1cbiAgICAgICAgICAgIHNkcENvbW1vblV0aWxzLmdldENuYW1lKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9XG4gICAgICAgICAgICBzZHBVbmlmaWVkUGxhblV0aWxzLmdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgIC8vIENvbXBsZXRlIGVuY29kaW5ncyB3aXRoIGdpdmVuIHZhbHVlcy5cbiAgICAgICAgaWYgKGVuY29kaW5ncykge1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2RpbmdzW2lkeF0pXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0sIGVuY29kaW5nc1tpZHhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBIYWNrIGZvciBWUDkgU1ZDLlxuICAgICAgICBpZiAoaGFja1ZwOVN2Yykge1xuICAgICAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzID0gW3NlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5nc1swXV07XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgVlA4IG9yIEgyNjQgYW5kIHRoZXJlIGlzIGVmZmVjdGl2ZSBzaW11bGNhc3QsIGFkZCBzY2FsYWJpbGl0eU1vZGUgdG9cbiAgICAgICAgLy8gZWFjaCBlbmNvZGluZy5cbiAgICAgICAgaWYgKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5sZW5ndGggPiAxICYmXG4gICAgICAgICAgICAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby92cDgnIHx8XG4gICAgICAgICAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby9oMjY0JykpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZW5jb2Rpbmcgb2Ygc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICAgICAgZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlID0gJ1MxVDMnO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kKHtcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICByZXVzZU1pZDogbWVkaWFTZWN0aW9uSWR4LnJldXNlTWlkLFxuICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGFuc3dlclJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgY29kZWNPcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIC8vIFN0b3JlIGluIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNldChsb2NhbElkLCB0cmFuc2NlaXZlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgcnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBydHBTZW5kZXI6IHRyYW5zY2VpdmVyLnNlbmRlclxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZGVyLnJlcGxhY2VUcmFjayhudWxsKTtcbiAgICAgICAgdGhpcy5fcGMucmVtb3ZlVHJhY2sodHJhbnNjZWl2ZXIuc2VuZGVyKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLmNsb3NlTWVkaWFTZWN0aW9uKHRyYW5zY2VpdmVyLm1pZCk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHJlcGxhY2VUcmFjayhsb2NhbElkLCB0cmFjaykge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbbG9jYWxJZDolcywgdHJhY2suaWQ6JXNdJywgbG9jYWxJZCwgdHJhY2suaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbbG9jYWxJZDolcywgbm8gdHJhY2tdJywgbG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5yZXBsYWNlVHJhY2sodHJhY2spO1xuICAgIH1cbiAgICBhc3luYyBzZXRNYXhTcGF0aWFsTGF5ZXIobG9jYWxJZCwgc3BhdGlhbExheWVyKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSBbbG9jYWxJZDolcywgc3BhdGlhbExheWVyOiVzXScsIGxvY2FsSWQsIHNwYXRpYWxMYXllcik7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlkeCA8PSBzcGF0aWFsTGF5ZXIpXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBhc3luYyBzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMobG9jYWxJZCwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSBbbG9jYWxJZDolcywgcGFyYW1zOiVvXScsIGxvY2FsSWQsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3NbaWR4XSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZW5jb2RpbmcpLCBwYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFNlbmRlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kRGF0YUNoYW5uZWwoeyBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMsIGxhYmVsLCBwcm90b2NvbCB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0VGltZTogbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJbmNyZWFzZSBuZXh0IGlkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9XG4gICAgICAgICAgICArK3RoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkICUgU0NUUF9OVU1fU1RSRUFNUy5NSVM7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgYW5zd2VyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhXG4gICAgICAgICAgICAgICAgLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ2FwcGxpY2F0aW9uJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ3NlcnZlcicsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kU2N0cEFzc29jaWF0aW9uKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2N0cFN0cmVhbVBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBzdHJlYW1JZDogb3B0aW9ucy5pZCxcbiAgICAgICAgICAgIG9yZGVyZWQ6IG9wdGlvbnMub3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lOiBvcHRpb25zLm1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHM6IG9wdGlvbnMubWF4UmV0cmFuc21pdHNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwsIHNjdHBTdHJlYW1QYXJhbWV0ZXJzIH07XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmUoeyB0cmFja0lkLCBraW5kLCBydHBQYXJhbWV0ZXJzIH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSBbdHJhY2tJZDolcywga2luZDolc10nLCB0cmFja0lkLCBraW5kKTtcbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IHJ0cFBhcmFtZXRlcnMubWlkIHx8IFN0cmluZyh0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5zaXplKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmUoe1xuICAgICAgICAgICAgbWlkOiBsb2NhbElkLFxuICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHN0cmVhbUlkOiBydHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUsXG4gICAgICAgICAgICB0cmFja0lkXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBsZXQgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICBjb25zdCBhbnN3ZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhXG4gICAgICAgICAgICAuZmluZCgobSkgPT4gU3RyaW5nKG0ubWlkKSA9PT0gbG9jYWxJZCk7XG4gICAgICAgIC8vIE1heSBuZWVkIHRvIG1vZGlmeSBjb2RlYyBwYXJhbWV0ZXJzIGluIHRoZSBhbnN3ZXIgYmFzZWQgb24gY29kZWNcbiAgICAgICAgLy8gcGFyYW1ldGVycyBpbiB0aGUgb2ZmZXIuXG4gICAgICAgIHNkcENvbW1vblV0aWxzLmFwcGx5Q29kZWNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX3BjLmdldFRyYW5zY2VpdmVycygpXG4gICAgICAgICAgICAuZmluZCgodCkgPT4gdC5taWQgPT09IGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZXcgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIC8vIFN0b3JlIGluIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNldChsb2NhbElkLCB0cmFuc2NlaXZlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgdHJhY2s6IHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLFxuICAgICAgICAgICAgcnRwUmVjZWl2ZXI6IHRyYW5zY2VpdmVyLnJlY2VpdmVyXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHN0b3BSZWNlaXZpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLmNsb3NlTWVkaWFTZWN0aW9uKHRyYW5zY2VpdmVyLm1pZCk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZWNlaXZlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVEYXRhQ2hhbm5lbCh7IHNjdHBTdHJlYW1QYXJhbWV0ZXJzLCBsYWJlbCwgcHJvdG9jb2wgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtSWQsIG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cyB9ID0gc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdFRpbWU6IG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBvZmZlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmVTY3RwQXNzb2NpYXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UoYW5zd2VyLnNkcCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnY2xpZW50JywgbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXRhQ2hhbm5lbCB9O1xuICAgIH1cbiAgICBhc3luYyBfc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlLCBsb2NhbFNkcE9iamVjdCB9KSB7XG4gICAgICAgIGlmICghbG9jYWxTZHBPYmplY3QpXG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIC8vIEdldCBvdXIgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzLlxuICAgICAgICBjb25zdCBkdGxzUGFyYW1ldGVycyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3REdGxzUGFyYW1ldGVycyh7IHNkcE9iamVjdDogbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgIC8vIFNldCBvdXIgRFRMUyByb2xlLlxuICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID0gbG9jYWxEdGxzUm9sZTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1vdGUgRFRMUyByb2xlIGluIHRoZSBTRFAuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVEdGxzUm9sZShsb2NhbER0bHNSb2xlID09PSAnY2xpZW50JyA/ICdzZXJ2ZXInIDogJ2NsaWVudCcpO1xuICAgICAgICAvLyBOZWVkIHRvIHRlbGwgdGhlIHJlbW90ZSB0cmFuc3BvcnQgYWJvdXQgb3VyIHBhcmFtZXRlcnMuXG4gICAgICAgIGF3YWl0IHRoaXMuc2FmZUVtaXRBc1Byb21pc2UoJ0Bjb25uZWN0JywgeyBkdGxzUGFyYW1ldGVycyB9KTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSB0cnVlO1xuICAgIH1cbiAgICBfYXNzZXJ0U2VuZERpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJzZW5kXCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdyZWN2Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwicmVjdlwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DaHJvbWU3MCA9IENocm9tZTcwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5DaHJvbWU3NCA9IHZvaWQgMDtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwic2RwLXRyYW5zZm9ybVwiKSk7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJcIik7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vdXRpbHNcIikpO1xuY29uc3Qgb3J0YyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vb3J0Y1wiKSk7XG5jb25zdCBzZHBDb21tb25VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvY29tbW9uVXRpbHNcIikpO1xuY29uc3Qgc2RwVW5pZmllZFBsYW5VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvdW5pZmllZFBsYW5VdGlsc1wiKSk7XG5jb25zdCBIYW5kbGVySW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9IYW5kbGVySW50ZXJmYWNlXCIpO1xuY29uc3QgUmVtb3RlU2RwXzEgPSByZXF1aXJlKFwiLi9zZHAvUmVtb3RlU2RwXCIpO1xuY29uc3Qgc2NhbGFiaWxpdHlNb2Rlc18xID0gcmVxdWlyZShcIi4uL3NjYWxhYmlsaXR5TW9kZXNcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdDaHJvbWU3NCcpO1xuY29uc3QgU0NUUF9OVU1fU1RSRUFNUyA9IHsgT1M6IDEwMjQsIE1JUzogMTAyNCB9O1xuY2xhc3MgQ2hyb21lNzQgZXh0ZW5kcyBIYW5kbGVySW50ZXJmYWNlXzEuSGFuZGxlckludGVyZmFjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIE1hcCBvZiBSVENUcmFuc2NlaXZlcnMgaW5kZXhlZCBieSBNSUQuXG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMb2NhbCBzdHJlYW0gZm9yIHNlbmRpbmcuXG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgLy8gV2hldGhlciBhIERhdGFDaGFubmVsIG09YXBwbGljYXRpb24gc2VjdGlvbiBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IGZhbHNlO1xuICAgICAgICAvLyBTZW5kaW5nIERhdGFDaGFubmVsIGlkIHZhbHVlIGNvdW50ZXIuIEluY3JlbWVudGVkIGZvciBlYWNoIG5ldyBEYXRhQ2hhbm5lbC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPSAwO1xuICAgICAgICAvLyBHb3QgdHJhbnNwb3J0IGxvY2FsIGFuZCByZW1vdGUgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBuZXcgQ2hyb21lNzQoKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnQ2hyb21lNzQnO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIC8vIENsb3NlIFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgICAgICBpZiAodGhpcy5fcGMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiAnYWxsJyxcbiAgICAgICAgICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICAgICAgICAgICAgcnRjcE11eFBvbGljeTogJ3JlcXVpcmUnLFxuICAgICAgICAgICAgc2RwU2VtYW50aWNzOiAndW5pZmllZC1wbGFuJ1xuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHBjLmFkZFRyYW5zY2VpdmVyKCdhdWRpbycpO1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoJ3ZpZGVvJyk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHBjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgY29uc3Qgc2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVSdHBDYXBhYmlsaXRpZXMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0UnRwQ2FwYWJpbGl0aWVzKHsgc2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZVJ0cENhcGFiaWxpdGllcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG51bVN0cmVhbXM6IFNDVFBfTlVNX1NUUkVBTVNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcnVuKHsgZGlyZWN0aW9uLCBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgc2N0cFBhcmFtZXRlcnMsIGljZVNlcnZlcnMsIGljZVRyYW5zcG9ydFBvbGljeSwgYWRkaXRpb25hbFNldHRpbmdzLCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncnVuKCknKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAgPSBuZXcgUmVtb3RlU2RwXzEuUmVtb3RlU2RwKHtcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVyc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmQgPVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kID1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG4gICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihPYmplY3QuYXNzaWduKHsgaWNlU2VydmVyczogaWNlU2VydmVycyB8fCBbXSwgaWNlVHJhbnNwb3J0UG9saWN5OiBpY2VUcmFuc3BvcnRQb2xpY3kgfHwgJ2FsbCcsIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLCBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsIHNkcFNlbWFudGljczogJ3VuaWZpZWQtcGxhbicgfSwgYWRkaXRpb25hbFNldHRpbmdzKSwgcHJvcHJpZXRhcnlDb25zdHJhaW50cyk7XG4gICAgICAgIC8vIEhhbmRsZSBSVENQZWVyQ29ubmVjdGlvbiBjb25uZWN0aW9uIHN0YXR1cy5cbiAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wYy5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjaGVja2luZyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGFzeW5jIHVwZGF0ZUljZVNlcnZlcnMoaWNlU2VydmVycykge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3VwZGF0ZUljZVNlcnZlcnMoKScpO1xuICAgICAgICBjb25zdCBjb25maWd1cmF0aW9uID0gdGhpcy5fcGMuZ2V0Q29uZmlndXJhdGlvbigpO1xuICAgICAgICBjb25maWd1cmF0aW9uLmljZVNlcnZlcnMgPSBpY2VTZXJ2ZXJzO1xuICAgICAgICB0aGlzLl9wYy5zZXRDb25maWd1cmF0aW9uKGNvbmZpZ3VyYXRpb24pO1xuICAgIH1cbiAgICBhc3luYyByZXN0YXJ0SWNlKGljZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCknKTtcbiAgICAgICAgLy8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggbmV3IHJlbW90ZSBJQ0UgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUljZVBhcmFtZXRlcnMoaWNlUGFyYW1ldGVycyk7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gPT09ICdzZW5kJykge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcih7IGljZVJlc3RhcnQ6IHRydWUgfSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc3BvcnRTdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQoeyB0cmFjaywgZW5jb2RpbmdzLCBjb2RlY09wdGlvbnMsIGNvZGVjIH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSBba2luZDolcywgdHJhY2suaWQ6JXNdJywgdHJhY2sua2luZCwgdHJhY2suaWQpO1xuICAgICAgICBpZiAoZW5jb2RpbmdzICYmIGVuY29kaW5ncy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBlbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLnJpZCA9IGByJHtpZHh9YDtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0sIHt9KTtcbiAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9XG4gICAgICAgICAgICBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MsIGNvZGVjKTtcbiAgICAgICAgY29uc3Qgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSwge30pO1xuICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzID1cbiAgICAgICAgICAgIG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb25JZHggPSB0aGlzLl9yZW1vdGVTZHAuZ2V0TmV4dE1lZGlhU2VjdGlvbklkeCgpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX3BjLmFkZFRyYW5zY2VpdmVyKHRyYWNrLCB7XG4gICAgICAgICAgICBkaXJlY3Rpb246ICdzZW5kb25seScsXG4gICAgICAgICAgICBzdHJlYW1zOiBbdGhpcy5fc2VuZFN0cmVhbV0sXG4gICAgICAgICAgICBzZW5kRW5jb2RpbmdzOiBlbmNvZGluZ3NcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxldCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICBsZXQgb2ZmZXJNZWRpYU9iamVjdDtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ3NlcnZlcicsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAvLyBTcGVjaWFsIGNhc2UgZm9yIFZQOSB3aXRoIFNWQy5cbiAgICAgICAgbGV0IGhhY2tWcDlTdmMgPSBmYWxzZTtcbiAgICAgICAgY29uc3QgbGF5ZXJzID0gc2NhbGFiaWxpdHlNb2Rlc18xLnBhcnNlKChlbmNvZGluZ3MgfHwgW3t9XSlbMF0uc2NhbGFiaWxpdHlNb2RlKTtcbiAgICAgICAgaWYgKGVuY29kaW5ncyAmJlxuICAgICAgICAgICAgZW5jb2RpbmdzLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgICAgICAgbGF5ZXJzLnNwYXRpYWxMYXllcnMgPiAxICYmXG4gICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOScpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgZW5hYmxpbmcgbGVnYWN5IHNpbXVsY2FzdCBmb3IgVlA5IFNWQycpO1xuICAgICAgICAgICAgaGFja1ZwOVN2YyA9IHRydWU7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW21lZGlhU2VjdGlvbklkeC5pZHhdO1xuICAgICAgICAgICAgc2RwVW5pZmllZFBsYW5VdGlscy5hZGRMZWdhY3lTaW11bGNhc3Qoe1xuICAgICAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICAgICAgbnVtU3RyZWFtczogbGF5ZXJzLnNwYXRpYWxMYXllcnNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogc2RwVHJhbnNmb3JtLndyaXRlKGxvY2FsU2RwT2JqZWN0KSB9O1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIC8vIFdlIGNhbiBub3cgZ2V0IHRoZSB0cmFuc2NlaXZlci5taWQuXG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSB0cmFuc2NlaXZlci5taWQ7XG4gICAgICAgIC8vIFNldCBNSUQuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLm1pZCA9IGxvY2FsSWQ7XG4gICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW21lZGlhU2VjdGlvbklkeC5pZHhdO1xuICAgICAgICAvLyBTZXQgUlRDUCBDTkFNRS5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSA9XG4gICAgICAgICAgICBzZHBDb21tb25VdGlscy5nZXRDbmFtZSh7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgIC8vIFNldCBSVFAgZW5jb2RpbmdzIGJ5IHBhcnNpbmcgdGhlIFNEUCBvZmZlciBpZiBubyBlbmNvZGluZ3MgYXJlIGdpdmVuLlxuICAgICAgICBpZiAoIWVuY29kaW5ncykge1xuICAgICAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzID1cbiAgICAgICAgICAgICAgICBzZHBVbmlmaWVkUGxhblV0aWxzLmdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MgYnkgcGFyc2luZyB0aGUgU0RQIG9mZmVyIGFuZCBjb21wbGV0ZSB0aGVtIHdpdGggZ2l2ZW5cbiAgICAgICAgLy8gb25lIGlmIGp1c3QgYSBzaW5nbGUgZW5jb2RpbmcgaGFzIGJlZW4gZ2l2ZW4uXG4gICAgICAgIGVsc2UgaWYgKGVuY29kaW5ncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGxldCBuZXdFbmNvZGluZ3MgPSBzZHBVbmlmaWVkUGxhblV0aWxzLmdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgICAgICBPYmplY3QuYXNzaWduKG5ld0VuY29kaW5nc1swXSwgZW5jb2RpbmdzWzBdKTtcbiAgICAgICAgICAgIC8vIEhhY2sgZm9yIFZQOSBTVkMuXG4gICAgICAgICAgICBpZiAoaGFja1ZwOVN2YylcbiAgICAgICAgICAgICAgICBuZXdFbmNvZGluZ3MgPSBbbmV3RW5jb2RpbmdzWzBdXTtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IG5ld0VuY29kaW5ncztcbiAgICAgICAgfVxuICAgICAgICAvLyBPdGhlcndpc2UgaWYgbW9yZSB0aGFuIDEgZW5jb2RpbmcgYXJlIGdpdmVuIHVzZSB0aGVtIHZlcmJhdGltLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9IGVuY29kaW5ncztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBWUDggb3IgSDI2NCBhbmQgdGhlcmUgaXMgZWZmZWN0aXZlIHNpbXVsY2FzdCwgYWRkIHNjYWxhYmlsaXR5TW9kZSB0b1xuICAgICAgICAvLyBlYWNoIGVuY29kaW5nLlxuICAgICAgICBpZiAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIChzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOCcgfHxcbiAgICAgICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL2gyNjQnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSAnUzFUMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmQoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIHJldXNlTWlkOiBtZWRpYVNlY3Rpb25JZHgucmV1c2VNaWQsXG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgYW5zd2VyUnRwUGFyYW1ldGVyczogc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBjb2RlY09wdGlvbnMsXG4gICAgICAgICAgICBleHRtYXBBbGxvd01peGVkOiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIC8vIFN0b3JlIGluIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNldChsb2NhbElkLCB0cmFuc2NlaXZlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgcnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBydHBTZW5kZXI6IHRyYW5zY2VpdmVyLnNlbmRlclxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZGVyLnJlcGxhY2VUcmFjayhudWxsKTtcbiAgICAgICAgdGhpcy5fcGMucmVtb3ZlVHJhY2sodHJhbnNjZWl2ZXIuc2VuZGVyKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLmNsb3NlTWVkaWFTZWN0aW9uKHRyYW5zY2VpdmVyLm1pZCk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHJlcGxhY2VUcmFjayhsb2NhbElkLCB0cmFjaykge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGlmICh0cmFjaykge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbbG9jYWxJZDolcywgdHJhY2suaWQ6JXNdJywgbG9jYWxJZCwgdHJhY2suaWQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXBsYWNlVHJhY2soKSBbbG9jYWxJZDolcywgbm8gdHJhY2tdJywgbG9jYWxJZCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5yZXBsYWNlVHJhY2sodHJhY2spO1xuICAgIH1cbiAgICBhc3luYyBzZXRNYXhTcGF0aWFsTGF5ZXIobG9jYWxJZCwgc3BhdGlhbExheWVyKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRNYXhTcGF0aWFsTGF5ZXIoKSBbbG9jYWxJZDolcywgc3BhdGlhbExheWVyOiVzXScsIGxvY2FsSWQsIHNwYXRpYWxMYXllcik7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlkeCA8PSBzcGF0aWFsTGF5ZXIpXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBhc3luYyBzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMobG9jYWxJZCwgcGFyYW1zKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMoKSBbbG9jYWxJZDolcywgcGFyYW1zOiVvXScsIGxvY2FsSWQsIHBhcmFtcyk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3NbaWR4XSA9IE9iamVjdC5hc3NpZ24oT2JqZWN0LmFzc2lnbih7fSwgZW5jb2RpbmcpLCBwYXJhbXMpO1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGFzeW5jIGdldFNlbmRlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnNlbmRlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kRGF0YUNoYW5uZWwoeyBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMsIGxhYmVsLCBwcm90b2NvbCB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJbmNyZWFzZSBuZXh0IGlkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9XG4gICAgICAgICAgICArK3RoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkICUgU0NUUF9OVU1fU1RSRUFNUy5NSVM7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgYW5zd2VyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhXG4gICAgICAgICAgICAgICAgLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ2FwcGxpY2F0aW9uJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ3NlcnZlcicsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kU2N0cEFzc29jaWF0aW9uKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2N0cFN0cmVhbVBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBzdHJlYW1JZDogb3B0aW9ucy5pZCxcbiAgICAgICAgICAgIG9yZGVyZWQ6IG9wdGlvbnMub3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lOiBvcHRpb25zLm1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHM6IG9wdGlvbnMubWF4UmV0cmFuc21pdHNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwsIHNjdHBTdHJlYW1QYXJhbWV0ZXJzIH07XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmUoeyB0cmFja0lkLCBraW5kLCBydHBQYXJhbWV0ZXJzIH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSBbdHJhY2tJZDolcywga2luZDolc10nLCB0cmFja0lkLCBraW5kKTtcbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IHJ0cFBhcmFtZXRlcnMubWlkIHx8IFN0cmluZyh0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5zaXplKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmUoe1xuICAgICAgICAgICAgbWlkOiBsb2NhbElkLFxuICAgICAgICAgICAga2luZCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHN0cmVhbUlkOiBydHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUsXG4gICAgICAgICAgICB0cmFja0lkXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBsZXQgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICBjb25zdCBhbnN3ZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhXG4gICAgICAgICAgICAuZmluZCgobSkgPT4gU3RyaW5nKG0ubWlkKSA9PT0gbG9jYWxJZCk7XG4gICAgICAgIC8vIE1heSBuZWVkIHRvIG1vZGlmeSBjb2RlYyBwYXJhbWV0ZXJzIGluIHRoZSBhbnN3ZXIgYmFzZWQgb24gY29kZWNcbiAgICAgICAgLy8gcGFyYW1ldGVycyBpbiB0aGUgb2ZmZXIuXG4gICAgICAgIHNkcENvbW1vblV0aWxzLmFwcGx5Q29kZWNQYXJhbWV0ZXJzKHtcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX3BjLmdldFRyYW5zY2VpdmVycygpXG4gICAgICAgICAgICAuZmluZCgodCkgPT4gdC5taWQgPT09IGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCduZXcgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIC8vIFN0b3JlIGluIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNldChsb2NhbElkLCB0cmFuc2NlaXZlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgdHJhY2s6IHRyYW5zY2VpdmVyLnJlY2VpdmVyLnRyYWNrLFxuICAgICAgICAgICAgcnRwUmVjZWl2ZXI6IHRyYW5zY2VpdmVyLnJlY2VpdmVyXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHN0b3BSZWNlaXZpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLmNsb3NlTWVkaWFTZWN0aW9uKHRyYW5zY2VpdmVyLm1pZCk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyBnZXRSZWNlaXZlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIHRyYW5zY2VpdmVyLnJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVEYXRhQ2hhbm5lbCh7IHNjdHBTdHJlYW1QYXJhbWV0ZXJzLCBsYWJlbCwgcHJvdG9jb2wgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgc3RyZWFtSWQsIG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cyB9ID0gc2N0cFN0cmVhbVBhcmFtZXRlcnM7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBvZmZlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnJlY2VpdmVTY3RwQXNzb2NpYXRpb24oKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UoYW5zd2VyLnNkcCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnY2xpZW50JywgbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXRhQ2hhbm5lbCB9O1xuICAgIH1cbiAgICBhc3luYyBfc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlLCBsb2NhbFNkcE9iamVjdCB9KSB7XG4gICAgICAgIGlmICghbG9jYWxTZHBPYmplY3QpXG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIC8vIEdldCBvdXIgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzLlxuICAgICAgICBjb25zdCBkdGxzUGFyYW1ldGVycyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3REdGxzUGFyYW1ldGVycyh7IHNkcE9iamVjdDogbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgIC8vIFNldCBvdXIgRFRMUyByb2xlLlxuICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID0gbG9jYWxEdGxzUm9sZTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1vdGUgRFRMUyByb2xlIGluIHRoZSBTRFAuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVEdGxzUm9sZShsb2NhbER0bHNSb2xlID09PSAnY2xpZW50JyA/ICdzZXJ2ZXInIDogJ2NsaWVudCcpO1xuICAgICAgICAvLyBOZWVkIHRvIHRlbGwgdGhlIHJlbW90ZSB0cmFuc3BvcnQgYWJvdXQgb3VyIHBhcmFtZXRlcnMuXG4gICAgICAgIGF3YWl0IHRoaXMuc2FmZUVtaXRBc1Byb21pc2UoJ0Bjb25uZWN0JywgeyBkdGxzUGFyYW1ldGVycyB9KTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSB0cnVlO1xuICAgIH1cbiAgICBfYXNzZXJ0U2VuZERpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJzZW5kXCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdyZWN2Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwicmVjdlwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5DaHJvbWU3NCA9IENocm9tZTc0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5FZGdlMTEgPSB2b2lkIDA7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJcIik7XG5jb25zdCBlcnJvcnNfMSA9IHJlcXVpcmUoXCIuLi9lcnJvcnNcIik7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vdXRpbHNcIikpO1xuY29uc3Qgb3J0YyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vb3J0Y1wiKSk7XG5jb25zdCBlZGdlVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vb3J0Yy9lZGdlVXRpbHNcIikpO1xuY29uc3QgSGFuZGxlckludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vSGFuZGxlckludGVyZmFjZVwiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ0VkZ2UxMScpO1xuY2xhc3MgRWRnZTExIGV4dGVuZHMgSGFuZGxlckludGVyZmFjZV8xLkhhbmRsZXJJbnRlcmZhY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBNYXAgb2YgUlRDUnRwU2VuZGVycyBpbmRleGVkIGJ5IGlkLlxuICAgICAgICB0aGlzLl9ydHBTZW5kZXJzID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBNYXAgb2YgUlRDUnRwUmVjZWl2ZXJzIGluZGV4ZWQgYnkgaWQuXG4gICAgICAgIHRoaXMuX3J0cFJlY2VpdmVycyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gTmV4dCBsb2NhbElkIGZvciBzZW5kaW5nIHRyYWNrcy5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRMb2NhbElkID0gMDtcbiAgICAgICAgLy8gR290IHRyYW5zcG9ydCBsb2NhbCBhbmQgcmVtb3RlIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gZmFsc2U7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBmYWN0b3J5IGZ1bmN0aW9uLlxuICAgICAqL1xuICAgIHN0YXRpYyBjcmVhdGVGYWN0b3J5KCkge1xuICAgICAgICByZXR1cm4gKCkgPT4gbmV3IEVkZ2UxMSgpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdFZGdlMTEnO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIC8vIENsb3NlIHRoZSBJQ0UgZ2F0aGVyZXIuXG4gICAgICAgIC8vIE5PVEU6IE5vdCB5ZXQgaW1wbGVtZW50ZWQgYnkgRWRnZS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2ljZUdhdGhlcmVyLmNsb3NlKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgLy8gQ2xvc2UgdGhlIElDRSB0cmFuc3BvcnQuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aGlzLl9pY2VUcmFuc3BvcnQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIC8vIENsb3NlIHRoZSBEVExTIHRyYW5zcG9ydC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuX2R0bHNUcmFuc3BvcnQuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIC8vIENsb3NlIFJUQ1J0cFNlbmRlcnMuXG4gICAgICAgIGZvciAoY29uc3QgcnRwU2VuZGVyIG9mIHRoaXMuX3J0cFNlbmRlcnMudmFsdWVzKCkpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcnRwU2VuZGVyLnN0b3AoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gQ2xvc2UgUlRDUnRwUmVjZWl2ZXJzLlxuICAgICAgICBmb3IgKGNvbnN0IHJ0cFJlY2VpdmVyIG9mIHRoaXMuX3J0cFJlY2VpdmVycy52YWx1ZXMoKSkge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBydHBSZWNlaXZlci5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICByZXR1cm4gZWRnZVV0aWxzLmdldENhcGFiaWxpdGllcygpO1xuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbnVtU3RyZWFtczogeyBPUzogMCwgTUlTOiAwIH1cbiAgICAgICAgfTtcbiAgICB9XG4gICAgcnVuKHsgZGlyZWN0aW9uLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3ksIGFkZGl0aW9uYWxTZXR0aW5ncywgLy8gZXNsaW50LWRpc2FibGUtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBwcm9wcmlldGFyeUNvbnN0cmFpbnRzLCAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZCA9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcmVtb3RlSWNlUGFyYW1ldGVycyA9IGljZVBhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMuX3JlbW90ZUljZUNhbmRpZGF0ZXMgPSBpY2VDYW5kaWRhdGVzO1xuICAgICAgICB0aGlzLl9yZW1vdGVEdGxzUGFyYW1ldGVycyA9IGR0bHNQYXJhbWV0ZXJzO1xuICAgICAgICB0aGlzLl9jbmFtZSA9IGBDTkFNRS0ke3V0aWxzLmdlbmVyYXRlUmFuZG9tTnVtYmVyKCl9YDtcbiAgICAgICAgdGhpcy5fc2V0SWNlR2F0aGVyZXIoeyBpY2VTZXJ2ZXJzLCBpY2VUcmFuc3BvcnRQb2xpY3kgfSk7XG4gICAgICAgIHRoaXMuX3NldEljZVRyYW5zcG9ydCgpO1xuICAgICAgICB0aGlzLl9zZXREdGxzVHJhbnNwb3J0KCk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKGljZVNlcnZlcnMpIHtcbiAgICAgICAgLy8gTk9URTogRWRnZSAxMSBkb2VzIG5vdCBpbXBsZW1lbnQgaWNlR2F0aGVyZXIuZ2F0ZXIoKS5cbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBzdXBwb3J0ZWQnKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdGFydEljZShpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG4gICAgICAgIHRoaXMuX3JlbW90ZUljZVBhcmFtZXRlcnMgPSBpY2VQYXJhbWV0ZXJzO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgaWNlVHJhbnNwb3J0LnN0YXJ0KCknKTtcbiAgICAgICAgdGhpcy5faWNlVHJhbnNwb3J0LnN0YXJ0KHRoaXMuX2ljZUdhdGhlcmVyLCBpY2VQYXJhbWV0ZXJzLCAnY29udHJvbGxpbmcnKTtcbiAgICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgdGhpcy5fcmVtb3RlSWNlQ2FuZGlkYXRlcykge1xuICAgICAgICAgICAgdGhpcy5faWNlVHJhbnNwb3J0LmFkZFJlbW90ZUNhbmRpZGF0ZShjYW5kaWRhdGUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2ljZVRyYW5zcG9ydC5hZGRSZW1vdGVDYW5kaWRhdGUoe30pO1xuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc3BvcnRTdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2ljZVRyYW5zcG9ydC5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICB7IHRyYWNrLCBlbmNvZGluZ3MsIGNvZGVjT3B0aW9ucywgY29kZWMgfSkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSBba2luZDolcywgdHJhY2suaWQ6JXNdJywgdHJhY2sua2luZCwgdHJhY2suaWQpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnc2VydmVyJyB9KTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBjYWxsaW5nIG5ldyBSVENSdHBTZW5kZXIoKScpO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSBuZXcgUlRDUnRwU2VuZGVyKHRyYWNrLCB0aGlzLl9kdGxzVHJhbnNwb3J0KTtcbiAgICAgICAgY29uc3QgcnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdLCB7fSk7XG4gICAgICAgIHJ0cFBhcmFtZXRlcnMuY29kZWNzID0gb3J0Yy5yZWR1Y2VDb2RlY3MocnRwUGFyYW1ldGVycy5jb2RlY3MsIGNvZGVjKTtcbiAgICAgICAgY29uc3QgdXNlUnR4ID0gcnRwUGFyYW1ldGVycy5jb2RlY3NcbiAgICAgICAgICAgIC5zb21lKChfY29kZWMpID0+IC8uK1xcL3J0eCQvaS50ZXN0KF9jb2RlYy5taW1lVHlwZSkpO1xuICAgICAgICBpZiAoIWVuY29kaW5ncylcbiAgICAgICAgICAgIGVuY29kaW5ncyA9IFt7fV07XG4gICAgICAgIGZvciAoY29uc3QgZW5jb2Rpbmcgb2YgZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICBlbmNvZGluZy5zc3JjID0gdXRpbHMuZ2VuZXJhdGVSYW5kb21OdW1iZXIoKTtcbiAgICAgICAgICAgIGlmICh1c2VSdHgpXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcucnR4ID0geyBzc3JjOiB1dGlscy5nZW5lcmF0ZVJhbmRvbU51bWJlcigpIH07XG4gICAgICAgIH1cbiAgICAgICAgcnRwUGFyYW1ldGVycy5lbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgICAgIC8vIEZpbGwgUlRDUnRwUGFyYW1ldGVycy5ydGNwLlxuICAgICAgICBydHBQYXJhbWV0ZXJzLnJ0Y3AgPVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGNuYW1lOiB0aGlzLl9jbmFtZSxcbiAgICAgICAgICAgICAgICByZWR1Y2VkU2l6ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBtdXg6IHRydWVcbiAgICAgICAgICAgIH07XG4gICAgICAgIC8vIE5PVEU6IENvbnZlcnQgb3VyIHN0YW5kYXJkIFJUQ1J0cFBhcmFtZXRlcnMgaW50byB0aG9zZSB0aGF0IEVkZ2VcbiAgICAgICAgLy8gZXhwZWN0cy5cbiAgICAgICAgY29uc3QgZWRnZVJ0cFBhcmFtZXRlcnMgPSBlZGdlVXRpbHMubWFuZ2xlUnRwUGFyYW1ldGVycyhydHBQYXJhbWV0ZXJzKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBjYWxsaW5nIHJ0cFNlbmRlci5zZW5kKCkgW3BhcmFtczolb10nLCBlZGdlUnRwUGFyYW1ldGVycyk7XG4gICAgICAgIGF3YWl0IHJ0cFNlbmRlci5zZW5kKGVkZ2VSdHBQYXJhbWV0ZXJzKTtcbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IFN0cmluZyh0aGlzLl9uZXh0U2VuZExvY2FsSWQpO1xuICAgICAgICB0aGlzLl9uZXh0U2VuZExvY2FsSWQrKztcbiAgICAgICAgLy8gU3RvcmUgaXQuXG4gICAgICAgIHRoaXMuX3J0cFNlbmRlcnMuc2V0KGxvY2FsSWQsIHJ0cFNlbmRlcik7XG4gICAgICAgIHJldHVybiB7IGxvY2FsSWQsIHJ0cFBhcmFtZXRlcnMsIHJ0cFNlbmRlciB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wU2VuZGluZyhsb2NhbElkKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fcnRwU2VuZGVycy5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSVENSdHBTZW5kZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHRoaXMuX3J0cFNlbmRlcnMuZGVsZXRlKGxvY2FsSWQpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBydHBTZW5kZXIuc3RvcCgpJyk7XG4gICAgICAgICAgICBydHBTZW5kZXIuc3RvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3N0b3BTZW5kaW5nKCkgfCBydHBTZW5kZXIuc3RvcCgpIGZhaWxlZDolbycsIGVycm9yKTtcbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHJlcGxhY2VUcmFjayhsb2NhbElkLCB0cmFjaykge1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIHRyYWNrLmlkOiVzXScsIGxvY2FsSWQsIHRyYWNrLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIG5vIHRyYWNrXScsIGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX3J0cFNlbmRlcnMuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFNlbmRlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICBydHBTZW5kZXIuc2V0VHJhY2sodHJhY2spO1xuICAgIH1cbiAgICBhc3luYyBzZXRNYXhTcGF0aWFsTGF5ZXIobG9jYWxJZCwgc3BhdGlhbExheWVyKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgW2xvY2FsSWQ6JXMsIHNwYXRpYWxMYXllcjolc10nLCBsb2NhbElkLCBzcGF0aWFsTGF5ZXIpO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9ydHBTZW5kZXJzLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHJ0cFNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzXG4gICAgICAgICAgICAuZm9yRWFjaCgoZW5jb2RpbmcsIGlkeCkgPT4ge1xuICAgICAgICAgICAgaWYgKGlkeCA8PSBzcGF0aWFsTGF5ZXIpXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gdHJ1ZTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSBmYWxzZTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJ0cFNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBhc3luYyBzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMobG9jYWxJZCwgcGFyYW1zKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgW2xvY2FsSWQ6JXMsIHBhcmFtczolb10nLCBsb2NhbElkLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9ydHBTZW5kZXJzLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1JUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHJ0cFNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVuY29kaW5nKSwgcGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJ0cFNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTZW5kZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX3J0cFNlbmRlcnMuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFNlbmRlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICByZXR1cm4gcnRwU2VuZGVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmREYXRhQ2hhbm5lbChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmUoeyB0cmFja0lkLCBraW5kLCBydHBQYXJhbWV0ZXJzIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgW3RyYWNrSWQ6JXMsIGtpbmQ6JXNdJywgdHJhY2tJZCwga2luZCk7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdzZXJ2ZXInIH0pO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgbmV3IFJUQ1J0cFJlY2VpdmVyKCknKTtcbiAgICAgICAgY29uc3QgcnRwUmVjZWl2ZXIgPSBuZXcgUlRDUnRwUmVjZWl2ZXIodGhpcy5fZHRsc1RyYW5zcG9ydCwga2luZCk7XG4gICAgICAgIHJ0cFJlY2VpdmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2Vycm9yJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIuZXJyb3IoJ3J0cFJlY2VpdmVyIFwiZXJyb3JcIiBldmVudCBbZXZlbnQ6JW9dJywgZXZlbnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTk9URTogQ29udmVydCBvdXIgc3RhbmRhcmQgUlRDUnRwUGFyYW1ldGVycyBpbnRvIHRob3NlIHRoYXQgRWRnZVxuICAgICAgICAvLyBleHBlY3RzLlxuICAgICAgICBjb25zdCBlZGdlUnRwUGFyYW1ldGVycyA9IGVkZ2VVdGlscy5tYW5nbGVSdHBQYXJhbWV0ZXJzKHJ0cFBhcmFtZXRlcnMpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcnRwUmVjZWl2ZXIucmVjZWl2ZSgpIFtwYXJhbXM6JW9dJywgZWRnZVJ0cFBhcmFtZXRlcnMpO1xuICAgICAgICBhd2FpdCBydHBSZWNlaXZlci5yZWNlaXZlKGVkZ2VSdHBQYXJhbWV0ZXJzKTtcbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IHRyYWNrSWQ7XG4gICAgICAgIC8vIFN0b3JlIGl0LlxuICAgICAgICB0aGlzLl9ydHBSZWNlaXZlcnMuc2V0KGxvY2FsSWQsIHJ0cFJlY2VpdmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICB0cmFjazogcnRwUmVjZWl2ZXIudHJhY2ssXG4gICAgICAgICAgICBydHBSZWNlaXZlclxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWQpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHJ0cFJlY2VpdmVyID0gdGhpcy5fcnRwUmVjZWl2ZXJzLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBSZWNlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUlRDUnRwUmVjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHRoaXMuX3J0cFJlY2VpdmVycy5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcnRwUmVjZWl2ZXIuc3RvcCgpJyk7XG4gICAgICAgICAgICBydHBSZWNlaXZlci5zdG9wKCk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXIud2Fybignc3RvcFJlY2VpdmluZygpIHwgcnRwUmVjZWl2ZXIuc3RvcCgpIGZhaWxlZDolbycsIGVycm9yKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRSZWNlaXZlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgY29uc3QgcnRwUmVjZWl2ZXIgPSB0aGlzLl9ydHBSZWNlaXZlcnMuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFJlY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdSVENSdHBSZWNlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgcmV0dXJuIHJ0cFJlY2VpdmVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmVEYXRhQ2hhbm5lbChcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgb3B0aW9ucykge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIF9zZXRJY2VHYXRoZXJlcih7IGljZVNlcnZlcnMsIGljZVRyYW5zcG9ydFBvbGljeSB9KSB7XG4gICAgICAgIGNvbnN0IGljZUdhdGhlcmVyID0gbmV3IFJUQ0ljZUdhdGhlcmVyKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IGljZVNlcnZlcnMgfHwgW10sXG4gICAgICAgICAgICBnYXRoZXJQb2xpY3k6IGljZVRyYW5zcG9ydFBvbGljeSB8fCAnYWxsJ1xuICAgICAgICB9KTtcbiAgICAgICAgaWNlR2F0aGVyZXIuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignaWNlR2F0aGVyZXIgXCJlcnJvclwiIGV2ZW50IFtldmVudDolb10nLCBldmVudCk7XG4gICAgICAgIH0pO1xuICAgICAgICAvLyBOT1RFOiBOb3QgeWV0IGltcGxlbWVudGVkIGJ5IEVkZ2UsIHdoaWNoIHN0YXJ0cyBnYXRoZXJpbmcgYXV0b21hdGljYWxseS5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGljZUdhdGhlcmVyLmdhdGhlcigpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdfc2V0SWNlR2F0aGVyZXIoKSB8IGljZUdhdGhlcmVyLmdhdGhlcigpIGZhaWxlZDogJXMnLCBlcnJvci50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9pY2VHYXRoZXJlciA9IGljZUdhdGhlcmVyO1xuICAgIH1cbiAgICBfc2V0SWNlVHJhbnNwb3J0KCkge1xuICAgICAgICBjb25zdCBpY2VUcmFuc3BvcnQgPSBuZXcgUlRDSWNlVHJhbnNwb3J0KHRoaXMuX2ljZUdhdGhlcmVyKTtcbiAgICAgICAgLy8gTk9URTogTm90IHlldCBpbXBsZW1lbnRlZCBieSBFZGdlLlxuICAgICAgICBpY2VUcmFuc3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKGljZVRyYW5zcG9ydC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNraW5nJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgLy8gTk9URTogTm90IHN0YW5kYXJkLCBidXQgaW1wbGVtZW50ZWQgYnkgRWRnZS5cbiAgICAgICAgaWNlVHJhbnNwb3J0LmFkZEV2ZW50TGlzdGVuZXIoJ2ljZXN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgc3dpdGNoIChpY2VUcmFuc3BvcnQuc3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjaGVja2luZyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGljZVRyYW5zcG9ydC5hZGRFdmVudExpc3RlbmVyKCdjYW5kaWRhdGVwYWlyY2hhbmdlJywgKGV2ZW50KSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2ljZVRyYW5zcG9ydCBcImNhbmRpZGF0ZXBhaXJjaGFuZ2VcIiBldmVudCBbcGFpcjolb10nLCBldmVudC5wYWlyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2ljZVRyYW5zcG9ydCA9IGljZVRyYW5zcG9ydDtcbiAgICB9XG4gICAgX3NldER0bHNUcmFuc3BvcnQoKSB7XG4gICAgICAgIGNvbnN0IGR0bHNUcmFuc3BvcnQgPSBuZXcgUlRDRHRsc1RyYW5zcG9ydCh0aGlzLl9pY2VUcmFuc3BvcnQpO1xuICAgICAgICAvLyBOT1RFOiBOb3QgeWV0IGltcGxlbWVudGVkIGJ5IEVkZ2UuXG4gICAgICAgIGR0bHNUcmFuc3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2R0bHNUcmFuc3BvcnQgXCJzdGF0ZWNoYW5nZVwiIGV2ZW50IFtzdGF0ZTolc10nLCBkdGxzVHJhbnNwb3J0LnN0YXRlKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIE5PVEU6IE5vdCBzdGFuZGFyZCwgYnV0IGltcGxlbWVudGVkIGJ5IEVkZ2UuXG4gICAgICAgIGR0bHNUcmFuc3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignZHRsc3N0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdkdGxzVHJhbnNwb3J0IFwiZHRsc3N0YXRlY2hhbmdlXCIgZXZlbnQgW3N0YXRlOiVzXScsIGR0bHNUcmFuc3BvcnQuc3RhdGUpO1xuICAgICAgICAgICAgaWYgKGR0bHNUcmFuc3BvcnQuc3RhdGUgPT09ICdjbG9zZWQnKVxuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGR0bHNUcmFuc3BvcnQuYWRkRXZlbnRMaXN0ZW5lcignZXJyb3InLCAoZXZlbnQpID0+IHtcbiAgICAgICAgICAgIGxvZ2dlci5lcnJvcignZHRsc1RyYW5zcG9ydCBcImVycm9yXCIgZXZlbnQgW2V2ZW50OiVvXScsIGV2ZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2R0bHNUcmFuc3BvcnQgPSBkdGxzVHJhbnNwb3J0O1xuICAgIH1cbiAgICBhc3luYyBfc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdfc2V0dXBUcmFuc3BvcnQoKScpO1xuICAgICAgICAvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cbiAgICAgICAgY29uc3QgZHRsc1BhcmFtZXRlcnMgPSB0aGlzLl9kdGxzVHJhbnNwb3J0LmdldExvY2FsUGFyYW1ldGVycygpO1xuICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID0gbG9jYWxEdGxzUm9sZTtcbiAgICAgICAgLy8gTmVlZCB0byB0ZWxsIHRoZSByZW1vdGUgdHJhbnNwb3J0IGFib3V0IG91ciBwYXJhbWV0ZXJzLlxuICAgICAgICBhd2FpdCB0aGlzLnNhZmVFbWl0QXNQcm9taXNlKCdAY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSk7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSBSVENJY2VUcmFuc3BvcnQuXG4gICAgICAgIHRoaXMuX2ljZVRyYW5zcG9ydC5zdGFydCh0aGlzLl9pY2VHYXRoZXJlciwgdGhpcy5fcmVtb3RlSWNlUGFyYW1ldGVycywgJ2NvbnRyb2xsaW5nJyk7XG4gICAgICAgIC8vIEFkZCByZW1vdGUgSUNFIGNhbmRpZGF0ZXMuXG4gICAgICAgIGZvciAoY29uc3QgY2FuZGlkYXRlIG9mIHRoaXMuX3JlbW90ZUljZUNhbmRpZGF0ZXMpIHtcbiAgICAgICAgICAgIHRoaXMuX2ljZVRyYW5zcG9ydC5hZGRSZW1vdGVDYW5kaWRhdGUoY2FuZGlkYXRlKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBBbHNvIHNpZ25hbCBhICdjb21wbGV0ZScgY2FuZGlkYXRlIGFzIHBlciBzcGVjLlxuICAgICAgICAvLyBOT1RFOiBJdCBzaG91bGQgYmUge2NvbXBsZXRlOiB0cnVlfSBidXQgRWRnZSBwcmVmZXJzIHt9LlxuICAgICAgICAvLyBOT1RFOiBJZiB3ZSBkb24ndCBzaWduYWwgZW5kIG9mIGNhbmRpZGF0ZXMsIHRoZSBFZGdlIFJUQ0ljZVRyYW5zcG9ydFxuICAgICAgICAvLyB3b24ndCBlbnRlciB0aGUgJ2NvbXBsZXRlZCcgc3RhdGUuXG4gICAgICAgIHRoaXMuX2ljZVRyYW5zcG9ydC5hZGRSZW1vdGVDYW5kaWRhdGUoe30pO1xuICAgICAgICAvLyBOT1RFOiBFZGdlIGRvZXMgbm90IGxpa2UgU0hBIGxlc3MgdGhhbiAyNTYuXG4gICAgICAgIHRoaXMuX3JlbW90ZUR0bHNQYXJhbWV0ZXJzLmZpbmdlcnByaW50cyA9IHRoaXMuX3JlbW90ZUR0bHNQYXJhbWV0ZXJzLmZpbmdlcnByaW50c1xuICAgICAgICAgICAgLmZpbHRlcigoZmluZ2VycHJpbnQpID0+IHtcbiAgICAgICAgICAgIHJldHVybiAoZmluZ2VycHJpbnQuYWxnb3JpdGhtID09PSAnc2hhLTI1NicgfHxcbiAgICAgICAgICAgICAgICBmaW5nZXJwcmludC5hbGdvcml0aG0gPT09ICdzaGEtMzg0JyB8fFxuICAgICAgICAgICAgICAgIGZpbmdlcnByaW50LmFsZ29yaXRobSA9PT0gJ3NoYS01MTInKTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8vIFN0YXJ0IHRoZSBSVENEdGxzVHJhbnNwb3J0LlxuICAgICAgICB0aGlzLl9kdGxzVHJhbnNwb3J0LnN0YXJ0KHRoaXMuX3JlbW90ZUR0bHNQYXJhbWV0ZXJzKTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSB0cnVlO1xuICAgIH1cbn1cbmV4cG9ydHMuRWRnZTExID0gRWRnZTExO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5GaXJlZm94NjAgPSB2b2lkIDA7XG5jb25zdCBzZHBUcmFuc2Zvcm0gPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcInNkcC10cmFuc2Zvcm1cIikpO1xuY29uc3QgTG9nZ2VyXzEgPSByZXF1aXJlKFwiLi4vTG9nZ2VyXCIpO1xuY29uc3QgZXJyb3JzXzEgPSByZXF1aXJlKFwiLi4vZXJyb3JzXCIpO1xuY29uc3QgdXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL3V0aWxzXCIpKTtcbmNvbnN0IG9ydGMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4uL29ydGNcIikpO1xuY29uc3Qgc2RwQ29tbW9uVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL2NvbW1vblV0aWxzXCIpKTtcbmNvbnN0IHNkcFVuaWZpZWRQbGFuVXRpbHMgPSBfX2ltcG9ydFN0YXIocmVxdWlyZShcIi4vc2RwL3VuaWZpZWRQbGFuVXRpbHNcIikpO1xuY29uc3QgSGFuZGxlckludGVyZmFjZV8xID0gcmVxdWlyZShcIi4vSGFuZGxlckludGVyZmFjZVwiKTtcbmNvbnN0IFJlbW90ZVNkcF8xID0gcmVxdWlyZShcIi4vc2RwL1JlbW90ZVNkcFwiKTtcbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXJfMS5Mb2dnZXIoJ0ZpcmVmb3g2MCcpO1xuY29uc3QgU0NUUF9OVU1fU1RSRUFNUyA9IHsgT1M6IDE2LCBNSVM6IDIwNDggfTtcbmNsYXNzIEZpcmVmb3g2MCBleHRlbmRzIEhhbmRsZXJJbnRlcmZhY2VfMS5IYW5kbGVySW50ZXJmYWNlIHtcbiAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgc3VwZXIoKTtcbiAgICAgICAgLy8gTWFwIG9mIFJUQ1RyYW5zY2VpdmVycyBpbmRleGVkIGJ5IE1JRC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIExvY2FsIHN0cmVhbSBmb3Igc2VuZGluZy5cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAvLyBXaGV0aGVyIGEgRGF0YUNoYW5uZWwgbT1hcHBsaWNhdGlvbiBzZWN0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFNlbmRpbmcgRGF0YUNoYW5uZWwgaWQgdmFsdWUgY291bnRlci4gSW5jcmVtZW50ZWQgZm9yIGVhY2ggbmV3IERhdGFDaGFubmVsLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9IDA7XG4gICAgICAgIC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBGaXJlZm94NjAoKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnRmlyZWZveDYwJztcbiAgICB9XG4gICAgY2xvc2UoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuICAgICAgICAvLyBDbG9zZSBSVENQZWVyQ29ubmVjdGlvbi5cbiAgICAgICAgaWYgKHRoaXMuX3BjKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHRoaXMuX3BjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICBjb25zdCBwYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbih7XG4gICAgICAgICAgICBpY2VTZXJ2ZXJzOiBbXSxcbiAgICAgICAgICAgIGljZVRyYW5zcG9ydFBvbGljeTogJ2FsbCcsXG4gICAgICAgICAgICBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJyxcbiAgICAgICAgICAgIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJ1xuICAgICAgICB9KTtcbiAgICAgICAgLy8gTk9URTogV2UgbmVlZCB0byBhZGQgYSByZWFsIHZpZGVvIHRyYWNrIHRvIGdldCB0aGUgUklEIGV4dGVuc2lvbiBtYXBwaW5nLlxuICAgICAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICAgICAgLy8gTk9URTogT3RoZXJ3aXNlIEZpcmVmb3ggZmFpbHMgaW4gbmV4dCBsaW5lLlxuICAgICAgICBjYW52YXMuZ2V0Q29udGV4dCgnMmQnKTtcbiAgICAgICAgY29uc3QgZmFrZVN0cmVhbSA9IGNhbnZhcy5jYXB0dXJlU3RyZWFtKCk7XG4gICAgICAgIGNvbnN0IGZha2VWaWRlb1RyYWNrID0gZmFrZVN0cmVhbS5nZXRWaWRlb1RyYWNrcygpWzBdO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJywgeyBkaXJlY3Rpb246ICdzZW5kcmVjdicgfSk7XG4gICAgICAgICAgICBjb25zdCB2aWRlb1RyYW5zY2VpdmVyID0gcGMuYWRkVHJhbnNjZWl2ZXIoZmFrZVZpZGVvVHJhY2ssIHsgZGlyZWN0aW9uOiAnc2VuZHJlY3YnIH0pO1xuICAgICAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHZpZGVvVHJhbnNjZWl2ZXIuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgICAgIGNvbnN0IGVuY29kaW5ncyA9IFtcbiAgICAgICAgICAgICAgICB7IHJpZDogJ3IwJywgbWF4Qml0cmF0ZTogMTAwMDAwIH0sXG4gICAgICAgICAgICAgICAgeyByaWQ6ICdyMScsIG1heEJpdHJhdGU6IDUwMDAwMCB9XG4gICAgICAgICAgICBdO1xuICAgICAgICAgICAgcGFyYW1ldGVycy5lbmNvZGluZ3MgPSBlbmNvZGluZ3M7XG4gICAgICAgICAgICBhd2FpdCB2aWRlb1RyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCBwYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBjYW52YXMucmVtb3ZlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmYWtlVmlkZW9UcmFjay5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgICAgIGNvbnN0IHNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3QgbmF0aXZlUnRwQ2FwYWJpbGl0aWVzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdFJ0cENhcGFiaWxpdGllcyh7IHNkcE9iamVjdCB9KTtcbiAgICAgICAgICAgIHJldHVybiBuYXRpdmVSdHBDYXBhYmlsaXRpZXM7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNhbnZhcy5yZW1vdmUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBmYWtlVmlkZW9UcmFjay5zdG9wKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IyKSB7IH1cbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG51bVN0cmVhbXM6IFNDVFBfTlVNX1NUUkVBTVNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcnVuKHsgZGlyZWN0aW9uLCBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgc2N0cFBhcmFtZXRlcnMsIGljZVNlcnZlcnMsIGljZVRyYW5zcG9ydFBvbGljeSwgYWRkaXRpb25hbFNldHRpbmdzLCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncnVuKCknKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAgPSBuZXcgUmVtb3RlU2RwXzEuUmVtb3RlU2RwKHtcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVyc1xuICAgICAgICB9KTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmQgPVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kID1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG4gICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLl9wYyA9IG5ldyBSVENQZWVyQ29ubmVjdGlvbihPYmplY3QuYXNzaWduKHsgaWNlU2VydmVyczogaWNlU2VydmVycyB8fCBbXSwgaWNlVHJhbnNwb3J0UG9saWN5OiBpY2VUcmFuc3BvcnRQb2xpY3kgfHwgJ2FsbCcsIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLCBydGNwTXV4UG9saWN5OiAncmVxdWlyZScgfSwgYWRkaXRpb25hbFNldHRpbmdzKSwgcHJvcHJpZXRhcnlDb25zdHJhaW50cyk7XG4gICAgICAgIC8vIEhhbmRsZSBSVENQZWVyQ29ubmVjdGlvbiBjb25uZWN0aW9uIHN0YXR1cy5cbiAgICAgICAgdGhpcy5fcGMuYWRkRXZlbnRMaXN0ZW5lcignaWNlY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgKCkgPT4ge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLl9wYy5pY2VDb25uZWN0aW9uU3RhdGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlICdjaGVja2luZyc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0aW5nJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnY29tcGxldGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZmFpbGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Rpc2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdkaXNjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nsb3NlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKGljZVNlcnZlcnMpIHtcbiAgICAgICAgLy8gTk9URTogRmlyZWZveCBkb2VzIG5vdCBpbXBsZW1lbnQgcGMuc2V0Q29uZmlndXJhdGlvbigpLlxuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IHN1cHBvcnRlZCcpO1xuICAgIH1cbiAgICBhc3luYyByZXN0YXJ0SWNlKGljZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCknKTtcbiAgICAgICAgLy8gUHJvdmlkZSB0aGUgcmVtb3RlIFNEUCBoYW5kbGVyIHdpdGggbmV3IHJlbW90ZSBJQ0UgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUljZVBhcmFtZXRlcnMoaWNlUGFyYW1ldGVycyk7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gPT09ICdzZW5kJykge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcih7IGljZVJlc3RhcnQ6IHRydWUgfSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXRUcmFuc3BvcnRTdGF0cygpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3BjLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmQoeyB0cmFjaywgZW5jb2RpbmdzLCBjb2RlY09wdGlvbnMsIGNvZGVjIH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSBba2luZDolcywgdHJhY2suaWQ6JXNdJywgdHJhY2sua2luZCwgdHJhY2suaWQpO1xuICAgICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICBlbmNvZGluZ3MgPSB1dGlscy5jbG9uZShlbmNvZGluZ3MsIFtdKTtcbiAgICAgICAgICAgIGlmIChlbmNvZGluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgICAgIGVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGVuY29kaW5nLnJpZCA9IGByJHtpZHh9YDtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAvLyBDbG9uZSB0aGUgZW5jb2RpbmdzIGFuZCByZXZlcnNlIHRoZW0gYmVjYXVzZSBGaXJlZm94IGxpa2VzIHRoZW1cbiAgICAgICAgICAgICAgICAvLyBmcm9tIGhpZ2ggdG8gbG93LlxuICAgICAgICAgICAgICAgIGVuY29kaW5ncy5yZXZlcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2VuZGluZ1J0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSwge30pO1xuICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzID1cbiAgICAgICAgICAgIG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdLCB7fSk7XG4gICAgICAgIC8vIFRoaXMgbWF5IHRocm93LlxuICAgICAgICBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MgPVxuICAgICAgICAgICAgb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzLCBjb2RlYyk7XG4gICAgICAgIC8vIE5PVEU6IEZpcmVmb3ggZmFpbHMgc29tZXRpbWVzIHRvIHByb3Blcmx5IGFudGljaXBhdGUgdGhlIGNsb3NlZCBtZWRpYVxuICAgICAgICAvLyBzZWN0aW9uIHRoYXQgaXQgc2hvdWxkIHVzZSwgc28gZG9uJ3QgcmV1c2UgY2xvc2VkIG1lZGlhIHNlY3Rpb25zLlxuICAgICAgICAvLyAgIGh0dHBzOi8vZ2l0aHViLmNvbS92ZXJzYXRpY2EvbWVkaWFzb3VwLWNsaWVudC9pc3N1ZXMvMTA0XG4gICAgICAgIC8vXG4gICAgICAgIC8vIGNvbnN0IG1lZGlhU2VjdGlvbklkeCA9IHRoaXMuX3JlbW90ZVNkcCEuZ2V0TmV4dE1lZGlhU2VjdGlvbklkeCgpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX3BjLmFkZFRyYW5zY2VpdmVyKHRyYWNrLCB7IGRpcmVjdGlvbjogJ3NlbmRvbmx5Jywgc3RyZWFtczogW3RoaXMuX3NlbmRTdHJlYW1dIH0pO1xuICAgICAgICAvLyBOT1RFOiBUaGlzIGlzIG5vdCBzcGVjIGNvbXBsaWFudHMuIEVuY29kaW5ncyBzaG91bGQgYmUgZ2l2ZW4gaW4gYWRkVHJhbnNjZWl2ZXJcbiAgICAgICAgLy8gc2Vjb25kIGFyZ3VtZW50LCBidXQgRmlyZWZveCBkb2VzIG5vdCBzdXBwb3J0IGl0LlxuICAgICAgICBpZiAoZW5jb2RpbmdzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFBhcmFtZXRlcnMoKTtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzID0gZW5jb2RpbmdzO1xuICAgICAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsZXQgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgLy8gSW4gRmlyZWZveCB1c2UgRFRMUyByb2xlIGNsaWVudCBldmVuIGlmIHdlIGFyZSB0aGUgXCJvZmZlcmVyXCIgc2luY2VcbiAgICAgICAgLy8gRmlyZWZveCBkb2VzIG5vdCByZXNwZWN0IElDRS1MaXRlLlxuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnY2xpZW50JywgbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIC8vIFdlIGNhbiBub3cgZ2V0IHRoZSB0cmFuc2NlaXZlci5taWQuXG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSB0cmFuc2NlaXZlci5taWQ7XG4gICAgICAgIC8vIFNldCBNSUQuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLm1pZCA9IGxvY2FsSWQ7XG4gICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgY29uc3Qgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW2xvY2FsU2RwT2JqZWN0Lm1lZGlhLmxlbmd0aCAtIDFdO1xuICAgICAgICAvLyBTZXQgUlRDUCBDTkFNRS5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSA9XG4gICAgICAgICAgICBzZHBDb21tb25VdGlscy5nZXRDbmFtZSh7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgIC8vIFNldCBSVFAgZW5jb2RpbmdzIGJ5IHBhcnNpbmcgdGhlIFNEUCBvZmZlciBpZiBubyBlbmNvZGluZ3MgYXJlIGdpdmVuLlxuICAgICAgICBpZiAoIWVuY29kaW5ncykge1xuICAgICAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzID1cbiAgICAgICAgICAgICAgICBzZHBVbmlmaWVkUGxhblV0aWxzLmdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MgYnkgcGFyc2luZyB0aGUgU0RQIG9mZmVyIGFuZCBjb21wbGV0ZSB0aGVtIHdpdGggZ2l2ZW5cbiAgICAgICAgLy8gb25lIGlmIGp1c3QgYSBzaW5nbGUgZW5jb2RpbmcgaGFzIGJlZW4gZ2l2ZW4uXG4gICAgICAgIGVsc2UgaWYgKGVuY29kaW5ncy5sZW5ndGggPT09IDEpIHtcbiAgICAgICAgICAgIGNvbnN0IG5ld0VuY29kaW5ncyA9IHNkcFVuaWZpZWRQbGFuVXRpbHMuZ2V0UnRwRW5jb2RpbmdzKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24obmV3RW5jb2RpbmdzWzBdLCBlbmNvZGluZ3NbMF0pO1xuICAgICAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzID0gbmV3RW5jb2RpbmdzO1xuICAgICAgICB9XG4gICAgICAgIC8vIE90aGVyd2lzZSBpZiBtb3JlIHRoYW4gMSBlbmNvZGluZyBhcmUgZ2l2ZW4gdXNlIHRoZW0gdmVyYmF0aW0gKGJ1dFxuICAgICAgICAvLyByZXZlcnNlIHRoZW0gYmFjayBzaW5jZSB3ZSByZXZlcnNlZCB0aGVtIGFib3ZlIHRvIHNhdGlzZnkgRmlyZWZveCkuXG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzID0gZW5jb2RpbmdzLnJldmVyc2UoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBWUDggb3IgSDI2NCBhbmQgdGhlcmUgaXMgZWZmZWN0aXZlIHNpbXVsY2FzdCwgYWRkIHNjYWxhYmlsaXR5TW9kZSB0b1xuICAgICAgICAvLyBlYWNoIGVuY29kaW5nLlxuICAgICAgICBpZiAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIChzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOCcgfHxcbiAgICAgICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL2gyNjQnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSAnUzFUMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmQoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvZGVjT3B0aW9ucyxcbiAgICAgICAgICAgIGV4dG1hcEFsbG93TWl4ZWQ6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgLy8gU3RvcmUgaW4gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2V0KGxvY2FsSWQsIHRyYW5zY2VpdmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICBydHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJ0cFNlbmRlcjogdHJhbnNjZWl2ZXIuc2VuZGVyXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHN0b3BTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCB0cmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgdHJhbnNjZWl2ZXIuc2VuZGVyLnJlcGxhY2VUcmFjayhudWxsKTtcbiAgICAgICAgdGhpcy5fcGMucmVtb3ZlVHJhY2sodHJhbnNjZWl2ZXIuc2VuZGVyKTtcbiAgICAgICAgLy8gTk9URTogQ2Fubm90IHVzZSBjbG9zZU1lZGlhU2VjdGlvbigpIGR1ZSB0byB0aGUgdGhlIG5vdGUgYWJvdmUgaW4gc2VuZCgpXG4gICAgICAgIC8vIG1ldGhvZC5cbiAgICAgICAgLy8gdGhpcy5fcmVtb3RlU2RwIS5jbG9zZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuZGlzYWJsZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICBhc3luYyByZXBsYWNlVHJhY2sobG9jYWxJZCwgdHJhY2spIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBpZiAodHJhY2spIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIHRyYWNrLmlkOiVzXScsIGxvY2FsSWQsIHRyYWNrLmlkKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVwbGFjZVRyYWNrKCkgW2xvY2FsSWQ6JXMsIG5vIHRyYWNrXScsIGxvY2FsSWQpO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIucmVwbGFjZVRyYWNrKHRyYWNrKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0TWF4U3BhdGlhbExheWVyKGxvY2FsSWQsIHNwYXRpYWxMYXllcikge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgW2xvY2FsSWQ6JXMsIHNwYXRpYWxMYXllcjolc10nLCBsb2NhbElkLCBzcGF0aWFsTGF5ZXIpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCB0cmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIC8vIE5PVEU6IFdlIHJlcXVpcmUgZW5jb2RpbmdzIGdpdmVuIGZyb20gbG93IHRvIGhpZ2gsIGhvd2V2ZXIgRmlyZWZveFxuICAgICAgICAvLyByZXF1aXJlcyB0aGVtIGluIHJldmVyc2Ugb3JkZXIsIHNvIGRvIG1hZ2ljIGhlcmUuXG4gICAgICAgIHNwYXRpYWxMYXllciA9IHBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCAtIDEgLSBzcGF0aWFsTGF5ZXI7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmIChpZHggPj0gc3BhdGlhbExheWVyKVxuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKGxvY2FsSWQsIHBhcmFtcykge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgW2xvY2FsSWQ6JXMsIHBhcmFtczolb10nLCBsb2NhbElkLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHRyYW5zY2VpdmVyLnNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVuY29kaW5nKSwgcGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHRyYW5zY2VpdmVyLnNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTZW5kZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZERhdGFDaGFubmVsKHsgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCBsYWJlbCwgcHJvdG9jb2wgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSW5jcmVhc2UgbmV4dCBpZC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPVxuICAgICAgICAgICAgKyt0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCAlIFNDVFBfTlVNX1NUUkVBTVMuTUlTO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIGFuc3dlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgICAgIC5maW5kKChtKSA9PiBtLnR5cGUgPT09ICdhcHBsaWNhdGlvbicpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdzZXJ2ZXInLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZFNjdHBBc3NvY2lhdGlvbih7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjdHBTdHJlYW1QYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgc3RyZWFtSWQ6IG9wdGlvbnMuaWQsXG4gICAgICAgICAgICBvcmRlcmVkOiBvcHRpb25zLm9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZTogb3B0aW9ucy5tYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzOiBvcHRpb25zLm1heFJldHJhbnNtaXRzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycyB9O1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlKHsgdHJhY2tJZCwga2luZCwgcnRwUGFyYW1ldGVycyB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgW3RyYWNrSWQ6JXMsIGtpbmQ6JXNdJywgdHJhY2tJZCwga2luZCk7XG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSBydHBQYXJhbWV0ZXJzLm1pZCB8fCBTdHJpbmcodGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2l6ZSk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlKHtcbiAgICAgICAgICAgIG1pZDogbG9jYWxJZCxcbiAgICAgICAgICAgIGtpbmQsXG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBzdHJlYW1JZDogcnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lLFxuICAgICAgICAgICAgdHJhY2tJZFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgbGV0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgY29uc3QgYW5zd2VyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgLmZpbmQoKG0pID0+IFN0cmluZyhtLm1pZCkgPT09IGxvY2FsSWQpO1xuICAgICAgICAvLyBNYXkgbmVlZCB0byBtb2RpZnkgY29kZWMgcGFyYW1ldGVycyBpbiB0aGUgYW5zd2VyIGJhc2VkIG9uIGNvZGVjXG4gICAgICAgIC8vIHBhcmFtZXRlcnMgaW4gdGhlIG9mZmVyLlxuICAgICAgICBzZHBDb21tb25VdGlscy5hcHBseUNvZGVjUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJNZWRpYU9iamVjdFxuICAgICAgICB9KTtcbiAgICAgICAgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdjbGllbnQnLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9wYy5nZXRUcmFuc2NlaXZlcnMoKVxuICAgICAgICAgICAgLmZpbmQoKHQpID0+IHQubWlkID09PSBsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbmV3IFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICAvLyBTdG9yZSBpbiB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5zZXQobG9jYWxJZCwgdHJhbnNjZWl2ZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbG9jYWxJZCxcbiAgICAgICAgICAgIHRyYWNrOiB0cmFuc2NlaXZlci5yZWNlaXZlci50cmFjayxcbiAgICAgICAgICAgIHJ0cFJlY2VpdmVyOiB0cmFuc2NlaXZlci5yZWNlaXZlclxuICAgICAgICB9O1xuICAgIH1cbiAgICBhc3luYyBzdG9wUmVjZWl2aW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC5jbG9zZU1lZGlhU2VjdGlvbih0cmFuc2NlaXZlci5taWQpO1xuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0UmVjZWl2ZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiB0cmFuc2NlaXZlci5yZWNlaXZlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlRGF0YUNoYW5uZWwoeyBzY3RwU3RyZWFtUGFyYW1ldGVycywgbGFiZWwsIHByb3RvY29sIH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB7IHN0cmVhbUlkLCBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMgfSA9IHNjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2xcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgb2ZmZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlU2N0cEFzc29jaWF0aW9uKCk7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ2NsaWVudCcsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwgfTtcbiAgICB9XG4gICAgYXN5bmMgX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZSwgbG9jYWxTZHBPYmplY3QgfSkge1xuICAgICAgICBpZiAoIWxvY2FsU2RwT2JqZWN0KVxuICAgICAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICAvLyBHZXQgb3VyIGxvY2FsIERUTFMgcGFyYW1ldGVycy5cbiAgICAgICAgY29uc3QgZHRsc1BhcmFtZXRlcnMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0RHRsc1BhcmFtZXRlcnMoeyBzZHBPYmplY3Q6IGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAvLyBTZXQgb3VyIERUTFMgcm9sZS5cbiAgICAgICAgZHRsc1BhcmFtZXRlcnMucm9sZSA9IGxvY2FsRHRsc1JvbGU7XG4gICAgICAgIC8vIFVwZGF0ZSB0aGUgcmVtb3RlIERUTFMgcm9sZSBpbiB0aGUgU0RQLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlRHRsc1JvbGUobG9jYWxEdGxzUm9sZSA9PT0gJ2NsaWVudCcgPyAnc2VydmVyJyA6ICdjbGllbnQnKTtcbiAgICAgICAgLy8gTmVlZCB0byB0ZWxsIHRoZSByZW1vdGUgdHJhbnNwb3J0IGFib3V0IG91ciBwYXJhbWV0ZXJzLlxuICAgICAgICBhd2FpdCB0aGlzLnNhZmVFbWl0QXNQcm9taXNlKCdAY29ubmVjdCcsIHsgZHRsc1BhcmFtZXRlcnMgfSk7XG4gICAgICAgIHRoaXMuX3RyYW5zcG9ydFJlYWR5ID0gdHJ1ZTtcbiAgICB9XG4gICAgX2Fzc2VydFNlbmREaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdzZW5kJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwic2VuZFwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIF9hc3NlcnRSZWN2RGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAncmVjdicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInJlY3ZcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuRmlyZWZveDYwID0gRmlyZWZveDYwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkhhbmRsZXJJbnRlcmZhY2UgPSB2b2lkIDA7XG5jb25zdCBFbmhhbmNlZEV2ZW50RW1pdHRlcl8xID0gcmVxdWlyZShcIi4uL0VuaGFuY2VkRXZlbnRFbWl0dGVyXCIpO1xuY2xhc3MgSGFuZGxlckludGVyZmFjZSBleHRlbmRzIEVuaGFuY2VkRXZlbnRFbWl0dGVyXzEuRW5oYW5jZWRFdmVudEVtaXR0ZXIge1xuICAgIC8qKlxuICAgICAqIEBlbWl0cyBAY29ubmVjdCAtIChcbiAgICAgKiAgICAgeyBkdGxzUGFyYW1ldGVyczogRHRsc1BhcmFtZXRlcnMgfSxcbiAgICAgKiAgICAgY2FsbGJhY2s6IEZ1bmN0aW9uLFxuICAgICAqICAgICBlcnJiYWNrOiBGdW5jdGlvblxuICAgICAqICAgKVxuICAgICAqIEBlbWl0cyBAY29ubmVjdGlvbnN0YXRlY2hhbmdlIC0gKGNvbm5lY3Rpb25TdGF0ZTogQ29ubmVjdGlvblN0YXRlKVxuICAgICAqL1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgIH1cbn1cbmV4cG9ydHMuSGFuZGxlckludGVyZmFjZSA9IEhhbmRsZXJJbnRlcmZhY2U7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlJlYWN0TmF0aXZlID0gdm9pZCAwO1xuY29uc3Qgc2RwVHJhbnNmb3JtID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJzZHAtdHJhbnNmb3JtXCIpKTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4uL0xvZ2dlclwiKTtcbmNvbnN0IGVycm9yc18xID0gcmVxdWlyZShcIi4uL2Vycm9yc1wiKTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi91dGlsc1wiKSk7XG5jb25zdCBvcnRjID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9vcnRjXCIpKTtcbmNvbnN0IHNkcENvbW1vblV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NkcC9jb21tb25VdGlsc1wiKSk7XG5jb25zdCBzZHBQbGFuQlV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NkcC9wbGFuQlV0aWxzXCIpKTtcbmNvbnN0IEhhbmRsZXJJbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL0hhbmRsZXJJbnRlcmZhY2VcIik7XG5jb25zdCBSZW1vdGVTZHBfMSA9IHJlcXVpcmUoXCIuL3NkcC9SZW1vdGVTZHBcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdSZWFjdE5hdGl2ZScpO1xuY29uc3QgU0NUUF9OVU1fU1RSRUFNUyA9IHsgT1M6IDEwMjQsIE1JUzogMTAyNCB9O1xuY2xhc3MgUmVhY3ROYXRpdmUgZXh0ZW5kcyBIYW5kbGVySW50ZXJmYWNlXzEuSGFuZGxlckludGVyZmFjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIExvY2FsIHN0cmVhbSBmb3Igc2VuZGluZy5cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbSA9IG5ldyBNZWRpYVN0cmVhbSgpO1xuICAgICAgICAvLyBNYXAgb2Ygc2VuZGluZyBNZWRpYVN0cmVhbVRyYWNrcyBpbmRleGVkIGJ5IGxvY2FsSWQuXG4gICAgICAgIHRoaXMuX21hcFNlbmRMb2NhbElkVHJhY2sgPSBuZXcgTWFwKCk7XG4gICAgICAgIC8vIE5leHQgc2VuZGluZyBsb2NhbElkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZExvY2FsSWQgPSAwO1xuICAgICAgICAvLyBNYXAgb2YgTUlELCBSVFAgcGFyYW1ldGVycyBhbmQgUlRDUnRwUmVjZWl2ZXIgaW5kZXhlZCBieSBsb2NhbCBpZC5cbiAgICAgICAgLy8gVmFsdWUgaXMgYW4gT2JqZWN0IHdpdGggbWlkLCBydHBQYXJhbWV0ZXJzIGFuZCBydHBSZWNlaXZlci5cbiAgICAgICAgdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBXaGV0aGVyIGEgRGF0YUNoYW5uZWwgbT1hcHBsaWNhdGlvbiBzZWN0aW9uIGhhcyBiZWVuIGNyZWF0ZWQuXG4gICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gZmFsc2U7XG4gICAgICAgIC8vIFNlbmRpbmcgRGF0YUNoYW5uZWwgaWQgdmFsdWUgY291bnRlci4gSW5jcmVtZW50ZWQgZm9yIGVhY2ggbmV3IERhdGFDaGFubmVsLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9IDA7XG4gICAgICAgIC8vIEdvdCB0cmFuc3BvcnQgbG9jYWwgYW5kIHJlbW90ZSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IGZhbHNlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGEgZmFjdG9yeSBmdW5jdGlvbi5cbiAgICAgKi9cbiAgICBzdGF0aWMgY3JlYXRlRmFjdG9yeSgpIHtcbiAgICAgICAgcmV0dXJuICgpID0+IG5ldyBSZWFjdE5hdGl2ZSgpO1xuICAgIH1cbiAgICBnZXQgbmFtZSgpIHtcbiAgICAgICAgcmV0dXJuICdSZWFjdE5hdGl2ZSc7XG4gICAgfVxuICAgIGNsb3NlKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcbiAgICAgICAgLy8gQ2xvc2UgUlRDUGVlckNvbm5lY3Rpb24uXG4gICAgICAgIGlmICh0aGlzLl9wYykge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB0aGlzLl9wYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7IH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVSdHBDYXBhYmlsaXRpZXMoKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygnZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgY29uc3QgcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oe1xuICAgICAgICAgICAgaWNlU2VydmVyczogW10sXG4gICAgICAgICAgICBpY2VUcmFuc3BvcnRQb2xpY3k6ICdhbGwnLFxuICAgICAgICAgICAgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsXG4gICAgICAgICAgICBydGNwTXV4UG9saWN5OiAncmVxdWlyZScsXG4gICAgICAgICAgICBzZHBTZW1hbnRpY3M6ICdwbGFuLWInXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCBwYy5jcmVhdGVPZmZlcih7XG4gICAgICAgICAgICAgICAgb2ZmZXJUb1JlY2VpdmVBdWRpbzogdHJ1ZSxcbiAgICAgICAgICAgICAgICBvZmZlclRvUmVjZWl2ZVZpZGVvOiB0cnVlXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICBjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoeyBzZHBPYmplY3QgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlUnRwQ2FwYWJpbGl0aWVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yMikgeyB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbnVtU3RyZWFtczogU0NUUF9OVU1fU1RSRUFNU1xuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcGxhbkI6IHRydWVcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kID1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBhdWRpbzogb3J0Yy5nZXRTZW5kaW5nUnRwUGFyYW1ldGVycygnYXVkaW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyksXG4gICAgICAgICAgICAgICAgdmlkZW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ3ZpZGVvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpXG4gICAgICAgICAgICB9O1xuICAgICAgICB0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZCA9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fcGMgPSBuZXcgUlRDUGVlckNvbm5lY3Rpb24oT2JqZWN0LmFzc2lnbih7IGljZVNlcnZlcnM6IGljZVNlcnZlcnMgfHwgW10sIGljZVRyYW5zcG9ydFBvbGljeTogaWNlVHJhbnNwb3J0UG9saWN5IHx8ICdhbGwnLCBidW5kbGVQb2xpY3k6ICdtYXgtYnVuZGxlJywgcnRjcE11eFBvbGljeTogJ3JlcXVpcmUnLCBzZHBTZW1hbnRpY3M6ICdwbGFuLWInIH0sIGFkZGl0aW9uYWxTZXR0aW5ncyksIHByb3ByaWV0YXJ5Q29uc3RyYWludHMpO1xuICAgICAgICAvLyBIYW5kbGUgUlRDUGVlckNvbm5lY3Rpb24gY29ubmVjdGlvbiBzdGF0dXMuXG4gICAgICAgIHRoaXMuX3BjLmFkZEV2ZW50TGlzdGVuZXIoJ2ljZWNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICgpID0+IHtcbiAgICAgICAgICAgIHN3aXRjaCAodGhpcy5fcGMuaWNlQ29ubmVjdGlvblN0YXRlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnY2hlY2tpbmcnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGluZycpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2NvbXBsZXRlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjb25uZWN0ZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2ZhaWxlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkaXNjb25uZWN0ZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnZGlzY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2Nsb3NlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdjbG9zZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBhc3luYyB1cGRhdGVJY2VTZXJ2ZXJzKGljZVNlcnZlcnMpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCd1cGRhdGVJY2VTZXJ2ZXJzKCknKTtcbiAgICAgICAgY29uc3QgY29uZmlndXJhdGlvbiA9IHRoaXMuX3BjLmdldENvbmZpZ3VyYXRpb24oKTtcbiAgICAgICAgY29uZmlndXJhdGlvbi5pY2VTZXJ2ZXJzID0gaWNlU2VydmVycztcbiAgICAgICAgdGhpcy5fcGMuc2V0Q29uZmlndXJhdGlvbihjb25maWd1cmF0aW9uKTtcbiAgICB9XG4gICAgYXN5bmMgcmVzdGFydEljZShpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpJyk7XG4gICAgICAgIC8vIFByb3ZpZGUgdGhlIHJlbW90ZSBTRFAgaGFuZGxlciB3aXRoIG5ldyByZW1vdGUgSUNFIHBhcmFtZXRlcnMuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVJY2VQYXJhbWV0ZXJzKGljZVBhcmFtZXRlcnMpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uID09PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoeyBpY2VSZXN0YXJ0OiB0cnVlIH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZXN0YXJ0SWNlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0VHJhbnNwb3J0U3RhdHMoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9wYy5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kKHsgdHJhY2ssIGVuY29kaW5ncywgY29kZWNPcHRpb25zLCBjb2RlYyB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgW2tpbmQ6JXMsIHRyYWNrLmlkOiVzXScsIHRyYWNrLmtpbmQsIHRyYWNrLmlkKTtcbiAgICAgICAgaWYgKGNvZGVjKSB7XG4gICAgICAgICAgICBsb2dnZXIud2Fybignc2VuZCgpIHwgY29kZWMgc2VsZWN0aW9uIGlzIG5vdCBhdmFpbGFibGUgaW4gJXMgaGFuZGxlcicsIHRoaXMubmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fc2VuZFN0cmVhbS5hZGRUcmFjayh0cmFjayk7XG4gICAgICAgIHRoaXMuX3BjLmFkZFN0cmVhbSh0aGlzLl9zZW5kU3RyZWFtKTtcbiAgICAgICAgbGV0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbGV0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgIGxldCBvZmZlck1lZGlhT2JqZWN0O1xuICAgICAgICBjb25zdCBzZW5kaW5nUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdLCB7fSk7XG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9XG4gICAgICAgICAgICBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MpO1xuICAgICAgICBjb25zdCBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHRoaXMuX3NlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzQnlLaW5kW3RyYWNrLmtpbmRdLCB7fSk7XG4gICAgICAgIHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9XG4gICAgICAgICAgICBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MpO1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnc2VydmVyJywgbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgIGlmICh0cmFjay5raW5kID09PSAndmlkZW8nICYmIGVuY29kaW5ncyAmJiBlbmNvZGluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBlbmFibGluZyBzaW11bGNhc3QnKTtcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWFcbiAgICAgICAgICAgICAgICAuZmluZCgobSkgPT4gbS50eXBlID09PSAndmlkZW8nKTtcbiAgICAgICAgICAgIHNkcFBsYW5CVXRpbHMuYWRkTGVnYWN5U2ltdWxjYXN0KHtcbiAgICAgICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgICAgIHRyYWNrLFxuICAgICAgICAgICAgICAgIG51bVN0cmVhbXM6IGVuY29kaW5ncy5sZW5ndGhcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogc2RwVHJhbnNmb3JtLndyaXRlKGxvY2FsU2RwT2JqZWN0KSB9O1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhXG4gICAgICAgICAgICAuZmluZCgobSkgPT4gbS50eXBlID09PSB0cmFjay5raW5kKTtcbiAgICAgICAgLy8gU2V0IFJUQ1AgQ05BTUUuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUgPVxuICAgICAgICAgICAgc2RwQ29tbW9uVXRpbHMuZ2V0Q25hbWUoeyBvZmZlck1lZGlhT2JqZWN0IH0pO1xuICAgICAgICAvLyBTZXQgUlRQIGVuY29kaW5ncy5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzID1cbiAgICAgICAgICAgIHNkcFBsYW5CVXRpbHMuZ2V0UnRwRW5jb2RpbmdzKHsgb2ZmZXJNZWRpYU9iamVjdCwgdHJhY2sgfSk7XG4gICAgICAgIC8vIENvbXBsZXRlIGVuY29kaW5ncyB3aXRoIGdpdmVuIHZhbHVlcy5cbiAgICAgICAgaWYgKGVuY29kaW5ncykge1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2RpbmdzW2lkeF0pXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0sIGVuY29kaW5nc1tpZHhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBWUDggb3IgSDI2NCBhbmQgdGhlcmUgaXMgZWZmZWN0aXZlIHNpbXVsY2FzdCwgYWRkIHNjYWxhYmlsaXR5TW9kZSB0b1xuICAgICAgICAvLyBlYWNoIGVuY29kaW5nLlxuICAgICAgICBpZiAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIChzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOCcgfHxcbiAgICAgICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL2gyNjQnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSAnUzFUMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmQoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGNvZGVjT3B0aW9uc1xuICAgICAgICB9KTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICBjb25zdCBsb2NhbElkID0gU3RyaW5nKHRoaXMuX25leHRTZW5kTG9jYWxJZCk7XG4gICAgICAgIHRoaXMuX25leHRTZW5kTG9jYWxJZCsrO1xuICAgICAgICAvLyBJbnNlcnQgaW50byB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9tYXBTZW5kTG9jYWxJZFRyYWNrLnNldChsb2NhbElkLCB0cmFjayk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbElkOiBsb2NhbElkLFxuICAgICAgICAgICAgcnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcFNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSBbbG9jYWxJZDolc10nLCBsb2NhbElkKTtcbiAgICAgICAgY29uc3QgdHJhY2sgPSB0aGlzLl9tYXBTZW5kTG9jYWxJZFRyYWNrLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFjaylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcigndHJhY2sgbm90IGZvdW5kJyk7XG4gICAgICAgIHRoaXMuX21hcFNlbmRMb2NhbElkVHJhY2suZGVsZXRlKGxvY2FsSWQpO1xuICAgICAgICB0aGlzLl9zZW5kU3RyZWFtLnJlbW92ZVRyYWNrKHRyYWNrKTtcbiAgICAgICAgdGhpcy5fcGMuYWRkU3RyZWFtKHRoaXMuX3NlbmRTdHJlYW0pO1xuICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIC8vIE5PVEU6IElmIHRoZXJlIGFyZSBubyBzZW5kaW5nIHRyYWNrcywgc2V0TG9jYWxEZXNjcmlwdGlvbigpIHdpbGwgZmFpbCB3aXRoXG4gICAgICAgICAgICAvLyBcIkZhaWxlZCB0byBjcmVhdGUgY2hhbm5lbHNcIi4gSWYgc28sIGlnbm9yZSBpdC5cbiAgICAgICAgICAgIGlmICh0aGlzLl9zZW5kU3RyZWFtLmdldFRyYWNrcygpLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlci53YXJuKCdzdG9wU2VuZGluZygpIHwgaWdub3JpbmcgZXhwZWN0ZWQgZXJyb3IgZHVlIG5vIHNlbmRpbmcgdHJhY2tzOiAlcycsIGVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9wYy5zaWduYWxpbmdTdGF0ZSA9PT0gJ3N0YWJsZScpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFNlbmRpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIHJlcGxhY2VUcmFjayhcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgbG9jYWxJZCwgdHJhY2spIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgc2V0TWF4U3BhdGlhbExheWVyKGxvY2FsSWQsIHNwYXRpYWxMYXllcikge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JzXzEuVW5zdXBwb3J0ZWRFcnJvcignbm90IGltcGxlbWVudGVkJyk7XG4gICAgfVxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdW51c2VkLXZhcnNcbiAgICBhc3luYyBzZXRSdHBFbmNvZGluZ1BhcmFtZXRlcnMobG9jYWxJZCwgcGFyYW1zKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIGFzeW5jIGdldFNlbmRlclN0YXRzKGxvY2FsSWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yc18xLlVuc3VwcG9ydGVkRXJyb3IoJ25vdCBpbXBsZW1lbnRlZCcpO1xuICAgIH1cbiAgICBhc3luYyBzZW5kRGF0YUNoYW5uZWwoeyBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMsIGxhYmVsLCBwcm90b2NvbCB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0VGltZTogbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJbmNyZWFzZSBuZXh0IGlkLlxuICAgICAgICB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCA9XG4gICAgICAgICAgICArK3RoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkICUgU0NUUF9OVU1fU1RSRUFNUy5NSVM7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgYW5zd2VyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhXG4gICAgICAgICAgICAgICAgLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ2FwcGxpY2F0aW9uJyk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ3NlcnZlcicsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5zZW5kU2N0cEFzc29jaWF0aW9uKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc2N0cFN0cmVhbVBhcmFtZXRlcnMgPSB7XG4gICAgICAgICAgICBzdHJlYW1JZDogb3B0aW9ucy5pZCxcbiAgICAgICAgICAgIG9yZGVyZWQ6IG9wdGlvbnMub3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lOiBvcHRpb25zLm1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHM6IG9wdGlvbnMubWF4UmV0cmFuc21pdHNcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIHsgZGF0YUNoYW5uZWwsIHNjdHBTdHJlYW1QYXJhbWV0ZXJzIH07XG4gICAgfVxuICAgIGFzeW5jIHJlY2VpdmUoeyB0cmFja0lkLCBraW5kLCBydHBQYXJhbWV0ZXJzIH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSBbdHJhY2tJZDolcywga2luZDolc10nLCB0cmFja0lkLCBraW5kKTtcbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IHRyYWNrSWQ7XG4gICAgICAgIGNvbnN0IG1pZCA9IGtpbmQ7XG4gICAgICAgIGxldCBzdHJlYW1JZCA9IHJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZTtcbiAgICAgICAgLy8gTk9URTogSW4gUmVhY3QtTmF0aXZlIHdlIGNhbm5vdCByZXVzZSB0aGUgc2FtZSByZW1vdGUgTWVkaWFTdHJlYW0gZm9yIG5ld1xuICAgICAgICAvLyByZW1vdGUgdHJhY2tzLiBUaGlzIGlzIGJlY2F1c2UgcmVhY3QtbmF0aXZlLXdlYnJ0YyBkb2VzIG5vdCByZWFjdCBvbiBuZXdcbiAgICAgICAgLy8gdHJhY2tzIGdlbmVyYXRlZCB3aXRoaW4gYWxyZWFkeSBleGlzdGluZyBzdHJlYW1zLCBzbyBmb3JjZSB0aGUgc3RyZWFtSWRcbiAgICAgICAgLy8gdG8gYmUgZGlmZmVyZW50LlxuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGZvcmNpbmcgYSByYW5kb20gcmVtb3RlIHN0cmVhbUlkIHRvIGF2b2lkIHdlbGwga25vd24gYnVnIGluIHJlYWN0LW5hdGl2ZS13ZWJydGMnKTtcbiAgICAgICAgc3RyZWFtSWQgKz0gYC1oYWNrLSR7dXRpbHMuZ2VuZXJhdGVSYW5kb21OdW1iZXIoKX1gO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZSh7XG4gICAgICAgICAgICBtaWQsXG4gICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc3RyZWFtSWQsXG4gICAgICAgICAgICB0cmFja0lkXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBsZXQgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKGFuc3dlci5zZHApO1xuICAgICAgICBjb25zdCBhbnN3ZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhXG4gICAgICAgICAgICAuZmluZCgobSkgPT4gU3RyaW5nKG0ubWlkKSA9PT0gbWlkKTtcbiAgICAgICAgLy8gTWF5IG5lZWQgdG8gbW9kaWZ5IGNvZGVjIHBhcmFtZXRlcnMgaW4gdGhlIGFuc3dlciBiYXNlZCBvbiBjb2RlY1xuICAgICAgICAvLyBwYXJhbWV0ZXJzIGluIHRoZSBvZmZlci5cbiAgICAgICAgc2RwQ29tbW9uVXRpbHMuYXBwbHlDb2RlY1BhcmFtZXRlcnMoe1xuICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgYW5zd2VyTWVkaWFPYmplY3RcbiAgICAgICAgfSk7XG4gICAgICAgIGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogc2RwVHJhbnNmb3JtLndyaXRlKGxvY2FsU2RwT2JqZWN0KSB9O1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnY2xpZW50JywgbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGNvbnN0IHN0cmVhbSA9IHRoaXMuX3BjLmdldFJlbW90ZVN0cmVhbXMoKVxuICAgICAgICAgICAgLmZpbmQoKHMpID0+IHMuaWQgPT09IHN0cmVhbUlkKTtcbiAgICAgICAgY29uc3QgdHJhY2sgPSBzdHJlYW0uZ2V0VHJhY2tCeUlkKGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYWNrKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdyZW1vdGUgdHJhY2sgbm90IGZvdW5kJyk7XG4gICAgICAgIC8vIEluc2VydCBpbnRvIHRoZSBtYXAuXG4gICAgICAgIHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5zZXQobG9jYWxJZCwgeyBtaWQsIHJ0cFBhcmFtZXRlcnMgfSk7XG4gICAgICAgIHJldHVybiB7IGxvY2FsSWQsIHRyYWNrIH07XG4gICAgfVxuICAgIGFzeW5jIHN0b3BSZWNlaXZpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIFtsb2NhbElkOiVzXScsIGxvY2FsSWQpO1xuICAgICAgICBjb25zdCB7IG1pZCwgcnRwUGFyYW1ldGVycyB9ID0gdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvLmdldChsb2NhbElkKSB8fCB7fTtcbiAgICAgICAgLy8gUmVtb3ZlIGZyb20gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvLmRlbGV0ZShsb2NhbElkKTtcbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnBsYW5CU3RvcFJlY2VpdmluZyh7IG1pZDogbWlkLCBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMgfSk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZUFuc3dlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BSZWNlaXZpbmcoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgIH1cbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLXVudXNlZC12YXJzXG4gICAgYXN5bmMgZ2V0UmVjZWl2ZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcnNfMS5VbnN1cHBvcnRlZEVycm9yKCdub3QgaW1wbGVtZW50ZWQnKTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZURhdGFDaGFubmVsKHsgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGxhYmVsLCBwcm90b2NvbCB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgeyBzdHJlYW1JZCwgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzIH0gPSBzY3RwU3RyZWFtUGFyYW1ldGVycztcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogc3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0VGltZTogbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIG9mZmVyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZVNjdHBBc3NvY2lhdGlvbih7IG9sZERhdGFDaGFubmVsU3BlYzogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KSB7XG4gICAgICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UoYW5zd2VyLnNkcCk7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnY2xpZW50JywgbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4geyBkYXRhQ2hhbm5lbCB9O1xuICAgIH1cbiAgICBhc3luYyBfc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlLCBsb2NhbFNkcE9iamVjdCB9KSB7XG4gICAgICAgIGlmICghbG9jYWxTZHBPYmplY3QpXG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIC8vIEdldCBvdXIgbG9jYWwgRFRMUyBwYXJhbWV0ZXJzLlxuICAgICAgICBjb25zdCBkdGxzUGFyYW1ldGVycyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3REdGxzUGFyYW1ldGVycyh7IHNkcE9iamVjdDogbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgIC8vIFNldCBvdXIgRFRMUyByb2xlLlxuICAgICAgICBkdGxzUGFyYW1ldGVycy5yb2xlID0gbG9jYWxEdGxzUm9sZTtcbiAgICAgICAgLy8gVXBkYXRlIHRoZSByZW1vdGUgRFRMUyByb2xlIGluIHRoZSBTRFAuXG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcC51cGRhdGVEdGxzUm9sZShsb2NhbER0bHNSb2xlID09PSAnY2xpZW50JyA/ICdzZXJ2ZXInIDogJ2NsaWVudCcpO1xuICAgICAgICAvLyBOZWVkIHRvIHRlbGwgdGhlIHJlbW90ZSB0cmFuc3BvcnQgYWJvdXQgb3VyIHBhcmFtZXRlcnMuXG4gICAgICAgIGF3YWl0IHRoaXMuc2FmZUVtaXRBc1Byb21pc2UoJ0Bjb25uZWN0JywgeyBkdGxzUGFyYW1ldGVycyB9KTtcbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSB0cnVlO1xuICAgIH1cbiAgICBfYXNzZXJ0U2VuZERpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJzZW5kXCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKSB7XG4gICAgICAgIGlmICh0aGlzLl9kaXJlY3Rpb24gIT09ICdyZWN2Jykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdtZXRob2QgY2FuIGp1c3QgYmUgY2FsbGVkIGZvciBoYW5kbGVycyB3aXRoIFwicmVjdlwiIGRpcmVjdGlvbicpO1xuICAgICAgICB9XG4gICAgfVxufVxuZXhwb3J0cy5SZWFjdE5hdGl2ZSA9IFJlYWN0TmF0aXZlO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5TYWZhcmkxMSA9IHZvaWQgMDtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwic2RwLXRyYW5zZm9ybVwiKSk7XG5jb25zdCBMb2dnZXJfMSA9IHJlcXVpcmUoXCIuLi9Mb2dnZXJcIik7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vdXRpbHNcIikpO1xuY29uc3Qgb3J0YyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vb3J0Y1wiKSk7XG5jb25zdCBzZHBDb21tb25VdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvY29tbW9uVXRpbHNcIikpO1xuY29uc3Qgc2RwUGxhbkJVdGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi9zZHAvcGxhbkJVdGlsc1wiKSk7XG5jb25zdCBIYW5kbGVySW50ZXJmYWNlXzEgPSByZXF1aXJlKFwiLi9IYW5kbGVySW50ZXJmYWNlXCIpO1xuY29uc3QgUmVtb3RlU2RwXzEgPSByZXF1aXJlKFwiLi9zZHAvUmVtb3RlU2RwXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignU2FmYXJpMTEnKTtcbmNvbnN0IFNDVFBfTlVNX1NUUkVBTVMgPSB7IE9TOiAxMDI0LCBNSVM6IDEwMjQgfTtcbmNsYXNzIFNhZmFyaTExIGV4dGVuZHMgSGFuZGxlckludGVyZmFjZV8xLkhhbmRsZXJJbnRlcmZhY2Uge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICBzdXBlcigpO1xuICAgICAgICAvLyBMb2NhbCBzdHJlYW0gZm9yIHNlbmRpbmcuXG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgLy8gTWFwIG9mIFJUQ1J0cFNlbmRlciBpbmRleGVkIGJ5IGxvY2FsSWQuXG4gICAgICAgIHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBOZXh0IHNlbmRpbmcgbG9jYWxJZC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRMb2NhbElkID0gMDtcbiAgICAgICAgLy8gTWFwIG9mIE1JRCwgUlRQIHBhcmFtZXRlcnMgYW5kIFJUQ1J0cFJlY2VpdmVyIGluZGV4ZWQgYnkgbG9jYWwgaWQuXG4gICAgICAgIC8vIFZhbHVlIGlzIGFuIE9iamVjdCB3aXRoIG1pZCwgcnRwUGFyYW1ldGVycyBhbmQgcnRwUmVjZWl2ZXIuXG4gICAgICAgIHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mbyA9IG5ldyBNYXAoKTtcbiAgICAgICAgLy8gV2hldGhlciBhIERhdGFDaGFubmVsIG09YXBwbGljYXRpb24gc2VjdGlvbiBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IGZhbHNlO1xuICAgICAgICAvLyBTZW5kaW5nIERhdGFDaGFubmVsIGlkIHZhbHVlIGNvdW50ZXIuIEluY3JlbWVudGVkIGZvciBlYWNoIG5ldyBEYXRhQ2hhbm5lbC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPSAwO1xuICAgICAgICAvLyBHb3QgdHJhbnNwb3J0IGxvY2FsIGFuZCByZW1vdGUgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBuZXcgU2FmYXJpMTEoKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnU2FmYXJpMTEnO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIC8vIENsb3NlIFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgICAgICBpZiAodGhpcy5fcGMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiAnYWxsJyxcbiAgICAgICAgICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICAgICAgICAgICAgcnRjcE11eFBvbGljeTogJ3JlcXVpcmUnLFxuICAgICAgICAgICAgc2RwU2VtYW50aWNzOiAncGxhbi1iJ1xuICAgICAgICB9KTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgcGMuY3JlYXRlT2ZmZXIoe1xuICAgICAgICAgICAgICAgIG9mZmVyVG9SZWNlaXZlQXVkaW86IHRydWUsXG4gICAgICAgICAgICAgICAgb2ZmZXJUb1JlY2VpdmVWaWRlbzogdHJ1ZVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHBjLmNsb3NlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHsgfVxuICAgICAgICAgICAgY29uc3Qgc2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBuYXRpdmVSdHBDYXBhYmlsaXRpZXMgPSBzZHBDb21tb25VdGlscy5leHRyYWN0UnRwQ2FwYWJpbGl0aWVzKHsgc2RwT2JqZWN0IH0pO1xuICAgICAgICAgICAgcmV0dXJuIG5hdGl2ZVJ0cENhcGFiaWxpdGllcztcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcjIpIHsgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlU2N0cENhcGFiaWxpdGllcygpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCknKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIG51bVN0cmVhbXM6IFNDVFBfTlVNX1NUUkVBTVNcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcnVuKHsgZGlyZWN0aW9uLCBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgc2N0cFBhcmFtZXRlcnMsIGljZVNlcnZlcnMsIGljZVRyYW5zcG9ydFBvbGljeSwgYWRkaXRpb25hbFNldHRpbmdzLCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyB9KSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncnVuKCknKTtcbiAgICAgICAgdGhpcy5fZGlyZWN0aW9uID0gZGlyZWN0aW9uO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAgPSBuZXcgUmVtb3RlU2RwXzEuUmVtb3RlU2RwKHtcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHBsYW5COiB0cnVlXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZCA9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmQgPVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKE9iamVjdC5hc3NpZ24oeyBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzIHx8IFtdLCBpY2VUcmFuc3BvcnRQb2xpY3k6IGljZVRyYW5zcG9ydFBvbGljeSB8fCAnYWxsJywgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyB9LCBhZGRpdGlvbmFsU2V0dGluZ3MpLCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzKTtcbiAgICAgICAgLy8gSGFuZGxlIFJUQ1BlZXJDb25uZWN0aW9uIGNvbm5lY3Rpb24gc3RhdHVzLlxuICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNraW5nJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlSWNlU2VydmVycyhpY2VTZXJ2ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlSWNlU2VydmVycygpJyk7XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLl9wYy5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uaWNlU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgIHRoaXMuX3BjLnNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3RhcnRJY2UoaWNlUGFyYW1ldGVycykge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuICAgICAgICAvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCBuZXcgcmVtb3RlIElDRSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlSWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zcG9ydFN0YXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZCh7IHRyYWNrLCBlbmNvZGluZ3MsIGNvZGVjT3B0aW9ucywgY29kZWMgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIFtraW5kOiVzLCB0cmFjay5pZDolc10nLCB0cmFjay5raW5kLCB0cmFjay5pZCk7XG4gICAgICAgIGlmIChjb2RlYykge1xuICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3NlbmQoKSB8IGNvZGVjIHNlbGVjdGlvbiBpcyBub3QgYXZhaWxhYmxlIGluICVzIGhhbmRsZXInLCB0aGlzLm5hbWUpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0uYWRkVHJhY2sodHJhY2spO1xuICAgICAgICB0aGlzLl9wYy5hZGRUcmFjayh0cmFjaywgdGhpcy5fc2VuZFN0cmVhbSk7XG4gICAgICAgIGxldCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKCk7XG4gICAgICAgIGxldCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICBsZXQgb2ZmZXJNZWRpYU9iamVjdDtcbiAgICAgICAgY29uc3Qgc2VuZGluZ1J0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSwge30pO1xuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MgPVxuICAgICAgICAgICAgb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzKTtcbiAgICAgICAgY29uc3Qgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSwge30pO1xuICAgICAgICBzZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycy5jb2RlY3MgPVxuICAgICAgICAgICAgb3J0Yy5yZWR1Y2VDb2RlY3Moc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3NldHVwVHJhbnNwb3J0KHsgbG9jYWxEdGxzUm9sZTogJ3NlcnZlcicsIGxvY2FsU2RwT2JqZWN0IH0pO1xuICAgICAgICBpZiAodHJhY2sua2luZCA9PT0gJ3ZpZGVvJyAmJiBlbmNvZGluZ3MgJiYgZW5jb2RpbmdzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgZW5hYmxpbmcgc2ltdWxjYXN0Jyk7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gJ3ZpZGVvJyk7XG4gICAgICAgICAgICBzZHBQbGFuQlV0aWxzLmFkZExlZ2FjeVNpbXVsY2FzdCh7XG4gICAgICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgICAgICB0cmFjayxcbiAgICAgICAgICAgICAgICBudW1TdHJlYW1zOiBlbmNvZGluZ3MubGVuZ3RoXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHNkcFRyYW5zZm9ybS53cml0ZShsb2NhbFNkcE9iamVjdCkgfTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0TG9jYWxEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZSh0aGlzLl9wYy5sb2NhbERlc2NyaXB0aW9uLnNkcCk7XG4gICAgICAgIG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgLmZpbmQoKG0pID0+IG0udHlwZSA9PT0gdHJhY2sua2luZCk7XG4gICAgICAgIC8vIFNldCBSVENQIENOQU1FLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lID1cbiAgICAgICAgICAgIHNkcENvbW1vblV0aWxzLmdldENuYW1lKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9XG4gICAgICAgICAgICBzZHBQbGFuQlV0aWxzLmdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QsIHRyYWNrIH0pO1xuICAgICAgICAvLyBDb21wbGV0ZSBlbmNvZGluZ3Mgd2l0aCBnaXZlbiB2YWx1ZXMuXG4gICAgICAgIGlmIChlbmNvZGluZ3MpIHtcbiAgICAgICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICAgICAgaWYgKGVuY29kaW5nc1tpZHhdKVxuICAgICAgICAgICAgICAgICAgICBPYmplY3QuYXNzaWduKHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdLCBlbmNvZGluZ3NbaWR4XSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gSWYgVlA4IGFuZCB0aGVyZSBpcyBlZmZlY3RpdmUgc2ltdWxjYXN0LCBhZGQgc2NhbGFiaWxpdHlNb2RlIHRvIGVhY2hcbiAgICAgICAgLy8gZW5jb2RpbmcuXG4gICAgICAgIGlmIChzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCkgPT09ICd2aWRlby92cDgnKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IGVuY29kaW5nIG9mIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncykge1xuICAgICAgICAgICAgICAgIGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSA9ICdTMVQzJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZCh7XG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0LFxuICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGFuc3dlclJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgY29kZWNPcHRpb25zXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmQoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSBTdHJpbmcodGhpcy5fbmV4dFNlbmRMb2NhbElkKTtcbiAgICAgICAgdGhpcy5fbmV4dFNlbmRMb2NhbElkKys7XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX3BjLmdldFNlbmRlcnMoKVxuICAgICAgICAgICAgLmZpbmQoKHMpID0+IHMudHJhY2sgPT09IHRyYWNrKTtcbiAgICAgICAgLy8gSW5zZXJ0IGludG8gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWFwU2VuZExvY2FsSWRSdHBTZW5kZXIuc2V0KGxvY2FsSWQsIHJ0cFNlbmRlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbElkOiBsb2NhbElkLFxuICAgICAgICAgICAgcnRwUGFyYW1ldGVyczogc2VuZGluZ1J0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBydHBTZW5kZXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcFNlbmRpbmcobG9jYWxJZCkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHJ0cFNlbmRlciA9IHRoaXMuX21hcFNlbmRMb2NhbElkUnRwU2VuZGVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCFydHBTZW5kZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwU2VuZGVyIG5vdCBmb3VuZCcpO1xuICAgICAgICBpZiAocnRwU2VuZGVyLnRyYWNrKVxuICAgICAgICAgICAgdGhpcy5fc2VuZFN0cmVhbS5yZW1vdmVUcmFjayhydHBTZW5kZXIudHJhY2spO1xuICAgICAgICB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5kZWxldGUobG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgLy8gTk9URTogSWYgdGhlcmUgYXJlIG5vIHNlbmRpbmcgdHJhY2tzLCBzZXRMb2NhbERlc2NyaXB0aW9uKCkgd2lsbCBmYWlsIHdpdGhcbiAgICAgICAgICAgIC8vIFwiRmFpbGVkIHRvIGNyZWF0ZSBjaGFubmVsc1wiLiBJZiBzbywgaWdub3JlIGl0LlxuICAgICAgICAgICAgaWYgKHRoaXMuX3NlbmRTdHJlYW0uZ2V0VHJhY2tzKCkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyLndhcm4oJ3N0b3BTZW5kaW5nKCkgfCBpZ25vcmluZyBleHBlY3RlZCBlcnJvciBkdWUgbm8gc2VuZGluZyB0cmFja3M6ICVzJywgZXJyb3IudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX3BjLnNpZ25hbGluZ1N0YXRlID09PSAnc3RhYmxlJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgcmVwbGFjZVRyYWNrKGxvY2FsSWQsIHRyYWNrKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCB0cmFjay5pZDolc10nLCBsb2NhbElkLCB0cmFjay5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCBubyB0cmFja10nLCBsb2NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgY29uc3Qgb2xkVHJhY2sgPSBydHBTZW5kZXIudHJhY2s7XG4gICAgICAgIGF3YWl0IHJ0cFNlbmRlci5yZXBsYWNlVHJhY2sodHJhY2spO1xuICAgICAgICAvLyBSZW1vdmUgdGhlIG9sZCB0cmFjayBmcm9tIHRoZSBsb2NhbCBzdHJlYW0uXG4gICAgICAgIGlmIChvbGRUcmFjaylcbiAgICAgICAgICAgIHRoaXMuX3NlbmRTdHJlYW0ucmVtb3ZlVHJhY2sob2xkVHJhY2spO1xuICAgICAgICAvLyBBZGQgdGhlIG5ldyB0cmFjayB0byB0aGUgbG9jYWwgc3RyZWFtLlxuICAgICAgICBpZiAodHJhY2spXG4gICAgICAgICAgICB0aGlzLl9zZW5kU3RyZWFtLmFkZFRyYWNrKHRyYWNrKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0TWF4U3BhdGlhbExheWVyKGxvY2FsSWQsIHNwYXRpYWxMYXllcikge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0TWF4U3BhdGlhbExheWVyKCkgW2xvY2FsSWQ6JXMsIHNwYXRpYWxMYXllcjolc10nLCBsb2NhbElkLCBzcGF0aWFsTGF5ZXIpO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHJ0cFNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIGlmIChpZHggPD0gc3BhdGlhbExheWVyKVxuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IHRydWU7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcuYWN0aXZlID0gZmFsc2U7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCBydHBTZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgYXN5bmMgc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKGxvY2FsSWQsIHBhcmFtcykge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2V0UnRwRW5jb2RpbmdQYXJhbWV0ZXJzKCkgW2xvY2FsSWQ6JXMsIHBhcmFtczolb10nLCBsb2NhbElkLCBwYXJhbXMpO1xuICAgICAgICBjb25zdCBydHBTZW5kZXIgPSB0aGlzLl9tYXBTZW5kTG9jYWxJZFJ0cFNlbmRlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwU2VuZGVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFNlbmRlciBub3QgZm91bmQnKTtcbiAgICAgICAgY29uc3QgcGFyYW1ldGVycyA9IHJ0cFNlbmRlci5nZXRQYXJhbWV0ZXJzKCk7XG4gICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzLmZvckVhY2goKGVuY29kaW5nLCBpZHgpID0+IHtcbiAgICAgICAgICAgIHBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0gPSBPYmplY3QuYXNzaWduKE9iamVjdC5hc3NpZ24oe30sIGVuY29kaW5nKSwgcGFyYW1zKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0IHJ0cFNlbmRlci5zZXRQYXJhbWV0ZXJzKHBhcmFtZXRlcnMpO1xuICAgIH1cbiAgICBhc3luYyBnZXRTZW5kZXJTdGF0cyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgcnRwU2VuZGVyID0gdGhpcy5fbWFwU2VuZExvY2FsSWRSdHBTZW5kZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXJ0cFNlbmRlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBTZW5kZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiBydHBTZW5kZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZERhdGFDaGFubmVsKHsgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzLCBsYWJlbCwgcHJvdG9jb2wgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XG4gICAgICAgICAgICBuZWdvdGlhdGVkOiB0cnVlLFxuICAgICAgICAgICAgaWQ6IHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkLFxuICAgICAgICAgICAgb3JkZXJlZCxcbiAgICAgICAgICAgIG1heFBhY2tldExpZmVUaW1lLFxuICAgICAgICAgICAgbWF4UmV0cmFuc21pdHMsXG4gICAgICAgICAgICBwcm90b2NvbFxuICAgICAgICB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIFtvcHRpb25zOiVvXScsIG9wdGlvbnMpO1xuICAgICAgICBjb25zdCBkYXRhQ2hhbm5lbCA9IHRoaXMuX3BjLmNyZWF0ZURhdGFDaGFubmVsKGxhYmVsLCBvcHRpb25zKTtcbiAgICAgICAgLy8gSW5jcmVhc2UgbmV4dCBpZC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPVxuICAgICAgICAgICAgKyt0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCAlIFNDVFBfTlVNX1NUUkVBTVMuTUlTO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIGFuc3dlciB3aXRoXG4gICAgICAgIC8vIG09YXBwbGljYXRpb24gc2VjdGlvbi5cbiAgICAgICAgaWYgKCF0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyTWVkaWFPYmplY3QgPSBsb2NhbFNkcE9iamVjdC5tZWRpYVxuICAgICAgICAgICAgICAgIC5maW5kKChtKSA9PiBtLnR5cGUgPT09ICdhcHBsaWNhdGlvbicpO1xuICAgICAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdzZXJ2ZXInLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAuc2VuZFNjdHBBc3NvY2lhdGlvbih7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSB7IHR5cGU6ICdhbnN3ZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHNjdHBTdHJlYW1QYXJhbWV0ZXJzID0ge1xuICAgICAgICAgICAgc3RyZWFtSWQ6IG9wdGlvbnMuaWQsXG4gICAgICAgICAgICBvcmRlcmVkOiBvcHRpb25zLm9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZTogb3B0aW9ucy5tYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzOiBvcHRpb25zLm1heFJldHJhbnNtaXRzXG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsLCBzY3RwU3RyZWFtUGFyYW1ldGVycyB9O1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlKHsgdHJhY2tJZCwga2luZCwgcnRwUGFyYW1ldGVycyB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgW3RyYWNrSWQ6JXMsIGtpbmQ6JXNdJywgdHJhY2tJZCwga2luZCk7XG4gICAgICAgIGNvbnN0IGxvY2FsSWQgPSB0cmFja0lkO1xuICAgICAgICBjb25zdCBtaWQgPSBraW5kO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZSh7XG4gICAgICAgICAgICBtaWQsXG4gICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc3RyZWFtSWQ6IHJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSxcbiAgICAgICAgICAgIHRyYWNrSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGxldCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UoYW5zd2VyLnNkcCk7XG4gICAgICAgIGNvbnN0IGFuc3dlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWFcbiAgICAgICAgICAgIC5maW5kKChtKSA9PiBTdHJpbmcobS5taWQpID09PSBtaWQpO1xuICAgICAgICAvLyBNYXkgbmVlZCB0byBtb2RpZnkgY29kZWMgcGFyYW1ldGVycyBpbiB0aGUgYW5zd2VyIGJhc2VkIG9uIGNvZGVjXG4gICAgICAgIC8vIHBhcmFtZXRlcnMgaW4gdGhlIG9mZmVyLlxuICAgICAgICBzZHBDb21tb25VdGlscy5hcHBseUNvZGVjUGFyYW1ldGVycyh7XG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJNZWRpYU9iamVjdFxuICAgICAgICB9KTtcbiAgICAgICAgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdjbGllbnQnLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbYW5zd2VyOiVvXScsIGFuc3dlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgY29uc3QgcnRwUmVjZWl2ZXIgPSB0aGlzLl9wYy5nZXRSZWNlaXZlcnMoKVxuICAgICAgICAgICAgLmZpbmQoKHIpID0+IHIudHJhY2sgJiYgci50cmFjay5pZCA9PT0gbG9jYWxJZCk7XG4gICAgICAgIGlmICghcnRwUmVjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25ldyBSVENSdHBSZWNlaXZlciBub3QnKTtcbiAgICAgICAgLy8gSW5zZXJ0IGludG8gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWFwUmVjdkxvY2FsSWRJbmZvLnNldChsb2NhbElkLCB7IG1pZCwgcnRwUGFyYW1ldGVycywgcnRwUmVjZWl2ZXIgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBsb2NhbElkLFxuICAgICAgICAgICAgdHJhY2s6IHJ0cFJlY2VpdmVyLnRyYWNrLFxuICAgICAgICAgICAgcnRwUmVjZWl2ZXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcFJlY2VpdmluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHsgbWlkLCBydHBQYXJhbWV0ZXJzIH0gPSB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8uZ2V0KGxvY2FsSWQpIHx8IHt9O1xuICAgICAgICAvLyBSZW1vdmUgZnJvbSB0aGUgbWFwLlxuICAgICAgICB0aGlzLl9tYXBSZWN2TG9jYWxJZEluZm8uZGVsZXRlKGxvY2FsSWQpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAucGxhbkJTdG9wUmVjZWl2aW5nKHsgbWlkOiBtaWQsIG9mZmVyUnRwUGFyYW1ldGVyczogcnRwUGFyYW1ldGVycyB9KTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlY2VpdmVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHsgcnRwUmVjZWl2ZXIgfSA9IHRoaXMuX21hcFJlY3ZMb2NhbElkSW5mby5nZXQobG9jYWxJZCkgfHwge307XG4gICAgICAgIGlmICghcnRwUmVjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwUmVjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIHJldHVybiBydHBSZWNlaXZlci5nZXRTdGF0cygpO1xuICAgIH1cbiAgICBhc3luYyByZWNlaXZlRGF0YUNoYW5uZWwoeyBzY3RwU3RyZWFtUGFyYW1ldGVycywgbGFiZWwsIHByb3RvY29sIH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0UmVjdkRpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCB7IHN0cmVhbUlkLCBvcmRlcmVkLCBtYXhQYWNrZXRMaWZlVGltZSwgbWF4UmV0cmFuc21pdHMgfSA9IHNjdHBTdHJlYW1QYXJhbWV0ZXJzO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiBzdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2xcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdyZWNlaXZlRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIElmIHRoaXMgaXMgdGhlIGZpcnN0IERhdGFDaGFubmVsIHdlIG5lZWQgdG8gY3JlYXRlIHRoZSBTRFAgb2ZmZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIHRoaXMuX3JlbW90ZVNkcC5yZWNlaXZlU2N0cEFzc29jaWF0aW9uKHsgb2xkRGF0YUNoYW5uZWxTcGVjOiB0cnVlIH0pO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdjbGllbnQnLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsIH07XG4gICAgfVxuICAgIGFzeW5jIF9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGUsIGxvY2FsU2RwT2JqZWN0IH0pIHtcbiAgICAgICAgaWYgKCFsb2NhbFNkcE9iamVjdClcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgLy8gR2V0IG91ciBsb2NhbCBEVExTIHBhcmFtZXRlcnMuXG4gICAgICAgIGNvbnN0IGR0bHNQYXJhbWV0ZXJzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdER0bHNQYXJhbWV0ZXJzKHsgc2RwT2JqZWN0OiBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgLy8gU2V0IG91ciBEVExTIHJvbGUuXG4gICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPSBsb2NhbER0bHNSb2xlO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbW90ZSBEVExTIHJvbGUgaW4gdGhlIFNEUC5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUR0bHNSb2xlKGxvY2FsRHRsc1JvbGUgPT09ICdjbGllbnQnID8gJ3NlcnZlcicgOiAnY2xpZW50Jyk7XG4gICAgICAgIC8vIE5lZWQgdG8gdGVsbCB0aGUgcmVtb3RlIHRyYW5zcG9ydCBhYm91dCBvdXIgcGFyYW1ldGVycy5cbiAgICAgICAgYXdhaXQgdGhpcy5zYWZlRW1pdEFzUHJvbWlzZSgnQGNvbm5lY3QnLCB7IGR0bHNQYXJhbWV0ZXJzIH0pO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IHRydWU7XG4gICAgfVxuICAgIF9hc3NlcnRTZW5kRGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInNlbmRcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYXNzZXJ0UmVjdkRpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3JlY3YnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJyZWN2XCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNhZmFyaTExID0gU2FmYXJpMTE7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLlNhZmFyaTEyID0gdm9pZCAwO1xuY29uc3Qgc2RwVHJhbnNmb3JtID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJzZHAtdHJhbnNmb3JtXCIpKTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4uL0xvZ2dlclwiKTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi91dGlsc1wiKSk7XG5jb25zdCBvcnRjID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi9vcnRjXCIpKTtcbmNvbnN0IHNkcENvbW1vblV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NkcC9jb21tb25VdGlsc1wiKSk7XG5jb25zdCBzZHBVbmlmaWVkUGxhblV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3NkcC91bmlmaWVkUGxhblV0aWxzXCIpKTtcbmNvbnN0IEhhbmRsZXJJbnRlcmZhY2VfMSA9IHJlcXVpcmUoXCIuL0hhbmRsZXJJbnRlcmZhY2VcIik7XG5jb25zdCBSZW1vdGVTZHBfMSA9IHJlcXVpcmUoXCIuL3NkcC9SZW1vdGVTZHBcIik7XG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyXzEuTG9nZ2VyKCdTYWZhcmkxMicpO1xuY29uc3QgU0NUUF9OVU1fU1RSRUFNUyA9IHsgT1M6IDEwMjQsIE1JUzogMTAyNCB9O1xuY2xhc3MgU2FmYXJpMTIgZXh0ZW5kcyBIYW5kbGVySW50ZXJmYWNlXzEuSGFuZGxlckludGVyZmFjZSB7XG4gICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgIHN1cGVyKCk7XG4gICAgICAgIC8vIE1hcCBvZiBSVENUcmFuc2NlaXZlcnMgaW5kZXhlZCBieSBNSUQuXG4gICAgICAgIHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyID0gbmV3IE1hcCgpO1xuICAgICAgICAvLyBMb2NhbCBzdHJlYW0gZm9yIHNlbmRpbmcuXG4gICAgICAgIHRoaXMuX3NlbmRTdHJlYW0gPSBuZXcgTWVkaWFTdHJlYW0oKTtcbiAgICAgICAgLy8gV2hldGhlciBhIERhdGFDaGFubmVsIG09YXBwbGljYXRpb24gc2VjdGlvbiBoYXMgYmVlbiBjcmVhdGVkLlxuICAgICAgICB0aGlzLl9oYXNEYXRhQ2hhbm5lbE1lZGlhU2VjdGlvbiA9IGZhbHNlO1xuICAgICAgICAvLyBTZW5kaW5nIERhdGFDaGFubmVsIGlkIHZhbHVlIGNvdW50ZXIuIEluY3JlbWVudGVkIGZvciBlYWNoIG5ldyBEYXRhQ2hhbm5lbC5cbiAgICAgICAgdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgPSAwO1xuICAgICAgICAvLyBHb3QgdHJhbnNwb3J0IGxvY2FsIGFuZCByZW1vdGUgcGFyYW1ldGVycy5cbiAgICAgICAgdGhpcy5fdHJhbnNwb3J0UmVhZHkgPSBmYWxzZTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogQ3JlYXRlcyBhIGZhY3RvcnkgZnVuY3Rpb24uXG4gICAgICovXG4gICAgc3RhdGljIGNyZWF0ZUZhY3RvcnkoKSB7XG4gICAgICAgIHJldHVybiAoKSA9PiBuZXcgU2FmYXJpMTIoKTtcbiAgICB9XG4gICAgZ2V0IG5hbWUoKSB7XG4gICAgICAgIHJldHVybiAnU2FmYXJpMTInO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdjbG9zZSgpJyk7XG4gICAgICAgIC8vIENsb3NlIFJUQ1BlZXJDb25uZWN0aW9uLlxuICAgICAgICBpZiAodGhpcy5fcGMpIHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgYXN5bmMgZ2V0TmF0aXZlUnRwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVJ0cENhcGFiaWxpdGllcygpJyk7XG4gICAgICAgIGNvbnN0IHBjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKHtcbiAgICAgICAgICAgIGljZVNlcnZlcnM6IFtdLFxuICAgICAgICAgICAgaWNlVHJhbnNwb3J0UG9saWN5OiAnYWxsJyxcbiAgICAgICAgICAgIGJ1bmRsZVBvbGljeTogJ21heC1idW5kbGUnLFxuICAgICAgICAgICAgcnRjcE11eFBvbGljeTogJ3JlcXVpcmUnXG4gICAgICAgIH0pO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgcGMuYWRkVHJhbnNjZWl2ZXIoJ2F1ZGlvJyk7XG4gICAgICAgICAgICBwYy5hZGRUcmFuc2NlaXZlcigndmlkZW8nKTtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgcGMuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlcnJvcikgeyB9XG4gICAgICAgICAgICBjb25zdCBzZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgICAgIGNvbnN0IG5hdGl2ZVJ0cENhcGFiaWxpdGllcyA9IHNkcENvbW1vblV0aWxzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMoeyBzZHBPYmplY3QgfSk7XG4gICAgICAgICAgICByZXR1cm4gbmF0aXZlUnRwQ2FwYWJpbGl0aWVzO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBwYy5jbG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGVycm9yMikgeyB9XG4gICAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgIH1cbiAgICBhc3luYyBnZXROYXRpdmVTY3RwQ2FwYWJpbGl0aWVzKCkge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ2dldE5hdGl2ZVNjdHBDYXBhYmlsaXRpZXMoKScpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbnVtU3RyZWFtczogU0NUUF9OVU1fU1RSRUFNU1xuICAgICAgICB9O1xuICAgIH1cbiAgICBydW4oeyBkaXJlY3Rpb24sIGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBzY3RwUGFyYW1ldGVycywgaWNlU2VydmVycywgaWNlVHJhbnNwb3J0UG9saWN5LCBhZGRpdGlvbmFsU2V0dGluZ3MsIHByb3ByaWV0YXJ5Q29uc3RyYWludHMsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzIH0pIHtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdydW4oKScpO1xuICAgICAgICB0aGlzLl9kaXJlY3Rpb24gPSBkaXJlY3Rpb247XG4gICAgICAgIHRoaXMuX3JlbW90ZVNkcCA9IG5ldyBSZW1vdGVTZHBfMS5SZW1vdGVTZHAoe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHNjdHBQYXJhbWV0ZXJzXG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9zZW5kaW5nUnRwUGFyYW1ldGVyc0J5S2luZCA9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYXVkaW86IG9ydGMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMoJ2F1ZGlvJywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpLFxuICAgICAgICAgICAgICAgIHZpZGVvOiBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCd2aWRlbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKVxuICAgICAgICAgICAgfTtcbiAgICAgICAgdGhpcy5fc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnNCeUtpbmQgPVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGF1ZGlvOiBvcnRjLmdldFNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzKCdhdWRpbycsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSxcbiAgICAgICAgICAgICAgICB2aWRlbzogb3J0Yy5nZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycygndmlkZW8nLCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcylcbiAgICAgICAgICAgIH07XG4gICAgICAgIHRoaXMuX3BjID0gbmV3IFJUQ1BlZXJDb25uZWN0aW9uKE9iamVjdC5hc3NpZ24oeyBpY2VTZXJ2ZXJzOiBpY2VTZXJ2ZXJzIHx8IFtdLCBpY2VUcmFuc3BvcnRQb2xpY3k6IGljZVRyYW5zcG9ydFBvbGljeSB8fCAnYWxsJywgYnVuZGxlUG9saWN5OiAnbWF4LWJ1bmRsZScsIHJ0Y3BNdXhQb2xpY3k6ICdyZXF1aXJlJyB9LCBhZGRpdGlvbmFsU2V0dGluZ3MpLCBwcm9wcmlldGFyeUNvbnN0cmFpbnRzKTtcbiAgICAgICAgLy8gSGFuZGxlIFJUQ1BlZXJDb25uZWN0aW9uIGNvbm5lY3Rpb24gc3RhdHVzLlxuICAgICAgICB0aGlzLl9wYy5hZGRFdmVudExpc3RlbmVyKCdpY2Vjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAoKSA9PiB7XG4gICAgICAgICAgICBzd2l0Y2ggKHRoaXMuX3BjLmljZUNvbm5lY3Rpb25TdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2NoZWNraW5nJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Nvbm5lY3RpbmcnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdjb21wbGV0ZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY29ubmVjdGVkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnQGNvbm5lY3Rpb25zdGF0ZWNoYW5nZScsICdmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGlzY29ubmVjdGVkJzpcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdAY29ubmVjdGlvbnN0YXRlY2hhbmdlJywgJ2Rpc2Nvbm5lY3RlZCcpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdjbG9zZWQnOlxuICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ0Bjb25uZWN0aW9uc3RhdGVjaGFuZ2UnLCAnY2xvc2VkJyk7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYXN5bmMgdXBkYXRlSWNlU2VydmVycyhpY2VTZXJ2ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlSWNlU2VydmVycygpJyk7XG4gICAgICAgIGNvbnN0IGNvbmZpZ3VyYXRpb24gPSB0aGlzLl9wYy5nZXRDb25maWd1cmF0aW9uKCk7XG4gICAgICAgIGNvbmZpZ3VyYXRpb24uaWNlU2VydmVycyA9IGljZVNlcnZlcnM7XG4gICAgICAgIHRoaXMuX3BjLnNldENvbmZpZ3VyYXRpb24oY29uZmlndXJhdGlvbik7XG4gICAgfVxuICAgIGFzeW5jIHJlc3RhcnRJY2UoaWNlUGFyYW1ldGVycykge1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3Jlc3RhcnRJY2UoKScpO1xuICAgICAgICAvLyBQcm92aWRlIHRoZSByZW1vdGUgU0RQIGhhbmRsZXIgd2l0aCBuZXcgcmVtb3RlIElDRSBwYXJhbWV0ZXJzLlxuICAgICAgICB0aGlzLl9yZW1vdGVTZHAudXBkYXRlSWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKTtcbiAgICAgICAgaWYgKCF0aGlzLl90cmFuc3BvcnRSZWFkeSlcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiA9PT0gJ3NlbmQnKSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IGF3YWl0IHRoaXMuX3BjLmNyZWF0ZU9mZmVyKHsgaWNlUmVzdGFydDogdHJ1ZSB9KTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVzdGFydEljZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIGdldFRyYW5zcG9ydFN0YXRzKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5fcGMuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgc2VuZCh7IHRyYWNrLCBlbmNvZGluZ3MsIGNvZGVjT3B0aW9ucywgY29kZWMgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIFtraW5kOiVzLCB0cmFjay5pZDolc10nLCB0cmFjay5raW5kLCB0cmFjay5pZCk7XG4gICAgICAgIGNvbnN0IHNlbmRpbmdSdHBQYXJhbWV0ZXJzID0gdXRpbHMuY2xvbmUodGhpcy5fc2VuZGluZ1J0cFBhcmFtZXRlcnNCeUtpbmRbdHJhY2sua2luZF0sIHt9KTtcbiAgICAgICAgLy8gVGhpcyBtYXkgdGhyb3cuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmNvZGVjcyA9XG4gICAgICAgICAgICBvcnRjLnJlZHVjZUNvZGVjcyhzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3MsIGNvZGVjKTtcbiAgICAgICAgY29uc3Qgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMgPSB1dGlscy5jbG9uZSh0aGlzLl9zZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVyc0J5S2luZFt0cmFjay5raW5kXSwge30pO1xuICAgICAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICAgICAgc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMuY29kZWNzID1cbiAgICAgICAgICAgIG9ydGMucmVkdWNlQ29kZWNzKHNlbmRpbmdSZW1vdGVSdHBQYXJhbWV0ZXJzLmNvZGVjcywgY29kZWMpO1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb25JZHggPSB0aGlzLl9yZW1vdGVTZHAuZ2V0TmV4dE1lZGlhU2VjdGlvbklkeCgpO1xuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX3BjLmFkZFRyYW5zY2VpdmVyKHRyYWNrLCB7IGRpcmVjdGlvbjogJ3NlbmRvbmx5Jywgc3RyZWFtczogW3RoaXMuX3NlbmRTdHJlYW1dIH0pO1xuICAgICAgICBsZXQgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsZXQgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2Uob2ZmZXIuc2RwKTtcbiAgICAgICAgbGV0IG9mZmVyTWVkaWFPYmplY3Q7XG4gICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpXG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdzZXJ2ZXInLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgaWYgKGVuY29kaW5ncyAmJiBlbmNvZGluZ3MubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBlbmFibGluZyBsZWdhY3kgc2ltdWxjYXN0Jyk7XG4gICAgICAgICAgICBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShvZmZlci5zZHApO1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCA9IGxvY2FsU2RwT2JqZWN0Lm1lZGlhW21lZGlhU2VjdGlvbklkeC5pZHhdO1xuICAgICAgICAgICAgc2RwVW5pZmllZFBsYW5VdGlscy5hZGRMZWdhY3lTaW11bGNhc3Qoe1xuICAgICAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICAgICAgbnVtU3RyZWFtczogZW5jb2RpbmdzLmxlbmd0aFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBvZmZlciA9IHsgdHlwZTogJ29mZmVyJywgc2RwOiBzZHBUcmFuc2Zvcm0ud3JpdGUobG9jYWxTZHBPYmplY3QpIH07XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgLy8gV2UgY2FuIG5vdyBnZXQgdGhlIHRyYW5zY2VpdmVyLm1pZC5cbiAgICAgICAgY29uc3QgbG9jYWxJZCA9IHRyYW5zY2VpdmVyLm1pZDtcbiAgICAgICAgLy8gU2V0IE1JRC5cbiAgICAgICAgc2VuZGluZ1J0cFBhcmFtZXRlcnMubWlkID0gbG9jYWxJZDtcbiAgICAgICAgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UodGhpcy5fcGMubG9jYWxEZXNjcmlwdGlvbi5zZHApO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWFbbWVkaWFTZWN0aW9uSWR4LmlkeF07XG4gICAgICAgIC8vIFNldCBSVENQIENOQU1FLlxuICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lID1cbiAgICAgICAgICAgIHNkcENvbW1vblV0aWxzLmdldENuYW1lKHsgb2ZmZXJNZWRpYU9iamVjdCB9KTtcbiAgICAgICAgLy8gU2V0IFJUUCBlbmNvZGluZ3MuXG4gICAgICAgIHNlbmRpbmdSdHBQYXJhbWV0ZXJzLmVuY29kaW5ncyA9XG4gICAgICAgICAgICBzZHBVbmlmaWVkUGxhblV0aWxzLmdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QgfSk7XG4gICAgICAgIC8vIENvbXBsZXRlIGVuY29kaW5ncyB3aXRoIGdpdmVuIHZhbHVlcy5cbiAgICAgICAgaWYgKGVuY29kaW5ncykge1xuICAgICAgICAgICAgZm9yIChsZXQgaWR4ID0gMDsgaWR4IDwgc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgICAgICBpZiAoZW5jb2RpbmdzW2lkeF0pXG4gICAgICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24oc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzW2lkeF0sIGVuY29kaW5nc1tpZHhdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBWUDggb3IgSDI2NCBhbmQgdGhlcmUgaXMgZWZmZWN0aXZlIHNpbXVsY2FzdCwgYWRkIHNjYWxhYmlsaXR5TW9kZSB0b1xuICAgICAgICAvLyBlYWNoIGVuY29kaW5nLlxuICAgICAgICBpZiAoc2VuZGluZ1J0cFBhcmFtZXRlcnMuZW5jb2RpbmdzLmxlbmd0aCA+IDEgJiZcbiAgICAgICAgICAgIChzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL3ZwOCcgfHxcbiAgICAgICAgICAgICAgICBzZW5kaW5nUnRwUGFyYW1ldGVycy5jb2RlY3NbMF0ubWltZVR5cGUudG9Mb3dlckNhc2UoKSA9PT0gJ3ZpZGVvL2gyNjQnKSkge1xuICAgICAgICAgICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBzZW5kaW5nUnRwUGFyYW1ldGVycy5lbmNvZGluZ3MpIHtcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUgPSAnUzFUMyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmQoe1xuICAgICAgICAgICAgb2ZmZXJNZWRpYU9iamVjdCxcbiAgICAgICAgICAgIHJldXNlTWlkOiBtZWRpYVNlY3Rpb25JZHgucmV1c2VNaWQsXG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnM6IHNlbmRpbmdSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgYW5zd2VyUnRwUGFyYW1ldGVyczogc2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBjb2RlY09wdGlvbnNcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgLy8gU3RvcmUgaW4gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2V0KGxvY2FsSWQsIHRyYW5zY2VpdmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICBydHBQYXJhbWV0ZXJzOiBzZW5kaW5nUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJ0cFNlbmRlcjogdHJhbnNjZWl2ZXIuc2VuZGVyXG4gICAgICAgIH07XG4gICAgfVxuICAgIGFzeW5jIHN0b3BTZW5kaW5nKGxvY2FsSWQpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB0cmFuc2NlaXZlci5zZW5kZXIucmVwbGFjZVRyYWNrKG51bGwpO1xuICAgICAgICB0aGlzLl9wYy5yZW1vdmVUcmFjayh0cmFuc2NlaXZlci5zZW5kZXIpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuY2xvc2VNZWRpYVNlY3Rpb24odHJhbnNjZWl2ZXIubWlkKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVPZmZlcigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3N0b3BTZW5kaW5nKCkgfCBjYWxsaW5nIHBjLnNldExvY2FsRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wU2VuZGluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFthbnN3ZXI6JW9dJywgYW5zd2VyKTtcbiAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICB9XG4gICAgYXN5bmMgcmVwbGFjZVRyYWNrKGxvY2FsSWQsIHRyYWNrKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFNlbmREaXJlY3Rpb24oKTtcbiAgICAgICAgaWYgKHRyYWNrKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCB0cmFjay5pZDolc10nLCBsb2NhbElkLCB0cmFjay5pZCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlcGxhY2VUcmFjaygpIFtsb2NhbElkOiVzLCBubyB0cmFja10nLCBsb2NhbElkKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0cmFuc2NlaXZlciA9IHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLmdldChsb2NhbElkKTtcbiAgICAgICAgaWYgKCF0cmFuc2NlaXZlcilcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignYXNzb2NpYXRlZCBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnJlcGxhY2VUcmFjayh0cmFjayk7XG4gICAgfVxuICAgIGFzeW5jIHNldE1heFNwYXRpYWxMYXllcihsb2NhbElkLCBzcGF0aWFsTGF5ZXIpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldE1heFNwYXRpYWxMYXllcigpIFtsb2NhbElkOiVzLCBzcGF0aWFsTGF5ZXI6JXNdJywgbG9jYWxJZCwgc3BhdGlhbExheWVyKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICBpZiAoaWR4IDw9IHNwYXRpYWxMYXllcilcbiAgICAgICAgICAgICAgICBlbmNvZGluZy5hY3RpdmUgPSB0cnVlO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIGVuY29kaW5nLmFjdGl2ZSA9IGZhbHNlO1xuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdHJhbnNjZWl2ZXIuc2VuZGVyLnNldFBhcmFtZXRlcnMocGFyYW1ldGVycyk7XG4gICAgfVxuICAgIGFzeW5jIHNldFJ0cEVuY29kaW5nUGFyYW1ldGVycyhsb2NhbElkLCBwYXJhbXMpIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3NldFJ0cEVuY29kaW5nUGFyYW1ldGVycygpIFtsb2NhbElkOiVzLCBwYXJhbXM6JW9dJywgbG9jYWxJZCwgcGFyYW1zKTtcbiAgICAgICAgY29uc3QgdHJhbnNjZWl2ZXIgPSB0aGlzLl9tYXBNaWRUcmFuc2NlaXZlci5nZXQobG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ2Fzc29jaWF0ZWQgUlRDUnRwVHJhbnNjZWl2ZXIgbm90IGZvdW5kJyk7XG4gICAgICAgIGNvbnN0IHBhcmFtZXRlcnMgPSB0cmFuc2NlaXZlci5zZW5kZXIuZ2V0UGFyYW1ldGVycygpO1xuICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5ncy5mb3JFYWNoKChlbmNvZGluZywgaWR4KSA9PiB7XG4gICAgICAgICAgICBwYXJhbWV0ZXJzLmVuY29kaW5nc1tpZHhdID0gT2JqZWN0LmFzc2lnbihPYmplY3QuYXNzaWduKHt9LCBlbmNvZGluZyksIHBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdCB0cmFuc2NlaXZlci5zZW5kZXIuc2V0UGFyYW1ldGVycyhwYXJhbWV0ZXJzKTtcbiAgICB9XG4gICAgYXN5bmMgZ2V0U2VuZGVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLl9hc3NlcnRTZW5kRGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIuc2VuZGVyLmdldFN0YXRzKCk7XG4gICAgfVxuICAgIGFzeW5jIHNlbmREYXRhQ2hhbm5lbCh7IG9yZGVyZWQsIG1heFBhY2tldExpZmVUaW1lLCBtYXhSZXRyYW5zbWl0cywgbGFiZWwsIHByb3RvY29sIH0pIHtcbiAgICAgICAgdGhpcy5fYXNzZXJ0U2VuZERpcmVjdGlvbigpO1xuICAgICAgICBjb25zdCBvcHRpb25zID0ge1xuICAgICAgICAgICAgbmVnb3RpYXRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlkOiB0aGlzLl9uZXh0U2VuZFNjdHBTdHJlYW1JZCxcbiAgICAgICAgICAgIG9yZGVyZWQsXG4gICAgICAgICAgICBtYXhQYWNrZXRMaWZlVGltZSxcbiAgICAgICAgICAgIG1heFJldHJhbnNtaXRzLFxuICAgICAgICAgICAgcHJvdG9jb2xcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzZW5kRGF0YUNoYW5uZWwoKSBbb3B0aW9uczolb10nLCBvcHRpb25zKTtcbiAgICAgICAgY29uc3QgZGF0YUNoYW5uZWwgPSB0aGlzLl9wYy5jcmVhdGVEYXRhQ2hhbm5lbChsYWJlbCwgb3B0aW9ucyk7XG4gICAgICAgIC8vIEluY3JlYXNlIG5leHQgaWQuXG4gICAgICAgIHRoaXMuX25leHRTZW5kU2N0cFN0cmVhbUlkID1cbiAgICAgICAgICAgICsrdGhpcy5fbmV4dFNlbmRTY3RwU3RyZWFtSWQgJSBTQ1RQX05VTV9TVFJFQU1TLk1JUztcbiAgICAgICAgLy8gSWYgdGhpcyBpcyB0aGUgZmlyc3QgRGF0YUNoYW5uZWwgd2UgbmVlZCB0byBjcmVhdGUgdGhlIFNEUCBhbnN3ZXIgd2l0aFxuICAgICAgICAvLyBtPWFwcGxpY2F0aW9uIHNlY3Rpb24uXG4gICAgICAgIGlmICghdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgICAgIGNvbnN0IG9mZmVyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlT2ZmZXIoKTtcbiAgICAgICAgICAgIGNvbnN0IGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKG9mZmVyLnNkcCk7XG4gICAgICAgICAgICBjb25zdCBvZmZlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWFcbiAgICAgICAgICAgICAgICAuZmluZCgobSkgPT4gbS50eXBlID09PSAnYXBwbGljYXRpb24nKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpXG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnc2VydmVyJywgbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3NlbmREYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW29mZmVyOiVvXScsIG9mZmVyKTtcbiAgICAgICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldExvY2FsRGVzY3JpcHRpb24ob2ZmZXIpO1xuICAgICAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnNlbmRTY3RwQXNzb2NpYXRpb24oeyBvZmZlck1lZGlhT2JqZWN0IH0pO1xuICAgICAgICAgICAgY29uc3QgYW5zd2VyID0geyB0eXBlOiAnYW5zd2VyJywgc2RwOiB0aGlzLl9yZW1vdGVTZHAuZ2V0U2RwKCkgfTtcbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1Zygnc2VuZERhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oYW5zd2VyKTtcbiAgICAgICAgICAgIHRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBzY3RwU3RyZWFtUGFyYW1ldGVycyA9IHtcbiAgICAgICAgICAgIHN0cmVhbUlkOiBvcHRpb25zLmlkLFxuICAgICAgICAgICAgb3JkZXJlZDogb3B0aW9ucy5vcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWU6IG9wdGlvbnMubWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0czogb3B0aW9ucy5tYXhSZXRyYW5zbWl0c1xuICAgICAgICB9O1xuICAgICAgICByZXR1cm4geyBkYXRhQ2hhbm5lbCwgc2N0cFN0cmVhbVBhcmFtZXRlcnMgfTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZSh7IHRyYWNrSWQsIGtpbmQsIHJ0cFBhcmFtZXRlcnMgfSkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIFt0cmFja0lkOiVzLCBraW5kOiVzXScsIHRyYWNrSWQsIGtpbmQpO1xuICAgICAgICBjb25zdCBsb2NhbElkID0gcnRwUGFyYW1ldGVycy5taWQgfHwgU3RyaW5nKHRoaXMuX21hcE1pZFRyYW5zY2VpdmVyLnNpemUpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZSh7XG4gICAgICAgICAgICBtaWQ6IGxvY2FsSWQsXG4gICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc3RyZWFtSWQ6IHJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZSxcbiAgICAgICAgICAgIHRyYWNrSWRcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG9mZmVyID0geyB0eXBlOiAnb2ZmZXInLCBzZHA6IHRoaXMuX3JlbW90ZVNkcC5nZXRTZHAoKSB9O1xuICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmUoKSB8IGNhbGxpbmcgcGMuc2V0UmVtb3RlRGVzY3JpcHRpb24oKSBbb2ZmZXI6JW9dJywgb2ZmZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgIGxldCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgY29uc3QgbG9jYWxTZHBPYmplY3QgPSBzZHBUcmFuc2Zvcm0ucGFyc2UoYW5zd2VyLnNkcCk7XG4gICAgICAgIGNvbnN0IGFuc3dlck1lZGlhT2JqZWN0ID0gbG9jYWxTZHBPYmplY3QubWVkaWFcbiAgICAgICAgICAgIC5maW5kKChtKSA9PiBTdHJpbmcobS5taWQpID09PSBsb2NhbElkKTtcbiAgICAgICAgLy8gTWF5IG5lZWQgdG8gbW9kaWZ5IGNvZGVjIHBhcmFtZXRlcnMgaW4gdGhlIGFuc3dlciBiYXNlZCBvbiBjb2RlY1xuICAgICAgICAvLyBwYXJhbWV0ZXJzIGluIHRoZSBvZmZlci5cbiAgICAgICAgc2RwQ29tbW9uVXRpbHMuYXBwbHlDb2RlY1BhcmFtZXRlcnMoe1xuICAgICAgICAgICAgb2ZmZXJSdHBQYXJhbWV0ZXJzOiBydHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgYW5zd2VyTWVkaWFPYmplY3RcbiAgICAgICAgfSk7XG4gICAgICAgIGFuc3dlciA9IHsgdHlwZTogJ2Fuc3dlcicsIHNkcDogc2RwVHJhbnNmb3JtLndyaXRlKGxvY2FsU2RwT2JqZWN0KSB9O1xuICAgICAgICBpZiAoIXRoaXMuX3RyYW5zcG9ydFJlYWR5KVxuICAgICAgICAgICAgYXdhaXQgdGhpcy5fc2V0dXBUcmFuc3BvcnQoeyBsb2NhbER0bHNSb2xlOiAnY2xpZW50JywgbG9jYWxTZHBPYmplY3QgfSk7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZSgpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fcGMuZ2V0VHJhbnNjZWl2ZXJzKClcbiAgICAgICAgICAgIC5maW5kKCh0KSA9PiB0Lm1pZCA9PT0gbG9jYWxJZCk7XG4gICAgICAgIGlmICghdHJhbnNjZWl2ZXIpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25ldyBSVENSdHBUcmFuc2NlaXZlciBub3QgZm91bmQnKTtcbiAgICAgICAgLy8gU3RvcmUgaW4gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuc2V0KGxvY2FsSWQsIHRyYW5zY2VpdmVyKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGxvY2FsSWQsXG4gICAgICAgICAgICB0cmFjazogdHJhbnNjZWl2ZXIucmVjZWl2ZXIudHJhY2ssXG4gICAgICAgICAgICBydHBSZWNlaXZlcjogdHJhbnNjZWl2ZXIucmVjZWl2ZXJcbiAgICAgICAgfTtcbiAgICB9XG4gICAgYXN5bmMgc3RvcFJlY2VpdmluZyhsb2NhbElkKSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgbG9nZ2VyLmRlYnVnKCdzdG9wUmVjZWl2aW5nKCkgW2xvY2FsSWQ6JXNdJywgbG9jYWxJZCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICB0aGlzLl9yZW1vdGVTZHAuY2xvc2VNZWRpYVNlY3Rpb24odHJhbnNjZWl2ZXIubWlkKTtcbiAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgIGF3YWl0IHRoaXMuX3BjLnNldFJlbW90ZURlc2NyaXB0aW9uKG9mZmVyKTtcbiAgICAgICAgY29uc3QgYW5zd2VyID0gYXdhaXQgdGhpcy5fcGMuY3JlYXRlQW5zd2VyKCk7XG4gICAgICAgIGxvZ2dlci5kZWJ1Zygnc3RvcFJlY2VpdmluZygpIHwgY2FsbGluZyBwYy5zZXRMb2NhbERlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRMb2NhbERlc2NyaXB0aW9uKGFuc3dlcik7XG4gICAgfVxuICAgIGFzeW5jIGdldFJlY2VpdmVyU3RhdHMobG9jYWxJZCkge1xuICAgICAgICB0aGlzLl9hc3NlcnRSZWN2RGlyZWN0aW9uKCk7XG4gICAgICAgIGNvbnN0IHRyYW5zY2VpdmVyID0gdGhpcy5fbWFwTWlkVHJhbnNjZWl2ZXIuZ2V0KGxvY2FsSWQpO1xuICAgICAgICBpZiAoIXRyYW5zY2VpdmVyKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhc3NvY2lhdGVkIFJUQ1J0cFRyYW5zY2VpdmVyIG5vdCBmb3VuZCcpO1xuICAgICAgICByZXR1cm4gdHJhbnNjZWl2ZXIucmVjZWl2ZXIuZ2V0U3RhdHMoKTtcbiAgICB9XG4gICAgYXN5bmMgcmVjZWl2ZURhdGFDaGFubmVsKHsgc2N0cFN0cmVhbVBhcmFtZXRlcnMsIGxhYmVsLCBwcm90b2NvbCB9KSB7XG4gICAgICAgIHRoaXMuX2Fzc2VydFJlY3ZEaXJlY3Rpb24oKTtcbiAgICAgICAgY29uc3QgeyBzdHJlYW1JZCwgb3JkZXJlZCwgbWF4UGFja2V0TGlmZVRpbWUsIG1heFJldHJhbnNtaXRzIH0gPSBzY3RwU3RyZWFtUGFyYW1ldGVycztcbiAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgICAgIG5lZ290aWF0ZWQ6IHRydWUsXG4gICAgICAgICAgICBpZDogc3RyZWFtSWQsXG4gICAgICAgICAgICBvcmRlcmVkLFxuICAgICAgICAgICAgbWF4UGFja2V0TGlmZVRpbWUsXG4gICAgICAgICAgICBtYXhSZXRyYW5zbWl0cyxcbiAgICAgICAgICAgIHByb3RvY29sXG4gICAgICAgIH07XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgW29wdGlvbnM6JW9dJywgb3B0aW9ucyk7XG4gICAgICAgIGNvbnN0IGRhdGFDaGFubmVsID0gdGhpcy5fcGMuY3JlYXRlRGF0YUNoYW5uZWwobGFiZWwsIG9wdGlvbnMpO1xuICAgICAgICAvLyBJZiB0aGlzIGlzIHRoZSBmaXJzdCBEYXRhQ2hhbm5lbCB3ZSBuZWVkIHRvIGNyZWF0ZSB0aGUgU0RQIG9mZmVyIHdpdGhcbiAgICAgICAgLy8gbT1hcHBsaWNhdGlvbiBzZWN0aW9uLlxuICAgICAgICBpZiAoIXRoaXMuX2hhc0RhdGFDaGFubmVsTWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICB0aGlzLl9yZW1vdGVTZHAucmVjZWl2ZVNjdHBBc3NvY2lhdGlvbigpO1xuICAgICAgICAgICAgY29uc3Qgb2ZmZXIgPSB7IHR5cGU6ICdvZmZlcicsIHNkcDogdGhpcy5fcmVtb3RlU2RwLmdldFNkcCgpIH07XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ3JlY2VpdmVEYXRhQ2hhbm5lbCgpIHwgY2FsbGluZyBwYy5zZXRSZW1vdGVEZXNjcmlwdGlvbigpIFtvZmZlcjolb10nLCBvZmZlcik7XG4gICAgICAgICAgICBhd2FpdCB0aGlzLl9wYy5zZXRSZW1vdGVEZXNjcmlwdGlvbihvZmZlcik7XG4gICAgICAgICAgICBjb25zdCBhbnN3ZXIgPSBhd2FpdCB0aGlzLl9wYy5jcmVhdGVBbnN3ZXIoKTtcbiAgICAgICAgICAgIGlmICghdGhpcy5fdHJhbnNwb3J0UmVhZHkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBsb2NhbFNkcE9iamVjdCA9IHNkcFRyYW5zZm9ybS5wYXJzZShhbnN3ZXIuc2RwKTtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLl9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGU6ICdjbGllbnQnLCBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxvZ2dlci5kZWJ1ZygncmVjZWl2ZURhdGFDaGFubmVsKCkgfCBjYWxsaW5nIHBjLnNldFJlbW90ZURlc2NyaXB0aW9uKCkgW2Fuc3dlcjolb10nLCBhbnN3ZXIpO1xuICAgICAgICAgICAgYXdhaXQgdGhpcy5fcGMuc2V0TG9jYWxEZXNjcmlwdGlvbihhbnN3ZXIpO1xuICAgICAgICAgICAgdGhpcy5faGFzRGF0YUNoYW5uZWxNZWRpYVNlY3Rpb24gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7IGRhdGFDaGFubmVsIH07XG4gICAgfVxuICAgIGFzeW5jIF9zZXR1cFRyYW5zcG9ydCh7IGxvY2FsRHRsc1JvbGUsIGxvY2FsU2RwT2JqZWN0IH0pIHtcbiAgICAgICAgaWYgKCFsb2NhbFNkcE9iamVjdClcbiAgICAgICAgICAgIGxvY2FsU2RwT2JqZWN0ID0gc2RwVHJhbnNmb3JtLnBhcnNlKHRoaXMuX3BjLmxvY2FsRGVzY3JpcHRpb24uc2RwKTtcbiAgICAgICAgLy8gR2V0IG91ciBsb2NhbCBEVExTIHBhcmFtZXRlcnMuXG4gICAgICAgIGNvbnN0IGR0bHNQYXJhbWV0ZXJzID0gc2RwQ29tbW9uVXRpbHMuZXh0cmFjdER0bHNQYXJhbWV0ZXJzKHsgc2RwT2JqZWN0OiBsb2NhbFNkcE9iamVjdCB9KTtcbiAgICAgICAgLy8gU2V0IG91ciBEVExTIHJvbGUuXG4gICAgICAgIGR0bHNQYXJhbWV0ZXJzLnJvbGUgPSBsb2NhbER0bHNSb2xlO1xuICAgICAgICAvLyBVcGRhdGUgdGhlIHJlbW90ZSBEVExTIHJvbGUgaW4gdGhlIFNEUC5cbiAgICAgICAgdGhpcy5fcmVtb3RlU2RwLnVwZGF0ZUR0bHNSb2xlKGxvY2FsRHRsc1JvbGUgPT09ICdjbGllbnQnID8gJ3NlcnZlcicgOiAnY2xpZW50Jyk7XG4gICAgICAgIC8vIE5lZWQgdG8gdGVsbCB0aGUgcmVtb3RlIHRyYW5zcG9ydCBhYm91dCBvdXIgcGFyYW1ldGVycy5cbiAgICAgICAgYXdhaXQgdGhpcy5zYWZlRW1pdEFzUHJvbWlzZSgnQGNvbm5lY3QnLCB7IGR0bHNQYXJhbWV0ZXJzIH0pO1xuICAgICAgICB0aGlzLl90cmFuc3BvcnRSZWFkeSA9IHRydWU7XG4gICAgfVxuICAgIF9hc3NlcnRTZW5kRGlyZWN0aW9uKCkge1xuICAgICAgICBpZiAodGhpcy5fZGlyZWN0aW9uICE9PSAnc2VuZCcpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignbWV0aG9kIGNhbiBqdXN0IGJlIGNhbGxlZCBmb3IgaGFuZGxlcnMgd2l0aCBcInNlbmRcIiBkaXJlY3Rpb24nKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfYXNzZXJ0UmVjdkRpcmVjdGlvbigpIHtcbiAgICAgICAgaWYgKHRoaXMuX2RpcmVjdGlvbiAhPT0gJ3JlY3YnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ21ldGhvZCBjYW4ganVzdCBiZSBjYWxsZWQgZm9yIGhhbmRsZXJzIHdpdGggXCJyZWN2XCIgZGlyZWN0aW9uJyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5leHBvcnRzLlNhZmFyaTEyID0gU2FmYXJpMTI7XG4iLCJcInVzZSBzdHJpY3RcIjtcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSAodGhpcyAmJiB0aGlzLl9fY3JlYXRlQmluZGluZykgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBrMiwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gbVtrXTsgfSB9KTtcbn0pIDogKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBvW2syXSA9IG1ba107XG59KSk7XG52YXIgX19zZXRNb2R1bGVEZWZhdWx0ID0gKHRoaXMgJiYgdGhpcy5fX3NldE1vZHVsZURlZmF1bHQpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgXCJkZWZhdWx0XCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgdmFsdWU6IHYgfSk7XG59KSA6IGZ1bmN0aW9uKG8sIHYpIHtcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XG59KTtcbnZhciBfX2ltcG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9faW1wb3J0U3RhcikgfHwgZnVuY3Rpb24gKG1vZCkge1xuICAgIGlmIChtb2QgJiYgbW9kLl9fZXNNb2R1bGUpIHJldHVybiBtb2Q7XG4gICAgdmFyIHJlc3VsdCA9IHt9O1xuICAgIGlmIChtb2QgIT0gbnVsbCkgZm9yICh2YXIgayBpbiBtb2QpIGlmIChrICE9PSBcImRlZmF1bHRcIiAmJiBPYmplY3QuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xuICAgIF9fc2V0TW9kdWxlRGVmYXVsdChyZXN1bHQsIG1vZCk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLm1hbmdsZVJ0cFBhcmFtZXRlcnMgPSBleHBvcnRzLmdldENhcGFiaWxpdGllcyA9IHZvaWQgMDtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuLi8uLi91dGlsc1wiKSk7XG4vKipcbiAqIE5vcm1hbGl6ZSBPUlRDIGJhc2VkIEVkZ2UncyBSVENSdHBSZWNlaXZlci5nZXRDYXBhYmlsaXRpZXMoKSB0byBwcm9kdWNlIGEgZnVsbFxuICogY29tcGxpYW50IE9SVEMgUlRDUnRwQ2FwYWJpbGl0aWVzLlxuICovXG5mdW5jdGlvbiBnZXRDYXBhYmlsaXRpZXMoKSB7XG4gICAgY29uc3QgbmF0aXZlQ2FwcyA9IFJUQ1J0cFJlY2VpdmVyLmdldENhcGFiaWxpdGllcygpO1xuICAgIGNvbnN0IGNhcHMgPSB1dGlscy5jbG9uZShuYXRpdmVDYXBzLCB7fSk7XG4gICAgZm9yIChjb25zdCBjb2RlYyBvZiBjYXBzLmNvZGVjcykge1xuICAgICAgICAvLyBSZW5hbWUgbnVtQ2hhbm5lbHMgdG8gY2hhbm5lbHMuXG4gICAgICAgIGNvZGVjLmNoYW5uZWxzID0gY29kZWMubnVtQ2hhbm5lbHM7XG4gICAgICAgIGRlbGV0ZSBjb2RlYy5udW1DaGFubmVscztcbiAgICAgICAgLy8gQWRkIG1pbWVUeXBlLlxuICAgICAgICBjb2RlYy5taW1lVHlwZSA9IGNvZGVjLm1pbWVUeXBlIHx8IGAke2NvZGVjLmtpbmR9LyR7Y29kZWMubmFtZX1gO1xuICAgICAgICAvLyBOT1RFOiBFZGdlIHNldHMgc29tZSBudW1lcmljIHBhcmFtZXRlcnMgYXMgc3RyaW5nIHJhdGhlciB0aGFuIG51bWJlci4gRml4IHRoZW0uXG4gICAgICAgIGlmIChjb2RlYy5wYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gY29kZWMucGFyYW1ldGVycztcbiAgICAgICAgICAgIGlmIChwYXJhbWV0ZXJzLmFwdClcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzLmFwdCA9IE51bWJlcihwYXJhbWV0ZXJzLmFwdCk7XG4gICAgICAgICAgICBpZiAocGFyYW1ldGVyc1sncGFja2V0aXphdGlvbi1tb2RlJ10pXG4gICAgICAgICAgICAgICAgcGFyYW1ldGVyc1sncGFja2V0aXphdGlvbi1tb2RlJ10gPSBOdW1iZXIocGFyYW1ldGVyc1sncGFja2V0aXphdGlvbi1tb2RlJ10pO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlbGV0ZSBlbXR5IHBhcmFtZXRlciBTdHJpbmcgaW4gcnRjcEZlZWRiYWNrLlxuICAgICAgICBmb3IgKGNvbnN0IGZlZWRiYWNrIG9mIGNvZGVjLnJ0Y3BGZWVkYmFjayB8fCBbXSkge1xuICAgICAgICAgICAgaWYgKCFmZWVkYmFjay5wYXJhbWV0ZXIpXG4gICAgICAgICAgICAgICAgZmVlZGJhY2sucGFyYW1ldGVyID0gJyc7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGNhcHM7XG59XG5leHBvcnRzLmdldENhcGFiaWxpdGllcyA9IGdldENhcGFiaWxpdGllcztcbi8qKlxuICogR2VuZXJhdGUgUlRDUnRwUGFyYW1ldGVycyBhcyBPUlRDIGJhc2VkIEVkZ2UgbGlrZXMuXG4gKi9cbmZ1bmN0aW9uIG1hbmdsZVJ0cFBhcmFtZXRlcnMocnRwUGFyYW1ldGVycykge1xuICAgIGNvbnN0IHBhcmFtcyA9IHV0aWxzLmNsb25lKHJ0cFBhcmFtZXRlcnMsIHt9KTtcbiAgICAvLyBSZW5hbWUgbWlkIHRvIG11eElkLlxuICAgIGlmIChwYXJhbXMubWlkKSB7XG4gICAgICAgIHBhcmFtcy5tdXhJZCA9IHBhcmFtcy5taWQ7XG4gICAgICAgIGRlbGV0ZSBwYXJhbXMubWlkO1xuICAgIH1cbiAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIHBhcmFtcy5jb2RlY3MpIHtcbiAgICAgICAgLy8gUmVuYW1lIGNoYW5uZWxzIHRvIG51bUNoYW5uZWxzLlxuICAgICAgICBpZiAoY29kZWMuY2hhbm5lbHMpIHtcbiAgICAgICAgICAgIGNvZGVjLm51bUNoYW5uZWxzID0gY29kZWMuY2hhbm5lbHM7XG4gICAgICAgICAgICBkZWxldGUgY29kZWMuY2hhbm5lbHM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gQWRkIGNvZGVjLm5hbWUgKHJlcXVyaWVkIGJ5IEVkZ2UpLlxuICAgICAgICBpZiAoY29kZWMubWltZVR5cGUgJiYgIWNvZGVjLm5hbWUpXG4gICAgICAgICAgICBjb2RlYy5uYW1lID0gY29kZWMubWltZVR5cGUuc3BsaXQoJy8nKVsxXTtcbiAgICAgICAgLy8gUmVtb3ZlIG1pbWVUeXBlLlxuICAgICAgICBkZWxldGUgY29kZWMubWltZVR5cGU7XG4gICAgfVxuICAgIHJldHVybiBwYXJhbXM7XG59XG5leHBvcnRzLm1hbmdsZVJ0cFBhcmFtZXRlcnMgPSBtYW5nbGVSdHBQYXJhbWV0ZXJzO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5PZmZlck1lZGlhU2VjdGlvbiA9IGV4cG9ydHMuQW5zd2VyTWVkaWFTZWN0aW9uID0gZXhwb3J0cy5NZWRpYVNlY3Rpb24gPSB2b2lkIDA7XG5jb25zdCB1dGlscyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi4vLi4vdXRpbHNcIikpO1xuY2xhc3MgTWVkaWFTZWN0aW9uIHtcbiAgICBjb25zdHJ1Y3Rvcih7IGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBwbGFuQiA9IGZhbHNlIH0pIHtcbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QgPSB7fTtcbiAgICAgICAgdGhpcy5fcGxhbkIgPSBwbGFuQjtcbiAgICAgICAgaWYgKGljZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaWNlQ2FuZGlkYXRlcykge1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuY2FuZGlkYXRlcyA9IFtdO1xuICAgICAgICAgICAgZm9yIChjb25zdCBjYW5kaWRhdGUgb2YgaWNlQ2FuZGlkYXRlcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGNhbmRpZGF0ZU9iamVjdCA9IHt9O1xuICAgICAgICAgICAgICAgIC8vIG1lZGlhc291cCBkb2VzIG1hbmRhdGVzIHJ0Y3AtbXV4IHNvIGNhbmRpZGF0ZXMgY29tcG9uZW50IGlzIGFsd2F5c1xuICAgICAgICAgICAgICAgIC8vIFJUUCAoMSkuXG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlT2JqZWN0LmNvbXBvbmVudCA9IDE7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlT2JqZWN0LmZvdW5kYXRpb24gPSBjYW5kaWRhdGUuZm91bmRhdGlvbjtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVPYmplY3QuaXAgPSBjYW5kaWRhdGUuaXA7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlT2JqZWN0LnBvcnQgPSBjYW5kaWRhdGUucG9ydDtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVPYmplY3QucHJpb3JpdHkgPSBjYW5kaWRhdGUucHJpb3JpdHk7XG4gICAgICAgICAgICAgICAgY2FuZGlkYXRlT2JqZWN0LnRyYW5zcG9ydCA9IGNhbmRpZGF0ZS5wcm90b2NvbDtcbiAgICAgICAgICAgICAgICBjYW5kaWRhdGVPYmplY3QudHlwZSA9IGNhbmRpZGF0ZS50eXBlO1xuICAgICAgICAgICAgICAgIGlmIChjYW5kaWRhdGUudGNwVHlwZSlcbiAgICAgICAgICAgICAgICAgICAgY2FuZGlkYXRlT2JqZWN0LnRjcHR5cGUgPSBjYW5kaWRhdGUudGNwVHlwZTtcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5jYW5kaWRhdGVzLnB1c2goY2FuZGlkYXRlT2JqZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmVuZE9mQ2FuZGlkYXRlcyA9ICdlbmQtb2YtY2FuZGlkYXRlcyc7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5pY2VPcHRpb25zID0gJ3Jlbm9taW5hdGlvbic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGR0bHNQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLnNldER0bHNSb2xlKGR0bHNQYXJhbWV0ZXJzLnJvbGUpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGdldCBtaWQoKSB7XG4gICAgICAgIHJldHVybiBTdHJpbmcodGhpcy5fbWVkaWFPYmplY3QubWlkKTtcbiAgICB9XG4gICAgZ2V0IGNsb3NlZCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhT2JqZWN0LnBvcnQgPT09IDA7XG4gICAgfVxuICAgIGdldE9iamVjdCgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX21lZGlhT2JqZWN0O1xuICAgIH1cbiAgICBzZXRJY2VQYXJhbWV0ZXJzKGljZVBhcmFtZXRlcnMpIHtcbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuaWNlVWZyYWcgPSBpY2VQYXJhbWV0ZXJzLnVzZXJuYW1lRnJhZ21lbnQ7XG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmljZVB3ZCA9IGljZVBhcmFtZXRlcnMucGFzc3dvcmQ7XG4gICAgfVxuICAgIGRpc2FibGUoKSB7XG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tZWRpYU9iamVjdC5leHQ7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tZWRpYU9iamVjdC5zc3JjcztcbiAgICAgICAgZGVsZXRlIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNHcm91cHM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tZWRpYU9iamVjdC5zaW11bGNhc3Q7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tZWRpYU9iamVjdC5zaW11bGNhc3RfMDM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tZWRpYU9iamVjdC5yaWRzO1xuICAgIH1cbiAgICBjbG9zZSgpIHtcbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZGlyZWN0aW9uID0gJ2luYWN0aXZlJztcbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucG9ydCA9IDA7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tZWRpYU9iamVjdC5leHQ7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tZWRpYU9iamVjdC5zc3JjcztcbiAgICAgICAgZGVsZXRlIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNHcm91cHM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tZWRpYU9iamVjdC5zaW11bGNhc3Q7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tZWRpYU9iamVjdC5zaW11bGNhc3RfMDM7XG4gICAgICAgIGRlbGV0ZSB0aGlzLl9tZWRpYU9iamVjdC5yaWRzO1xuICAgICAgICBkZWxldGUgdGhpcy5fbWVkaWFPYmplY3QuZXh0bWFwQWxsb3dNaXhlZDtcbiAgICB9XG59XG5leHBvcnRzLk1lZGlhU2VjdGlvbiA9IE1lZGlhU2VjdGlvbjtcbmNsYXNzIEFuc3dlck1lZGlhU2VjdGlvbiBleHRlbmRzIE1lZGlhU2VjdGlvbiB7XG4gICAgY29uc3RydWN0b3IoeyBpY2VQYXJhbWV0ZXJzLCBpY2VDYW5kaWRhdGVzLCBkdGxzUGFyYW1ldGVycywgc2N0cFBhcmFtZXRlcnMsIHBsYWluUnRwUGFyYW1ldGVycywgcGxhbkIgPSBmYWxzZSwgb2ZmZXJNZWRpYU9iamVjdCwgb2ZmZXJSdHBQYXJhbWV0ZXJzLCBhbnN3ZXJSdHBQYXJhbWV0ZXJzLCBjb2RlY09wdGlvbnMsIGV4dG1hcEFsbG93TWl4ZWQgPSBmYWxzZSB9KSB7XG4gICAgICAgIHN1cGVyKHsgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHBsYW5CIH0pO1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5taWQgPSBTdHJpbmcob2ZmZXJNZWRpYU9iamVjdC5taWQpO1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC50eXBlID0gb2ZmZXJNZWRpYU9iamVjdC50eXBlO1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wcm90b2NvbCA9IG9mZmVyTWVkaWFPYmplY3QucHJvdG9jb2w7XG4gICAgICAgIGlmICghcGxhaW5SdHBQYXJhbWV0ZXJzKSB7XG4gICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5jb25uZWN0aW9uID0geyBpcDogJzEyNy4wLjAuMScsIHZlcnNpb246IDQgfTtcbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBvcnQgPSA3O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuY29ubmVjdGlvbiA9XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpcDogcGxhaW5SdHBQYXJhbWV0ZXJzLmlwLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBwbGFpblJ0cFBhcmFtZXRlcnMuaXBWZXJzaW9uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBvcnQgPSBwbGFpblJ0cFBhcmFtZXRlcnMucG9ydDtcbiAgICAgICAgfVxuICAgICAgICBzd2l0Y2ggKG9mZmVyTWVkaWFPYmplY3QudHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZGlyZWN0aW9uID0gJ3JlY3Zvbmx5JztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucnRwID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0Y3BGYiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5mbXRwID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgY29kZWMgb2YgYW5zd2VyUnRwUGFyYW1ldGVycy5jb2RlY3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ0cCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBjb2RlYy5wYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlYzogZ2V0Q29kZWNOYW1lKGNvZGVjKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXRlOiBjb2RlYy5jbG9ja1JhdGVcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29kZWMuY2hhbm5lbHMgPiAxKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJ0cC5lbmNvZGluZyA9IGNvZGVjLmNoYW5uZWxzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucnRwLnB1c2gocnRwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvZGVjUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKGNvZGVjLnBhcmFtZXRlcnMsIHt9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjb2RlY09wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB7IG9wdXNTdGVyZW8sIG9wdXNGZWMsIG9wdXNEdHgsIG9wdXNNYXhQbGF5YmFja1JhdGUsIG9wdXNNYXhBdmVyYWdlQml0cmF0ZSwgb3B1c1B0aW1lLCB2aWRlb0dvb2dsZVN0YXJ0Qml0cmF0ZSwgdmlkZW9Hb29nbGVNYXhCaXRyYXRlLCB2aWRlb0dvb2dsZU1pbkJpdHJhdGUgfSA9IGNvZGVjT3B0aW9ucztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBvZmZlckNvZGVjID0gb2ZmZXJSdHBQYXJhbWV0ZXJzLmNvZGVjc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAuZmluZCgoYykgPT4gKGMucGF5bG9hZFR5cGUgPT09IGNvZGVjLnBheWxvYWRUeXBlKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3dpdGNoIChjb2RlYy5taW1lVHlwZS50b0xvd2VyQ2FzZSgpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F1ZGlvL29wdXMnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHVzU3RlcmVvICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb2ZmZXJDb2RlYy5wYXJhbWV0ZXJzWydzcHJvcC1zdGVyZW8nXSA9IG9wdXNTdGVyZW8gPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWNQYXJhbWV0ZXJzLnN0ZXJlbyA9IG9wdXNTdGVyZW8gPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9wdXNGZWMgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZlckNvZGVjLnBhcmFtZXRlcnMudXNlaW5iYW5kZmVjID0gb3B1c0ZlYyA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlY1BhcmFtZXRlcnMudXNlaW5iYW5kZmVjID0gb3B1c0ZlYyA/IDEgOiAwO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAob3B1c0R0eCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9mZmVyQ29kZWMucGFyYW1ldGVycy51c2VkdHggPSBvcHVzRHR4ID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjUGFyYW1ldGVycy51c2VkdHggPSBvcHVzRHR4ID8gMSA6IDA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHVzTWF4UGxheWJhY2tSYXRlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWNQYXJhbWV0ZXJzLm1heHBsYXliYWNrcmF0ZSA9IG9wdXNNYXhQbGF5YmFja1JhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHVzTWF4QXZlcmFnZUJpdHJhdGUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb2RlY1BhcmFtZXRlcnMubWF4YXZlcmFnZWJpdHJhdGUgPSBvcHVzTWF4QXZlcmFnZUJpdHJhdGU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChvcHVzUHRpbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvZmZlckNvZGVjLnBhcmFtZXRlcnMucHRpbWUgPSBvcHVzUHRpbWU7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjUGFyYW1ldGVycy5wdGltZSA9IG9wdXNQdGltZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ZpZGVvL3ZwOCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ZpZGVvL3ZwOSc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3ZpZGVvL2gyNjQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlICd2aWRlby9oMjY1JzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlkZW9Hb29nbGVTdGFydEJpdHJhdGUgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWNQYXJhbWV0ZXJzWyd4LWdvb2dsZS1zdGFydC1iaXRyYXRlJ10gPSB2aWRlb0dvb2dsZVN0YXJ0Qml0cmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlkZW9Hb29nbGVNYXhCaXRyYXRlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjUGFyYW1ldGVyc1sneC1nb29nbGUtbWF4LWJpdHJhdGUnXSA9IHZpZGVvR29vZ2xlTWF4Qml0cmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodmlkZW9Hb29nbGVNaW5CaXRyYXRlICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvZGVjUGFyYW1ldGVyc1sneC1nb29nbGUtbWluLWJpdHJhdGUnXSA9IHZpZGVvR29vZ2xlTWluQml0cmF0ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmbXRwID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGNvZGVjLnBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogJydcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjb2RlY1BhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZtdHAuY29uZmlnKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyArPSAnOyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm10cC5jb25maWcgKz0gYCR7a2V5fT0ke2NvZGVjUGFyYW1ldGVyc1trZXldfWA7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoZm10cC5jb25maWcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZm10cC5wdXNoKGZtdHApO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBmYiBvZiBjb2RlYy5ydGNwRmVlZGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5ydGNwRmIucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGNvZGVjLnBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0eXBlOiBmYi50eXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlOiBmYi5wYXJhbWV0ZXJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wYXlsb2FkcyA9IGFuc3dlclJ0cFBhcmFtZXRlcnMuY29kZWNzXG4gICAgICAgICAgICAgICAgICAgICAgICAubWFwKChjb2RlYykgPT4gY29kZWMucGF5bG9hZFR5cGUpXG4gICAgICAgICAgICAgICAgICAgICAgICAuam9pbignICcpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5leHQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBleHQgb2YgYW5zd2VyUnRwUGFyYW1ldGVycy5oZWFkZXJFeHRlbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBEb24ndCBhZGQgYSBoZWFkZXIgZXh0ZW5zaW9uIGlmIG5vdCBwcmVzZW50IGluIHRoZSBvZmZlci5cbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZvdW5kID0gKG9mZmVyTWVkaWFPYmplY3QuZXh0IHx8IFtdKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zb21lKChsb2NhbEV4dCkgPT4gbG9jYWxFeHQudXJpID09PSBleHQudXJpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghZm91bmQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5leHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJpOiBleHQudXJpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBleHQuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIEFsbG93IGJvdGggMSBieXRlIGFuZCAyIGJ5dGVzIGxlbmd0aCBoZWFkZXIgZXh0ZW5zaW9ucy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGV4dG1hcEFsbG93TWl4ZWQgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QuZXh0bWFwQWxsb3dNaXhlZCA9PT0gJ2V4dG1hcC1hbGxvdy1taXhlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmV4dG1hcEFsbG93TWl4ZWQgPSAnZXh0bWFwLWFsbG93LW1peGVkJztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAvLyBTaW11bGNhc3QuXG4gICAgICAgICAgICAgICAgICAgIGlmIChvZmZlck1lZGlhT2JqZWN0LnNpbXVsY2FzdCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc2ltdWxjYXN0ID1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcjE6ICdyZWN2JyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbGlzdDE6IG9mZmVyTWVkaWFPYmplY3Quc2ltdWxjYXN0Lmxpc3QxXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJpZHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmlkIG9mIG9mZmVyTWVkaWFPYmplY3QucmlkcyB8fCBbXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWQuZGlyZWN0aW9uICE9PSAnc2VuZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJpZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiByaWQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ3JlY3YnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gU2ltdWxjYXN0IChkcmFmdCB2ZXJzaW9uIDAzKS5cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAob2ZmZXJNZWRpYU9iamVjdC5zaW11bGNhc3RfMDMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjYW1lbGNhc2VcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNpbXVsY2FzdF8wMyA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogb2ZmZXJNZWRpYU9iamVjdC5zaW11bGNhc3RfMDMudmFsdWUucmVwbGFjZSgvc2VuZC9nLCAncmVjdicpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJpZHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgcmlkIG9mIG9mZmVyTWVkaWFPYmplY3QucmlkcyB8fCBbXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyaWQuZGlyZWN0aW9uICE9PSAnc2VuZCcpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJpZHMucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiByaWQuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGlvbjogJ3JlY3YnXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucnRjcE11eCA9ICdydGNwLW11eCc7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0Y3BSc2l6ZSA9ICdydGNwLXJzaXplJztcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BsYW5CICYmIHRoaXMuX21lZGlhT2JqZWN0LnR5cGUgPT09ICd2aWRlbycpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC54R29vZ2xlRmxhZyA9ICdjb25mZXJlbmNlJztcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSAnYXBwbGljYXRpb24nOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gTmV3IHNwZWMuXG4gICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2Ygb2ZmZXJNZWRpYU9iamVjdC5zY3RwUG9ydCA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBheWxvYWRzID0gJ3dlYnJ0Yy1kYXRhY2hhbm5lbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zY3RwUG9ydCA9IHNjdHBQYXJhbWV0ZXJzLnBvcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5tYXhNZXNzYWdlU2l6ZSA9IHNjdHBQYXJhbWV0ZXJzLm1heE1lc3NhZ2VTaXplO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE9sZCBzcGVjLlxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChvZmZlck1lZGlhT2JqZWN0LnNjdHBtYXApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBheWxvYWRzID0gc2N0cFBhcmFtZXRlcnMucG9ydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNjdHBtYXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwOiAnd2VicnRjLWRhdGFjaGFubmVsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2N0cG1hcE51bWJlcjogc2N0cFBhcmFtZXRlcnMucG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4TWVzc2FnZVNpemU6IHNjdHBQYXJhbWV0ZXJzLm1heE1lc3NhZ2VTaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgc2V0RHRsc1JvbGUocm9sZSkge1xuICAgICAgICBzd2l0Y2ggKHJvbGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2NsaWVudCc6XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc2V0dXAgPSAnYWN0aXZlJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlcnZlcic6XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc2V0dXAgPSAncGFzc2l2ZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhdXRvJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zZXR1cCA9ICdhY3RwYXNzJztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuQW5zd2VyTWVkaWFTZWN0aW9uID0gQW5zd2VyTWVkaWFTZWN0aW9uO1xuY2xhc3MgT2ZmZXJNZWRpYVNlY3Rpb24gZXh0ZW5kcyBNZWRpYVNlY3Rpb24ge1xuICAgIGNvbnN0cnVjdG9yKHsgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBwbGFpblJ0cFBhcmFtZXRlcnMsIHBsYW5CID0gZmFsc2UsIG1pZCwga2luZCwgb2ZmZXJSdHBQYXJhbWV0ZXJzLCBzdHJlYW1JZCwgdHJhY2tJZCwgb2xkRGF0YUNoYW5uZWxTcGVjID0gZmFsc2UgfSkge1xuICAgICAgICBzdXBlcih7IGljZVBhcmFtZXRlcnMsIGljZUNhbmRpZGF0ZXMsIGR0bHNQYXJhbWV0ZXJzLCBwbGFuQiB9KTtcbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QubWlkID0gU3RyaW5nKG1pZCk7XG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnR5cGUgPSBraW5kO1xuICAgICAgICBpZiAoIXBsYWluUnRwUGFyYW1ldGVycykge1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuY29ubmVjdGlvbiA9IHsgaXA6ICcxMjcuMC4wLjEnLCB2ZXJzaW9uOiA0IH07XG4gICAgICAgICAgICBpZiAoIXNjdHBQYXJhbWV0ZXJzKVxuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnByb3RvY29sID0gJ1VEUC9UTFMvUlRQL1NBVlBGJztcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5wcm90b2NvbCA9ICdVRFAvRFRMUy9TQ1RQJztcbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBvcnQgPSA3O1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuY29ubmVjdGlvbiA9XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBpcDogcGxhaW5SdHBQYXJhbWV0ZXJzLmlwLFxuICAgICAgICAgICAgICAgICAgICB2ZXJzaW9uOiBwbGFpblJ0cFBhcmFtZXRlcnMuaXBWZXJzaW9uXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnByb3RvY29sID0gJ1JUUC9BVlAnO1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucG9ydCA9IHBsYWluUnRwUGFyYW1ldGVycy5wb3J0O1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAoa2luZCkge1xuICAgICAgICAgICAgY2FzZSAnYXVkaW8nOlxuICAgICAgICAgICAgY2FzZSAndmlkZW8nOlxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucnRwID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0Y3BGYiA9IFtdO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5mbXRwID0gW107XG4gICAgICAgICAgICAgICAgICAgIGlmICghdGhpcy5fcGxhbkIpXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5tc2lkID0gYCR7c3RyZWFtSWQgfHwgJy0nfSAke3RyYWNrSWR9YDtcbiAgICAgICAgICAgICAgICAgICAgZm9yIChjb25zdCBjb2RlYyBvZiBvZmZlclJ0cFBhcmFtZXRlcnMuY29kZWNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBydHAgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogY29kZWMucGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29kZWM6IGdldENvZGVjTmFtZShjb2RlYyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF0ZTogY29kZWMuY2xvY2tSYXRlXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGNvZGVjLmNoYW5uZWxzID4gMSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBydHAuZW5jb2RpbmcgPSBjb2RlYy5jaGFubmVscztcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0cC5wdXNoKHJ0cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBmbXRwID0ge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBheWxvYWQ6IGNvZGVjLnBheWxvYWRUeXBlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogJydcbiAgICAgICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhjb2RlYy5wYXJhbWV0ZXJzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbXRwLmNvbmZpZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZm10cC5jb25maWcgKz0gJzsnO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IGAke2tleX09JHtjb2RlYy5wYXJhbWV0ZXJzW2tleV19YDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChmbXRwLmNvbmZpZylcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5mbXRwLnB1c2goZm10cCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IGZiIG9mIGNvZGVjLnJ0Y3BGZWVkYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0Y3BGYi5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcGF5bG9hZDogY29kZWMucGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IGZiLnR5cGUsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHN1YnR5cGU6IGZiLnBhcmFtZXRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBheWxvYWRzID0gb2ZmZXJSdHBQYXJhbWV0ZXJzLmNvZGVjc1xuICAgICAgICAgICAgICAgICAgICAgICAgLm1hcCgoY29kZWMpID0+IGNvZGVjLnBheWxvYWRUeXBlKVxuICAgICAgICAgICAgICAgICAgICAgICAgLmpvaW4oJyAnKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QuZXh0ID0gW107XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZXh0IG9mIG9mZmVyUnRwUGFyYW1ldGVycy5oZWFkZXJFeHRlbnNpb25zKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5leHQucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdXJpOiBleHQudXJpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBleHQuaWRcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0Y3BNdXggPSAncnRjcC1tdXgnO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5ydGNwUnNpemUgPSAncnRjcC1yc2l6ZSc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVuY29kaW5nID0gb2ZmZXJSdHBQYXJhbWV0ZXJzLmVuY29kaW5nc1swXTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3NyYyA9IGVuY29kaW5nLnNzcmM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHJ0eFNzcmMgPSAoZW5jb2RpbmcucnR4ICYmIGVuY29kaW5nLnJ0eC5zc3JjKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBlbmNvZGluZy5ydHguc3NyY1xuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzID0gW107XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNHcm91cHMgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9mZmVyUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZDogc3NyYyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6ICdjbmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IG9mZmVyUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5fcGxhbkIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBzc3JjLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogJ21zaWQnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBgJHtzdHJlYW1JZCB8fCAnLSd9ICR7dHJhY2tJZH1gXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocnR4U3NyYykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKG9mZmVyUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc3NyY3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBydHhTc3JjLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6ICdjbmFtZScsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvZmZlclJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuX3BsYW5CKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc3NyY3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlkOiBydHhTc3JjLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6ICdtc2lkJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFsdWU6IGAke3N0cmVhbUlkIHx8ICctJ30gJHt0cmFja0lkfWBcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIEFzc29jaWF0ZSBvcmlnaW5hbCBhbmQgcmV0cmFuc21pc3Npb24gU1NSQ3MuXG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zc3JjR3JvdXBzLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlbWFudGljczogJ0ZJRCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc3NyY3M6IGAke3NzcmN9ICR7cnR4U3NyY31gXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdhcHBsaWNhdGlvbic6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAvLyBOZXcgc3BlYy5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvbGREYXRhQ2hhbm5lbFNwZWMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBheWxvYWRzID0gJ3dlYnJ0Yy1kYXRhY2hhbm5lbCc7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zY3RwUG9ydCA9IHNjdHBQYXJhbWV0ZXJzLnBvcnQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5tYXhNZXNzYWdlU2l6ZSA9IHNjdHBQYXJhbWV0ZXJzLm1heE1lc3NhZ2VTaXplO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIC8vIE9sZCBzcGVjLlxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnBheWxvYWRzID0gc2N0cFBhcmFtZXRlcnMucG9ydDtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNjdHBtYXAgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXBwOiAnd2VicnRjLWRhdGFjaGFubmVsJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2N0cG1hcE51bWJlcjogc2N0cFBhcmFtZXRlcnMucG9ydCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF4TWVzc2FnZVNpemU6IHNjdHBQYXJhbWV0ZXJzLm1heE1lc3NhZ2VTaXplXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11bnVzZWQtdmFyc1xuICAgIHNldER0bHNSb2xlKHJvbGUpIHtcbiAgICAgICAgLy8gQWx3YXlzICdhY3RwYXNzJy5cbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc2V0dXAgPSAnYWN0cGFzcyc7XG4gICAgfVxuICAgIHBsYW5CUmVjZWl2ZSh7IG9mZmVyUnRwUGFyYW1ldGVycywgc3RyZWFtSWQsIHRyYWNrSWQgfSkge1xuICAgICAgICBjb25zdCBlbmNvZGluZyA9IG9mZmVyUnRwUGFyYW1ldGVycy5lbmNvZGluZ3NbMF07XG4gICAgICAgIGNvbnN0IHNzcmMgPSBlbmNvZGluZy5zc3JjO1xuICAgICAgICBjb25zdCBydHhTc3JjID0gKGVuY29kaW5nLnJ0eCAmJiBlbmNvZGluZy5ydHguc3NyYylcbiAgICAgICAgICAgID8gZW5jb2RpbmcucnR4LnNzcmNcbiAgICAgICAgICAgIDogdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIG9mZmVyUnRwUGFyYW1ldGVycy5jb2RlY3MpIHtcbiAgICAgICAgICAgIGNvbnN0IHJ0cCA9IHtcbiAgICAgICAgICAgICAgICBwYXlsb2FkOiBjb2RlYy5wYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICBjb2RlYzogZ2V0Q29kZWNOYW1lKGNvZGVjKSxcbiAgICAgICAgICAgICAgICByYXRlOiBjb2RlYy5jbG9ja1JhdGVcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoY29kZWMuY2hhbm5lbHMgPiAxKVxuICAgICAgICAgICAgICAgIHJ0cC5lbmNvZGluZyA9IGNvZGVjLmNoYW5uZWxzO1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucnRwLnB1c2gocnRwKTtcbiAgICAgICAgICAgIGNvbnN0IGZtdHAgPSB7XG4gICAgICAgICAgICAgICAgcGF5bG9hZDogY29kZWMucGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgY29uZmlnOiAnJ1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGZtdHAuY29uZmlnKVxuICAgICAgICAgICAgICAgICAgICBmbXRwLmNvbmZpZyArPSAnOyc7XG4gICAgICAgICAgICAgICAgZm10cC5jb25maWcgKz0gYCR7a2V5fT0ke2NvZGVjLnBhcmFtZXRlcnNba2V5XX1gO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGZtdHAuY29uZmlnKVxuICAgICAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LmZtdHAucHVzaChmbXRwKTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgZmIgb2YgY29kZWMucnRjcEZlZWRiYWNrKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucnRjcEZiLnB1c2goe1xuICAgICAgICAgICAgICAgICAgICBwYXlsb2FkOiBjb2RlYy5wYXlsb2FkVHlwZSxcbiAgICAgICAgICAgICAgICAgICAgdHlwZTogZmIudHlwZSxcbiAgICAgICAgICAgICAgICAgICAgc3VidHlwZTogZmIucGFyYW1ldGVyXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucGF5bG9hZHMgKz0gYCAke29mZmVyUnRwUGFyYW1ldGVyc1xuICAgICAgICAgICAgLmNvZGVjc1xuICAgICAgICAgICAgLm1hcCgoY29kZWMpID0+IGNvZGVjLnBheWxvYWRUeXBlKVxuICAgICAgICAgICAgLmpvaW4oJyAnKX1gO1xuICAgICAgICBpZiAob2ZmZXJSdHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWUpIHtcbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkOiBzc3JjLFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZTogJ2NuYW1lJyxcbiAgICAgICAgICAgICAgICB2YWx1ZTogb2ZmZXJSdHBQYXJhbWV0ZXJzLnJ0Y3AuY25hbWVcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IHNzcmMsXG4gICAgICAgICAgICBhdHRyaWJ1dGU6ICdtc2lkJyxcbiAgICAgICAgICAgIHZhbHVlOiBgJHtzdHJlYW1JZCB8fCAnLSd9ICR7dHJhY2tJZH1gXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAocnR4U3NyYykge1xuICAgICAgICAgICAgaWYgKG9mZmVyUnRwUGFyYW1ldGVycy5ydGNwLmNuYW1lKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc3NyY3MucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBydHhTc3JjLFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGU6ICdjbmFtZScsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlOiBvZmZlclJ0cFBhcmFtZXRlcnMucnRjcC5jbmFtZVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc3NyY3MucHVzaCh7XG4gICAgICAgICAgICAgICAgaWQ6IHJ0eFNzcmMsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlOiAnbXNpZCcsXG4gICAgICAgICAgICAgICAgdmFsdWU6IGAke3N0cmVhbUlkIHx8ICctJ30gJHt0cmFja0lkfWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgLy8gQXNzb2NpYXRlIG9yaWdpbmFsIGFuZCByZXRyYW5zbWlzc2lvbiBTU1JDcy5cbiAgICAgICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnNzcmNHcm91cHMucHVzaCh7XG4gICAgICAgICAgICAgICAgc2VtYW50aWNzOiAnRklEJyxcbiAgICAgICAgICAgICAgICBzc3JjczogYCR7c3NyY30gJHtydHhTc3JjfWBcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHBsYW5CU3RvcFJlY2VpdmluZyh7IG9mZmVyUnRwUGFyYW1ldGVycyB9KSB7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0gb2ZmZXJSdHBQYXJhbWV0ZXJzLmVuY29kaW5nc1swXTtcbiAgICAgICAgY29uc3Qgc3NyYyA9IGVuY29kaW5nLnNzcmM7XG4gICAgICAgIGNvbnN0IHJ0eFNzcmMgPSAoZW5jb2RpbmcucnR4ICYmIGVuY29kaW5nLnJ0eC5zc3JjKVxuICAgICAgICAgICAgPyBlbmNvZGluZy5ydHguc3NyY1xuICAgICAgICAgICAgOiB1bmRlZmluZWQ7XG4gICAgICAgIGNvbnN0IHBheWxvYWRzID0gb2ZmZXJSdHBQYXJhbWV0ZXJzLmNvZGVjc1xuICAgICAgICAgICAgLm1hcCgoY29kZWMpID0+IGNvZGVjLnBheWxvYWRUeXBlKTtcbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucGF5bG9hZHMgPSB0aGlzLl9tZWRpYU9iamVjdC5wYXlsb2Fkcy5zcGxpdCgnICcpXG4gICAgICAgICAgICAuZmlsdGVyKChwYXlsb2FkKSA9PiAhcGF5bG9hZHMuaW5jbHVkZXMoTnVtYmVyKHBheWxvYWQpKSlcbiAgICAgICAgICAgIC5qb2luKCcgJyk7XG4gICAgICAgIHRoaXMuX21lZGlhT2JqZWN0LnJ0cCA9IHRoaXMuX21lZGlhT2JqZWN0LnJ0cFxuICAgICAgICAgICAgLmZpbHRlcigocnRwKSA9PiAhcGF5bG9hZHMuaW5jbHVkZXMocnRwLnBheWxvYWQpKTtcbiAgICAgICAgdGhpcy5fbWVkaWFPYmplY3QucnRjcEZiID0gdGhpcy5fbWVkaWFPYmplY3QucnRjcEZiXG4gICAgICAgICAgICAuZmlsdGVyKChydGNwRmIpID0+ICFwYXlsb2Fkcy5pbmNsdWRlcyhydGNwRmIucGF5bG9hZCkpO1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5mbXRwID0gdGhpcy5fbWVkaWFPYmplY3QuZm10cFxuICAgICAgICAgICAgLmZpbHRlcigoZm10cCkgPT4gIXBheWxvYWRzLmluY2x1ZGVzKGZtdHAucGF5bG9hZCkpO1xuICAgICAgICB0aGlzLl9tZWRpYU9iamVjdC5zc3JjcyA9IHRoaXMuX21lZGlhT2JqZWN0LnNzcmNzXG4gICAgICAgICAgICAuZmlsdGVyKChzKSA9PiBzLmlkICE9PSBzc3JjICYmIHMuaWQgIT09IHJ0eFNzcmMpO1xuICAgICAgICBpZiAocnR4U3NyYykge1xuICAgICAgICAgICAgdGhpcy5fbWVkaWFPYmplY3Quc3NyY0dyb3VwcyA9IHRoaXMuX21lZGlhT2JqZWN0LnNzcmNHcm91cHNcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChncm91cCkgPT4gZ3JvdXAuc3NyY3MgIT09IGAke3NzcmN9ICR7cnR4U3NyY31gKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuT2ZmZXJNZWRpYVNlY3Rpb24gPSBPZmZlck1lZGlhU2VjdGlvbjtcbmZ1bmN0aW9uIGdldENvZGVjTmFtZShjb2RlYykge1xuICAgIGNvbnN0IE1pbWVUeXBlUmVnZXggPSBuZXcgUmVnRXhwKCdeKGF1ZGlvfHZpZGVvKS8oLispJywgJ2knKTtcbiAgICBjb25zdCBtaW1lVHlwZU1hdGNoID0gTWltZVR5cGVSZWdleC5leGVjKGNvZGVjLm1pbWVUeXBlKTtcbiAgICBpZiAoIW1pbWVUeXBlTWF0Y2gpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY29kZWMubWltZVR5cGUnKTtcbiAgICByZXR1cm4gbWltZVR5cGVNYXRjaFsyXTtcbn1cbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSAodGhpcyAmJiB0aGlzLl9fc2V0TW9kdWxlRGVmYXVsdCkgfHwgKE9iamVjdC5jcmVhdGUgPyAoZnVuY3Rpb24obywgdikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcbn0pIDogZnVuY3Rpb24obywgdikge1xuICAgIG9bXCJkZWZhdWx0XCJdID0gdjtcbn0pO1xudmFyIF9faW1wb3J0U3RhciA9ICh0aGlzICYmIHRoaXMuX19pbXBvcnRTdGFyKSB8fCBmdW5jdGlvbiAobW9kKSB7XG4gICAgaWYgKG1vZCAmJiBtb2QuX19lc01vZHVsZSkgcmV0dXJuIG1vZDtcbiAgICB2YXIgcmVzdWx0ID0ge307XG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5oYXNPd25Qcm9wZXJ0eS5jYWxsKG1vZCwgaykpIF9fY3JlYXRlQmluZGluZyhyZXN1bHQsIG1vZCwgayk7XG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVtb3RlU2RwID0gdm9pZCAwO1xuY29uc3Qgc2RwVHJhbnNmb3JtID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCJzZHAtdHJhbnNmb3JtXCIpKTtcbmNvbnN0IExvZ2dlcl8xID0gcmVxdWlyZShcIi4uLy4uL0xvZ2dlclwiKTtcbmNvbnN0IE1lZGlhU2VjdGlvbl8xID0gcmVxdWlyZShcIi4vTWVkaWFTZWN0aW9uXCIpO1xuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcl8xLkxvZ2dlcignUmVtb3RlU2RwJyk7XG5jbGFzcyBSZW1vdGVTZHAge1xuICAgIGNvbnN0cnVjdG9yKHsgaWNlUGFyYW1ldGVycywgaWNlQ2FuZGlkYXRlcywgZHRsc1BhcmFtZXRlcnMsIHNjdHBQYXJhbWV0ZXJzLCBwbGFpblJ0cFBhcmFtZXRlcnMsIHBsYW5CID0gZmFsc2UgfSkge1xuICAgICAgICAvLyBNZWRpYVNlY3Rpb24gaW5zdGFuY2VzIHdpdGggc2FtZSBvcmRlciBhcyBpbiB0aGUgU0RQLlxuICAgICAgICB0aGlzLl9tZWRpYVNlY3Rpb25zID0gW107XG4gICAgICAgIC8vIE1lZGlhU2VjdGlvbiBpbmRpY2VzIGluZGV4ZWQgYnkgTUlELlxuICAgICAgICB0aGlzLl9taWRUb0luZGV4ID0gbmV3IE1hcCgpO1xuICAgICAgICB0aGlzLl9pY2VQYXJhbWV0ZXJzID0gaWNlUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5faWNlQ2FuZGlkYXRlcyA9IGljZUNhbmRpZGF0ZXM7XG4gICAgICAgIHRoaXMuX2R0bHNQYXJhbWV0ZXJzID0gZHRsc1BhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMuX3NjdHBQYXJhbWV0ZXJzID0gc2N0cFBhcmFtZXRlcnM7XG4gICAgICAgIHRoaXMuX3BsYWluUnRwUGFyYW1ldGVycyA9IHBsYWluUnRwUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5fcGxhbkIgPSBwbGFuQjtcbiAgICAgICAgdGhpcy5fc2RwT2JqZWN0ID1cbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICB2ZXJzaW9uOiAwLFxuICAgICAgICAgICAgICAgIG9yaWdpbjoge1xuICAgICAgICAgICAgICAgICAgICBhZGRyZXNzOiAnMC4wLjAuMCcsXG4gICAgICAgICAgICAgICAgICAgIGlwVmVyOiA0LFxuICAgICAgICAgICAgICAgICAgICBuZXRUeXBlOiAnSU4nLFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uSWQ6IDEwMDAwLFxuICAgICAgICAgICAgICAgICAgICBzZXNzaW9uVmVyc2lvbjogMCxcbiAgICAgICAgICAgICAgICAgICAgdXNlcm5hbWU6ICdtZWRpYXNvdXAtY2xpZW50J1xuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgbmFtZTogJy0nLFxuICAgICAgICAgICAgICAgIHRpbWluZzogeyBzdGFydDogMCwgc3RvcDogMCB9LFxuICAgICAgICAgICAgICAgIG1lZGlhOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgLy8gSWYgSUNFIHBhcmFtZXRlcnMgYXJlIGdpdmVuLCBhZGQgSUNFLUxpdGUgaW5kaWNhdG9yLlxuICAgICAgICBpZiAoaWNlUGFyYW1ldGVycyAmJiBpY2VQYXJhbWV0ZXJzLmljZUxpdGUpIHtcbiAgICAgICAgICAgIHRoaXMuX3NkcE9iamVjdC5pY2VsaXRlID0gJ2ljZS1saXRlJztcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBEVExTIHBhcmFtZXRlcnMgYXJlIGdpdmVuLCBhc3N1bWUgV2ViUlRDIGFuZCBCVU5ETEUuXG4gICAgICAgIGlmIChkdGxzUGFyYW1ldGVycykge1xuICAgICAgICAgICAgdGhpcy5fc2RwT2JqZWN0Lm1zaWRTZW1hbnRpYyA9IHsgc2VtYW50aWM6ICdXTVMnLCB0b2tlbjogJyonIH07XG4gICAgICAgICAgICAvLyBOT1RFOiBXZSB0YWtlIHRoZSBsYXRlc3QgZmluZ2VycHJpbnQuXG4gICAgICAgICAgICBjb25zdCBudW1GaW5nZXJwcmludHMgPSB0aGlzLl9kdGxzUGFyYW1ldGVycy5maW5nZXJwcmludHMubGVuZ3RoO1xuICAgICAgICAgICAgdGhpcy5fc2RwT2JqZWN0LmZpbmdlcnByaW50ID1cbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGR0bHNQYXJhbWV0ZXJzLmZpbmdlcnByaW50c1tudW1GaW5nZXJwcmludHMgLSAxXS5hbGdvcml0aG0sXG4gICAgICAgICAgICAgICAgICAgIGhhc2g6IGR0bHNQYXJhbWV0ZXJzLmZpbmdlcnByaW50c1tudW1GaW5nZXJwcmludHMgLSAxXS52YWx1ZVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB0aGlzLl9zZHBPYmplY3QuZ3JvdXBzID0gW3sgdHlwZTogJ0JVTkRMRScsIG1pZHM6ICcnIH1dO1xuICAgICAgICB9XG4gICAgICAgIC8vIElmIHRoZXJlIGFyZSBwbGFpbiBSUFQgcGFyYW1ldGVycywgb3ZlcnJpZGUgU0RQIG9yaWdpbi5cbiAgICAgICAgaWYgKHBsYWluUnRwUGFyYW1ldGVycykge1xuICAgICAgICAgICAgdGhpcy5fc2RwT2JqZWN0Lm9yaWdpbi5hZGRyZXNzID0gcGxhaW5SdHBQYXJhbWV0ZXJzLmlwO1xuICAgICAgICAgICAgdGhpcy5fc2RwT2JqZWN0Lm9yaWdpbi5pcFZlciA9IHBsYWluUnRwUGFyYW1ldGVycy5pcFZlcnNpb247XG4gICAgICAgIH1cbiAgICB9XG4gICAgdXBkYXRlSWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlSWNlUGFyYW1ldGVycygpIFtpY2VQYXJhbWV0ZXJzOiVvXScsIGljZVBhcmFtZXRlcnMpO1xuICAgICAgICB0aGlzLl9pY2VQYXJhbWV0ZXJzID0gaWNlUGFyYW1ldGVycztcbiAgICAgICAgdGhpcy5fc2RwT2JqZWN0LmljZWxpdGUgPSBpY2VQYXJhbWV0ZXJzLmljZUxpdGUgPyAnaWNlLWxpdGUnIDogdW5kZWZpbmVkO1xuICAgICAgICBmb3IgKGNvbnN0IG1lZGlhU2VjdGlvbiBvZiB0aGlzLl9tZWRpYVNlY3Rpb25zKSB7XG4gICAgICAgICAgICBtZWRpYVNlY3Rpb24uc2V0SWNlUGFyYW1ldGVycyhpY2VQYXJhbWV0ZXJzKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB1cGRhdGVEdGxzUm9sZShyb2xlKSB7XG4gICAgICAgIGxvZ2dlci5kZWJ1ZygndXBkYXRlRHRsc1JvbGUoKSBbcm9sZTolc10nLCByb2xlKTtcbiAgICAgICAgdGhpcy5fZHRsc1BhcmFtZXRlcnMucm9sZSA9IHJvbGU7XG4gICAgICAgIGZvciAoY29uc3QgbWVkaWFTZWN0aW9uIG9mIHRoaXMuX21lZGlhU2VjdGlvbnMpIHtcbiAgICAgICAgICAgIG1lZGlhU2VjdGlvbi5zZXREdGxzUm9sZShyb2xlKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBnZXROZXh0TWVkaWFTZWN0aW9uSWR4KCkge1xuICAgICAgICAvLyBJZiBhIGNsb3NlZCBtZWRpYSBzZWN0aW9uIGlzIGZvdW5kLCByZXR1cm4gaXRzIGluZGV4LlxuICAgICAgICBmb3IgKGxldCBpZHggPSAwOyBpZHggPCB0aGlzLl9tZWRpYVNlY3Rpb25zLmxlbmd0aDsgKytpZHgpIHtcbiAgICAgICAgICAgIGNvbnN0IG1lZGlhU2VjdGlvbiA9IHRoaXMuX21lZGlhU2VjdGlvbnNbaWR4XTtcbiAgICAgICAgICAgIGlmIChtZWRpYVNlY3Rpb24uY2xvc2VkKVxuICAgICAgICAgICAgICAgIHJldHVybiB7IGlkeCwgcmV1c2VNaWQ6IG1lZGlhU2VjdGlvbi5taWQgfTtcbiAgICAgICAgfVxuICAgICAgICAvLyBJZiBubyBjbG9zZWQgbWVkaWEgc2VjdGlvbiBpcyBmb3VuZCwgcmV0dXJuIG5leHQgb25lLlxuICAgICAgICByZXR1cm4geyBpZHg6IHRoaXMuX21lZGlhU2VjdGlvbnMubGVuZ3RoIH07XG4gICAgfVxuICAgIHNlbmQoeyBvZmZlck1lZGlhT2JqZWN0LCByZXVzZU1pZCwgb2ZmZXJSdHBQYXJhbWV0ZXJzLCBhbnN3ZXJSdHBQYXJhbWV0ZXJzLCBjb2RlY09wdGlvbnMsIGV4dG1hcEFsbG93TWl4ZWQgPSBmYWxzZSB9KSB7XG4gICAgICAgIGNvbnN0IG1lZGlhU2VjdGlvbiA9IG5ldyBNZWRpYVNlY3Rpb25fMS5BbnN3ZXJNZWRpYVNlY3Rpb24oe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVyczogdGhpcy5faWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXM6IHRoaXMuX2ljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVyczogdGhpcy5fZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBwbGFpblJ0cFBhcmFtZXRlcnM6IHRoaXMuX3BsYWluUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHBsYW5COiB0aGlzLl9wbGFuQixcbiAgICAgICAgICAgIG9mZmVyTWVkaWFPYmplY3QsXG4gICAgICAgICAgICBvZmZlclJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBhbnN3ZXJSdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgY29kZWNPcHRpb25zLFxuICAgICAgICAgICAgZXh0bWFwQWxsb3dNaXhlZFxuICAgICAgICB9KTtcbiAgICAgICAgLy8gVW5pZmllZC1QbGFuIHdpdGggY2xvc2VkIG1lZGlhIHNlY3Rpb24gcmVwbGFjZW1lbnQuXG4gICAgICAgIGlmIChyZXVzZU1pZCkge1xuICAgICAgICAgICAgdGhpcy5fcmVwbGFjZU1lZGlhU2VjdGlvbihtZWRpYVNlY3Rpb24sIHJldXNlTWlkKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBVbmlmaWVkLVBsYW4gb3IgUGxhbi1CIHdpdGggZGlmZmVyZW50IG1lZGlhIGtpbmQuXG4gICAgICAgIGVsc2UgaWYgKCF0aGlzLl9taWRUb0luZGV4LmhhcyhtZWRpYVNlY3Rpb24ubWlkKSkge1xuICAgICAgICAgICAgdGhpcy5fYWRkTWVkaWFTZWN0aW9uKG1lZGlhU2VjdGlvbik7XG4gICAgICAgIH1cbiAgICAgICAgLy8gUGxhbi1CIHdpdGggc2FtZSBtZWRpYSBraW5kLlxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZWNlaXZlKHsgbWlkLCBraW5kLCBvZmZlclJ0cFBhcmFtZXRlcnMsIHN0cmVhbUlkLCB0cmFja0lkIH0pIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fbWlkVG9JbmRleC5nZXQobWlkKTtcbiAgICAgICAgbGV0IG1lZGlhU2VjdGlvbjtcbiAgICAgICAgaWYgKGlkeCAhPT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgbWVkaWFTZWN0aW9uID0gdGhpcy5fbWVkaWFTZWN0aW9uc1tpZHhdO1xuICAgICAgICAvLyBVbmlmaWVkLVBsYW4gb3IgZGlmZmVyZW50IG1lZGlhIGtpbmQuXG4gICAgICAgIGlmICghbWVkaWFTZWN0aW9uKSB7XG4gICAgICAgICAgICBtZWRpYVNlY3Rpb24gPSBuZXcgTWVkaWFTZWN0aW9uXzEuT2ZmZXJNZWRpYVNlY3Rpb24oe1xuICAgICAgICAgICAgICAgIGljZVBhcmFtZXRlcnM6IHRoaXMuX2ljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgaWNlQ2FuZGlkYXRlczogdGhpcy5faWNlQ2FuZGlkYXRlcyxcbiAgICAgICAgICAgICAgICBkdGxzUGFyYW1ldGVyczogdGhpcy5fZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcGxhaW5SdHBQYXJhbWV0ZXJzOiB0aGlzLl9wbGFpblJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICAgICAgcGxhbkI6IHRoaXMuX3BsYW5CLFxuICAgICAgICAgICAgICAgIG1pZCxcbiAgICAgICAgICAgICAgICBraW5kLFxuICAgICAgICAgICAgICAgIG9mZmVyUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgICAgICBzdHJlYW1JZCxcbiAgICAgICAgICAgICAgICB0cmFja0lkXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIC8vIExldCdzIHRyeSB0byByZWN5Y2xlIGEgY2xvc2VkIG1lZGlhIHNlY3Rpb24gKGlmIGFueSkuXG4gICAgICAgICAgICAvLyBOT1RFOiBZZXMsIHdlIGNhbiByZWN5Y2xlIGEgY2xvc2VkIG09YXVkaW8gc2VjdGlvbiB3aXRoIGEgbmV3IG09dmlkZW8uXG4gICAgICAgICAgICBjb25zdCBvbGRNZWRpYVNlY3Rpb24gPSB0aGlzLl9tZWRpYVNlY3Rpb25zLmZpbmQoKG0pID0+IChtLmNsb3NlZCkpO1xuICAgICAgICAgICAgaWYgKG9sZE1lZGlhU2VjdGlvbikge1xuICAgICAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uLCBvbGRNZWRpYVNlY3Rpb24ubWlkKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuX2FkZE1lZGlhU2VjdGlvbihtZWRpYVNlY3Rpb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFBsYW4tQi5cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZWRpYVNlY3Rpb24ucGxhbkJSZWNlaXZlKHsgb2ZmZXJSdHBQYXJhbWV0ZXJzLCBzdHJlYW1JZCwgdHJhY2tJZCB9KTtcbiAgICAgICAgICAgIHRoaXMuX3JlcGxhY2VNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBkaXNhYmxlTWVkaWFTZWN0aW9uKG1pZCkge1xuICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9taWRUb0luZGV4LmdldChtaWQpO1xuICAgICAgICBpZiAoaWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gbWVkaWEgc2VjdGlvbiBmb3VuZCB3aXRoIG1pZCAnJHttaWR9J2ApO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IG1lZGlhU2VjdGlvbiA9IHRoaXMuX21lZGlhU2VjdGlvbnNbaWR4XTtcbiAgICAgICAgbWVkaWFTZWN0aW9uLmRpc2FibGUoKTtcbiAgICB9XG4gICAgY2xvc2VNZWRpYVNlY3Rpb24obWlkKSB7XG4gICAgICAgIGNvbnN0IGlkeCA9IHRoaXMuX21pZFRvSW5kZXguZ2V0KG1pZCk7XG4gICAgICAgIGlmIChpZHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBubyBtZWRpYSBzZWN0aW9uIGZvdW5kIHdpdGggbWlkICcke21pZH0nYCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgbWVkaWFTZWN0aW9uID0gdGhpcy5fbWVkaWFTZWN0aW9uc1tpZHhdO1xuICAgICAgICAvLyBOT1RFOiBDbG9zaW5nIHRoZSBmaXJzdCBtIHNlY3Rpb24gaXMgYSBwYWluIHNpbmNlIGl0IGludmFsaWRhdGVzIHRoZVxuICAgICAgICAvLyBidW5kbGVkIHRyYW5zcG9ydCwgc28gbGV0J3MgYXZvaWQgaXQuXG4gICAgICAgIGlmIChtaWQgPT09IHRoaXMuX2ZpcnN0TWlkKSB7XG4gICAgICAgICAgICBsb2dnZXIuZGVidWcoJ2Nsb3NlTWVkaWFTZWN0aW9uKCkgfCBjYW5ub3QgY2xvc2UgZmlyc3QgbWVkaWEgc2VjdGlvbiwgZGlzYWJsaW5nIGl0IGluc3RlYWQgW21pZDolc10nLCBtaWQpO1xuICAgICAgICAgICAgdGhpcy5kaXNhYmxlTWVkaWFTZWN0aW9uKG1pZCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWVkaWFTZWN0aW9uLmNsb3NlKCk7XG4gICAgICAgIC8vIFJlZ2VuZXJhdGUgQlVORExFIG1pZHMuXG4gICAgICAgIHRoaXMuX3JlZ2VuZXJhdGVCdW5kbGVNaWRzKCk7XG4gICAgfVxuICAgIHBsYW5CU3RvcFJlY2VpdmluZyh7IG1pZCwgb2ZmZXJSdHBQYXJhbWV0ZXJzIH0pIHtcbiAgICAgICAgY29uc3QgaWR4ID0gdGhpcy5fbWlkVG9JbmRleC5nZXQobWlkKTtcbiAgICAgICAgaWYgKGlkeCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIG1lZGlhIHNlY3Rpb24gZm91bmQgd2l0aCBtaWQgJyR7bWlkfSdgKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb24gPSB0aGlzLl9tZWRpYVNlY3Rpb25zW2lkeF07XG4gICAgICAgIG1lZGlhU2VjdGlvbi5wbGFuQlN0b3BSZWNlaXZpbmcoeyBvZmZlclJ0cFBhcmFtZXRlcnMgfSk7XG4gICAgICAgIHRoaXMuX3JlcGxhY2VNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uKTtcbiAgICB9XG4gICAgc2VuZFNjdHBBc3NvY2lhdGlvbih7IG9mZmVyTWVkaWFPYmplY3QgfSkge1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb24gPSBuZXcgTWVkaWFTZWN0aW9uXzEuQW5zd2VyTWVkaWFTZWN0aW9uKHtcbiAgICAgICAgICAgIGljZVBhcmFtZXRlcnM6IHRoaXMuX2ljZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBpY2VDYW5kaWRhdGVzOiB0aGlzLl9pY2VDYW5kaWRhdGVzLFxuICAgICAgICAgICAgZHRsc1BhcmFtZXRlcnM6IHRoaXMuX2R0bHNQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgc2N0cFBhcmFtZXRlcnM6IHRoaXMuX3NjdHBQYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcGxhaW5SdHBQYXJhbWV0ZXJzOiB0aGlzLl9wbGFpblJ0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBvZmZlck1lZGlhT2JqZWN0XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLl9hZGRNZWRpYVNlY3Rpb24obWVkaWFTZWN0aW9uKTtcbiAgICB9XG4gICAgcmVjZWl2ZVNjdHBBc3NvY2lhdGlvbih7IG9sZERhdGFDaGFubmVsU3BlYyA9IGZhbHNlIH0gPSB7fSkge1xuICAgICAgICBjb25zdCBtZWRpYVNlY3Rpb24gPSBuZXcgTWVkaWFTZWN0aW9uXzEuT2ZmZXJNZWRpYVNlY3Rpb24oe1xuICAgICAgICAgICAgaWNlUGFyYW1ldGVyczogdGhpcy5faWNlUGFyYW1ldGVycyxcbiAgICAgICAgICAgIGljZUNhbmRpZGF0ZXM6IHRoaXMuX2ljZUNhbmRpZGF0ZXMsXG4gICAgICAgICAgICBkdGxzUGFyYW1ldGVyczogdGhpcy5fZHRsc1BhcmFtZXRlcnMsXG4gICAgICAgICAgICBzY3RwUGFyYW1ldGVyczogdGhpcy5fc2N0cFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBwbGFpblJ0cFBhcmFtZXRlcnM6IHRoaXMuX3BsYWluUnRwUGFyYW1ldGVycyxcbiAgICAgICAgICAgIG1pZDogJ2RhdGFjaGFubmVsJyxcbiAgICAgICAgICAgIGtpbmQ6ICdhcHBsaWNhdGlvbicsXG4gICAgICAgICAgICBvbGREYXRhQ2hhbm5lbFNwZWNcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuX2FkZE1lZGlhU2VjdGlvbihtZWRpYVNlY3Rpb24pO1xuICAgIH1cbiAgICBnZXRTZHAoKSB7XG4gICAgICAgIC8vIEluY3JlYXNlIFNEUCB2ZXJzaW9uLlxuICAgICAgICB0aGlzLl9zZHBPYmplY3Qub3JpZ2luLnNlc3Npb25WZXJzaW9uKys7XG4gICAgICAgIHJldHVybiBzZHBUcmFuc2Zvcm0ud3JpdGUodGhpcy5fc2RwT2JqZWN0KTtcbiAgICB9XG4gICAgX2FkZE1lZGlhU2VjdGlvbihuZXdNZWRpYVNlY3Rpb24pIHtcbiAgICAgICAgaWYgKCF0aGlzLl9maXJzdE1pZClcbiAgICAgICAgICAgIHRoaXMuX2ZpcnN0TWlkID0gbmV3TWVkaWFTZWN0aW9uLm1pZDtcbiAgICAgICAgLy8gQWRkIHRvIHRoZSB2ZWN0b3IuXG4gICAgICAgIHRoaXMuX21lZGlhU2VjdGlvbnMucHVzaChuZXdNZWRpYVNlY3Rpb24pO1xuICAgICAgICAvLyBBZGQgdG8gdGhlIG1hcC5cbiAgICAgICAgdGhpcy5fbWlkVG9JbmRleC5zZXQobmV3TWVkaWFTZWN0aW9uLm1pZCwgdGhpcy5fbWVkaWFTZWN0aW9ucy5sZW5ndGggLSAxKTtcbiAgICAgICAgLy8gQWRkIHRvIHRoZSBTRFAgb2JqZWN0LlxuICAgICAgICB0aGlzLl9zZHBPYmplY3QubWVkaWEucHVzaChuZXdNZWRpYVNlY3Rpb24uZ2V0T2JqZWN0KCkpO1xuICAgICAgICAvLyBSZWdlbmVyYXRlIEJVTkRMRSBtaWRzLlxuICAgICAgICB0aGlzLl9yZWdlbmVyYXRlQnVuZGxlTWlkcygpO1xuICAgIH1cbiAgICBfcmVwbGFjZU1lZGlhU2VjdGlvbihuZXdNZWRpYVNlY3Rpb24sIHJldXNlTWlkKSB7XG4gICAgICAgIC8vIFN0b3JlIGl0IGluIHRoZSBtYXAuXG4gICAgICAgIGlmICh0eXBlb2YgcmV1c2VNaWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9taWRUb0luZGV4LmdldChyZXVzZU1pZCk7XG4gICAgICAgICAgICBpZiAoaWR4ID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYG5vIG1lZGlhIHNlY3Rpb24gZm91bmQgZm9yIHJldXNlTWlkICcke3JldXNlTWlkfSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IG9sZE1lZGlhU2VjdGlvbiA9IHRoaXMuX21lZGlhU2VjdGlvbnNbaWR4XTtcbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGluZGV4IGluIHRoZSB2ZWN0b3Igd2l0aCB0aGUgbmV3IG1lZGlhIHNlY3Rpb24uXG4gICAgICAgICAgICB0aGlzLl9tZWRpYVNlY3Rpb25zW2lkeF0gPSBuZXdNZWRpYVNlY3Rpb247XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIG1hcC5cbiAgICAgICAgICAgIHRoaXMuX21pZFRvSW5kZXguZGVsZXRlKG9sZE1lZGlhU2VjdGlvbi5taWQpO1xuICAgICAgICAgICAgdGhpcy5fbWlkVG9JbmRleC5zZXQobmV3TWVkaWFTZWN0aW9uLm1pZCwgaWR4KTtcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgU0RQIG9iamVjdC5cbiAgICAgICAgICAgIHRoaXMuX3NkcE9iamVjdC5tZWRpYVtpZHhdID0gbmV3TWVkaWFTZWN0aW9uLmdldE9iamVjdCgpO1xuICAgICAgICAgICAgLy8gUmVnZW5lcmF0ZSBCVU5ETEUgbWlkcy5cbiAgICAgICAgICAgIHRoaXMuX3JlZ2VuZXJhdGVCdW5kbGVNaWRzKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjb25zdCBpZHggPSB0aGlzLl9taWRUb0luZGV4LmdldChuZXdNZWRpYVNlY3Rpb24ubWlkKTtcbiAgICAgICAgICAgIGlmIChpZHggPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgbm8gbWVkaWEgc2VjdGlvbiBmb3VuZCB3aXRoIG1pZCAnJHtuZXdNZWRpYVNlY3Rpb24ubWlkfSdgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIFJlcGxhY2UgdGhlIGluZGV4IGluIHRoZSB2ZWN0b3Igd2l0aCB0aGUgbmV3IG1lZGlhIHNlY3Rpb24uXG4gICAgICAgICAgICB0aGlzLl9tZWRpYVNlY3Rpb25zW2lkeF0gPSBuZXdNZWRpYVNlY3Rpb247XG4gICAgICAgICAgICAvLyBVcGRhdGUgdGhlIFNEUCBvYmplY3QuXG4gICAgICAgICAgICB0aGlzLl9zZHBPYmplY3QubWVkaWFbaWR4XSA9IG5ld01lZGlhU2VjdGlvbi5nZXRPYmplY3QoKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBfcmVnZW5lcmF0ZUJ1bmRsZU1pZHMoKSB7XG4gICAgICAgIGlmICghdGhpcy5fZHRsc1BhcmFtZXRlcnMpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMuX3NkcE9iamVjdC5ncm91cHNbMF0ubWlkcyA9IHRoaXMuX21lZGlhU2VjdGlvbnNcbiAgICAgICAgICAgIC5maWx0ZXIoKG1lZGlhU2VjdGlvbikgPT4gIW1lZGlhU2VjdGlvbi5jbG9zZWQpXG4gICAgICAgICAgICAubWFwKChtZWRpYVNlY3Rpb24pID0+IG1lZGlhU2VjdGlvbi5taWQpXG4gICAgICAgICAgICAuam9pbignICcpO1xuICAgIH1cbn1cbmV4cG9ydHMuUmVtb3RlU2RwID0gUmVtb3RlU2RwO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hcHBseUNvZGVjUGFyYW1ldGVycyA9IGV4cG9ydHMuZ2V0Q25hbWUgPSBleHBvcnRzLmV4dHJhY3REdGxzUGFyYW1ldGVycyA9IGV4cG9ydHMuZXh0cmFjdFJ0cENhcGFiaWxpdGllcyA9IHZvaWQgMDtcbmNvbnN0IHNkcFRyYW5zZm9ybSA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwic2RwLXRyYW5zZm9ybVwiKSk7XG5mdW5jdGlvbiBleHRyYWN0UnRwQ2FwYWJpbGl0aWVzKHsgc2RwT2JqZWN0IH0pIHtcbiAgICAvLyBNYXAgb2YgUnRwQ29kZWNQYXJhbWV0ZXJzIGluZGV4ZWQgYnkgcGF5bG9hZCB0eXBlLlxuICAgIGNvbnN0IGNvZGVjc01hcCA9IG5ldyBNYXAoKTtcbiAgICAvLyBBcnJheSBvZiBSdHBIZWFkZXJFeHRlbnNpb25zLlxuICAgIGNvbnN0IGhlYWRlckV4dGVuc2lvbnMgPSBbXTtcbiAgICAvLyBXaGV0aGVyIGEgbT1hdWRpby92aWRlbyBzZWN0aW9uIGhhcyBiZWVuIGFscmVhZHkgZm91bmQuXG4gICAgbGV0IGdvdEF1ZGlvID0gZmFsc2U7XG4gICAgbGV0IGdvdFZpZGVvID0gZmFsc2U7XG4gICAgZm9yIChjb25zdCBtIG9mIHNkcE9iamVjdC5tZWRpYSkge1xuICAgICAgICBjb25zdCBraW5kID0gbS50eXBlO1xuICAgICAgICBzd2l0Y2ggKGtpbmQpIHtcbiAgICAgICAgICAgIGNhc2UgJ2F1ZGlvJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnb3RBdWRpbylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBnb3RBdWRpbyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ3ZpZGVvJzpcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChnb3RWaWRlbylcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICBnb3RWaWRlbyA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IGNvZGVjcy5cbiAgICAgICAgZm9yIChjb25zdCBydHAgb2YgbS5ydHApIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVjID0ge1xuICAgICAgICAgICAgICAgIGtpbmQ6IGtpbmQsXG4gICAgICAgICAgICAgICAgbWltZVR5cGU6IGAke2tpbmR9LyR7cnRwLmNvZGVjfWAsXG4gICAgICAgICAgICAgICAgcHJlZmVycmVkUGF5bG9hZFR5cGU6IHJ0cC5wYXlsb2FkLFxuICAgICAgICAgICAgICAgIGNsb2NrUmF0ZTogcnRwLnJhdGUsXG4gICAgICAgICAgICAgICAgY2hhbm5lbHM6IHJ0cC5lbmNvZGluZyxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB7fSxcbiAgICAgICAgICAgICAgICBydGNwRmVlZGJhY2s6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgY29kZWNzTWFwLnNldChjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSwgY29kZWMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIEdldCBjb2RlYyBwYXJhbWV0ZXJzLlxuICAgICAgICBmb3IgKGNvbnN0IGZtdHAgb2YgbS5mbXRwIHx8IFtdKSB7XG4gICAgICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gc2RwVHJhbnNmb3JtLnBhcnNlUGFyYW1zKGZtdHAuY29uZmlnKTtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVjID0gY29kZWNzTWFwLmdldChmbXRwLnBheWxvYWQpO1xuICAgICAgICAgICAgaWYgKCFjb2RlYylcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIC8vIFNwZWNpYWxzIGNhc2UgdG8gY29udmVydCBwYXJhbWV0ZXIgdmFsdWUgdG8gc3RyaW5nLlxuICAgICAgICAgICAgaWYgKHBhcmFtZXRlcnMgJiYgcGFyYW1ldGVycy5oYXNPd25Qcm9wZXJ0eSgncHJvZmlsZS1sZXZlbC1pZCcpKVxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnNbJ3Byb2ZpbGUtbGV2ZWwtaWQnXSA9IFN0cmluZyhwYXJhbWV0ZXJzWydwcm9maWxlLWxldmVsLWlkJ10pO1xuICAgICAgICAgICAgY29kZWMucGFyYW1ldGVycyA9IHBhcmFtZXRlcnM7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IFJUQ1AgZmVlZGJhY2sgZm9yIGVhY2ggY29kZWMuXG4gICAgICAgIGZvciAoY29uc3QgZmIgb2YgbS5ydGNwRmIgfHwgW10pIHtcbiAgICAgICAgICAgIGNvbnN0IGNvZGVjID0gY29kZWNzTWFwLmdldChmYi5wYXlsb2FkKTtcbiAgICAgICAgICAgIGlmICghY29kZWMpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBmZWVkYmFjayA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBmYi50eXBlLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcjogZmIuc3VidHlwZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghZmVlZGJhY2sucGFyYW1ldGVyKVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBmZWVkYmFjay5wYXJhbWV0ZXI7XG4gICAgICAgICAgICBjb2RlYy5ydGNwRmVlZGJhY2sucHVzaChmZWVkYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gR2V0IFJUUCBoZWFkZXIgZXh0ZW5zaW9ucy5cbiAgICAgICAgZm9yIChjb25zdCBleHQgb2YgbS5leHQgfHwgW10pIHtcbiAgICAgICAgICAgIC8vIElnbm9yZSBlbmNyeXB0ZWQgZXh0ZW5zaW9ucyAobm90IHlldCBzdXBwb3J0ZWQgaW4gbWVkaWFzb3VwKS5cbiAgICAgICAgICAgIGlmIChleHRbJ2VuY3J5cHQtdXJpJ10pXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBjb25zdCBoZWFkZXJFeHRlbnNpb24gPSB7XG4gICAgICAgICAgICAgICAga2luZDoga2luZCxcbiAgICAgICAgICAgICAgICB1cmk6IGV4dC51cmksXG4gICAgICAgICAgICAgICAgcHJlZmVycmVkSWQ6IGV4dC52YWx1ZVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGhlYWRlckV4dGVuc2lvbnMucHVzaChoZWFkZXJFeHRlbnNpb24pO1xuICAgICAgICB9XG4gICAgfVxuICAgIGNvbnN0IHJ0cENhcGFiaWxpdGllcyA9IHtcbiAgICAgICAgY29kZWNzOiBBcnJheS5mcm9tKGNvZGVjc01hcC52YWx1ZXMoKSksXG4gICAgICAgIGhlYWRlckV4dGVuc2lvbnM6IGhlYWRlckV4dGVuc2lvbnNcbiAgICB9O1xuICAgIHJldHVybiBydHBDYXBhYmlsaXRpZXM7XG59XG5leHBvcnRzLmV4dHJhY3RSdHBDYXBhYmlsaXRpZXMgPSBleHRyYWN0UnRwQ2FwYWJpbGl0aWVzO1xuZnVuY3Rpb24gZXh0cmFjdER0bHNQYXJhbWV0ZXJzKHsgc2RwT2JqZWN0IH0pIHtcbiAgICBjb25zdCBtZWRpYU9iamVjdCA9IChzZHBPYmplY3QubWVkaWEgfHwgW10pXG4gICAgICAgIC5maW5kKChtKSA9PiAobS5pY2VVZnJhZyAmJiBtLnBvcnQgIT09IDApKTtcbiAgICBpZiAoIW1lZGlhT2JqZWN0KVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ25vIGFjdGl2ZSBtZWRpYSBzZWN0aW9uIGZvdW5kJyk7XG4gICAgY29uc3QgZmluZ2VycHJpbnQgPSBtZWRpYU9iamVjdC5maW5nZXJwcmludCB8fCBzZHBPYmplY3QuZmluZ2VycHJpbnQ7XG4gICAgbGV0IHJvbGU7XG4gICAgc3dpdGNoIChtZWRpYU9iamVjdC5zZXR1cCkge1xuICAgICAgICBjYXNlICdhY3RpdmUnOlxuICAgICAgICAgICAgcm9sZSA9ICdjbGllbnQnO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3Bhc3NpdmUnOlxuICAgICAgICAgICAgcm9sZSA9ICdzZXJ2ZXInO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2FjdHBhc3MnOlxuICAgICAgICAgICAgcm9sZSA9ICdhdXRvJztcbiAgICAgICAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBkdGxzUGFyYW1ldGVycyA9IHtcbiAgICAgICAgcm9sZSxcbiAgICAgICAgZmluZ2VycHJpbnRzOiBbXG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgYWxnb3JpdGhtOiBmaW5nZXJwcmludC50eXBlLFxuICAgICAgICAgICAgICAgIHZhbHVlOiBmaW5nZXJwcmludC5oYXNoXG4gICAgICAgICAgICB9XG4gICAgICAgIF1cbiAgICB9O1xuICAgIHJldHVybiBkdGxzUGFyYW1ldGVycztcbn1cbmV4cG9ydHMuZXh0cmFjdER0bHNQYXJhbWV0ZXJzID0gZXh0cmFjdER0bHNQYXJhbWV0ZXJzO1xuZnVuY3Rpb24gZ2V0Q25hbWUoeyBvZmZlck1lZGlhT2JqZWN0IH0pIHtcbiAgICBjb25zdCBzc3JjQ25hbWVMaW5lID0gKG9mZmVyTWVkaWFPYmplY3Quc3NyY3MgfHwgW10pXG4gICAgICAgIC5maW5kKChsaW5lKSA9PiBsaW5lLmF0dHJpYnV0ZSA9PT0gJ2NuYW1lJyk7XG4gICAgaWYgKCFzc3JjQ25hbWVMaW5lKVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgcmV0dXJuIHNzcmNDbmFtZUxpbmUudmFsdWU7XG59XG5leHBvcnRzLmdldENuYW1lID0gZ2V0Q25hbWU7XG4vKipcbiAqIEFwcGx5IGNvZGVjIHBhcmFtZXRlcnMgaW4gdGhlIGdpdmVuIFNEUCBtPSBzZWN0aW9uIGFuc3dlciBiYXNlZCBvbiB0aGVcbiAqIGdpdmVuIFJUUCBwYXJhbWV0ZXJzIG9mIGFuIG9mZmVyLlxuICovXG5mdW5jdGlvbiBhcHBseUNvZGVjUGFyYW1ldGVycyh7IG9mZmVyUnRwUGFyYW1ldGVycywgYW5zd2VyTWVkaWFPYmplY3QgfSkge1xuICAgIGZvciAoY29uc3QgY29kZWMgb2Ygb2ZmZXJSdHBQYXJhbWV0ZXJzLmNvZGVjcykge1xuICAgICAgICBjb25zdCBtaW1lVHlwZSA9IGNvZGVjLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIC8vIEF2b2lkIHBhcnNpbmcgY29kZWMgcGFyYW1ldGVycyBmb3IgdW5oYW5kbGVkIGNvZGVjcy5cbiAgICAgICAgaWYgKG1pbWVUeXBlICE9PSAnYXVkaW8vb3B1cycpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgcnRwID0gKGFuc3dlck1lZGlhT2JqZWN0LnJ0cCB8fCBbXSlcbiAgICAgICAgICAgIC5maW5kKChyKSA9PiByLnBheWxvYWQgPT09IGNvZGVjLnBheWxvYWRUeXBlKTtcbiAgICAgICAgaWYgKCFydHApXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgLy8gSnVzdCBpbiBjYXNlLlxuICAgICAgICBhbnN3ZXJNZWRpYU9iamVjdC5mbXRwID0gYW5zd2VyTWVkaWFPYmplY3QuZm10cCB8fCBbXTtcbiAgICAgICAgbGV0IGZtdHAgPSBhbnN3ZXJNZWRpYU9iamVjdC5mbXRwXG4gICAgICAgICAgICAuZmluZCgoZikgPT4gZi5wYXlsb2FkID09PSBjb2RlYy5wYXlsb2FkVHlwZSk7XG4gICAgICAgIGlmICghZm10cCkge1xuICAgICAgICAgICAgZm10cCA9IHsgcGF5bG9hZDogY29kZWMucGF5bG9hZFR5cGUsIGNvbmZpZzogJycgfTtcbiAgICAgICAgICAgIGFuc3dlck1lZGlhT2JqZWN0LmZtdHAucHVzaChmbXRwKTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBwYXJhbWV0ZXJzID0gc2RwVHJhbnNmb3JtLnBhcnNlUGFyYW1zKGZtdHAuY29uZmlnKTtcbiAgICAgICAgc3dpdGNoIChtaW1lVHlwZSkge1xuICAgICAgICAgICAgY2FzZSAnYXVkaW8vb3B1cyc6XG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzcHJvcFN0ZXJlbyA9IGNvZGVjLnBhcmFtZXRlcnNbJ3Nwcm9wLXN0ZXJlbyddO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3Byb3BTdGVyZW8gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtZXRlcnMuc3RlcmVvID0gc3Byb3BTdGVyZW8gPyAxIDogMDtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8vIFdyaXRlIHRoZSBjb2RlYyBmbXRwLmNvbmZpZyBiYWNrLlxuICAgICAgICBmbXRwLmNvbmZpZyA9ICcnO1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKSkge1xuICAgICAgICAgICAgaWYgKGZtdHAuY29uZmlnKVxuICAgICAgICAgICAgICAgIGZtdHAuY29uZmlnICs9ICc7JztcbiAgICAgICAgICAgIGZtdHAuY29uZmlnICs9IGAke2tleX09JHtwYXJhbWV0ZXJzW2tleV19YDtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuYXBwbHlDb2RlY1BhcmFtZXRlcnMgPSBhcHBseUNvZGVjUGFyYW1ldGVycztcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5hZGRMZWdhY3lTaW11bGNhc3QgPSBleHBvcnRzLmdldFJ0cEVuY29kaW5ncyA9IHZvaWQgMDtcbmZ1bmN0aW9uIGdldFJ0cEVuY29kaW5ncyh7IG9mZmVyTWVkaWFPYmplY3QsIHRyYWNrIH0pIHtcbiAgICAvLyBGaXJzdCBtZWRpYSBTU1JDIChvciB0aGUgb25seSBvbmUpLlxuICAgIGxldCBmaXJzdFNzcmM7XG4gICAgY29uc3Qgc3NyY3MgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIG9mZmVyTWVkaWFPYmplY3Quc3NyY3MgfHwgW10pIHtcbiAgICAgICAgaWYgKGxpbmUuYXR0cmlidXRlICE9PSAnbXNpZCcpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgdHJhY2tJZCA9IGxpbmUudmFsdWUuc3BsaXQoJyAnKVsxXTtcbiAgICAgICAgaWYgKHRyYWNrSWQgPT09IHRyYWNrLmlkKSB7XG4gICAgICAgICAgICBjb25zdCBzc3JjID0gbGluZS5pZDtcbiAgICAgICAgICAgIHNzcmNzLmFkZChzc3JjKTtcbiAgICAgICAgICAgIGlmICghZmlyc3RTc3JjKVxuICAgICAgICAgICAgICAgIGZpcnN0U3NyYyA9IHNzcmM7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHNzcmNzLnNpemUgPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYT1zc3JjIGxpbmUgd2l0aCBtc2lkIGluZm9ybWF0aW9uIG5vdCBmb3VuZCBbdHJhY2suaWQ6JHt0cmFjay5pZH1dYCk7XG4gICAgY29uc3Qgc3NyY1RvUnR4U3NyYyA9IG5ldyBNYXAoKTtcbiAgICAvLyBGaXJzdCBhc3N1bWUgUlRYIGlzIHVzZWQuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIG9mZmVyTWVkaWFPYmplY3Quc3NyY0dyb3VwcyB8fCBbXSkge1xuICAgICAgICBpZiAobGluZS5zZW1hbnRpY3MgIT09ICdGSUQnKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBbc3NyYywgcnR4U3NyY10gPSBsaW5lLnNzcmNzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIHNzcmMgPSBOdW1iZXIoc3NyYyk7XG4gICAgICAgIHJ0eFNzcmMgPSBOdW1iZXIocnR4U3NyYyk7XG4gICAgICAgIGlmIChzc3Jjcy5oYXMoc3NyYykpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBib3RoIHRoZSBTU1JDIGFuZCBSVFggU1NSQyBmcm9tIHRoZSBzZXQgc28gbGF0ZXIgd2Uga25vdyB0aGF0IHRoZXlcbiAgICAgICAgICAgIC8vIGFyZSBhbHJlYWR5IGhhbmRsZWQuXG4gICAgICAgICAgICBzc3Jjcy5kZWxldGUoc3NyYyk7XG4gICAgICAgICAgICBzc3Jjcy5kZWxldGUocnR4U3NyYyk7XG4gICAgICAgICAgICAvLyBBZGQgdG8gdGhlIG1hcC5cbiAgICAgICAgICAgIHNzcmNUb1J0eFNzcmMuc2V0KHNzcmMsIHJ0eFNzcmMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBzZXQgb2YgU1NSQ3MgaXMgbm90IGVtcHR5IGl0IG1lYW5zIHRoYXQgUlRYIGlzIG5vdCBiZWluZyB1c2VkLCBzbyB0YWtlXG4gICAgLy8gbWVkaWEgU1NSQ3MgZnJvbSB0aGVyZS5cbiAgICBmb3IgKGNvbnN0IHNzcmMgb2Ygc3NyY3MpIHtcbiAgICAgICAgLy8gQWRkIHRvIHRoZSBtYXAuXG4gICAgICAgIHNzcmNUb1J0eFNzcmMuc2V0KHNzcmMsIG51bGwpO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGluZ3MgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtzc3JjLCBydHhTc3JjXSBvZiBzc3JjVG9SdHhTc3JjKSB7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0geyBzc3JjIH07XG4gICAgICAgIGlmIChydHhTc3JjKVxuICAgICAgICAgICAgZW5jb2RpbmcucnR4ID0geyBzc3JjOiBydHhTc3JjIH07XG4gICAgICAgIGVuY29kaW5ncy5wdXNoKGVuY29kaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kaW5ncztcbn1cbmV4cG9ydHMuZ2V0UnRwRW5jb2RpbmdzID0gZ2V0UnRwRW5jb2RpbmdzO1xuLyoqXG4gKiBBZGRzIG11bHRpLXNzcmMgYmFzZWQgc2ltdWxjYXN0IGludG8gdGhlIGdpdmVuIFNEUCBtZWRpYSBzZWN0aW9uIG9mZmVyLlxuICovXG5mdW5jdGlvbiBhZGRMZWdhY3lTaW11bGNhc3QoeyBvZmZlck1lZGlhT2JqZWN0LCB0cmFjaywgbnVtU3RyZWFtcyB9KSB7XG4gICAgaWYgKG51bVN0cmVhbXMgPD0gMSlcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbnVtU3RyZWFtcyBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAxJyk7XG4gICAgbGV0IGZpcnN0U3NyYztcbiAgICBsZXQgZmlyc3RSdHhTc3JjO1xuICAgIGxldCBzdHJlYW1JZDtcbiAgICAvLyBHZXQgdGhlIFNTUkMuXG4gICAgY29uc3Qgc3NyY01zaWRMaW5lID0gKG9mZmVyTWVkaWFPYmplY3Quc3NyY3MgfHwgW10pXG4gICAgICAgIC5maW5kKChsaW5lKSA9PiB7XG4gICAgICAgIGlmIChsaW5lLmF0dHJpYnV0ZSAhPT0gJ21zaWQnKVxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICBjb25zdCB0cmFja0lkID0gbGluZS52YWx1ZS5zcGxpdCgnICcpWzFdO1xuICAgICAgICBpZiAodHJhY2tJZCA9PT0gdHJhY2suaWQpIHtcbiAgICAgICAgICAgIGZpcnN0U3NyYyA9IGxpbmUuaWQ7XG4gICAgICAgICAgICBzdHJlYW1JZCA9IGxpbmUudmFsdWUuc3BsaXQoJyAnKVswXTtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfSk7XG4gICAgaWYgKCFzc3JjTXNpZExpbmUpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgYT1zc3JjIGxpbmUgd2l0aCBtc2lkIGluZm9ybWF0aW9uIG5vdCBmb3VuZCBbdHJhY2suaWQ6JHt0cmFjay5pZH1dYCk7XG4gICAgLy8gR2V0IHRoZSBTU1JDIGZvciBSVFguXG4gICAgKG9mZmVyTWVkaWFPYmplY3Quc3NyY0dyb3VwcyB8fCBbXSlcbiAgICAgICAgLnNvbWUoKGxpbmUpID0+IHtcbiAgICAgICAgaWYgKGxpbmUuc2VtYW50aWNzICE9PSAnRklEJylcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgY29uc3Qgc3NyY3MgPSBsaW5lLnNzcmNzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIGlmIChOdW1iZXIoc3NyY3NbMF0pID09PSBmaXJzdFNzcmMpIHtcbiAgICAgICAgICAgIGZpcnN0UnR4U3NyYyA9IE51bWJlcihzc3Jjc1sxXSk7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH0pO1xuICAgIGNvbnN0IHNzcmNDbmFtZUxpbmUgPSBvZmZlck1lZGlhT2JqZWN0LnNzcmNzXG4gICAgICAgIC5maW5kKChsaW5lKSA9PiAobGluZS5hdHRyaWJ1dGUgPT09ICdjbmFtZScgJiYgbGluZS5pZCA9PT0gZmlyc3RTc3JjKSk7XG4gICAgaWYgKCFzc3JjQ25hbWVMaW5lKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYGE9c3NyYyBsaW5lIHdpdGggY25hbWUgaW5mb3JtYXRpb24gbm90IGZvdW5kIFt0cmFjay5pZDoke3RyYWNrLmlkfV1gKTtcbiAgICBjb25zdCBjbmFtZSA9IHNzcmNDbmFtZUxpbmUudmFsdWU7XG4gICAgY29uc3Qgc3NyY3MgPSBbXTtcbiAgICBjb25zdCBydHhTc3JjcyA9IFtdO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbnVtU3RyZWFtczsgKytpKSB7XG4gICAgICAgIHNzcmNzLnB1c2goZmlyc3RTc3JjICsgaSk7XG4gICAgICAgIGlmIChmaXJzdFJ0eFNzcmMpXG4gICAgICAgICAgICBydHhTc3Jjcy5wdXNoKGZpcnN0UnR4U3NyYyArIGkpO1xuICAgIH1cbiAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNHcm91cHMgPSBvZmZlck1lZGlhT2JqZWN0LnNzcmNHcm91cHMgfHwgW107XG4gICAgb2ZmZXJNZWRpYU9iamVjdC5zc3JjcyA9IG9mZmVyTWVkaWFPYmplY3Quc3NyY3MgfHwgW107XG4gICAgb2ZmZXJNZWRpYU9iamVjdC5zc3JjR3JvdXBzLnB1c2goe1xuICAgICAgICBzZW1hbnRpY3M6ICdTSU0nLFxuICAgICAgICBzc3Jjczogc3NyY3Muam9pbignICcpXG4gICAgfSk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBzc3Jjcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBzc3JjID0gc3NyY3NbaV07XG4gICAgICAgIG9mZmVyTWVkaWFPYmplY3Quc3NyY3MucHVzaCh7XG4gICAgICAgICAgICBpZDogc3NyYyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZTogJ2NuYW1lJyxcbiAgICAgICAgICAgIHZhbHVlOiBjbmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBzc3JjLFxuICAgICAgICAgICAgYXR0cmlidXRlOiAnbXNpZCcsXG4gICAgICAgICAgICB2YWx1ZTogYCR7c3RyZWFtSWR9ICR7dHJhY2suaWR9YFxuICAgICAgICB9KTtcbiAgICB9XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBydHhTc3Jjcy5sZW5ndGg7ICsraSkge1xuICAgICAgICBjb25zdCBzc3JjID0gc3NyY3NbaV07XG4gICAgICAgIGNvbnN0IHJ0eFNzcmMgPSBydHhTc3Jjc1tpXTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBydHhTc3JjLFxuICAgICAgICAgICAgYXR0cmlidXRlOiAnY25hbWUnLFxuICAgICAgICAgICAgdmFsdWU6IGNuYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IHJ0eFNzcmMsXG4gICAgICAgICAgICBhdHRyaWJ1dGU6ICdtc2lkJyxcbiAgICAgICAgICAgIHZhbHVlOiBgJHtzdHJlYW1JZH0gJHt0cmFjay5pZH1gXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNHcm91cHMucHVzaCh7XG4gICAgICAgICAgICBzZW1hbnRpY3M6ICdGSUQnLFxuICAgICAgICAgICAgc3NyY3M6IGAke3NzcmN9ICR7cnR4U3NyY31gXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuYWRkTGVnYWN5U2ltdWxjYXN0ID0gYWRkTGVnYWN5U2ltdWxjYXN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFkZExlZ2FjeVNpbXVsY2FzdCA9IGV4cG9ydHMuZ2V0UnRwRW5jb2RpbmdzID0gdm9pZCAwO1xuZnVuY3Rpb24gZ2V0UnRwRW5jb2RpbmdzKHsgb2ZmZXJNZWRpYU9iamVjdCB9KSB7XG4gICAgY29uc3Qgc3NyY3MgPSBuZXcgU2V0KCk7XG4gICAgZm9yIChjb25zdCBsaW5lIG9mIG9mZmVyTWVkaWFPYmplY3Quc3NyY3MgfHwgW10pIHtcbiAgICAgICAgY29uc3Qgc3NyYyA9IGxpbmUuaWQ7XG4gICAgICAgIHNzcmNzLmFkZChzc3JjKTtcbiAgICB9XG4gICAgaWYgKHNzcmNzLnNpemUgPT09IDApXG4gICAgICAgIHRocm93IG5ldyBFcnJvcignbm8gYT1zc3JjIGxpbmVzIGZvdW5kJyk7XG4gICAgY29uc3Qgc3NyY1RvUnR4U3NyYyA9IG5ldyBNYXAoKTtcbiAgICAvLyBGaXJzdCBhc3N1bWUgUlRYIGlzIHVzZWQuXG4gICAgZm9yIChjb25zdCBsaW5lIG9mIG9mZmVyTWVkaWFPYmplY3Quc3NyY0dyb3VwcyB8fCBbXSkge1xuICAgICAgICBpZiAobGluZS5zZW1hbnRpY3MgIT09ICdGSUQnKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGxldCBbc3NyYywgcnR4U3NyY10gPSBsaW5lLnNzcmNzLnNwbGl0KC9cXHMrLyk7XG4gICAgICAgIHNzcmMgPSBOdW1iZXIoc3NyYyk7XG4gICAgICAgIHJ0eFNzcmMgPSBOdW1iZXIocnR4U3NyYyk7XG4gICAgICAgIGlmIChzc3Jjcy5oYXMoc3NyYykpIHtcbiAgICAgICAgICAgIC8vIFJlbW92ZSBib3RoIHRoZSBTU1JDIGFuZCBSVFggU1NSQyBmcm9tIHRoZSBzZXQgc28gbGF0ZXIgd2Uga25vdyB0aGF0IHRoZXlcbiAgICAgICAgICAgIC8vIGFyZSBhbHJlYWR5IGhhbmRsZWQuXG4gICAgICAgICAgICBzc3Jjcy5kZWxldGUoc3NyYyk7XG4gICAgICAgICAgICBzc3Jjcy5kZWxldGUocnR4U3NyYyk7XG4gICAgICAgICAgICAvLyBBZGQgdG8gdGhlIG1hcC5cbiAgICAgICAgICAgIHNzcmNUb1J0eFNzcmMuc2V0KHNzcmMsIHJ0eFNzcmMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIElmIHRoZSBzZXQgb2YgU1NSQ3MgaXMgbm90IGVtcHR5IGl0IG1lYW5zIHRoYXQgUlRYIGlzIG5vdCBiZWluZyB1c2VkLCBzbyB0YWtlXG4gICAgLy8gbWVkaWEgU1NSQ3MgZnJvbSB0aGVyZS5cbiAgICBmb3IgKGNvbnN0IHNzcmMgb2Ygc3NyY3MpIHtcbiAgICAgICAgLy8gQWRkIHRvIHRoZSBtYXAuXG4gICAgICAgIHNzcmNUb1J0eFNzcmMuc2V0KHNzcmMsIG51bGwpO1xuICAgIH1cbiAgICBjb25zdCBlbmNvZGluZ3MgPSBbXTtcbiAgICBmb3IgKGNvbnN0IFtzc3JjLCBydHhTc3JjXSBvZiBzc3JjVG9SdHhTc3JjKSB7XG4gICAgICAgIGNvbnN0IGVuY29kaW5nID0geyBzc3JjIH07XG4gICAgICAgIGlmIChydHhTc3JjKVxuICAgICAgICAgICAgZW5jb2RpbmcucnR4ID0geyBzc3JjOiBydHhTc3JjIH07XG4gICAgICAgIGVuY29kaW5ncy5wdXNoKGVuY29kaW5nKTtcbiAgICB9XG4gICAgcmV0dXJuIGVuY29kaW5ncztcbn1cbmV4cG9ydHMuZ2V0UnRwRW5jb2RpbmdzID0gZ2V0UnRwRW5jb2RpbmdzO1xuLyoqXG4gKiBBZGRzIG11bHRpLXNzcmMgYmFzZWQgc2ltdWxjYXN0IGludG8gdGhlIGdpdmVuIFNEUCBtZWRpYSBzZWN0aW9uIG9mZmVyLlxuICovXG5mdW5jdGlvbiBhZGRMZWdhY3lTaW11bGNhc3QoeyBvZmZlck1lZGlhT2JqZWN0LCBudW1TdHJlYW1zIH0pIHtcbiAgICBpZiAobnVtU3RyZWFtcyA8PSAxKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdudW1TdHJlYW1zIG11c3QgYmUgZ3JlYXRlciB0aGFuIDEnKTtcbiAgICAvLyBHZXQgdGhlIFNTUkMuXG4gICAgY29uc3Qgc3NyY01zaWRMaW5lID0gKG9mZmVyTWVkaWFPYmplY3Quc3NyY3MgfHwgW10pXG4gICAgICAgIC5maW5kKChsaW5lKSA9PiBsaW5lLmF0dHJpYnV0ZSA9PT0gJ21zaWQnKTtcbiAgICBpZiAoIXNzcmNNc2lkTGluZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhPXNzcmMgbGluZSB3aXRoIG1zaWQgaW5mb3JtYXRpb24gbm90IGZvdW5kJyk7XG4gICAgY29uc3QgW3N0cmVhbUlkLCB0cmFja0lkXSA9IHNzcmNNc2lkTGluZS52YWx1ZS5zcGxpdCgnICcpO1xuICAgIGNvbnN0IGZpcnN0U3NyYyA9IHNzcmNNc2lkTGluZS5pZDtcbiAgICBsZXQgZmlyc3RSdHhTc3JjO1xuICAgIC8vIEdldCB0aGUgU1NSQyBmb3IgUlRYLlxuICAgIChvZmZlck1lZGlhT2JqZWN0LnNzcmNHcm91cHMgfHwgW10pXG4gICAgICAgIC5zb21lKChsaW5lKSA9PiB7XG4gICAgICAgIGlmIChsaW5lLnNlbWFudGljcyAhPT0gJ0ZJRCcpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGNvbnN0IHNzcmNzID0gbGluZS5zc3Jjcy5zcGxpdCgvXFxzKy8pO1xuICAgICAgICBpZiAoTnVtYmVyKHNzcmNzWzBdKSA9PT0gZmlyc3RTc3JjKSB7XG4gICAgICAgICAgICBmaXJzdFJ0eFNzcmMgPSBOdW1iZXIoc3NyY3NbMV0pO1xuICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9KTtcbiAgICBjb25zdCBzc3JjQ25hbWVMaW5lID0gb2ZmZXJNZWRpYU9iamVjdC5zc3Jjc1xuICAgICAgICAuZmluZCgobGluZSkgPT4gbGluZS5hdHRyaWJ1dGUgPT09ICdjbmFtZScpO1xuICAgIGlmICghc3NyY0NuYW1lTGluZSlcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdhPXNzcmMgbGluZSB3aXRoIGNuYW1lIGluZm9ybWF0aW9uIG5vdCBmb3VuZCcpO1xuICAgIGNvbnN0IGNuYW1lID0gc3NyY0NuYW1lTGluZS52YWx1ZTtcbiAgICBjb25zdCBzc3JjcyA9IFtdO1xuICAgIGNvbnN0IHJ0eFNzcmNzID0gW107XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBudW1TdHJlYW1zOyArK2kpIHtcbiAgICAgICAgc3NyY3MucHVzaChmaXJzdFNzcmMgKyBpKTtcbiAgICAgICAgaWYgKGZpcnN0UnR4U3NyYylcbiAgICAgICAgICAgIHJ0eFNzcmNzLnB1c2goZmlyc3RSdHhTc3JjICsgaSk7XG4gICAgfVxuICAgIG9mZmVyTWVkaWFPYmplY3Quc3NyY0dyb3VwcyA9IFtdO1xuICAgIG9mZmVyTWVkaWFPYmplY3Quc3NyY3MgPSBbXTtcbiAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNHcm91cHMucHVzaCh7XG4gICAgICAgIHNlbWFudGljczogJ1NJTScsXG4gICAgICAgIHNzcmNzOiBzc3Jjcy5qb2luKCcgJylcbiAgICB9KTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IHNzcmNzLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIGNvbnN0IHNzcmMgPSBzc3Jjc1tpXTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBzc3JjLFxuICAgICAgICAgICAgYXR0cmlidXRlOiAnY25hbWUnLFxuICAgICAgICAgICAgdmFsdWU6IGNuYW1lXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNzLnB1c2goe1xuICAgICAgICAgICAgaWQ6IHNzcmMsXG4gICAgICAgICAgICBhdHRyaWJ1dGU6ICdtc2lkJyxcbiAgICAgICAgICAgIHZhbHVlOiBgJHtzdHJlYW1JZH0gJHt0cmFja0lkfWBcbiAgICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgcnR4U3NyY3MubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgY29uc3Qgc3NyYyA9IHNzcmNzW2ldO1xuICAgICAgICBjb25zdCBydHhTc3JjID0gcnR4U3NyY3NbaV07XG4gICAgICAgIG9mZmVyTWVkaWFPYmplY3Quc3NyY3MucHVzaCh7XG4gICAgICAgICAgICBpZDogcnR4U3NyYyxcbiAgICAgICAgICAgIGF0dHJpYnV0ZTogJ2NuYW1lJyxcbiAgICAgICAgICAgIHZhbHVlOiBjbmFtZVxuICAgICAgICB9KTtcbiAgICAgICAgb2ZmZXJNZWRpYU9iamVjdC5zc3Jjcy5wdXNoKHtcbiAgICAgICAgICAgIGlkOiBydHhTc3JjLFxuICAgICAgICAgICAgYXR0cmlidXRlOiAnbXNpZCcsXG4gICAgICAgICAgICB2YWx1ZTogYCR7c3RyZWFtSWR9ICR7dHJhY2tJZH1gXG4gICAgICAgIH0pO1xuICAgICAgICBvZmZlck1lZGlhT2JqZWN0LnNzcmNHcm91cHMucHVzaCh7XG4gICAgICAgICAgICBzZW1hbnRpY3M6ICdGSUQnLFxuICAgICAgICAgICAgc3NyY3M6IGAke3NzcmN9ICR7cnR4U3NyY31gXG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmV4cG9ydHMuYWRkTGVnYWN5U2ltdWxjYXN0ID0gYWRkTGVnYWN5U2ltdWxjYXN0O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5kZXRlY3REZXZpY2UgPSBleHBvcnRzLkRldmljZSA9IGV4cG9ydHMudmVyc2lvbiA9IGV4cG9ydHMudHlwZXMgPSB2b2lkIDA7XG5jb25zdCBEZXZpY2VfMSA9IHJlcXVpcmUoXCIuL0RldmljZVwiKTtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIkRldmljZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gRGV2aWNlXzEuRGV2aWNlOyB9IH0pO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiZGV0ZWN0RGV2aWNlXCIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbiAoKSB7IHJldHVybiBEZXZpY2VfMS5kZXRlY3REZXZpY2U7IH0gfSk7XG5jb25zdCB0eXBlcyA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiLi90eXBlc1wiKSk7XG5leHBvcnRzLnR5cGVzID0gdHlwZXM7XG4vKipcbiAqIEV4cG9zZSBtZWRpYXNvdXAtY2xpZW50IHZlcnNpb24uXG4gKi9cbmV4cG9ydHMudmVyc2lvbiA9ICczLjYuMzQnO1xuLyoqXG4gKiBFeHBvc2UgcGFyc2VTY2FsYWJpbGl0eU1vZGUoKSBmdW5jdGlvbi5cbiAqL1xudmFyIHNjYWxhYmlsaXR5TW9kZXNfMSA9IHJlcXVpcmUoXCIuL3NjYWxhYmlsaXR5TW9kZXNcIik7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJwYXJzZVNjYWxhYmlsaXR5TW9kZVwiLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2NhbGFiaWxpdHlNb2Rlc18xLnBhcnNlOyB9IH0pO1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG52YXIgX19jcmVhdGVCaW5kaW5nID0gKHRoaXMgJiYgdGhpcy5fX2NyZWF0ZUJpbmRpbmcpIHx8IChPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkobywgazIsIHsgZW51bWVyYWJsZTogdHJ1ZSwgZ2V0OiBmdW5jdGlvbigpIHsgcmV0dXJuIG1ba107IH0gfSk7XG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgb1trMl0gPSBtW2tdO1xufSkpO1xudmFyIF9fc2V0TW9kdWxlRGVmYXVsdCA9ICh0aGlzICYmIHRoaXMuX19zZXRNb2R1bGVEZWZhdWx0KSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCB2KSB7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIFwiZGVmYXVsdFwiLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2IH0pO1xufSkgOiBmdW5jdGlvbihvLCB2KSB7XG4gICAgb1tcImRlZmF1bHRcIl0gPSB2O1xufSk7XG52YXIgX19pbXBvcnRTdGFyID0gKHRoaXMgJiYgdGhpcy5fX2ltcG9ydFN0YXIpIHx8IGZ1bmN0aW9uIChtb2QpIHtcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICBpZiAobW9kICE9IG51bGwpIGZvciAodmFyIGsgaW4gbW9kKSBpZiAoayAhPT0gXCJkZWZhdWx0XCIgJiYgT2JqZWN0Lmhhc093blByb3BlcnR5LmNhbGwobW9kLCBrKSkgX19jcmVhdGVCaW5kaW5nKHJlc3VsdCwgbW9kLCBrKTtcbiAgICBfX3NldE1vZHVsZURlZmF1bHQocmVzdWx0LCBtb2QpO1xuICAgIHJldHVybiByZXN1bHQ7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5jYW5SZWNlaXZlID0gZXhwb3J0cy5jYW5TZW5kID0gZXhwb3J0cy5nZW5lcmF0ZVByb2JhdG9yUnRwUGFyYW1ldGVycyA9IGV4cG9ydHMucmVkdWNlQ29kZWNzID0gZXhwb3J0cy5nZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycyA9IGV4cG9ydHMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMgPSBleHBvcnRzLmdldFJlY3ZSdHBDYXBhYmlsaXRpZXMgPSBleHBvcnRzLmdldEV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzID0gZXhwb3J0cy52YWxpZGF0ZVNjdHBTdHJlYW1QYXJhbWV0ZXJzID0gZXhwb3J0cy52YWxpZGF0ZVNjdHBQYXJhbWV0ZXJzID0gZXhwb3J0cy52YWxpZGF0ZU51bVNjdHBTdHJlYW1zID0gZXhwb3J0cy52YWxpZGF0ZVNjdHBDYXBhYmlsaXRpZXMgPSBleHBvcnRzLnZhbGlkYXRlUnRjcFBhcmFtZXRlcnMgPSBleHBvcnRzLnZhbGlkYXRlUnRwRW5jb2RpbmdQYXJhbWV0ZXJzID0gZXhwb3J0cy52YWxpZGF0ZVJ0cEhlYWRlckV4dGVuc2lvblBhcmFtZXRlcnMgPSBleHBvcnRzLnZhbGlkYXRlUnRwQ29kZWNQYXJhbWV0ZXJzID0gZXhwb3J0cy52YWxpZGF0ZVJ0cFBhcmFtZXRlcnMgPSBleHBvcnRzLnZhbGlkYXRlUnRwSGVhZGVyRXh0ZW5zaW9uID0gZXhwb3J0cy52YWxpZGF0ZVJ0Y3BGZWVkYmFjayA9IGV4cG9ydHMudmFsaWRhdGVSdHBDb2RlY0NhcGFiaWxpdHkgPSBleHBvcnRzLnZhbGlkYXRlUnRwQ2FwYWJpbGl0aWVzID0gdm9pZCAwO1xuY29uc3QgaDI2NCA9IF9faW1wb3J0U3RhcihyZXF1aXJlKFwiaDI2NC1wcm9maWxlLWxldmVsLWlkXCIpKTtcbmNvbnN0IHV0aWxzID0gX19pbXBvcnRTdGFyKHJlcXVpcmUoXCIuL3V0aWxzXCIpKTtcbmNvbnN0IFJUUF9QUk9CQVRPUl9NSUQgPSAncHJvYmF0b3InO1xuY29uc3QgUlRQX1BST0JBVE9SX1NTUkMgPSAxMjM0O1xuY29uc3QgUlRQX1BST0JBVE9SX0NPREVDX1BBWUxPQURfVFlQRSA9IDEyNztcbi8qKlxuICogVmFsaWRhdGVzIFJ0cENhcGFiaWxpdGllcy4gSXQgbWF5IG1vZGlmeSBnaXZlbiBkYXRhIGJ5IGFkZGluZyBtaXNzaW5nXG4gKiBmaWVsZHMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEl0IHRocm93cyBpZiBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJ0cENhcGFiaWxpdGllcyhjYXBzKSB7XG4gICAgaWYgKHR5cGVvZiBjYXBzICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FwcyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgLy8gY29kZWNzIGlzIG9wdGlvbmFsLiBJZiB1bnNldCwgZmlsbCB3aXRoIGFuIGVtcHR5IGFycmF5LlxuICAgIGlmIChjYXBzLmNvZGVjcyAmJiAhQXJyYXkuaXNBcnJheShjYXBzLmNvZGVjcykpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhcHMuY29kZWNzIGlzIG5vdCBhbiBhcnJheScpO1xuICAgIGVsc2UgaWYgKCFjYXBzLmNvZGVjcylcbiAgICAgICAgY2Fwcy5jb2RlY3MgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIGNhcHMuY29kZWNzKSB7XG4gICAgICAgIHZhbGlkYXRlUnRwQ29kZWNDYXBhYmlsaXR5KGNvZGVjKTtcbiAgICB9XG4gICAgLy8gaGVhZGVyRXh0ZW5zaW9ucyBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIGZpbGwgd2l0aCBhbiBlbXB0eSBhcnJheS5cbiAgICBpZiAoY2Fwcy5oZWFkZXJFeHRlbnNpb25zICYmICFBcnJheS5pc0FycmF5KGNhcHMuaGVhZGVyRXh0ZW5zaW9ucykpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NhcHMuaGVhZGVyRXh0ZW5zaW9ucyBpcyBub3QgYW4gYXJyYXknKTtcbiAgICBlbHNlIGlmICghY2Fwcy5oZWFkZXJFeHRlbnNpb25zKVxuICAgICAgICBjYXBzLmhlYWRlckV4dGVuc2lvbnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGV4dCBvZiBjYXBzLmhlYWRlckV4dGVuc2lvbnMpIHtcbiAgICAgICAgdmFsaWRhdGVSdHBIZWFkZXJFeHRlbnNpb24oZXh0KTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlUnRwQ2FwYWJpbGl0aWVzID0gdmFsaWRhdGVSdHBDYXBhYmlsaXRpZXM7XG4vKipcbiAqIFZhbGlkYXRlcyBSdHBDb2RlY0NhcGFiaWxpdHkuIEl0IG1heSBtb2RpZnkgZ2l2ZW4gZGF0YSBieSBhZGRpbmcgbWlzc2luZ1xuICogZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBJdCB0aHJvd3MgaWYgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSdHBDb2RlY0NhcGFiaWxpdHkoY29kZWMpIHtcbiAgICBjb25zdCBNaW1lVHlwZVJlZ2V4ID0gbmV3IFJlZ0V4cCgnXihhdWRpb3x2aWRlbykvKC4rKScsICdpJyk7XG4gICAgaWYgKHR5cGVvZiBjb2RlYyAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2NvZGVjIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAvLyBtaW1lVHlwZSBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKCFjb2RlYy5taW1lVHlwZSB8fCB0eXBlb2YgY29kZWMubWltZVR5cGUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGNvZGVjLm1pbWVUeXBlJyk7XG4gICAgY29uc3QgbWltZVR5cGVNYXRjaCA9IE1pbWVUeXBlUmVnZXguZXhlYyhjb2RlYy5taW1lVHlwZSk7XG4gICAgaWYgKCFtaW1lVHlwZU1hdGNoKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGNvZGVjLm1pbWVUeXBlJyk7XG4gICAgLy8gSnVzdCBvdmVycmlkZSBraW5kIHdpdGggbWVkaWEgY29tcG9uZW50IG9mIG1pbWVUeXBlLlxuICAgIGNvZGVjLmtpbmQgPSBtaW1lVHlwZU1hdGNoWzFdLnRvTG93ZXJDYXNlKCk7XG4gICAgLy8gcHJlZmVycmVkUGF5bG9hZFR5cGUgaXMgb3B0aW9uYWwuXG4gICAgaWYgKGNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlICYmIHR5cGVvZiBjb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZSAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY29kZWMucHJlZmVycmVkUGF5bG9hZFR5cGUnKTtcbiAgICAvLyBjbG9ja1JhdGUgaXMgbWFuZGF0b3J5LlxuICAgIGlmICh0eXBlb2YgY29kZWMuY2xvY2tSYXRlICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBjb2RlYy5jbG9ja1JhdGUnKTtcbiAgICAvLyBjaGFubmVscyBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIHNldCBpdCB0byAxIChqdXN0IGlmIGF1ZGlvKS5cbiAgICBpZiAoY29kZWMua2luZCA9PT0gJ2F1ZGlvJykge1xuICAgICAgICBpZiAodHlwZW9mIGNvZGVjLmNoYW5uZWxzICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIGNvZGVjLmNoYW5uZWxzID0gMTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIGRlbGV0ZSBjb2RlYy5jaGFubmVscztcbiAgICB9XG4gICAgLy8gcGFyYW1ldGVycyBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIHNldCBpdCB0byBhbiBlbXB0eSBvYmplY3QuXG4gICAgaWYgKCFjb2RlYy5wYXJhbWV0ZXJzIHx8IHR5cGVvZiBjb2RlYy5wYXJhbWV0ZXJzICE9PSAnb2JqZWN0JylcbiAgICAgICAgY29kZWMucGFyYW1ldGVycyA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGNvZGVjLnBhcmFtZXRlcnMpKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGNvZGVjLnBhcmFtZXRlcnNba2V5XTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGNvZGVjLnBhcmFtZXRlcnNba2V5XSA9ICcnO1xuICAgICAgICAgICAgdmFsdWUgPSAnJztcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHZhbHVlICE9PSAnc3RyaW5nJyAmJiB0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGBpbnZhbGlkIGNvZGVjIHBhcmFtZXRlciBba2V5OiR7a2V5fXMsIHZhbHVlOiR7dmFsdWV9XWApO1xuICAgICAgICB9XG4gICAgICAgIC8vIFNwZWNpZmljIHBhcmFtZXRlcnMgdmFsaWRhdGlvbi5cbiAgICAgICAgaWYgKGtleSA9PT0gJ2FwdCcpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdudW1iZXInKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY29kZWMgYXB0IHBhcmFtZXRlcicpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIHJ0Y3BGZWVkYmFjayBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIHNldCBpdCB0byBhbiBlbXB0eSBhcnJheS5cbiAgICBpZiAoIWNvZGVjLnJ0Y3BGZWVkYmFjayB8fCAhQXJyYXkuaXNBcnJheShjb2RlYy5ydGNwRmVlZGJhY2spKVxuICAgICAgICBjb2RlYy5ydGNwRmVlZGJhY2sgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGZiIG9mIGNvZGVjLnJ0Y3BGZWVkYmFjaykge1xuICAgICAgICB2YWxpZGF0ZVJ0Y3BGZWVkYmFjayhmYik7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVJ0cENvZGVjQ2FwYWJpbGl0eSA9IHZhbGlkYXRlUnRwQ29kZWNDYXBhYmlsaXR5O1xuLyoqXG4gKiBWYWxpZGF0ZXMgUnRjcEZlZWRiYWNrLiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUnRjcEZlZWRiYWNrKGZiKSB7XG4gICAgaWYgKHR5cGVvZiBmYiAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ZiIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAvLyB0eXBlIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAoIWZiLnR5cGUgfHwgdHlwZW9mIGZiLnR5cGUgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIGZiLnR5cGUnKTtcbiAgICAvLyBwYXJhbWV0ZXIgaXMgb3B0aW9uYWwuIElmIHVuc2V0IHNldCBpdCB0byBhbiBlbXB0eSBzdHJpbmcuXG4gICAgaWYgKCFmYi5wYXJhbWV0ZXIgfHwgdHlwZW9mIGZiLnBhcmFtZXRlciAhPT0gJ3N0cmluZycpXG4gICAgICAgIGZiLnBhcmFtZXRlciA9ICcnO1xufVxuZXhwb3J0cy52YWxpZGF0ZVJ0Y3BGZWVkYmFjayA9IHZhbGlkYXRlUnRjcEZlZWRiYWNrO1xuLyoqXG4gKiBWYWxpZGF0ZXMgUnRwSGVhZGVyRXh0ZW5zaW9uLiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUnRwSGVhZGVyRXh0ZW5zaW9uKGV4dCkge1xuICAgIGlmICh0eXBlb2YgZXh0ICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXh0IGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAvLyBraW5kIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAoZXh0LmtpbmQgIT09ICdhdWRpbycgJiYgZXh0LmtpbmQgIT09ICd2aWRlbycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZXh0LmtpbmQnKTtcbiAgICAvLyB1cmkgaXMgbWFuZGF0b3J5LlxuICAgIGlmICghZXh0LnVyaSB8fCB0eXBlb2YgZXh0LnVyaSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgZXh0LnVyaScpO1xuICAgIC8vIHByZWZlcnJlZElkIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAodHlwZW9mIGV4dC5wcmVmZXJyZWRJZCAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgZXh0LnByZWZlcnJlZElkJyk7XG4gICAgLy8gcHJlZmVycmVkRW5jcnlwdCBpcyBvcHRpb25hbC4gSWYgdW5zZXQgc2V0IGl0IHRvIGZhbHNlLlxuICAgIGlmIChleHQucHJlZmVycmVkRW5jcnlwdCAmJiB0eXBlb2YgZXh0LnByZWZlcnJlZEVuY3J5cHQgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBleHQucHJlZmVycmVkRW5jcnlwdCcpO1xuICAgIGVsc2UgaWYgKCFleHQucHJlZmVycmVkRW5jcnlwdClcbiAgICAgICAgZXh0LnByZWZlcnJlZEVuY3J5cHQgPSBmYWxzZTtcbiAgICAvLyBkaXJlY3Rpb24gaXMgb3B0aW9uYWwuIElmIHVuc2V0IHNldCBpdCB0byBzZW5kcmVjdi5cbiAgICBpZiAoZXh0LmRpcmVjdGlvbiAmJiB0eXBlb2YgZXh0LmRpcmVjdGlvbiAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgZXh0LmRpcmVjdGlvbicpO1xuICAgIGVsc2UgaWYgKCFleHQuZGlyZWN0aW9uKVxuICAgICAgICBleHQuZGlyZWN0aW9uID0gJ3NlbmRyZWN2Jztcbn1cbmV4cG9ydHMudmFsaWRhdGVSdHBIZWFkZXJFeHRlbnNpb24gPSB2YWxpZGF0ZVJ0cEhlYWRlckV4dGVuc2lvbjtcbi8qKlxuICogVmFsaWRhdGVzIFJ0cFBhcmFtZXRlcnMuIEl0IG1heSBtb2RpZnkgZ2l2ZW4gZGF0YSBieSBhZGRpbmcgbWlzc2luZ1xuICogZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBJdCB0aHJvd3MgaWYgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSdHBQYXJhbWV0ZXJzKHBhcmFtcykge1xuICAgIGlmICh0eXBlb2YgcGFyYW1zICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigncGFyYW1zIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAvLyBtaWQgaXMgb3B0aW9uYWwuXG4gICAgaWYgKHBhcmFtcy5taWQgJiYgdHlwZW9mIHBhcmFtcy5taWQgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbXMubWlkIGlzIG5vdCBhIHN0cmluZycpO1xuICAgIC8vIGNvZGVjcyBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKCFBcnJheS5pc0FycmF5KHBhcmFtcy5jb2RlY3MpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIHBhcmFtcy5jb2RlY3MnKTtcbiAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIHBhcmFtcy5jb2RlY3MpIHtcbiAgICAgICAgdmFsaWRhdGVSdHBDb2RlY1BhcmFtZXRlcnMoY29kZWMpO1xuICAgIH1cbiAgICAvLyBoZWFkZXJFeHRlbnNpb25zIGlzIG9wdGlvbmFsLiBJZiB1bnNldCwgZmlsbCB3aXRoIGFuIGVtcHR5IGFycmF5LlxuICAgIGlmIChwYXJhbXMuaGVhZGVyRXh0ZW5zaW9ucyAmJiAhQXJyYXkuaXNBcnJheShwYXJhbXMuaGVhZGVyRXh0ZW5zaW9ucykpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtcy5oZWFkZXJFeHRlbnNpb25zIGlzIG5vdCBhbiBhcnJheScpO1xuICAgIGVsc2UgaWYgKCFwYXJhbXMuaGVhZGVyRXh0ZW5zaW9ucylcbiAgICAgICAgcGFyYW1zLmhlYWRlckV4dGVuc2lvbnMgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGV4dCBvZiBwYXJhbXMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgICAgICB2YWxpZGF0ZVJ0cEhlYWRlckV4dGVuc2lvblBhcmFtZXRlcnMoZXh0KTtcbiAgICB9XG4gICAgLy8gZW5jb2RpbmdzIGlzIG9wdGlvbmFsLiBJZiB1bnNldCwgZmlsbCB3aXRoIGFuIGVtcHR5IGFycmF5LlxuICAgIGlmIChwYXJhbXMuZW5jb2RpbmdzICYmICFBcnJheS5pc0FycmF5KHBhcmFtcy5lbmNvZGluZ3MpKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbXMuZW5jb2RpbmdzIGlzIG5vdCBhbiBhcnJheScpO1xuICAgIGVsc2UgaWYgKCFwYXJhbXMuZW5jb2RpbmdzKVxuICAgICAgICBwYXJhbXMuZW5jb2RpbmdzID0gW107XG4gICAgZm9yIChjb25zdCBlbmNvZGluZyBvZiBwYXJhbXMuZW5jb2RpbmdzKSB7XG4gICAgICAgIHZhbGlkYXRlUnRwRW5jb2RpbmdQYXJhbWV0ZXJzKGVuY29kaW5nKTtcbiAgICB9XG4gICAgLy8gcnRjcCBpcyBvcHRpb25hbC4gSWYgdW5zZXQsIGZpbGwgd2l0aCBhbiBlbXB0eSBvYmplY3QuXG4gICAgaWYgKHBhcmFtcy5ydGNwICYmIHR5cGVvZiBwYXJhbXMucnRjcCAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtcy5ydGNwIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICBlbHNlIGlmICghcGFyYW1zLnJ0Y3ApXG4gICAgICAgIHBhcmFtcy5ydGNwID0ge307XG4gICAgdmFsaWRhdGVSdGNwUGFyYW1ldGVycyhwYXJhbXMucnRjcCk7XG59XG5leHBvcnRzLnZhbGlkYXRlUnRwUGFyYW1ldGVycyA9IHZhbGlkYXRlUnRwUGFyYW1ldGVycztcbi8qKlxuICogVmFsaWRhdGVzIFJ0cENvZGVjUGFyYW1ldGVycy4gSXQgbWF5IG1vZGlmeSBnaXZlbiBkYXRhIGJ5IGFkZGluZyBtaXNzaW5nXG4gKiBmaWVsZHMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEl0IHRocm93cyBpZiBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZVJ0cENvZGVjUGFyYW1ldGVycyhjb2RlYykge1xuICAgIGNvbnN0IE1pbWVUeXBlUmVnZXggPSBuZXcgUmVnRXhwKCdeKGF1ZGlvfHZpZGVvKS8oLispJywgJ2knKTtcbiAgICBpZiAodHlwZW9mIGNvZGVjICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY29kZWMgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgIC8vIG1pbWVUeXBlIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAoIWNvZGVjLm1pbWVUeXBlIHx8IHR5cGVvZiBjb2RlYy5taW1lVHlwZSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgY29kZWMubWltZVR5cGUnKTtcbiAgICBjb25zdCBtaW1lVHlwZU1hdGNoID0gTWltZVR5cGVSZWdleC5leGVjKGNvZGVjLm1pbWVUeXBlKTtcbiAgICBpZiAoIW1pbWVUeXBlTWF0Y2gpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2ludmFsaWQgY29kZWMubWltZVR5cGUnKTtcbiAgICAvLyBwYXlsb2FkVHlwZSBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKHR5cGVvZiBjb2RlYy5wYXlsb2FkVHlwZSAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgY29kZWMucGF5bG9hZFR5cGUnKTtcbiAgICAvLyBjbG9ja1JhdGUgaXMgbWFuZGF0b3J5LlxuICAgIGlmICh0eXBlb2YgY29kZWMuY2xvY2tSYXRlICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBjb2RlYy5jbG9ja1JhdGUnKTtcbiAgICBjb25zdCBraW5kID0gbWltZVR5cGVNYXRjaFsxXS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIGNoYW5uZWxzIGlzIG9wdGlvbmFsLiBJZiB1bnNldCwgc2V0IGl0IHRvIDEgKGp1c3QgaWYgYXVkaW8pLlxuICAgIGlmIChraW5kID09PSAnYXVkaW8nKSB7XG4gICAgICAgIGlmICh0eXBlb2YgY29kZWMuY2hhbm5lbHMgIT09ICdudW1iZXInKVxuICAgICAgICAgICAgY29kZWMuY2hhbm5lbHMgPSAxO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZGVsZXRlIGNvZGVjLmNoYW5uZWxzO1xuICAgIH1cbiAgICAvLyBwYXJhbWV0ZXJzIGlzIG9wdGlvbmFsLiBJZiB1bnNldCwgc2V0IGl0IHRvIGFuIGVtcHR5IG9iamVjdC5cbiAgICBpZiAoIWNvZGVjLnBhcmFtZXRlcnMgfHwgdHlwZW9mIGNvZGVjLnBhcmFtZXRlcnMgIT09ICdvYmplY3QnKVxuICAgICAgICBjb2RlYy5wYXJhbWV0ZXJzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoY29kZWMucGFyYW1ldGVycykpIHtcbiAgICAgICAgbGV0IHZhbHVlID0gY29kZWMucGFyYW1ldGVyc1trZXldO1xuICAgICAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgY29kZWMucGFyYW1ldGVyc1trZXldID0gJyc7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoYGludmFsaWQgY29kZWMgcGFyYW1ldGVyIFtrZXk6JHtrZXl9cywgdmFsdWU6JHt2YWx1ZX1dYCk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU3BlY2lmaWMgcGFyYW1ldGVycyB2YWxpZGF0aW9uLlxuICAgICAgICBpZiAoa2V5ID09PSAnYXB0Jykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBjb2RlYyBhcHQgcGFyYW1ldGVyJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLy8gcnRjcEZlZWRiYWNrIGlzIG9wdGlvbmFsLiBJZiB1bnNldCwgc2V0IGl0IHRvIGFuIGVtcHR5IGFycmF5LlxuICAgIGlmICghY29kZWMucnRjcEZlZWRiYWNrIHx8ICFBcnJheS5pc0FycmF5KGNvZGVjLnJ0Y3BGZWVkYmFjaykpXG4gICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IFtdO1xuICAgIGZvciAoY29uc3QgZmIgb2YgY29kZWMucnRjcEZlZWRiYWNrKSB7XG4gICAgICAgIHZhbGlkYXRlUnRjcEZlZWRiYWNrKGZiKTtcbiAgICB9XG59XG5leHBvcnRzLnZhbGlkYXRlUnRwQ29kZWNQYXJhbWV0ZXJzID0gdmFsaWRhdGVSdHBDb2RlY1BhcmFtZXRlcnM7XG4vKipcbiAqIFZhbGlkYXRlcyBSdHBIZWFkZXJFeHRlbnNpb25QYXJhbWV0ZXRlcnMuIEl0IG1heSBtb2RpZnkgZ2l2ZW4gZGF0YSBieSBhZGRpbmcgbWlzc2luZ1xuICogZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBJdCB0aHJvd3MgaWYgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSdHBIZWFkZXJFeHRlbnNpb25QYXJhbWV0ZXJzKGV4dCkge1xuICAgIGlmICh0eXBlb2YgZXh0ICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXh0IGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAvLyB1cmkgaXMgbWFuZGF0b3J5LlxuICAgIGlmICghZXh0LnVyaSB8fCB0eXBlb2YgZXh0LnVyaSAhPT0gJ3N0cmluZycpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgZXh0LnVyaScpO1xuICAgIC8vIGlkIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAodHlwZW9mIGV4dC5pZCAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgZXh0LmlkJyk7XG4gICAgLy8gZW5jcnlwdCBpcyBvcHRpb25hbC4gSWYgdW5zZXQgc2V0IGl0IHRvIGZhbHNlLlxuICAgIGlmIChleHQuZW5jcnlwdCAmJiB0eXBlb2YgZXh0LmVuY3J5cHQgIT09ICdib29sZWFuJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBleHQuZW5jcnlwdCcpO1xuICAgIGVsc2UgaWYgKCFleHQuZW5jcnlwdClcbiAgICAgICAgZXh0LmVuY3J5cHQgPSBmYWxzZTtcbiAgICAvLyBwYXJhbWV0ZXJzIGlzIG9wdGlvbmFsLiBJZiB1bnNldCwgc2V0IGl0IHRvIGFuIGVtcHR5IG9iamVjdC5cbiAgICBpZiAoIWV4dC5wYXJhbWV0ZXJzIHx8IHR5cGVvZiBleHQucGFyYW1ldGVycyAhPT0gJ29iamVjdCcpXG4gICAgICAgIGV4dC5wYXJhbWV0ZXJzID0ge307XG4gICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMoZXh0LnBhcmFtZXRlcnMpKSB7XG4gICAgICAgIGxldCB2YWx1ZSA9IGV4dC5wYXJhbWV0ZXJzW2tleV07XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBleHQucGFyYW1ldGVyc1trZXldID0gJyc7XG4gICAgICAgICAgICB2YWx1ZSA9ICcnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgIT09ICdzdHJpbmcnICYmIHR5cGVvZiB2YWx1ZSAhPT0gJ251bWJlcicpXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGhlYWRlciBleHRlbnNpb24gcGFyYW1ldGVyJyk7XG4gICAgfVxufVxuZXhwb3J0cy52YWxpZGF0ZVJ0cEhlYWRlckV4dGVuc2lvblBhcmFtZXRlcnMgPSB2YWxpZGF0ZVJ0cEhlYWRlckV4dGVuc2lvblBhcmFtZXRlcnM7XG4vKipcbiAqIFZhbGlkYXRlcyBSdHBFbmNvZGluZ1BhcmFtZXRlcnMuIEl0IG1heSBtb2RpZnkgZ2l2ZW4gZGF0YSBieSBhZGRpbmcgbWlzc2luZ1xuICogZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBJdCB0aHJvd3MgaWYgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVSdHBFbmNvZGluZ1BhcmFtZXRlcnMoZW5jb2RpbmcpIHtcbiAgICBpZiAodHlwZW9mIGVuY29kaW5nICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZW5jb2RpbmcgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgIC8vIHNzcmMgaXMgb3B0aW9uYWwuXG4gICAgaWYgKGVuY29kaW5nLnNzcmMgJiYgdHlwZW9mIGVuY29kaW5nLnNzcmMgIT09ICdudW1iZXInKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGVuY29kaW5nLnNzcmMnKTtcbiAgICAvLyByaWQgaXMgb3B0aW9uYWwuXG4gICAgaWYgKGVuY29kaW5nLnJpZCAmJiB0eXBlb2YgZW5jb2RpbmcucmlkICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBlbmNvZGluZy5yaWQnKTtcbiAgICAvLyBydHggaXMgb3B0aW9uYWwuXG4gICAgaWYgKGVuY29kaW5nLnJ0eCAmJiB0eXBlb2YgZW5jb2RpbmcucnR4ICE9PSAnb2JqZWN0Jykge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIGVuY29kaW5nLnJ0eCcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChlbmNvZGluZy5ydHgpIHtcbiAgICAgICAgLy8gUlRYIHNzcmMgaXMgbWFuZGF0b3J5IGlmIHJ0eCBpcyBwcmVzZW50LlxuICAgICAgICBpZiAodHlwZW9mIGVuY29kaW5nLnJ0eC5zc3JjICE9PSAnbnVtYmVyJylcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgZW5jb2RpbmcucnR4LnNzcmMnKTtcbiAgICB9XG4gICAgLy8gZHR4IGlzIG9wdGlvbmFsLiBJZiB1bnNldCBzZXQgaXQgdG8gZmFsc2UuXG4gICAgaWYgKCFlbmNvZGluZy5kdHggfHwgdHlwZW9mIGVuY29kaW5nLmR0eCAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICBlbmNvZGluZy5kdHggPSBmYWxzZTtcbiAgICAvLyBzY2FsYWJpbGl0eU1vZGUgaXMgb3B0aW9uYWwuXG4gICAgaWYgKGVuY29kaW5nLnNjYWxhYmlsaXR5TW9kZSAmJiB0eXBlb2YgZW5jb2Rpbmcuc2NhbGFiaWxpdHlNb2RlICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBlbmNvZGluZy5zY2FsYWJpbGl0eU1vZGUnKTtcbn1cbmV4cG9ydHMudmFsaWRhdGVSdHBFbmNvZGluZ1BhcmFtZXRlcnMgPSB2YWxpZGF0ZVJ0cEVuY29kaW5nUGFyYW1ldGVycztcbi8qKlxuICogVmFsaWRhdGVzIFJ0Y3BQYXJhbWV0ZXJzLiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlUnRjcFBhcmFtZXRlcnMocnRjcCkge1xuICAgIGlmICh0eXBlb2YgcnRjcCAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3J0Y3AgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgIC8vIGNuYW1lIGlzIG9wdGlvbmFsLlxuICAgIGlmIChydGNwLmNuYW1lICYmIHR5cGVvZiBydGNwLmNuYW1lICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBydGNwLmNuYW1lJyk7XG4gICAgLy8gcmVkdWNlZFNpemUgaXMgb3B0aW9uYWwuIElmIHVuc2V0IHNldCBpdCB0byB0cnVlLlxuICAgIGlmICghcnRjcC5yZWR1Y2VkU2l6ZSB8fCB0eXBlb2YgcnRjcC5yZWR1Y2VkU2l6ZSAhPT0gJ2Jvb2xlYW4nKVxuICAgICAgICBydGNwLnJlZHVjZWRTaXplID0gdHJ1ZTtcbn1cbmV4cG9ydHMudmFsaWRhdGVSdGNwUGFyYW1ldGVycyA9IHZhbGlkYXRlUnRjcFBhcmFtZXRlcnM7XG4vKipcbiAqIFZhbGlkYXRlcyBTY3RwQ2FwYWJpbGl0aWVzLiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU2N0cENhcGFiaWxpdGllcyhjYXBzKSB7XG4gICAgaWYgKHR5cGVvZiBjYXBzICE9PSAnb2JqZWN0JylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignY2FwcyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgLy8gbnVtU3RyZWFtcyBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKCFjYXBzLm51bVN0cmVhbXMgfHwgdHlwZW9mIGNhcHMubnVtU3RyZWFtcyAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgY2Fwcy5udW1TdHJlYW1zJyk7XG4gICAgdmFsaWRhdGVOdW1TY3RwU3RyZWFtcyhjYXBzLm51bVN0cmVhbXMpO1xufVxuZXhwb3J0cy52YWxpZGF0ZVNjdHBDYXBhYmlsaXRpZXMgPSB2YWxpZGF0ZVNjdHBDYXBhYmlsaXRpZXM7XG4vKipcbiAqIFZhbGlkYXRlcyBOdW1TY3RwU3RyZWFtcy4gSXQgbWF5IG1vZGlmeSBnaXZlbiBkYXRhIGJ5IGFkZGluZyBtaXNzaW5nXG4gKiBmaWVsZHMgd2l0aCBkZWZhdWx0IHZhbHVlcy5cbiAqIEl0IHRocm93cyBpZiBpbnZhbGlkLlxuICovXG5mdW5jdGlvbiB2YWxpZGF0ZU51bVNjdHBTdHJlYW1zKG51bVN0cmVhbXMpIHtcbiAgICBpZiAodHlwZW9mIG51bVN0cmVhbXMgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdudW1TdHJlYW1zIGlzIG5vdCBhbiBvYmplY3QnKTtcbiAgICAvLyBPUyBpcyBtYW5kYXRvcnkuXG4gICAgaWYgKHR5cGVvZiBudW1TdHJlYW1zLk9TICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBudW1TdHJlYW1zLk9TJyk7XG4gICAgLy8gTUlTIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAodHlwZW9mIG51bVN0cmVhbXMuTUlTICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBudW1TdHJlYW1zLk1JUycpO1xufVxuZXhwb3J0cy52YWxpZGF0ZU51bVNjdHBTdHJlYW1zID0gdmFsaWRhdGVOdW1TY3RwU3RyZWFtcztcbi8qKlxuICogVmFsaWRhdGVzIFNjdHBQYXJhbWV0ZXJzLiBJdCBtYXkgbW9kaWZ5IGdpdmVuIGRhdGEgYnkgYWRkaW5nIG1pc3NpbmdcbiAqIGZpZWxkcyB3aXRoIGRlZmF1bHQgdmFsdWVzLlxuICogSXQgdGhyb3dzIGlmIGludmFsaWQuXG4gKi9cbmZ1bmN0aW9uIHZhbGlkYXRlU2N0cFBhcmFtZXRlcnMocGFyYW1zKSB7XG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgIT09ICdvYmplY3QnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdwYXJhbXMgaXMgbm90IGFuIG9iamVjdCcpO1xuICAgIC8vIHBvcnQgaXMgbWFuZGF0b3J5LlxuICAgIGlmICh0eXBlb2YgcGFyYW1zLnBvcnQgIT09ICdudW1iZXInKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdtaXNzaW5nIHBhcmFtcy5wb3J0Jyk7XG4gICAgLy8gT1MgaXMgbWFuZGF0b3J5LlxuICAgIGlmICh0eXBlb2YgcGFyYW1zLk9TICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBwYXJhbXMuT1MnKTtcbiAgICAvLyBNSVMgaXMgbWFuZGF0b3J5LlxuICAgIGlmICh0eXBlb2YgcGFyYW1zLk1JUyAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgcGFyYW1zLk1JUycpO1xuICAgIC8vIG1heE1lc3NhZ2VTaXplIGlzIG1hbmRhdG9yeS5cbiAgICBpZiAodHlwZW9mIHBhcmFtcy5tYXhNZXNzYWdlU2l6ZSAhPT0gJ251bWJlcicpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ21pc3NpbmcgcGFyYW1zLm1heE1lc3NhZ2VTaXplJyk7XG59XG5leHBvcnRzLnZhbGlkYXRlU2N0cFBhcmFtZXRlcnMgPSB2YWxpZGF0ZVNjdHBQYXJhbWV0ZXJzO1xuLyoqXG4gKiBWYWxpZGF0ZXMgU2N0cFN0cmVhbVBhcmFtZXRlcnMuIEl0IG1heSBtb2RpZnkgZ2l2ZW4gZGF0YSBieSBhZGRpbmcgbWlzc2luZ1xuICogZmllbGRzIHdpdGggZGVmYXVsdCB2YWx1ZXMuXG4gKiBJdCB0aHJvd3MgaWYgaW52YWxpZC5cbiAqL1xuZnVuY3Rpb24gdmFsaWRhdGVTY3RwU3RyZWFtUGFyYW1ldGVycyhwYXJhbXMpIHtcbiAgICBpZiAodHlwZW9mIHBhcmFtcyAhPT0gJ29iamVjdCcpXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ3BhcmFtcyBpcyBub3QgYW4gb2JqZWN0Jyk7XG4gICAgLy8gc3RyZWFtSWQgaXMgbWFuZGF0b3J5LlxuICAgIGlmICh0eXBlb2YgcGFyYW1zLnN0cmVhbUlkICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbWlzc2luZyBwYXJhbXMuc3RyZWFtSWQnKTtcbiAgICAvLyBvcmRlcmVkIGlzIG9wdGlvbmFsLlxuICAgIGxldCBvcmRlcmVkR2l2ZW4gPSBmYWxzZTtcbiAgICBpZiAodHlwZW9mIHBhcmFtcy5vcmRlcmVkID09PSAnYm9vbGVhbicpXG4gICAgICAgIG9yZGVyZWRHaXZlbiA9IHRydWU7XG4gICAgZWxzZVxuICAgICAgICBwYXJhbXMub3JkZXJlZCA9IHRydWU7XG4gICAgLy8gbWF4UGFja2V0TGlmZVRpbWUgaXMgb3B0aW9uYWwuXG4gICAgaWYgKHBhcmFtcy5tYXhQYWNrZXRMaWZlVGltZSAmJiB0eXBlb2YgcGFyYW1zLm1heFBhY2tldExpZmVUaW1lICE9PSAnbnVtYmVyJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXJhbXMubWF4UGFja2V0TGlmZVRpbWUnKTtcbiAgICAvLyBtYXhSZXRyYW5zbWl0cyBpcyBvcHRpb25hbC5cbiAgICBpZiAocGFyYW1zLm1heFJldHJhbnNtaXRzICYmIHR5cGVvZiBwYXJhbXMubWF4UmV0cmFuc21pdHMgIT09ICdudW1iZXInKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhcmFtcy5tYXhSZXRyYW5zbWl0cycpO1xuICAgIGlmIChwYXJhbXMubWF4UGFja2V0TGlmZVRpbWUgJiYgcGFyYW1zLm1heFJldHJhbnNtaXRzKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjYW5ub3QgcHJvdmlkZSBib3RoIG1heFBhY2tldExpZmVUaW1lIGFuZCBtYXhSZXRyYW5zbWl0cycpO1xuICAgIGlmIChvcmRlcmVkR2l2ZW4gJiZcbiAgICAgICAgcGFyYW1zLm9yZGVyZWQgJiZcbiAgICAgICAgKHBhcmFtcy5tYXhQYWNrZXRMaWZlVGltZSB8fCBwYXJhbXMubWF4UmV0cmFuc21pdHMpKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ2Nhbm5vdCBiZSBvcmRlcmVkIHdpdGggbWF4UGFja2V0TGlmZVRpbWUgb3IgbWF4UmV0cmFuc21pdHMnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoIW9yZGVyZWRHaXZlbiAmJiAocGFyYW1zLm1heFBhY2tldExpZmVUaW1lIHx8IHBhcmFtcy5tYXhSZXRyYW5zbWl0cykpIHtcbiAgICAgICAgcGFyYW1zLm9yZGVyZWQgPSBmYWxzZTtcbiAgICB9XG4gICAgLy8gbGFiZWwgaXMgb3B0aW9uYWwuXG4gICAgaWYgKHBhcmFtcy5sYWJlbCAmJiB0eXBlb2YgcGFyYW1zLmxhYmVsICE9PSAnc3RyaW5nJylcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignaW52YWxpZCBwYXJhbXMubGFiZWwnKTtcbiAgICAvLyBwcm90b2NvbCBpcyBvcHRpb25hbC5cbiAgICBpZiAocGFyYW1zLnByb3RvY29sICYmIHR5cGVvZiBwYXJhbXMucHJvdG9jb2wgIT09ICdzdHJpbmcnKVxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdpbnZhbGlkIHBhcmFtcy5wcm90b2NvbCcpO1xufVxuZXhwb3J0cy52YWxpZGF0ZVNjdHBTdHJlYW1QYXJhbWV0ZXJzID0gdmFsaWRhdGVTY3RwU3RyZWFtUGFyYW1ldGVycztcbi8qKlxuICogR2VuZXJhdGUgZXh0ZW5kZWQgUlRQIGNhcGFiaWxpdGllcyBmb3Igc2VuZGluZyBhbmQgcmVjZWl2aW5nLlxuICovXG5mdW5jdGlvbiBnZXRFeHRlbmRlZFJ0cENhcGFiaWxpdGllcyhsb2NhbENhcHMsIHJlbW90ZUNhcHMpIHtcbiAgICBjb25zdCBleHRlbmRlZFJ0cENhcGFiaWxpdGllcyA9IHtcbiAgICAgICAgY29kZWNzOiBbXSxcbiAgICAgICAgaGVhZGVyRXh0ZW5zaW9uczogW11cbiAgICB9O1xuICAgIC8vIE1hdGNoIG1lZGlhIGNvZGVjcyBhbmQga2VlcCB0aGUgb3JkZXIgcHJlZmVycmVkIGJ5IHJlbW90ZUNhcHMuXG4gICAgZm9yIChjb25zdCByZW1vdGVDb2RlYyBvZiByZW1vdGVDYXBzLmNvZGVjcyB8fCBbXSkge1xuICAgICAgICBpZiAoaXNSdHhDb2RlYyhyZW1vdGVDb2RlYykpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdMb2NhbENvZGVjID0gKGxvY2FsQ2Fwcy5jb2RlY3MgfHwgW10pXG4gICAgICAgICAgICAuZmluZCgobG9jYWxDb2RlYykgPT4gKG1hdGNoQ29kZWNzKGxvY2FsQ29kZWMsIHJlbW90ZUNvZGVjLCB7IHN0cmljdDogdHJ1ZSwgbW9kaWZ5OiB0cnVlIH0pKSk7XG4gICAgICAgIGlmICghbWF0Y2hpbmdMb2NhbENvZGVjKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGV4dGVuZGVkQ29kZWMgPSB7XG4gICAgICAgICAgICBtaW1lVHlwZTogbWF0Y2hpbmdMb2NhbENvZGVjLm1pbWVUeXBlLFxuICAgICAgICAgICAga2luZDogbWF0Y2hpbmdMb2NhbENvZGVjLmtpbmQsXG4gICAgICAgICAgICBjbG9ja1JhdGU6IG1hdGNoaW5nTG9jYWxDb2RlYy5jbG9ja1JhdGUsXG4gICAgICAgICAgICBjaGFubmVsczogbWF0Y2hpbmdMb2NhbENvZGVjLmNoYW5uZWxzLFxuICAgICAgICAgICAgbG9jYWxQYXlsb2FkVHlwZTogbWF0Y2hpbmdMb2NhbENvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlLFxuICAgICAgICAgICAgbG9jYWxSdHhQYXlsb2FkVHlwZTogdW5kZWZpbmVkLFxuICAgICAgICAgICAgcmVtb3RlUGF5bG9hZFR5cGU6IHJlbW90ZUNvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlLFxuICAgICAgICAgICAgcmVtb3RlUnR4UGF5bG9hZFR5cGU6IHVuZGVmaW5lZCxcbiAgICAgICAgICAgIGxvY2FsUGFyYW1ldGVyczogbWF0Y2hpbmdMb2NhbENvZGVjLnBhcmFtZXRlcnMsXG4gICAgICAgICAgICByZW1vdGVQYXJhbWV0ZXJzOiByZW1vdGVDb2RlYy5wYXJhbWV0ZXJzLFxuICAgICAgICAgICAgcnRjcEZlZWRiYWNrOiByZWR1Y2VSdGNwRmVlZGJhY2sobWF0Y2hpbmdMb2NhbENvZGVjLCByZW1vdGVDb2RlYylcbiAgICAgICAgfTtcbiAgICAgICAgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuY29kZWNzLnB1c2goZXh0ZW5kZWRDb2RlYyk7XG4gICAgfVxuICAgIC8vIE1hdGNoIFJUWCBjb2RlY3MuXG4gICAgZm9yIChjb25zdCBleHRlbmRlZENvZGVjIG9mIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0xvY2FsUnR4Q29kZWMgPSBsb2NhbENhcHMuY29kZWNzXG4gICAgICAgICAgICAuZmluZCgobG9jYWxDb2RlYykgPT4gKGlzUnR4Q29kZWMobG9jYWxDb2RlYykgJiZcbiAgICAgICAgICAgIGxvY2FsQ29kZWMucGFyYW1ldGVycy5hcHQgPT09IGV4dGVuZGVkQ29kZWMubG9jYWxQYXlsb2FkVHlwZSkpO1xuICAgICAgICBjb25zdCBtYXRjaGluZ1JlbW90ZVJ0eENvZGVjID0gcmVtb3RlQ2Fwcy5jb2RlY3NcbiAgICAgICAgICAgIC5maW5kKChyZW1vdGVDb2RlYykgPT4gKGlzUnR4Q29kZWMocmVtb3RlQ29kZWMpICYmXG4gICAgICAgICAgICByZW1vdGVDb2RlYy5wYXJhbWV0ZXJzLmFwdCA9PT0gZXh0ZW5kZWRDb2RlYy5yZW1vdGVQYXlsb2FkVHlwZSkpO1xuICAgICAgICBpZiAobWF0Y2hpbmdMb2NhbFJ0eENvZGVjICYmIG1hdGNoaW5nUmVtb3RlUnR4Q29kZWMpIHtcbiAgICAgICAgICAgIGV4dGVuZGVkQ29kZWMubG9jYWxSdHhQYXlsb2FkVHlwZSA9IG1hdGNoaW5nTG9jYWxSdHhDb2RlYy5wcmVmZXJyZWRQYXlsb2FkVHlwZTtcbiAgICAgICAgICAgIGV4dGVuZGVkQ29kZWMucmVtb3RlUnR4UGF5bG9hZFR5cGUgPSBtYXRjaGluZ1JlbW90ZVJ0eENvZGVjLnByZWZlcnJlZFBheWxvYWRUeXBlO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8vIE1hdGNoIGhlYWRlciBleHRlbnNpb25zLlxuICAgIGZvciAoY29uc3QgcmVtb3RlRXh0IG9mIHJlbW90ZUNhcHMuaGVhZGVyRXh0ZW5zaW9ucykge1xuICAgICAgICBjb25zdCBtYXRjaGluZ0xvY2FsRXh0ID0gbG9jYWxDYXBzLmhlYWRlckV4dGVuc2lvbnNcbiAgICAgICAgICAgIC5maW5kKChsb2NhbEV4dCkgPT4gKG1hdGNoSGVhZGVyRXh0ZW5zaW9ucyhsb2NhbEV4dCwgcmVtb3RlRXh0KSkpO1xuICAgICAgICBpZiAoIW1hdGNoaW5nTG9jYWxFeHQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgZXh0ZW5kZWRFeHQgPSB7XG4gICAgICAgICAgICBraW5kOiByZW1vdGVFeHQua2luZCxcbiAgICAgICAgICAgIHVyaTogcmVtb3RlRXh0LnVyaSxcbiAgICAgICAgICAgIHNlbmRJZDogbWF0Y2hpbmdMb2NhbEV4dC5wcmVmZXJyZWRJZCxcbiAgICAgICAgICAgIHJlY3ZJZDogcmVtb3RlRXh0LnByZWZlcnJlZElkLFxuICAgICAgICAgICAgZW5jcnlwdDogbWF0Y2hpbmdMb2NhbEV4dC5wcmVmZXJyZWRFbmNyeXB0LFxuICAgICAgICAgICAgZGlyZWN0aW9uOiAnc2VuZHJlY3YnXG4gICAgICAgIH07XG4gICAgICAgIHN3aXRjaCAocmVtb3RlRXh0LmRpcmVjdGlvbikge1xuICAgICAgICAgICAgY2FzZSAnc2VuZHJlY3YnOlxuICAgICAgICAgICAgICAgIGV4dGVuZGVkRXh0LmRpcmVjdGlvbiA9ICdzZW5kcmVjdic7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZWN2b25seSc6XG4gICAgICAgICAgICAgICAgZXh0ZW5kZWRFeHQuZGlyZWN0aW9uID0gJ3NlbmRvbmx5JztcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ3NlbmRvbmx5JzpcbiAgICAgICAgICAgICAgICBleHRlbmRlZEV4dC5kaXJlY3Rpb24gPSAncmVjdm9ubHknO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5hY3RpdmUnOlxuICAgICAgICAgICAgICAgIGV4dGVuZGVkRXh0LmRpcmVjdGlvbiA9ICdpbmFjdGl2ZSc7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuaGVhZGVyRXh0ZW5zaW9ucy5wdXNoKGV4dGVuZGVkRXh0KTtcbiAgICB9XG4gICAgcmV0dXJuIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzO1xufVxuZXhwb3J0cy5nZXRFeHRlbmRlZFJ0cENhcGFiaWxpdGllcyA9IGdldEV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzO1xuLyoqXG4gKiBHZW5lcmF0ZSBSVFAgY2FwYWJpbGl0aWVzIGZvciByZWNlaXZpbmcgbWVkaWEgYmFzZWQgb24gdGhlIGdpdmVuIGV4dGVuZGVkXG4gKiBSVFAgY2FwYWJpbGl0aWVzLlxuICovXG5mdW5jdGlvbiBnZXRSZWN2UnRwQ2FwYWJpbGl0aWVzKGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSB7XG4gICAgY29uc3QgcnRwQ2FwYWJpbGl0aWVzID0ge1xuICAgICAgICBjb2RlY3M6IFtdLFxuICAgICAgICBoZWFkZXJFeHRlbnNpb25zOiBbXVxuICAgIH07XG4gICAgZm9yIChjb25zdCBleHRlbmRlZENvZGVjIG9mIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgICBjb25zdCBjb2RlYyA9IHtcbiAgICAgICAgICAgIG1pbWVUeXBlOiBleHRlbmRlZENvZGVjLm1pbWVUeXBlLFxuICAgICAgICAgICAga2luZDogZXh0ZW5kZWRDb2RlYy5raW5kLFxuICAgICAgICAgICAgcHJlZmVycmVkUGF5bG9hZFR5cGU6IGV4dGVuZGVkQ29kZWMucmVtb3RlUGF5bG9hZFR5cGUsXG4gICAgICAgICAgICBjbG9ja1JhdGU6IGV4dGVuZGVkQ29kZWMuY2xvY2tSYXRlLFxuICAgICAgICAgICAgY2hhbm5lbHM6IGV4dGVuZGVkQ29kZWMuY2hhbm5lbHMsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBleHRlbmRlZENvZGVjLmxvY2FsUGFyYW1ldGVycyxcbiAgICAgICAgICAgIHJ0Y3BGZWVkYmFjazogZXh0ZW5kZWRDb2RlYy5ydGNwRmVlZGJhY2tcbiAgICAgICAgfTtcbiAgICAgICAgcnRwQ2FwYWJpbGl0aWVzLmNvZGVjcy5wdXNoKGNvZGVjKTtcbiAgICAgICAgLy8gQWRkIFJUWCBjb2RlYy5cbiAgICAgICAgaWYgKCFleHRlbmRlZENvZGVjLnJlbW90ZVJ0eFBheWxvYWRUeXBlKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IHJ0eENvZGVjID0ge1xuICAgICAgICAgICAgbWltZVR5cGU6IGAke2V4dGVuZGVkQ29kZWMua2luZH0vcnR4YCxcbiAgICAgICAgICAgIGtpbmQ6IGV4dGVuZGVkQ29kZWMua2luZCxcbiAgICAgICAgICAgIHByZWZlcnJlZFBheWxvYWRUeXBlOiBleHRlbmRlZENvZGVjLnJlbW90ZVJ0eFBheWxvYWRUeXBlLFxuICAgICAgICAgICAgY2xvY2tSYXRlOiBleHRlbmRlZENvZGVjLmNsb2NrUmF0ZSxcbiAgICAgICAgICAgIHBhcmFtZXRlcnM6IHtcbiAgICAgICAgICAgICAgICBhcHQ6IGV4dGVuZGVkQ29kZWMucmVtb3RlUGF5bG9hZFR5cGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBydGNwRmVlZGJhY2s6IFtdXG4gICAgICAgIH07XG4gICAgICAgIHJ0cENhcGFiaWxpdGllcy5jb2RlY3MucHVzaChydHhDb2RlYyk7XG4gICAgICAgIC8vIFRPRE86IEluIHRoZSBmdXR1cmUsIHdlIG5lZWQgdG8gYWRkIEZFQywgQ04sIGV0YywgY29kZWNzLlxuICAgIH1cbiAgICBmb3IgKGNvbnN0IGV4dGVuZGVkRXh0ZW5zaW9uIG9mIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmhlYWRlckV4dGVuc2lvbnMpIHtcbiAgICAgICAgLy8gSWdub3JlIFJUUCBleHRlbnNpb25zIG5vdCB2YWxpZCBmb3IgcmVjZWl2aW5nLlxuICAgICAgICBpZiAoZXh0ZW5kZWRFeHRlbnNpb24uZGlyZWN0aW9uICE9PSAnc2VuZHJlY3YnICYmXG4gICAgICAgICAgICBleHRlbmRlZEV4dGVuc2lvbi5kaXJlY3Rpb24gIT09ICdyZWN2b25seScpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4dCA9IHtcbiAgICAgICAgICAgIGtpbmQ6IGV4dGVuZGVkRXh0ZW5zaW9uLmtpbmQsXG4gICAgICAgICAgICB1cmk6IGV4dGVuZGVkRXh0ZW5zaW9uLnVyaSxcbiAgICAgICAgICAgIHByZWZlcnJlZElkOiBleHRlbmRlZEV4dGVuc2lvbi5yZWN2SWQsXG4gICAgICAgICAgICBwcmVmZXJyZWRFbmNyeXB0OiBleHRlbmRlZEV4dGVuc2lvbi5lbmNyeXB0LFxuICAgICAgICAgICAgZGlyZWN0aW9uOiBleHRlbmRlZEV4dGVuc2lvbi5kaXJlY3Rpb25cbiAgICAgICAgfTtcbiAgICAgICAgcnRwQ2FwYWJpbGl0aWVzLmhlYWRlckV4dGVuc2lvbnMucHVzaChleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcnRwQ2FwYWJpbGl0aWVzO1xufVxuZXhwb3J0cy5nZXRSZWN2UnRwQ2FwYWJpbGl0aWVzID0gZ2V0UmVjdlJ0cENhcGFiaWxpdGllcztcbi8qKlxuICogR2VuZXJhdGUgUlRQIHBhcmFtZXRlcnMgb2YgdGhlIGdpdmVuIGtpbmQgZm9yIHNlbmRpbmcgbWVkaWEuXG4gKiBOT1RFOiBtaWQsIGVuY29kaW5ncyBhbmQgcnRjcCBmaWVsZHMgYXJlIGxlZnQgZW1wdHkuXG4gKi9cbmZ1bmN0aW9uIGdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKGtpbmQsIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzKSB7XG4gICAgY29uc3QgcnRwUGFyYW1ldGVycyA9IHtcbiAgICAgICAgbWlkOiB1bmRlZmluZWQsXG4gICAgICAgIGNvZGVjczogW10sXG4gICAgICAgIGhlYWRlckV4dGVuc2lvbnM6IFtdLFxuICAgICAgICBlbmNvZGluZ3M6IFtdLFxuICAgICAgICBydGNwOiB7fVxuICAgIH07XG4gICAgZm9yIChjb25zdCBleHRlbmRlZENvZGVjIG9mIGV4dGVuZGVkUnRwQ2FwYWJpbGl0aWVzLmNvZGVjcykge1xuICAgICAgICBpZiAoZXh0ZW5kZWRDb2RlYy5raW5kICE9PSBraW5kKVxuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIGNvbnN0IGNvZGVjID0ge1xuICAgICAgICAgICAgbWltZVR5cGU6IGV4dGVuZGVkQ29kZWMubWltZVR5cGUsXG4gICAgICAgICAgICBwYXlsb2FkVHlwZTogZXh0ZW5kZWRDb2RlYy5sb2NhbFBheWxvYWRUeXBlLFxuICAgICAgICAgICAgY2xvY2tSYXRlOiBleHRlbmRlZENvZGVjLmNsb2NrUmF0ZSxcbiAgICAgICAgICAgIGNoYW5uZWxzOiBleHRlbmRlZENvZGVjLmNoYW5uZWxzLFxuICAgICAgICAgICAgcGFyYW1ldGVyczogZXh0ZW5kZWRDb2RlYy5sb2NhbFBhcmFtZXRlcnMsXG4gICAgICAgICAgICBydGNwRmVlZGJhY2s6IGV4dGVuZGVkQ29kZWMucnRjcEZlZWRiYWNrXG4gICAgICAgIH07XG4gICAgICAgIHJ0cFBhcmFtZXRlcnMuY29kZWNzLnB1c2goY29kZWMpO1xuICAgICAgICAvLyBBZGQgUlRYIGNvZGVjLlxuICAgICAgICBpZiAoZXh0ZW5kZWRDb2RlYy5sb2NhbFJ0eFBheWxvYWRUeXBlKSB7XG4gICAgICAgICAgICBjb25zdCBydHhDb2RlYyA9IHtcbiAgICAgICAgICAgICAgICBtaW1lVHlwZTogYCR7ZXh0ZW5kZWRDb2RlYy5raW5kfS9ydHhgLFxuICAgICAgICAgICAgICAgIHBheWxvYWRUeXBlOiBleHRlbmRlZENvZGVjLmxvY2FsUnR4UGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgY2xvY2tSYXRlOiBleHRlbmRlZENvZGVjLmNsb2NrUmF0ZSxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIGFwdDogZXh0ZW5kZWRDb2RlYy5sb2NhbFBheWxvYWRUeXBlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBydGNwRmVlZGJhY2s6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcnRwUGFyYW1ldGVycy5jb2RlY3MucHVzaChydHhDb2RlYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBleHRlbmRlZEV4dGVuc2lvbiBvZiBleHRlbmRlZFJ0cENhcGFiaWxpdGllcy5oZWFkZXJFeHRlbnNpb25zKSB7XG4gICAgICAgIC8vIElnbm9yZSBSVFAgZXh0ZW5zaW9ucyBvZiBhIGRpZmZlcmVudCBraW5kIGFuZCB0aG9zZSBub3QgdmFsaWQgZm9yIHNlbmRpbmcuXG4gICAgICAgIGlmICgoZXh0ZW5kZWRFeHRlbnNpb24ua2luZCAmJiBleHRlbmRlZEV4dGVuc2lvbi5raW5kICE9PSBraW5kKSB8fFxuICAgICAgICAgICAgKGV4dGVuZGVkRXh0ZW5zaW9uLmRpcmVjdGlvbiAhPT0gJ3NlbmRyZWN2JyAmJlxuICAgICAgICAgICAgICAgIGV4dGVuZGVkRXh0ZW5zaW9uLmRpcmVjdGlvbiAhPT0gJ3NlbmRvbmx5JykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4dCA9IHtcbiAgICAgICAgICAgIHVyaTogZXh0ZW5kZWRFeHRlbnNpb24udXJpLFxuICAgICAgICAgICAgaWQ6IGV4dGVuZGVkRXh0ZW5zaW9uLnNlbmRJZCxcbiAgICAgICAgICAgIGVuY3J5cHQ6IGV4dGVuZGVkRXh0ZW5zaW9uLmVuY3J5cHQsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7fVxuICAgICAgICB9O1xuICAgICAgICBydHBQYXJhbWV0ZXJzLmhlYWRlckV4dGVuc2lvbnMucHVzaChleHQpO1xuICAgIH1cbiAgICByZXR1cm4gcnRwUGFyYW1ldGVycztcbn1cbmV4cG9ydHMuZ2V0U2VuZGluZ1J0cFBhcmFtZXRlcnMgPSBnZXRTZW5kaW5nUnRwUGFyYW1ldGVycztcbi8qKlxuICogR2VuZXJhdGUgUlRQIHBhcmFtZXRlcnMgb2YgdGhlIGdpdmVuIGtpbmQgc3VpdGFibGUgZm9yIHRoZSByZW1vdGUgU0RQIGFuc3dlci5cbiAqL1xuZnVuY3Rpb24gZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoa2luZCwgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpIHtcbiAgICBjb25zdCBydHBQYXJhbWV0ZXJzID0ge1xuICAgICAgICBtaWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgY29kZWNzOiBbXSxcbiAgICAgICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgICAgIGVuY29kaW5nczogW10sXG4gICAgICAgIHJ0Y3A6IHt9XG4gICAgfTtcbiAgICBmb3IgKGNvbnN0IGV4dGVuZGVkQ29kZWMgb2YgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuY29kZWNzKSB7XG4gICAgICAgIGlmIChleHRlbmRlZENvZGVjLmtpbmQgIT09IGtpbmQpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgY29uc3QgY29kZWMgPSB7XG4gICAgICAgICAgICBtaW1lVHlwZTogZXh0ZW5kZWRDb2RlYy5taW1lVHlwZSxcbiAgICAgICAgICAgIHBheWxvYWRUeXBlOiBleHRlbmRlZENvZGVjLmxvY2FsUGF5bG9hZFR5cGUsXG4gICAgICAgICAgICBjbG9ja1JhdGU6IGV4dGVuZGVkQ29kZWMuY2xvY2tSYXRlLFxuICAgICAgICAgICAgY2hhbm5lbHM6IGV4dGVuZGVkQ29kZWMuY2hhbm5lbHMsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBleHRlbmRlZENvZGVjLnJlbW90ZVBhcmFtZXRlcnMsXG4gICAgICAgICAgICBydGNwRmVlZGJhY2s6IGV4dGVuZGVkQ29kZWMucnRjcEZlZWRiYWNrXG4gICAgICAgIH07XG4gICAgICAgIHJ0cFBhcmFtZXRlcnMuY29kZWNzLnB1c2goY29kZWMpO1xuICAgICAgICAvLyBBZGQgUlRYIGNvZGVjLlxuICAgICAgICBpZiAoZXh0ZW5kZWRDb2RlYy5sb2NhbFJ0eFBheWxvYWRUeXBlKSB7XG4gICAgICAgICAgICBjb25zdCBydHhDb2RlYyA9IHtcbiAgICAgICAgICAgICAgICBtaW1lVHlwZTogYCR7ZXh0ZW5kZWRDb2RlYy5raW5kfS9ydHhgLFxuICAgICAgICAgICAgICAgIHBheWxvYWRUeXBlOiBleHRlbmRlZENvZGVjLmxvY2FsUnR4UGF5bG9hZFR5cGUsXG4gICAgICAgICAgICAgICAgY2xvY2tSYXRlOiBleHRlbmRlZENvZGVjLmNsb2NrUmF0ZSxcbiAgICAgICAgICAgICAgICBwYXJhbWV0ZXJzOiB7XG4gICAgICAgICAgICAgICAgICAgIGFwdDogZXh0ZW5kZWRDb2RlYy5sb2NhbFBheWxvYWRUeXBlXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBydGNwRmVlZGJhY2s6IFtdXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgcnRwUGFyYW1ldGVycy5jb2RlY3MucHVzaChydHhDb2RlYyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZm9yIChjb25zdCBleHRlbmRlZEV4dGVuc2lvbiBvZiBleHRlbmRlZFJ0cENhcGFiaWxpdGllcy5oZWFkZXJFeHRlbnNpb25zKSB7XG4gICAgICAgIC8vIElnbm9yZSBSVFAgZXh0ZW5zaW9ucyBvZiBhIGRpZmZlcmVudCBraW5kIGFuZCB0aG9zZSBub3QgdmFsaWQgZm9yIHNlbmRpbmcuXG4gICAgICAgIGlmICgoZXh0ZW5kZWRFeHRlbnNpb24ua2luZCAmJiBleHRlbmRlZEV4dGVuc2lvbi5raW5kICE9PSBraW5kKSB8fFxuICAgICAgICAgICAgKGV4dGVuZGVkRXh0ZW5zaW9uLmRpcmVjdGlvbiAhPT0gJ3NlbmRyZWN2JyAmJlxuICAgICAgICAgICAgICAgIGV4dGVuZGVkRXh0ZW5zaW9uLmRpcmVjdGlvbiAhPT0gJ3NlbmRvbmx5JykpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGV4dCA9IHtcbiAgICAgICAgICAgIHVyaTogZXh0ZW5kZWRFeHRlbnNpb24udXJpLFxuICAgICAgICAgICAgaWQ6IGV4dGVuZGVkRXh0ZW5zaW9uLnNlbmRJZCxcbiAgICAgICAgICAgIGVuY3J5cHQ6IGV4dGVuZGVkRXh0ZW5zaW9uLmVuY3J5cHQsXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiB7fVxuICAgICAgICB9O1xuICAgICAgICBydHBQYXJhbWV0ZXJzLmhlYWRlckV4dGVuc2lvbnMucHVzaChleHQpO1xuICAgIH1cbiAgICAvLyBSZWR1Y2UgY29kZWNzJyBSVENQIGZlZWRiYWNrLiBVc2UgVHJhbnNwb3J0LUNDIGlmIGF2YWlsYWJsZSwgUkVNQiBvdGhlcndpc2UuXG4gICAgaWYgKHJ0cFBhcmFtZXRlcnMuaGVhZGVyRXh0ZW5zaW9ucy5zb21lKChleHQpID0+IChleHQudXJpID09PSAnaHR0cDovL3d3dy5pZXRmLm9yZy9pZC9kcmFmdC1ob2xtZXItcm1jYXQtdHJhbnNwb3J0LXdpZGUtY2MtZXh0ZW5zaW9ucy0wMScpKSkge1xuICAgICAgICBmb3IgKGNvbnN0IGNvZGVjIG9mIHJ0cFBhcmFtZXRlcnMuY29kZWNzKSB7XG4gICAgICAgICAgICBjb2RlYy5ydGNwRmVlZGJhY2sgPSAoY29kZWMucnRjcEZlZWRiYWNrIHx8IFtdKVxuICAgICAgICAgICAgICAgIC5maWx0ZXIoKGZiKSA9PiBmYi50eXBlICE9PSAnZ29vZy1yZW1iJyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSBpZiAocnRwUGFyYW1ldGVycy5oZWFkZXJFeHRlbnNpb25zLnNvbWUoKGV4dCkgPT4gKGV4dC51cmkgPT09ICdodHRwOi8vd3d3LndlYnJ0Yy5vcmcvZXhwZXJpbWVudHMvcnRwLWhkcmV4dC9hYnMtc2VuZC10aW1lJykpKSB7XG4gICAgICAgIGZvciAoY29uc3QgY29kZWMgb2YgcnRwUGFyYW1ldGVycy5jb2RlY3MpIHtcbiAgICAgICAgICAgIGNvZGVjLnJ0Y3BGZWVkYmFjayA9IChjb2RlYy5ydGNwRmVlZGJhY2sgfHwgW10pXG4gICAgICAgICAgICAgICAgLmZpbHRlcigoZmIpID0+IGZiLnR5cGUgIT09ICd0cmFuc3BvcnQtY2MnKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgZm9yIChjb25zdCBjb2RlYyBvZiBydHBQYXJhbWV0ZXJzLmNvZGVjcykge1xuICAgICAgICAgICAgY29kZWMucnRjcEZlZWRiYWNrID0gKGNvZGVjLnJ0Y3BGZWVkYmFjayB8fCBbXSlcbiAgICAgICAgICAgICAgICAuZmlsdGVyKChmYikgPT4gKGZiLnR5cGUgIT09ICd0cmFuc3BvcnQtY2MnICYmXG4gICAgICAgICAgICAgICAgZmIudHlwZSAhPT0gJ2dvb2ctcmVtYicpKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gcnRwUGFyYW1ldGVycztcbn1cbmV4cG9ydHMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMgPSBnZXRTZW5kaW5nUmVtb3RlUnRwUGFyYW1ldGVycztcbi8qKlxuICogUmVkdWNlIGdpdmVuIGNvZGVjcyBieSByZXR1cm5pbmcgYW4gYXJyYXkgb2YgY29kZWNzIFwiY29tcGF0aWJsZVwiIHdpdGggdGhlXG4gKiBnaXZlbiBjYXBhYmlsaXR5IGNvZGVjLiBJZiBubyBjYXBhYmlsaXR5IGNvZGVjIGlzIGdpdmVuLCB0YWtlIHRoZSBmaXJzdFxuICogb25lKHMpLlxuICpcbiAqIEdpdmVuIGNvZGVjcyBtdXN0IGJlIGdlbmVyYXRlZCBieSBvcnRjLmdldFNlbmRpbmdSdHBQYXJhbWV0ZXJzKCkgb3JcbiAqIG9ydGMuZ2V0U2VuZGluZ1JlbW90ZVJ0cFBhcmFtZXRlcnMoKS5cbiAqXG4gKiBUaGUgcmV0dXJuZWQgYXJyYXkgb2YgY29kZWNzIGFsc28gaW5jbHVkZSBhIFJUWCBjb2RlYyBpZiBhdmFpbGFibGUuXG4gKi9cbmZ1bmN0aW9uIHJlZHVjZUNvZGVjcyhjb2RlY3MsIGNhcENvZGVjKSB7XG4gICAgY29uc3QgZmlsdGVyZWRDb2RlY3MgPSBbXTtcbiAgICAvLyBJZiBubyBjYXBhYmlsaXR5IGNvZGVjIGlzIGdpdmVuLCB0YWtlIHRoZSBmaXJzdCBvbmUgKGFuZCBSVFgpLlxuICAgIGlmICghY2FwQ29kZWMpIHtcbiAgICAgICAgZmlsdGVyZWRDb2RlY3MucHVzaChjb2RlY3NbMF0pO1xuICAgICAgICBpZiAoaXNSdHhDb2RlYyhjb2RlY3NbMV0pKVxuICAgICAgICAgICAgZmlsdGVyZWRDb2RlY3MucHVzaChjb2RlY3NbMV0pO1xuICAgIH1cbiAgICAvLyBPdGhlcndpc2UgbG9vayBmb3IgYSBjb21wYXRpYmxlIHNldCBvZiBjb2RlY3MuXG4gICAgZWxzZSB7XG4gICAgICAgIGZvciAobGV0IGlkeCA9IDA7IGlkeCA8IGNvZGVjcy5sZW5ndGg7ICsraWR4KSB7XG4gICAgICAgICAgICBpZiAobWF0Y2hDb2RlY3MoY29kZWNzW2lkeF0sIGNhcENvZGVjKSkge1xuICAgICAgICAgICAgICAgIGZpbHRlcmVkQ29kZWNzLnB1c2goY29kZWNzW2lkeF0pO1xuICAgICAgICAgICAgICAgIGlmIChpc1J0eENvZGVjKGNvZGVjc1tpZHggKyAxXSkpXG4gICAgICAgICAgICAgICAgICAgIGZpbHRlcmVkQ29kZWNzLnB1c2goY29kZWNzW2lkeCArIDFdKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZmlsdGVyZWRDb2RlY3MubGVuZ3RoID09PSAwKVxuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignbm8gbWF0Y2hpbmcgY29kZWMgZm91bmQnKTtcbiAgICB9XG4gICAgcmV0dXJuIGZpbHRlcmVkQ29kZWNzO1xufVxuZXhwb3J0cy5yZWR1Y2VDb2RlY3MgPSByZWR1Y2VDb2RlY3M7XG4vKipcbiAqIENyZWF0ZSBSVFAgcGFyYW1ldGVycyBmb3IgYSBDb25zdW1lciBmb3IgdGhlIFJUUCBwcm9iYXRvci5cbiAqL1xuZnVuY3Rpb24gZ2VuZXJhdGVQcm9iYXRvclJ0cFBhcmFtZXRlcnModmlkZW9SdHBQYXJhbWV0ZXJzKSB7XG4gICAgLy8gQ2xvbmUgZ2l2ZW4gcmVmZXJlbmNlIHZpZGVvIFJUUCBwYXJhbWV0ZXJzLlxuICAgIHZpZGVvUnRwUGFyYW1ldGVycyA9IHV0aWxzLmNsb25lKHZpZGVvUnRwUGFyYW1ldGVycywge30pO1xuICAgIC8vIFRoaXMgbWF5IHRocm93LlxuICAgIHZhbGlkYXRlUnRwUGFyYW1ldGVycyh2aWRlb1J0cFBhcmFtZXRlcnMpO1xuICAgIGNvbnN0IHJ0cFBhcmFtZXRlcnMgPSB7XG4gICAgICAgIG1pZDogUlRQX1BST0JBVE9SX01JRCxcbiAgICAgICAgY29kZWNzOiBbXSxcbiAgICAgICAgaGVhZGVyRXh0ZW5zaW9uczogW10sXG4gICAgICAgIGVuY29kaW5nczogW3sgc3NyYzogUlRQX1BST0JBVE9SX1NTUkMgfV0sXG4gICAgICAgIHJ0Y3A6IHsgY25hbWU6ICdwcm9iYXRvcicgfVxuICAgIH07XG4gICAgcnRwUGFyYW1ldGVycy5jb2RlY3MucHVzaCh2aWRlb1J0cFBhcmFtZXRlcnMuY29kZWNzWzBdKTtcbiAgICBydHBQYXJhbWV0ZXJzLmNvZGVjc1swXS5wYXlsb2FkVHlwZSA9IFJUUF9QUk9CQVRPUl9DT0RFQ19QQVlMT0FEX1RZUEU7XG4gICAgcnRwUGFyYW1ldGVycy5oZWFkZXJFeHRlbnNpb25zID0gdmlkZW9SdHBQYXJhbWV0ZXJzLmhlYWRlckV4dGVuc2lvbnM7XG4gICAgcmV0dXJuIHJ0cFBhcmFtZXRlcnM7XG59XG5leHBvcnRzLmdlbmVyYXRlUHJvYmF0b3JSdHBQYXJhbWV0ZXJzID0gZ2VuZXJhdGVQcm9iYXRvclJ0cFBhcmFtZXRlcnM7XG4vKipcbiAqIFdoZXRoZXIgbWVkaWEgY2FuIGJlIHNlbnQgYmFzZWQgb24gdGhlIGdpdmVuIFJUUCBjYXBhYmlsaXRpZXMuXG4gKi9cbmZ1bmN0aW9uIGNhblNlbmQoa2luZCwgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpIHtcbiAgICByZXR1cm4gZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMuY29kZWNzLlxuICAgICAgICBzb21lKChjb2RlYykgPT4gY29kZWMua2luZCA9PT0ga2luZCk7XG59XG5leHBvcnRzLmNhblNlbmQgPSBjYW5TZW5kO1xuLyoqXG4gKiBXaGV0aGVyIHRoZSBnaXZlbiBSVFAgcGFyYW1ldGVycyBjYW4gYmUgcmVjZWl2ZWQgd2l0aCB0aGUgZ2l2ZW4gUlRQXG4gKiBjYXBhYmlsaXRpZXMuXG4gKi9cbmZ1bmN0aW9uIGNhblJlY2VpdmUocnRwUGFyYW1ldGVycywgZXh0ZW5kZWRSdHBDYXBhYmlsaXRpZXMpIHtcbiAgICAvLyBUaGlzIG1heSB0aHJvdy5cbiAgICB2YWxpZGF0ZVJ0cFBhcmFtZXRlcnMocnRwUGFyYW1ldGVycyk7XG4gICAgaWYgKHJ0cFBhcmFtZXRlcnMuY29kZWNzLmxlbmd0aCA9PT0gMClcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGNvbnN0IGZpcnN0TWVkaWFDb2RlYyA9IHJ0cFBhcmFtZXRlcnMuY29kZWNzWzBdO1xuICAgIHJldHVybiBleHRlbmRlZFJ0cENhcGFiaWxpdGllcy5jb2RlY3NcbiAgICAgICAgLnNvbWUoKGNvZGVjKSA9PiBjb2RlYy5yZW1vdGVQYXlsb2FkVHlwZSA9PT0gZmlyc3RNZWRpYUNvZGVjLnBheWxvYWRUeXBlKTtcbn1cbmV4cG9ydHMuY2FuUmVjZWl2ZSA9IGNhblJlY2VpdmU7XG5mdW5jdGlvbiBpc1J0eENvZGVjKGNvZGVjKSB7XG4gICAgaWYgKCFjb2RlYylcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiAvLitcXC9ydHgkL2kudGVzdChjb2RlYy5taW1lVHlwZSk7XG59XG5mdW5jdGlvbiBtYXRjaENvZGVjcyhhQ29kZWMsIGJDb2RlYywgeyBzdHJpY3QgPSBmYWxzZSwgbW9kaWZ5ID0gZmFsc2UgfSA9IHt9KSB7XG4gICAgY29uc3QgYU1pbWVUeXBlID0gYUNvZGVjLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgY29uc3QgYk1pbWVUeXBlID0gYkNvZGVjLm1pbWVUeXBlLnRvTG93ZXJDYXNlKCk7XG4gICAgaWYgKGFNaW1lVHlwZSAhPT0gYk1pbWVUeXBlKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGFDb2RlYy5jbG9ja1JhdGUgIT09IGJDb2RlYy5jbG9ja1JhdGUpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoYUNvZGVjLmNoYW5uZWxzICE9PSBiQ29kZWMuY2hhbm5lbHMpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAvLyBQZXIgY29kZWMgc3BlY2lhbCBjaGVja3MuXG4gICAgc3dpdGNoIChhTWltZVR5cGUpIHtcbiAgICAgICAgY2FzZSAndmlkZW8vaDI2NCc6XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgY29uc3QgYVBhY2tldGl6YXRpb25Nb2RlID0gYUNvZGVjLnBhcmFtZXRlcnNbJ3BhY2tldGl6YXRpb24tbW9kZSddIHx8IDA7XG4gICAgICAgICAgICAgICAgY29uc3QgYlBhY2tldGl6YXRpb25Nb2RlID0gYkNvZGVjLnBhcmFtZXRlcnNbJ3BhY2tldGl6YXRpb24tbW9kZSddIHx8IDA7XG4gICAgICAgICAgICAgICAgaWYgKGFQYWNrZXRpemF0aW9uTW9kZSAhPT0gYlBhY2tldGl6YXRpb25Nb2RlKVxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgICAgICAgICAgLy8gSWYgc3RyaWN0IG1hdGNoaW5nIGNoZWNrIHByb2ZpbGUtbGV2ZWwtaWQuXG4gICAgICAgICAgICAgICAgaWYgKHN0cmljdCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWgyNjQuaXNTYW1lUHJvZmlsZShhQ29kZWMucGFyYW1ldGVycywgYkNvZGVjLnBhcmFtZXRlcnMpKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICBsZXQgc2VsZWN0ZWRQcm9maWxlTGV2ZWxJZDtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHNlbGVjdGVkUHJvZmlsZUxldmVsSWQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGgyNjQuZ2VuZXJhdGVQcm9maWxlTGV2ZWxJZEZvckFuc3dlcihhQ29kZWMucGFyYW1ldGVycywgYkNvZGVjLnBhcmFtZXRlcnMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChtb2RpZnkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChzZWxlY3RlZFByb2ZpbGVMZXZlbElkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYUNvZGVjLnBhcmFtZXRlcnNbJ3Byb2ZpbGUtbGV2ZWwtaWQnXSA9IHNlbGVjdGVkUHJvZmlsZUxldmVsSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYkNvZGVjLnBhcmFtZXRlcnNbJ3Byb2ZpbGUtbGV2ZWwtaWQnXSA9IHNlbGVjdGVkUHJvZmlsZUxldmVsSWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYUNvZGVjLnBhcmFtZXRlcnNbJ3Byb2ZpbGUtbGV2ZWwtaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgYkNvZGVjLnBhcmFtZXRlcnNbJ3Byb2ZpbGUtbGV2ZWwtaWQnXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgY2FzZSAndmlkZW8vdnA5JzpcbiAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAvLyBJZiBzdHJpY3QgbWF0Y2hpbmcgY2hlY2sgcHJvZmlsZS1pZC5cbiAgICAgICAgICAgICAgICBpZiAoc3RyaWN0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFQcm9maWxlSWQgPSBhQ29kZWMucGFyYW1ldGVyc1sncHJvZmlsZS1pZCddIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGJQcm9maWxlSWQgPSBiQ29kZWMucGFyYW1ldGVyc1sncHJvZmlsZS1pZCddIHx8IDA7XG4gICAgICAgICAgICAgICAgICAgIGlmIChhUHJvZmlsZUlkICE9PSBiUHJvZmlsZUlkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5mdW5jdGlvbiBtYXRjaEhlYWRlckV4dGVuc2lvbnMoYUV4dCwgYkV4dCkge1xuICAgIGlmIChhRXh0LmtpbmQgJiYgYkV4dC5raW5kICYmIGFFeHQua2luZCAhPT0gYkV4dC5raW5kKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKGFFeHQudXJpICE9PSBiRXh0LnVyaSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gcmVkdWNlUnRjcEZlZWRiYWNrKGNvZGVjQSwgY29kZWNCKSB7XG4gICAgY29uc3QgcmVkdWNlZFJ0Y3BGZWVkYmFjayA9IFtdO1xuICAgIGZvciAoY29uc3QgYUZiIG9mIGNvZGVjQS5ydGNwRmVlZGJhY2sgfHwgW10pIHtcbiAgICAgICAgY29uc3QgbWF0Y2hpbmdCRmIgPSAoY29kZWNCLnJ0Y3BGZWVkYmFjayB8fCBbXSlcbiAgICAgICAgICAgIC5maW5kKChiRmIpID0+IChiRmIudHlwZSA9PT0gYUZiLnR5cGUgJiZcbiAgICAgICAgICAgIChiRmIucGFyYW1ldGVyID09PSBhRmIucGFyYW1ldGVyIHx8ICghYkZiLnBhcmFtZXRlciAmJiAhYUZiLnBhcmFtZXRlcikpKSk7XG4gICAgICAgIGlmIChtYXRjaGluZ0JGYilcbiAgICAgICAgICAgIHJlZHVjZWRSdGNwRmVlZGJhY2sucHVzaChtYXRjaGluZ0JGYik7XG4gICAgfVxuICAgIHJldHVybiByZWR1Y2VkUnRjcEZlZWRiYWNrO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLnBhcnNlID0gdm9pZCAwO1xuY29uc3QgU2NhbGFiaWxpdHlNb2RlUmVnZXggPSBuZXcgUmVnRXhwKCdeW0xTXShbMS05XVxcXFxkezAsMX0pVChbMS05XVxcXFxkezAsMX0pJyk7XG5mdW5jdGlvbiBwYXJzZShzY2FsYWJpbGl0eU1vZGUpIHtcbiAgICBjb25zdCBtYXRjaCA9IFNjYWxhYmlsaXR5TW9kZVJlZ2V4LmV4ZWMoc2NhbGFiaWxpdHlNb2RlIHx8ICcnKTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYXRpYWxMYXllcnM6IE51bWJlcihtYXRjaFsxXSksXG4gICAgICAgICAgICB0ZW1wb3JhbExheWVyczogTnVtYmVyKG1hdGNoWzJdKVxuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHNwYXRpYWxMYXllcnM6IDEsXG4gICAgICAgICAgICB0ZW1wb3JhbExheWVyczogMVxuICAgICAgICB9O1xuICAgIH1cbn1cbmV4cG9ydHMucGFyc2UgPSBwYXJzZTtcbiIsIlwidXNlIHN0cmljdFwiO1xudmFyIF9fY3JlYXRlQmluZGluZyA9ICh0aGlzICYmIHRoaXMuX19jcmVhdGVCaW5kaW5nKSB8fCAoT2JqZWN0LmNyZWF0ZSA/IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xuICAgIGlmIChrMiA9PT0gdW5kZWZpbmVkKSBrMiA9IGs7XG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xufSkgOiAoZnVuY3Rpb24obywgbSwgaywgazIpIHtcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xuICAgIG9bazJdID0gbVtrXTtcbn0pKTtcbnZhciBfX2V4cG9ydFN0YXIgPSAodGhpcyAmJiB0aGlzLl9fZXhwb3J0U3RhcikgfHwgZnVuY3Rpb24obSwgZXhwb3J0cykge1xuICAgIGZvciAodmFyIHAgaW4gbSkgaWYgKHAgIT09IFwiZGVmYXVsdFwiICYmICFleHBvcnRzLmhhc093blByb3BlcnR5KHApKSBfX2NyZWF0ZUJpbmRpbmcoZXhwb3J0cywgbSwgcCk7XG59O1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0RldmljZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vVHJhbnNwb3J0XCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9Qcm9kdWNlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vQ29uc3VtZXJcIiksIGV4cG9ydHMpO1xuX19leHBvcnRTdGFyKHJlcXVpcmUoXCIuL0RhdGFQcm9kdWNlclwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vRGF0YUNvbnN1bWVyXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9SdHBQYXJhbWV0ZXJzXCIpLCBleHBvcnRzKTtcbl9fZXhwb3J0U3RhcihyZXF1aXJlKFwiLi9TY3RwUGFyYW1ldGVyc1wiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vaGFuZGxlcnMvSGFuZGxlckludGVyZmFjZVwiKSwgZXhwb3J0cyk7XG5fX2V4cG9ydFN0YXIocmVxdWlyZShcIi4vZXJyb3JzXCIpLCBleHBvcnRzKTtcbiIsIlwidXNlIHN0cmljdFwiO1xuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5nZW5lcmF0ZVJhbmRvbU51bWJlciA9IGV4cG9ydHMuY2xvbmUgPSB2b2lkIDA7XG4vKipcbiAqIENsb25lcyB0aGUgZ2l2ZW4gZGF0YS5cbiAqL1xuZnVuY3Rpb24gY2xvbmUoZGF0YSwgZGVmYXVsdFZhbHVlKSB7XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAndW5kZWZpbmVkJylcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICByZXR1cm4gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShkYXRhKSk7XG59XG5leHBvcnRzLmNsb25lID0gY2xvbmU7XG4vKipcbiAqIEdlbmVyYXRlcyBhIHJhbmRvbSBwb3NpdGl2ZSBpbnRlZ2VyLlxuICovXG5mdW5jdGlvbiBnZW5lcmF0ZVJhbmRvbU51bWJlcigpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTAwMDAwMDApO1xufVxuZXhwb3J0cy5nZW5lcmF0ZVJhbmRvbU51bWJlciA9IGdlbmVyYXRlUmFuZG9tTnVtYmVyO1xuIiwiLyoqXG4gKiBIZWxwZXJzLlxuICovXG5cbnZhciBzID0gMTAwMDtcbnZhciBtID0gcyAqIDYwO1xudmFyIGggPSBtICogNjA7XG52YXIgZCA9IGggKiAyNDtcbnZhciB3ID0gZCAqIDc7XG52YXIgeSA9IGQgKiAzNjUuMjU7XG5cbi8qKlxuICogUGFyc2Ugb3IgZm9ybWF0IHRoZSBnaXZlbiBgdmFsYC5cbiAqXG4gKiBPcHRpb25zOlxuICpcbiAqICAtIGBsb25nYCB2ZXJib3NlIGZvcm1hdHRpbmcgW2ZhbHNlXVxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfE51bWJlcn0gdmFsXG4gKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnNdXG4gKiBAdGhyb3dzIHtFcnJvcn0gdGhyb3cgYW4gZXJyb3IgaWYgdmFsIGlzIG5vdCBhIG5vbi1lbXB0eSBzdHJpbmcgb3IgYSBudW1iZXJcbiAqIEByZXR1cm4ge1N0cmluZ3xOdW1iZXJ9XG4gKiBAYXBpIHB1YmxpY1xuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odmFsLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICB2YXIgdHlwZSA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlID09PSAnc3RyaW5nJyAmJiB2YWwubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBwYXJzZSh2YWwpO1xuICB9IGVsc2UgaWYgKHR5cGUgPT09ICdudW1iZXInICYmIGlzRmluaXRlKHZhbCkpIHtcbiAgICByZXR1cm4gb3B0aW9ucy5sb25nID8gZm10TG9uZyh2YWwpIDogZm10U2hvcnQodmFsKTtcbiAgfVxuICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgJ3ZhbCBpcyBub3QgYSBub24tZW1wdHkgc3RyaW5nIG9yIGEgdmFsaWQgbnVtYmVyLiB2YWw9JyArXG4gICAgICBKU09OLnN0cmluZ2lmeSh2YWwpXG4gICk7XG59O1xuXG4vKipcbiAqIFBhcnNlIHRoZSBnaXZlbiBgc3RyYCBhbmQgcmV0dXJuIG1pbGxpc2Vjb25kcy5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyXG4gKiBAcmV0dXJuIHtOdW1iZXJ9XG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuXG5mdW5jdGlvbiBwYXJzZShzdHIpIHtcbiAgc3RyID0gU3RyaW5nKHN0cik7XG4gIGlmIChzdHIubGVuZ3RoID4gMTAwKSB7XG4gICAgcmV0dXJuO1xuICB9XG4gIHZhciBtYXRjaCA9IC9eKC0/KD86XFxkKyk/XFwuP1xcZCspICoobWlsbGlzZWNvbmRzP3xtc2Vjcz98bXN8c2Vjb25kcz98c2Vjcz98c3xtaW51dGVzP3xtaW5zP3xtfGhvdXJzP3xocnM/fGh8ZGF5cz98ZHx3ZWVrcz98d3x5ZWFycz98eXJzP3x5KT8kL2kuZXhlYyhcbiAgICBzdHJcbiAgKTtcbiAgaWYgKCFtYXRjaCkge1xuICAgIHJldHVybjtcbiAgfVxuICB2YXIgbiA9IHBhcnNlRmxvYXQobWF0Y2hbMV0pO1xuICB2YXIgdHlwZSA9IChtYXRjaFsyXSB8fCAnbXMnKS50b0xvd2VyQ2FzZSgpO1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlICd5ZWFycyc6XG4gICAgY2FzZSAneWVhcic6XG4gICAgY2FzZSAneXJzJzpcbiAgICBjYXNlICd5cic6XG4gICAgY2FzZSAneSc6XG4gICAgICByZXR1cm4gbiAqIHk7XG4gICAgY2FzZSAnd2Vla3MnOlxuICAgIGNhc2UgJ3dlZWsnOlxuICAgIGNhc2UgJ3cnOlxuICAgICAgcmV0dXJuIG4gKiB3O1xuICAgIGNhc2UgJ2RheXMnOlxuICAgIGNhc2UgJ2RheSc6XG4gICAgY2FzZSAnZCc6XG4gICAgICByZXR1cm4gbiAqIGQ7XG4gICAgY2FzZSAnaG91cnMnOlxuICAgIGNhc2UgJ2hvdXInOlxuICAgIGNhc2UgJ2hycyc6XG4gICAgY2FzZSAnaHInOlxuICAgIGNhc2UgJ2gnOlxuICAgICAgcmV0dXJuIG4gKiBoO1xuICAgIGNhc2UgJ21pbnV0ZXMnOlxuICAgIGNhc2UgJ21pbnV0ZSc6XG4gICAgY2FzZSAnbWlucyc6XG4gICAgY2FzZSAnbWluJzpcbiAgICBjYXNlICdtJzpcbiAgICAgIHJldHVybiBuICogbTtcbiAgICBjYXNlICdzZWNvbmRzJzpcbiAgICBjYXNlICdzZWNvbmQnOlxuICAgIGNhc2UgJ3NlY3MnOlxuICAgIGNhc2UgJ3NlYyc6XG4gICAgY2FzZSAncyc6XG4gICAgICByZXR1cm4gbiAqIHM7XG4gICAgY2FzZSAnbWlsbGlzZWNvbmRzJzpcbiAgICBjYXNlICdtaWxsaXNlY29uZCc6XG4gICAgY2FzZSAnbXNlY3MnOlxuICAgIGNhc2UgJ21zZWMnOlxuICAgIGNhc2UgJ21zJzpcbiAgICAgIHJldHVybiBuO1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG59XG5cbi8qKlxuICogU2hvcnQgZm9ybWF0IGZvciBgbXNgLlxuICpcbiAqIEBwYXJhbSB7TnVtYmVyfSBtc1xuICogQHJldHVybiB7U3RyaW5nfVxuICogQGFwaSBwcml2YXRlXG4gKi9cblxuZnVuY3Rpb24gZm10U2hvcnQobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gZCkgKyAnZCc7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChtcyAvIGgpICsgJ2gnO1xuICB9XG4gIGlmIChtc0FicyA+PSBtKSB7XG4gICAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBtKSArICdtJztcbiAgfVxuICBpZiAobXNBYnMgPj0gcykge1xuICAgIHJldHVybiBNYXRoLnJvdW5kKG1zIC8gcykgKyAncyc7XG4gIH1cbiAgcmV0dXJuIG1zICsgJ21zJztcbn1cblxuLyoqXG4gKiBMb25nIGZvcm1hdCBmb3IgYG1zYC5cbiAqXG4gKiBAcGFyYW0ge051bWJlcn0gbXNcbiAqIEByZXR1cm4ge1N0cmluZ31cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5cbmZ1bmN0aW9uIGZtdExvbmcobXMpIHtcbiAgdmFyIG1zQWJzID0gTWF0aC5hYnMobXMpO1xuICBpZiAobXNBYnMgPj0gZCkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBkLCAnZGF5Jyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IGgpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgaCwgJ2hvdXInKTtcbiAgfVxuICBpZiAobXNBYnMgPj0gbSkge1xuICAgIHJldHVybiBwbHVyYWwobXMsIG1zQWJzLCBtLCAnbWludXRlJyk7XG4gIH1cbiAgaWYgKG1zQWJzID49IHMpIHtcbiAgICByZXR1cm4gcGx1cmFsKG1zLCBtc0FicywgcywgJ3NlY29uZCcpO1xuICB9XG4gIHJldHVybiBtcyArICcgbXMnO1xufVxuXG4vKipcbiAqIFBsdXJhbGl6YXRpb24gaGVscGVyLlxuICovXG5cbmZ1bmN0aW9uIHBsdXJhbChtcywgbXNBYnMsIG4sIG5hbWUpIHtcbiAgdmFyIGlzUGx1cmFsID0gbXNBYnMgPj0gbiAqIDEuNTtcbiAgcmV0dXJuIE1hdGgucm91bmQobXMgLyBuKSArICcgJyArIG5hbWUgKyAoaXNQbHVyYWwgPyAncycgOiAnJyk7XG59XG4iLCIvLyBzaGltIGZvciB1c2luZyBwcm9jZXNzIGluIGJyb3dzZXJcbnZhciBwcm9jZXNzID0gbW9kdWxlLmV4cG9ydHMgPSB7fTtcblxuLy8gY2FjaGVkIGZyb20gd2hhdGV2ZXIgZ2xvYmFsIGlzIHByZXNlbnQgc28gdGhhdCB0ZXN0IHJ1bm5lcnMgdGhhdCBzdHViIGl0XG4vLyBkb24ndCBicmVhayB0aGluZ3MuICBCdXQgd2UgbmVlZCB0byB3cmFwIGl0IGluIGEgdHJ5IGNhdGNoIGluIGNhc2UgaXQgaXNcbi8vIHdyYXBwZWQgaW4gc3RyaWN0IG1vZGUgY29kZSB3aGljaCBkb2Vzbid0IGRlZmluZSBhbnkgZ2xvYmFscy4gIEl0J3MgaW5zaWRlIGFcbi8vIGZ1bmN0aW9uIGJlY2F1c2UgdHJ5L2NhdGNoZXMgZGVvcHRpbWl6ZSBpbiBjZXJ0YWluIGVuZ2luZXMuXG5cbnZhciBjYWNoZWRTZXRUaW1lb3V0O1xudmFyIGNhY2hlZENsZWFyVGltZW91dDtcblxuZnVuY3Rpb24gZGVmYXVsdFNldFRpbW91dCgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ3NldFRpbWVvdXQgaGFzIG5vdCBiZWVuIGRlZmluZWQnKTtcbn1cbmZ1bmN0aW9uIGRlZmF1bHRDbGVhclRpbWVvdXQgKCkge1xuICAgIHRocm93IG5ldyBFcnJvcignY2xlYXJUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG4oZnVuY3Rpb24gKCkge1xuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc2V0VGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gZGVmYXVsdFNldFRpbW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIGlmICh0eXBlb2YgY2xlYXJUaW1lb3V0ID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgICAgICB9XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBkZWZhdWx0Q2xlYXJUaW1lb3V0O1xuICAgIH1cbn0gKCkpXG5mdW5jdGlvbiBydW5UaW1lb3V0KGZ1bikge1xuICAgIGlmIChjYWNoZWRTZXRUaW1lb3V0ID09PSBzZXRUaW1lb3V0KSB7XG4gICAgICAgIC8vbm9ybWFsIGVudmlyb21lbnRzIGluIHNhbmUgc2l0dWF0aW9uc1xuICAgICAgICByZXR1cm4gc2V0VGltZW91dChmdW4sIDApO1xuICAgIH1cbiAgICAvLyBpZiBzZXRUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkU2V0VGltZW91dCA9PT0gZGVmYXVsdFNldFRpbW91dCB8fCAhY2FjaGVkU2V0VGltZW91dCkgJiYgc2V0VGltZW91dCkge1xuICAgICAgICBjYWNoZWRTZXRUaW1lb3V0ID0gc2V0VGltZW91dDtcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dChmdW4sIDApO1xuICAgIH0gY2F0Y2goZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRTZXRUaW1lb3V0LmNhbGwobnVsbCwgZnVuLCAwKTtcbiAgICAgICAgfSBjYXRjaChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yXG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKHRoaXMsIGZ1biwgMCk7XG4gICAgICAgIH1cbiAgICB9XG5cblxufVxuZnVuY3Rpb24gcnVuQ2xlYXJUaW1lb3V0KG1hcmtlcikge1xuICAgIGlmIChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGNsZWFyVGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICAvLyBpZiBjbGVhclRpbWVvdXQgd2Fzbid0IGF2YWlsYWJsZSBidXQgd2FzIGxhdHRlciBkZWZpbmVkXG4gICAgaWYgKChjYWNoZWRDbGVhclRpbWVvdXQgPT09IGRlZmF1bHRDbGVhclRpbWVvdXQgfHwgIWNhY2hlZENsZWFyVGltZW91dCkgJiYgY2xlYXJUaW1lb3V0KSB7XG4gICAgICAgIGNhY2hlZENsZWFyVGltZW91dCA9IGNsZWFyVGltZW91dDtcbiAgICAgICAgcmV0dXJuIGNsZWFyVGltZW91dChtYXJrZXIpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICAvLyB3aGVuIHdoZW4gc29tZWJvZHkgaGFzIHNjcmV3ZWQgd2l0aCBzZXRUaW1lb3V0IGJ1dCBubyBJLkUuIG1hZGRuZXNzXG4gICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIC8vIFdoZW4gd2UgYXJlIGluIEkuRS4gYnV0IHRoZSBzY3JpcHQgaGFzIGJlZW4gZXZhbGVkIHNvIEkuRS4gZG9lc24ndCAgdHJ1c3QgdGhlIGdsb2JhbCBvYmplY3Qgd2hlbiBjYWxsZWQgbm9ybWFsbHlcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbChudWxsLCBtYXJrZXIpO1xuICAgICAgICB9IGNhdGNoIChlKXtcbiAgICAgICAgICAgIC8vIHNhbWUgYXMgYWJvdmUgYnV0IHdoZW4gaXQncyBhIHZlcnNpb24gb2YgSS5FLiB0aGF0IG11c3QgaGF2ZSB0aGUgZ2xvYmFsIG9iamVjdCBmb3IgJ3RoaXMnLCBob3BmdWxseSBvdXIgY29udGV4dCBjb3JyZWN0IG90aGVyd2lzZSBpdCB3aWxsIHRocm93IGEgZ2xvYmFsIGVycm9yLlxuICAgICAgICAgICAgLy8gU29tZSB2ZXJzaW9ucyBvZiBJLkUuIGhhdmUgZGlmZmVyZW50IHJ1bGVzIGZvciBjbGVhclRpbWVvdXQgdnMgc2V0VGltZW91dFxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZENsZWFyVGltZW91dC5jYWxsKHRoaXMsIG1hcmtlcik7XG4gICAgICAgIH1cbiAgICB9XG5cblxuXG59XG52YXIgcXVldWUgPSBbXTtcbnZhciBkcmFpbmluZyA9IGZhbHNlO1xudmFyIGN1cnJlbnRRdWV1ZTtcbnZhciBxdWV1ZUluZGV4ID0gLTE7XG5cbmZ1bmN0aW9uIGNsZWFuVXBOZXh0VGljaygpIHtcbiAgICBpZiAoIWRyYWluaW5nIHx8ICFjdXJyZW50UXVldWUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBkcmFpbmluZyA9IGZhbHNlO1xuICAgIGlmIChjdXJyZW50UXVldWUubGVuZ3RoKSB7XG4gICAgICAgIHF1ZXVlID0gY3VycmVudFF1ZXVlLmNvbmNhdChxdWV1ZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgIH1cbiAgICBpZiAocXVldWUubGVuZ3RoKSB7XG4gICAgICAgIGRyYWluUXVldWUoKTtcbiAgICB9XG59XG5cbmZ1bmN0aW9uIGRyYWluUXVldWUoKSB7XG4gICAgaWYgKGRyYWluaW5nKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdmFyIHRpbWVvdXQgPSBydW5UaW1lb3V0KGNsZWFuVXBOZXh0VGljayk7XG4gICAgZHJhaW5pbmcgPSB0cnVlO1xuXG4gICAgdmFyIGxlbiA9IHF1ZXVlLmxlbmd0aDtcbiAgICB3aGlsZShsZW4pIHtcbiAgICAgICAgY3VycmVudFF1ZXVlID0gcXVldWU7XG4gICAgICAgIHF1ZXVlID0gW107XG4gICAgICAgIHdoaWxlICgrK3F1ZXVlSW5kZXggPCBsZW4pIHtcbiAgICAgICAgICAgIGlmIChjdXJyZW50UXVldWUpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50UXVldWVbcXVldWVJbmRleF0ucnVuKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcXVldWVJbmRleCA9IC0xO1xuICAgICAgICBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgfVxuICAgIGN1cnJlbnRRdWV1ZSA9IG51bGw7XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBydW5DbGVhclRpbWVvdXQodGltZW91dCk7XG59XG5cbnByb2Nlc3MubmV4dFRpY2sgPSBmdW5jdGlvbiAoZnVuKSB7XG4gICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMSkge1xuICAgICAgICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgYXJnc1tpIC0gMV0gPSBhcmd1bWVudHNbaV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcXVldWUucHVzaChuZXcgSXRlbShmdW4sIGFyZ3MpKTtcbiAgICBpZiAocXVldWUubGVuZ3RoID09PSAxICYmICFkcmFpbmluZykge1xuICAgICAgICBydW5UaW1lb3V0KGRyYWluUXVldWUpO1xuICAgIH1cbn07XG5cbi8vIHY4IGxpa2VzIHByZWRpY3RpYmxlIG9iamVjdHNcbmZ1bmN0aW9uIEl0ZW0oZnVuLCBhcnJheSkge1xuICAgIHRoaXMuZnVuID0gZnVuO1xuICAgIHRoaXMuYXJyYXkgPSBhcnJheTtcbn1cbkl0ZW0ucHJvdG90eXBlLnJ1biA9IGZ1bmN0aW9uICgpIHtcbiAgICB0aGlzLmZ1bi5hcHBseShudWxsLCB0aGlzLmFycmF5KTtcbn07XG5wcm9jZXNzLnRpdGxlID0gJ2Jyb3dzZXInO1xucHJvY2Vzcy5icm93c2VyID0gdHJ1ZTtcbnByb2Nlc3MuZW52ID0ge307XG5wcm9jZXNzLmFyZ3YgPSBbXTtcbnByb2Nlc3MudmVyc2lvbiA9ICcnOyAvLyBlbXB0eSBzdHJpbmcgdG8gYXZvaWQgcmVnZXhwIGlzc3Vlc1xucHJvY2Vzcy52ZXJzaW9ucyA9IHt9O1xuXG5mdW5jdGlvbiBub29wKCkge31cblxucHJvY2Vzcy5vbiA9IG5vb3A7XG5wcm9jZXNzLmFkZExpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3Mub25jZSA9IG5vb3A7XG5wcm9jZXNzLm9mZiA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUxpc3RlbmVyID0gbm9vcDtcbnByb2Nlc3MucmVtb3ZlQWxsTGlzdGVuZXJzID0gbm9vcDtcbnByb2Nlc3MuZW1pdCA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnByZXBlbmRPbmNlTGlzdGVuZXIgPSBub29wO1xuXG5wcm9jZXNzLmxpc3RlbmVycyA9IGZ1bmN0aW9uIChuYW1lKSB7IHJldHVybiBbXSB9XG5cbnByb2Nlc3MuYmluZGluZyA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmJpbmRpbmcgaXMgbm90IHN1cHBvcnRlZCcpO1xufTtcblxucHJvY2Vzcy5jd2QgPSBmdW5jdGlvbiAoKSB7IHJldHVybiAnLycgfTtcbnByb2Nlc3MuY2hkaXIgPSBmdW5jdGlvbiAoZGlyKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdwcm9jZXNzLmNoZGlyIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5wcm9jZXNzLnVtYXNrID0gZnVuY3Rpb24oKSB7IHJldHVybiAwOyB9O1xuIiwiY29uc3QgeyBFdmVudEVtaXR0ZXIgfSA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi9Mb2dnZXInKTtcblxuY2xhc3MgRW5oYW5jZWRFdmVudEVtaXR0ZXIgZXh0ZW5kcyBFdmVudEVtaXR0ZXJcbntcblx0Y29uc3RydWN0b3IobG9nZ2VyKVxuXHR7XG5cdFx0c3VwZXIoKTtcblx0XHR0aGlzLnNldE1heExpc3RlbmVycyhJbmZpbml0eSk7XG5cblx0XHR0aGlzLl9sb2dnZXIgPSBsb2dnZXIgfHwgbmV3IExvZ2dlcignRW5oYW5jZWRFdmVudEVtaXR0ZXInKTtcblx0fVxuXG5cdHNhZmVFbWl0KGV2ZW50LCAuLi5hcmdzKVxuXHR7XG5cdFx0dHJ5XG5cdFx0e1xuXHRcdFx0dGhpcy5lbWl0KGV2ZW50LCAuLi5hcmdzKTtcblx0XHR9XG5cdFx0Y2F0Y2ggKGVycm9yKVxuXHRcdHtcblx0XHRcdHRoaXMuX2xvZ2dlci5lcnJvcihcblx0XHRcdFx0J3NhZmVFbWl0KCkgfCBldmVudCBsaXN0ZW5lciB0aHJldyBhbiBlcnJvciBbZXZlbnQ6JXNdOiVvJyxcblx0XHRcdFx0ZXZlbnQsIGVycm9yKTtcblx0XHR9XG5cdH1cblxuXHRhc3luYyBzYWZlRW1pdEFzUHJvbWlzZShldmVudCwgLi4uYXJncylcblx0e1xuXHRcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PlxuXHRcdHtcblx0XHRcdHRoaXMuc2FmZUVtaXQoZXZlbnQsIC4uLmFyZ3MsIHJlc29sdmUsIHJlamVjdCk7XG5cdFx0fSk7XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBFbmhhbmNlZEV2ZW50RW1pdHRlcjtcbiIsImNvbnN0IGRlYnVnID0gcmVxdWlyZSgnZGVidWcnKTtcblxuY29uc3QgQVBQX05BTUUgPSAncHJvdG9vLWNsaWVudCc7XG5cbmNsYXNzIExvZ2dlclxue1xuXHRjb25zdHJ1Y3RvcihwcmVmaXgpXG5cdHtcblx0XHRpZiAocHJlZml4KVxuXHRcdHtcblx0XHRcdHRoaXMuX2RlYnVnID0gZGVidWcoYCR7QVBQX05BTUV9OiR7cHJlZml4fWApO1xuXHRcdFx0dGhpcy5fd2FybiA9IGRlYnVnKGAke0FQUF9OQU1FfTpXQVJOOiR7cHJlZml4fWApO1xuXHRcdFx0dGhpcy5fZXJyb3IgPSBkZWJ1ZyhgJHtBUFBfTkFNRX06RVJST1I6JHtwcmVmaXh9YCk7XG5cdFx0fVxuXHRcdGVsc2Vcblx0XHR7XG5cdFx0XHR0aGlzLl9kZWJ1ZyA9IGRlYnVnKEFQUF9OQU1FKTtcblx0XHRcdHRoaXMuX3dhcm4gPSBkZWJ1ZyhgJHtBUFBfTkFNRX06V0FSTmApO1xuXHRcdFx0dGhpcy5fZXJyb3IgPSBkZWJ1ZyhgJHtBUFBfTkFNRX06RVJST1JgKTtcblx0XHR9XG5cblx0XHQvKiBlc2xpbnQtZGlzYWJsZSBuby1jb25zb2xlICovXG5cdFx0dGhpcy5fZGVidWcubG9nID0gY29uc29sZS5pbmZvLmJpbmQoY29uc29sZSk7XG5cdFx0dGhpcy5fd2Fybi5sb2cgPSBjb25zb2xlLndhcm4uYmluZChjb25zb2xlKTtcblx0XHR0aGlzLl9lcnJvci5sb2cgPSBjb25zb2xlLmVycm9yLmJpbmQoY29uc29sZSk7XG5cdFx0LyogZXNsaW50LWVuYWJsZSBuby1jb25zb2xlICovXG5cdH1cblxuXHRnZXQgZGVidWcoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX2RlYnVnO1xuXHR9XG5cblx0Z2V0IHdhcm4oKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX3dhcm47XG5cdH1cblxuXHRnZXQgZXJyb3IoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX2Vycm9yO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gTG9nZ2VyO1xuIiwiY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi9Mb2dnZXInKTtcbmNvbnN0IHsgZ2VuZXJhdGVSYW5kb21OdW1iZXIgfSA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcblxuY29uc3QgbG9nZ2VyID0gbmV3IExvZ2dlcignTWVzc2FnZScpO1xuXG5jbGFzcyBNZXNzYWdlXG57XG5cdHN0YXRpYyBwYXJzZShyYXcpXG5cdHtcblx0XHRsZXQgb2JqZWN0O1xuXHRcdGNvbnN0IG1lc3NhZ2UgPSB7fTtcblxuXHRcdHRyeVxuXHRcdHtcblx0XHRcdG9iamVjdCA9IEpTT04ucGFyc2UocmF3KTtcblx0XHR9XG5cdFx0Y2F0Y2ggKGVycm9yKVxuXHRcdHtcblx0XHRcdGxvZ2dlci5lcnJvcigncGFyc2UoKSB8IGludmFsaWQgSlNPTjogJXMnLCBlcnJvcik7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAodHlwZW9mIG9iamVjdCAhPT0gJ29iamVjdCcgfHwgQXJyYXkuaXNBcnJheShvYmplY3QpKVxuXHRcdHtcblx0XHRcdGxvZ2dlci5lcnJvcigncGFyc2UoKSB8IG5vdCBhbiBvYmplY3QnKTtcblxuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblxuXHRcdC8vIFJlcXVlc3QuXG5cdFx0aWYgKG9iamVjdC5yZXF1ZXN0KVxuXHRcdHtcblx0XHRcdG1lc3NhZ2UucmVxdWVzdCA9IHRydWU7XG5cblx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0Lm1ldGhvZCAhPT0gJ3N0cmluZycpXG5cdFx0XHR7XG5cdFx0XHRcdGxvZ2dlci5lcnJvcigncGFyc2UoKSB8IG1pc3NpbmcvaW52YWxpZCBtZXRob2QgZmllbGQnKTtcblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGlmICh0eXBlb2Ygb2JqZWN0LmlkICE9PSAnbnVtYmVyJylcblx0XHRcdHtcblx0XHRcdFx0bG9nZ2VyLmVycm9yKCdwYXJzZSgpIHwgbWlzc2luZy9pbnZhbGlkIGlkIGZpZWxkJyk7XG5cblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHRtZXNzYWdlLmlkID0gb2JqZWN0LmlkO1xuXHRcdFx0bWVzc2FnZS5tZXRob2QgPSBvYmplY3QubWV0aG9kO1xuXHRcdFx0bWVzc2FnZS5kYXRhID0gb2JqZWN0LmRhdGEgfHwge307XG5cdFx0fVxuXHRcdC8vIFJlc3BvbnNlLlxuXHRcdGVsc2UgaWYgKG9iamVjdC5yZXNwb25zZSlcblx0XHR7XG5cdFx0XHRtZXNzYWdlLnJlc3BvbnNlID0gdHJ1ZTtcblxuXHRcdFx0aWYgKHR5cGVvZiBvYmplY3QuaWQgIT09ICdudW1iZXInKVxuXHRcdFx0e1xuXHRcdFx0XHRsb2dnZXIuZXJyb3IoJ3BhcnNlKCkgfCBtaXNzaW5nL2ludmFsaWQgaWQgZmllbGQnKTtcblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdG1lc3NhZ2UuaWQgPSBvYmplY3QuaWQ7XG5cblx0XHRcdC8vIFN1Y2Nlc3MuXG5cdFx0XHRpZiAob2JqZWN0Lm9rKVxuXHRcdFx0e1xuXHRcdFx0XHRtZXNzYWdlLm9rID0gdHJ1ZTtcblx0XHRcdFx0bWVzc2FnZS5kYXRhID0gb2JqZWN0LmRhdGEgfHwge307XG5cdFx0XHR9XG5cdFx0XHQvLyBFcnJvci5cblx0XHRcdGVsc2Vcblx0XHRcdHtcblx0XHRcdFx0bWVzc2FnZS5vayA9IGZhbHNlO1xuXHRcdFx0XHRtZXNzYWdlLmVycm9yQ29kZSA9IG9iamVjdC5lcnJvckNvZGU7XG5cdFx0XHRcdG1lc3NhZ2UuZXJyb3JSZWFzb24gPSBvYmplY3QuZXJyb3JSZWFzb247XG5cdFx0XHR9XG5cdFx0fVxuXHRcdC8vIE5vdGlmaWNhdGlvbi5cblx0XHRlbHNlIGlmIChvYmplY3Qubm90aWZpY2F0aW9uKVxuXHRcdHtcblx0XHRcdG1lc3NhZ2Uubm90aWZpY2F0aW9uID0gdHJ1ZTtcblxuXHRcdFx0aWYgKHR5cGVvZiBvYmplY3QubWV0aG9kICE9PSAnc3RyaW5nJylcblx0XHRcdHtcblx0XHRcdFx0bG9nZ2VyLmVycm9yKCdwYXJzZSgpIHwgbWlzc2luZy9pbnZhbGlkIG1ldGhvZCBmaWVsZCcpO1xuXG5cdFx0XHRcdHJldHVybjtcblx0XHRcdH1cblxuXHRcdFx0bWVzc2FnZS5tZXRob2QgPSBvYmplY3QubWV0aG9kO1xuXHRcdFx0bWVzc2FnZS5kYXRhID0gb2JqZWN0LmRhdGEgfHwge307XG5cdFx0fVxuXHRcdC8vIEludmFsaWQuXG5cdFx0ZWxzZVxuXHRcdHtcblx0XHRcdGxvZ2dlci5lcnJvcigncGFyc2UoKSB8IG1pc3NpbmcgcmVxdWVzdC9yZXNwb25zZSBmaWVsZCcpO1xuXG5cdFx0XHRyZXR1cm47XG5cdFx0fVxuXG5cdFx0cmV0dXJuIG1lc3NhZ2U7XG5cdH1cblxuXHRzdGF0aWMgY3JlYXRlUmVxdWVzdChtZXRob2QsIGRhdGEpXG5cdHtcblx0XHRjb25zdCByZXF1ZXN0ID1cblx0XHR7XG5cdFx0XHRyZXF1ZXN0IDogdHJ1ZSxcblx0XHRcdGlkICAgICAgOiBnZW5lcmF0ZVJhbmRvbU51bWJlcigpLFxuXHRcdFx0bWV0aG9kICA6IG1ldGhvZCxcblx0XHRcdGRhdGEgICAgOiBkYXRhIHx8IHt9XG5cdFx0fTtcblxuXHRcdHJldHVybiByZXF1ZXN0O1xuXHR9XG5cblx0c3RhdGljIGNyZWF0ZVN1Y2Nlc3NSZXNwb25zZShyZXF1ZXN0LCBkYXRhKVxuXHR7XG5cdFx0Y29uc3QgcmVzcG9uc2UgPVxuXHRcdHtcblx0XHRcdHJlc3BvbnNlIDogdHJ1ZSxcblx0XHRcdGlkICAgICAgIDogcmVxdWVzdC5pZCxcblx0XHRcdG9rICAgICAgIDogdHJ1ZSxcblx0XHRcdGRhdGEgICAgIDogZGF0YSB8fCB7fVxuXHRcdH07XG5cblx0XHRyZXR1cm4gcmVzcG9uc2U7XG5cdH1cblxuXHRzdGF0aWMgY3JlYXRlRXJyb3JSZXNwb25zZShyZXF1ZXN0LCBlcnJvckNvZGUsIGVycm9yUmVhc29uKVxuXHR7XG5cdFx0Y29uc3QgcmVzcG9uc2UgPVxuXHRcdHtcblx0XHRcdHJlc3BvbnNlICAgIDogdHJ1ZSxcblx0XHRcdGlkICAgICAgICAgIDogcmVxdWVzdC5pZCxcblx0XHRcdG9rICAgICAgICAgIDogZmFsc2UsXG5cdFx0XHRlcnJvckNvZGUgICA6IGVycm9yQ29kZSxcblx0XHRcdGVycm9yUmVhc29uIDogZXJyb3JSZWFzb25cblx0XHR9O1xuXG5cdFx0cmV0dXJuIHJlc3BvbnNlO1xuXHR9XG5cblx0c3RhdGljIGNyZWF0ZU5vdGlmaWNhdGlvbihtZXRob2QsIGRhdGEpXG5cdHtcblx0XHRjb25zdCBub3RpZmljYXRpb24gPVxuXHRcdHtcblx0XHRcdG5vdGlmaWNhdGlvbiA6IHRydWUsXG5cdFx0XHRtZXRob2QgICAgICAgOiBtZXRob2QsXG5cdFx0XHRkYXRhICAgICAgICAgOiBkYXRhIHx8IHt9XG5cdFx0fTtcblxuXHRcdHJldHVybiBub3RpZmljYXRpb247XG5cdH1cbn1cblxubW9kdWxlLmV4cG9ydHMgPSBNZXNzYWdlO1xuIiwiY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi9Mb2dnZXInKTtcbmNvbnN0IEVuaGFuY2VkRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnLi9FbmhhbmNlZEV2ZW50RW1pdHRlcicpO1xuY29uc3QgTWVzc2FnZSA9IHJlcXVpcmUoJy4vTWVzc2FnZScpO1xuXG5jb25zdCBsb2dnZXIgPSBuZXcgTG9nZ2VyKCdQZWVyJyk7XG5cbmNsYXNzIFBlZXIgZXh0ZW5kcyBFbmhhbmNlZEV2ZW50RW1pdHRlclxue1xuXHQvKipcblx0ICogQHBhcmFtIHtwcm90b28uVHJhbnNwb3J0fSB0cmFuc3BvcnRcblx0ICpcblx0ICogQGVtaXRzIG9wZW5cblx0ICogQGVtaXRzIHtjdXJyZW50QXR0ZW1wdDogTnVtYmVyfSBmYWlsZWRcblx0ICogQGVtaXRzIGRpc2Nvbm5lY3RlZFxuXHQgKiBAZW1pdHMgY2xvc2Vcblx0ICogQGVtaXRzIHtyZXF1ZXN0OiBwcm90b28uUmVxdWVzdCwgYWNjZXB0OiBGdW5jdGlvbiwgcmVqZWN0OiBGdW5jdGlvbn0gcmVxdWVzdFxuXHQgKiBAZW1pdHMge25vdGlmaWNhdGlvbjogcHJvdG9vLk5vdGlmaWNhdGlvbn0gbm90aWZpY2F0aW9uXG5cdCAqL1xuXHRjb25zdHJ1Y3Rvcih0cmFuc3BvcnQpXG5cdHtcblx0XHRzdXBlcihsb2dnZXIpO1xuXG5cdFx0bG9nZ2VyLmRlYnVnKCdjb25zdHJ1Y3RvcigpJyk7XG5cblx0XHQvLyBDbG9zZWQgZmxhZy5cblx0XHQvLyBAdHlwZSB7Qm9vbGVhbn1cblx0XHR0aGlzLl9jbG9zZWQgPSBmYWxzZTtcblxuXHRcdC8vIFRyYW5zcG9ydC5cblx0XHQvLyBAdHlwZSB7cHJvdG9vLlRyYW5zcG9ydH1cblx0XHR0aGlzLl90cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG5cblx0XHQvLyBDb25uZWN0ZWQgZmxhZy5cblx0XHQvLyBAdHlwZSB7Qm9vbGVhbn1cblx0XHR0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcblxuXHRcdC8vIEN1c3RvbSBkYXRhIG9iamVjdC5cblx0XHQvLyBAdHlwZSB7T2JqZWN0fVxuXHRcdHRoaXMuX2RhdGEgPSB7fTtcblxuXHRcdC8vIE1hcCBvZiBwZW5kaW5nIHNlbnQgcmVxdWVzdCBvYmplY3RzIGluZGV4ZWQgYnkgcmVxdWVzdCBpZC5cblx0XHQvLyBAdHlwZSB7TWFwPE51bWJlciwgT2JqZWN0Pn1cblx0XHR0aGlzLl9zZW50cyA9IG5ldyBNYXAoKTtcblxuXHRcdC8vIEhhbmRsZSB0cmFuc3BvcnQuXG5cdFx0dGhpcy5faGFuZGxlVHJhbnNwb3J0KCk7XG5cdH1cblxuXHQvKipcblx0ICogV2hldGhlciB0aGUgUGVlciBpcyBjbG9zZWQuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtCb29sZWFufVxuXHQgKi9cblx0Z2V0IGNsb3NlZCgpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fY2xvc2VkO1xuXHR9XG5cblx0LyoqXG5cdCAqIFdoZXRoZXIgdGhlIFBlZXIgaXMgY29ubmVjdGVkLlxuXHQgKlxuXHQgKiBAcmV0dXJucyB7Qm9vbGVhbn1cblx0ICovXG5cdGdldCBjb25uZWN0ZWQoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX2Nvbm5lY3RlZDtcblx0fVxuXG5cdC8qKlxuXHQgKiBBcHAgY3VzdG9tIGRhdGEuXG5cdCAqXG5cdCAqIEByZXR1cm5zIHtPYmplY3R9XG5cdCAqL1xuXHRnZXQgZGF0YSgpXG5cdHtcblx0XHRyZXR1cm4gdGhpcy5fZGF0YTtcblx0fVxuXG5cdC8qKlxuXHQgKiBJbnZhbGlkIHNldHRlci5cblx0ICovXG5cdHNldCBkYXRhKGRhdGEpIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tdW51c2VkLXZhcnNcblx0e1xuXHRcdHRocm93IG5ldyBFcnJvcignY2Fubm90IG92ZXJyaWRlIGRhdGEgb2JqZWN0Jyk7XG5cdH1cblxuXHQvKipcblx0ICogQ2xvc2UgdGhpcyBQZWVyIGFuZCBpdHMgVHJhbnNwb3J0LlxuXHQgKi9cblx0Y2xvc2UoKVxuXHR7XG5cdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdHJldHVybjtcblxuXHRcdGxvZ2dlci5kZWJ1ZygnY2xvc2UoKScpO1xuXG5cdFx0dGhpcy5fY2xvc2VkID0gdHJ1ZTtcblx0XHR0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcblxuXHRcdC8vIENsb3NlIFRyYW5zcG9ydC5cblx0XHR0aGlzLl90cmFuc3BvcnQuY2xvc2UoKTtcblxuXHRcdC8vIENsb3NlIGV2ZXJ5IHBlbmRpbmcgc2VudC5cblx0XHRmb3IgKGNvbnN0IHNlbnQgb2YgdGhpcy5fc2VudHMudmFsdWVzKCkpXG5cdFx0e1xuXHRcdFx0c2VudC5jbG9zZSgpO1xuXHRcdH1cblxuXHRcdC8vIEVtaXQgJ2Nsb3NlJyBldmVudC5cblx0XHR0aGlzLnNhZmVFbWl0KCdjbG9zZScpO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlbmQgYSBwcm90b28gcmVxdWVzdCB0byB0aGUgc2VydmVyLXNpZGUgUm9vbS5cblx0ICpcblx0ICogQHBhcmFtIHtTdHJpbmd9IG1ldGhvZFxuXHQgKiBAcGFyYW0ge09iamVjdH0gW2RhdGFdXG5cdCAqXG5cdCAqIEBhc3luY1xuXHQgKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgcmVzcG9uc2UgZGF0YSBPYmplY3QgaWYgYSBzdWNjZXNzIHJlc3BvbnNlIGlzIHJlY2VpdmVkLlxuXHQgKi9cblx0YXN5bmMgcmVxdWVzdChtZXRob2QsIGRhdGEgPSB1bmRlZmluZWQpXG5cdHtcblx0XHRjb25zdCByZXF1ZXN0ID0gTWVzc2FnZS5jcmVhdGVSZXF1ZXN0KG1ldGhvZCwgZGF0YSk7XG5cblx0XHR0aGlzLl9sb2dnZXIuZGVidWcoJ3JlcXVlc3QoKSBbbWV0aG9kOiVzLCBpZDolc10nLCBtZXRob2QsIHJlcXVlc3QuaWQpO1xuXG5cdFx0Ly8gVGhpcyBtYXkgdGhyb3cuXG5cdFx0YXdhaXQgdGhpcy5fdHJhbnNwb3J0LnNlbmQocmVxdWVzdCk7XG5cblx0XHRyZXR1cm4gbmV3IFByb21pc2UoKHBSZXNvbHZlLCBwUmVqZWN0KSA9PlxuXHRcdHtcblx0XHRcdGNvbnN0IHRpbWVvdXQgPSAxNTAwICogKDE1ICsgKDAuMSAqIHRoaXMuX3NlbnRzLnNpemUpKTtcblx0XHRcdGNvbnN0IHNlbnQgPVxuXHRcdFx0e1xuXHRcdFx0XHRpZCAgICAgIDogcmVxdWVzdC5pZCxcblx0XHRcdFx0bWV0aG9kICA6IHJlcXVlc3QubWV0aG9kLFxuXHRcdFx0XHRyZXNvbHZlIDogKGRhdGEyKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKCF0aGlzLl9zZW50cy5kZWxldGUocmVxdWVzdC5pZCkpXG5cdFx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoc2VudC50aW1lcik7XG5cdFx0XHRcdFx0cFJlc29sdmUoZGF0YTIpO1xuXHRcdFx0XHR9LFxuXHRcdFx0XHRyZWplY3QgOiAoZXJyb3IpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoIXRoaXMuX3NlbnRzLmRlbGV0ZShyZXF1ZXN0LmlkKSlcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdGNsZWFyVGltZW91dChzZW50LnRpbWVyKTtcblx0XHRcdFx0XHRwUmVqZWN0KGVycm9yKTtcblx0XHRcdFx0fSxcblx0XHRcdFx0dGltZXIgOiBzZXRUaW1lb3V0KCgpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRpZiAoIXRoaXMuX3NlbnRzLmRlbGV0ZShyZXF1ZXN0LmlkKSlcblx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdHBSZWplY3QobmV3IEVycm9yKCdyZXF1ZXN0IHRpbWVvdXQnKSk7XG5cdFx0XHRcdH0sIHRpbWVvdXQpLFxuXHRcdFx0XHRjbG9zZSA6ICgpID0+XG5cdFx0XHRcdHtcblx0XHRcdFx0XHRjbGVhclRpbWVvdXQoc2VudC50aW1lcik7XG5cdFx0XHRcdFx0cFJlamVjdChuZXcgRXJyb3IoJ3BlZXIgY2xvc2VkJykpO1xuXHRcdFx0XHR9XG5cdFx0XHR9O1xuXG5cdFx0XHQvLyBBZGQgc2VudCBzdHVmZiB0byB0aGUgbWFwLlxuXHRcdFx0dGhpcy5fc2VudHMuc2V0KHJlcXVlc3QuaWQsIHNlbnQpO1xuXHRcdH0pO1xuXHR9XG5cblx0LyoqXG5cdCAqIFNlbmQgYSBwcm90b28gbm90aWZpY2F0aW9uIHRvIHRoZSBzZXJ2ZXItc2lkZSBSb29tLlxuXHQgKlxuXHQgKiBAcGFyYW0ge1N0cmluZ30gbWV0aG9kXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbZGF0YV1cblx0ICpcblx0ICogQGFzeW5jXG5cdCAqL1xuXHRhc3luYyBub3RpZnkobWV0aG9kLCBkYXRhID0gdW5kZWZpbmVkKVxuXHR7XG5cdFx0Y29uc3Qgbm90aWZpY2F0aW9uID0gTWVzc2FnZS5jcmVhdGVOb3RpZmljYXRpb24obWV0aG9kLCBkYXRhKTtcblxuXHRcdHRoaXMuX2xvZ2dlci5kZWJ1Zygnbm90aWZ5KCkgW21ldGhvZDolc10nLCBtZXRob2QpO1xuXG5cdFx0Ly8gVGhpcyBtYXkgdGhyb3cuXG5cdFx0YXdhaXQgdGhpcy5fdHJhbnNwb3J0LnNlbmQobm90aWZpY2F0aW9uKTtcblx0fVxuXG5cdF9oYW5kbGVUcmFuc3BvcnQoKVxuXHR7XG5cdFx0aWYgKHRoaXMuX3RyYW5zcG9ydC5jbG9zZWQpXG5cdFx0e1xuXHRcdFx0dGhpcy5fY2xvc2VkID0gdHJ1ZTtcblxuXHRcdFx0c2V0VGltZW91dCgoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAodGhpcy5fY2xvc2VkKVxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcblxuXHRcdFx0XHR0aGlzLnNhZmVFbWl0KCdjbG9zZScpO1xuXHRcdFx0fSk7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHR0aGlzLl90cmFuc3BvcnQub24oJ29wZW4nLCAoKSA9PlxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdlbWl0IFwib3BlblwiJyk7XG5cblx0XHRcdHRoaXMuX2Nvbm5lY3RlZCA9IHRydWU7XG5cblx0XHRcdHRoaXMuc2FmZUVtaXQoJ29wZW4nKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuX3RyYW5zcG9ydC5vbignZGlzY29ubmVjdGVkJywgKCkgPT5cblx0XHR7XG5cdFx0XHRpZiAodGhpcy5fY2xvc2VkKVxuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdGxvZ2dlci5kZWJ1ZygnZW1pdCBcImRpc2Nvbm5lY3RlZFwiJyk7XG5cblx0XHRcdHRoaXMuX2Nvbm5lY3RlZCA9IGZhbHNlO1xuXG5cdFx0XHR0aGlzLnNhZmVFbWl0KCdkaXNjb25uZWN0ZWQnKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuX3RyYW5zcG9ydC5vbignZmFpbGVkJywgKGN1cnJlbnRBdHRlbXB0KSA9PlxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdlbWl0IFwiZmFpbGVkXCIgW2N1cnJlbnRBdHRlbXB0OiVzXScsIGN1cnJlbnRBdHRlbXB0KTtcblxuXHRcdFx0dGhpcy5fY29ubmVjdGVkID0gZmFsc2U7XG5cblx0XHRcdHRoaXMuc2FmZUVtaXQoJ2ZhaWxlZCcsIGN1cnJlbnRBdHRlbXB0KTtcblx0XHR9KTtcblxuXHRcdHRoaXMuX3RyYW5zcG9ydC5vbignY2xvc2UnLCAoKSA9PlxuXHRcdHtcblx0XHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0XHRcdHJldHVybjtcblxuXHRcdFx0dGhpcy5fY2xvc2VkID0gdHJ1ZTtcblxuXHRcdFx0bG9nZ2VyLmRlYnVnKCdlbWl0IFwiY2xvc2VcIicpO1xuXG5cdFx0XHR0aGlzLl9jb25uZWN0ZWQgPSBmYWxzZTtcblxuXHRcdFx0dGhpcy5zYWZlRW1pdCgnY2xvc2UnKTtcblx0XHR9KTtcblxuXHRcdHRoaXMuX3RyYW5zcG9ydC5vbignbWVzc2FnZScsIChtZXNzYWdlKSA9PlxuXHRcdHtcblx0XHRcdGlmIChtZXNzYWdlLnJlcXVlc3QpXG5cdFx0XHRcdHRoaXMuX2hhbmRsZVJlcXVlc3QobWVzc2FnZSk7XG5cdFx0XHRlbHNlIGlmIChtZXNzYWdlLnJlc3BvbnNlKVxuXHRcdFx0XHR0aGlzLl9oYW5kbGVSZXNwb25zZShtZXNzYWdlKTtcblx0XHRcdGVsc2UgaWYgKG1lc3NhZ2Uubm90aWZpY2F0aW9uKVxuXHRcdFx0XHR0aGlzLl9oYW5kbGVOb3RpZmljYXRpb24obWVzc2FnZSk7XG5cdFx0fSk7XG5cdH1cblxuXHRfaGFuZGxlUmVxdWVzdChyZXF1ZXN0KVxuXHR7XG5cdFx0dHJ5XG5cdFx0e1xuXHRcdFx0dGhpcy5lbWl0KCdyZXF1ZXN0Jyxcblx0XHRcdFx0Ly8gUmVxdWVzdC5cblx0XHRcdFx0cmVxdWVzdCxcblx0XHRcdFx0Ly8gYWNjZXB0KCkgZnVuY3Rpb24uXG5cdFx0XHRcdChkYXRhKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0Y29uc3QgcmVzcG9uc2UgPSBNZXNzYWdlLmNyZWF0ZVN1Y2Nlc3NSZXNwb25zZShyZXF1ZXN0LCBkYXRhKTtcblxuXHRcdFx0XHRcdHRoaXMuX3RyYW5zcG9ydC5zZW5kKHJlc3BvbnNlKVxuXHRcdFx0XHRcdFx0LmNhdGNoKCgpID0+IHt9KTtcblx0XHRcdFx0fSxcblx0XHRcdFx0Ly8gcmVqZWN0KCkgZnVuY3Rpb24uXG5cdFx0XHRcdChlcnJvckNvZGUsIGVycm9yUmVhc29uKSA9PlxuXHRcdFx0XHR7XG5cdFx0XHRcdFx0aWYgKGVycm9yQ29kZSBpbnN0YW5jZW9mIEVycm9yKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdGVycm9yUmVhc29uID0gZXJyb3JDb2RlLm1lc3NhZ2U7XG5cdFx0XHRcdFx0XHRlcnJvckNvZGUgPSA1MDA7XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdGVsc2UgaWYgKHR5cGVvZiBlcnJvckNvZGUgPT09ICdudW1iZXInICYmIGVycm9yUmVhc29uIGluc3RhbmNlb2YgRXJyb3IpXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0ZXJyb3JSZWFzb24gPSBlcnJvclJlYXNvbi5tZXNzYWdlO1xuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IHJlc3BvbnNlID1cblx0XHRcdFx0XHRcdE1lc3NhZ2UuY3JlYXRlRXJyb3JSZXNwb25zZShyZXF1ZXN0LCBlcnJvckNvZGUsIGVycm9yUmVhc29uKTtcblxuXHRcdFx0XHRcdHRoaXMuX3RyYW5zcG9ydC5zZW5kKHJlc3BvbnNlKVxuXHRcdFx0XHRcdFx0LmNhdGNoKCgpID0+IHt9KTtcblx0XHRcdFx0fSk7XG5cdFx0fVxuXHRcdGNhdGNoIChlcnJvcilcblx0XHR7XG5cdFx0XHRjb25zdCByZXNwb25zZSA9IE1lc3NhZ2UuY3JlYXRlRXJyb3JSZXNwb25zZShyZXF1ZXN0LCA1MDAsIFN0cmluZyhlcnJvcikpO1xuXG5cdFx0XHR0aGlzLl90cmFuc3BvcnQuc2VuZChyZXNwb25zZSlcblx0XHRcdFx0LmNhdGNoKCgpID0+IHt9KTtcblx0XHR9XG5cdH1cblxuXHRfaGFuZGxlUmVzcG9uc2UocmVzcG9uc2UpXG5cdHtcblx0XHRjb25zdCBzZW50ID0gdGhpcy5fc2VudHMuZ2V0KHJlc3BvbnNlLmlkKTtcblxuXHRcdGlmICghc2VudClcblx0XHR7XG5cdFx0XHRsb2dnZXIuZXJyb3IoXG5cdFx0XHRcdCdyZWNlaXZlZCByZXNwb25zZSBkb2VzIG5vdCBtYXRjaCBhbnkgc2VudCByZXF1ZXN0IFtpZDolc10nLCByZXNwb25zZS5pZCk7XG5cblx0XHRcdHJldHVybjtcblx0XHR9XG5cblx0XHRpZiAocmVzcG9uc2Uub2spXG5cdFx0e1xuXHRcdFx0c2VudC5yZXNvbHZlKHJlc3BvbnNlLmRhdGEpO1xuXHRcdH1cblx0XHRlbHNlXG5cdFx0e1xuXHRcdFx0Y29uc3QgZXJyb3IgPSBuZXcgRXJyb3IocmVzcG9uc2UuZXJyb3JSZWFzb24pO1xuXG5cdFx0XHRlcnJvci5jb2RlID0gcmVzcG9uc2UuZXJyb3JDb2RlO1xuXHRcdFx0c2VudC5yZWplY3QoZXJyb3IpO1xuXHRcdH1cblx0fVxuXG5cdF9oYW5kbGVOb3RpZmljYXRpb24obm90aWZpY2F0aW9uKVxuXHR7XG5cdFx0dGhpcy5zYWZlRW1pdCgnbm90aWZpY2F0aW9uJywgbm90aWZpY2F0aW9uKTtcblx0fVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IFBlZXI7XG4iLCJjb25zdCB7IHZlcnNpb24gfSA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpO1xuY29uc3QgUGVlciA9IHJlcXVpcmUoJy4vUGVlcicpO1xuY29uc3QgV2ViU29ja2V0VHJhbnNwb3J0ID0gcmVxdWlyZSgnLi90cmFuc3BvcnRzL1dlYlNvY2tldFRyYW5zcG9ydCcpO1xuXG4vKipcbiAqIEV4cG9zZSBtZWRpYXNvdXAtY2xpZW50IHZlcnNpb24uXG4gKlxuICogQHR5cGUge1N0cmluZ31cbiAqL1xuZXhwb3J0cy52ZXJzaW9uID0gdmVyc2lvbjtcblxuLyoqXG4gKiBFeHBvc2UgUGVlciBjbGFzcy5cbiAqXG4gKiBAdHlwZSB7Q2xhc3N9XG4gKi9cbmV4cG9ydHMuUGVlciA9IFBlZXI7XG5cbi8qKlxuICogRXhwb3NlIFdlYlNvY2tldFRyYW5zcG9ydCBjbGFzcy5cbiAqXG4gKiBAdHlwZSB7Q2xhc3N9XG4gKi9cbmV4cG9ydHMuV2ViU29ja2V0VHJhbnNwb3J0ID0gV2ViU29ja2V0VHJhbnNwb3J0O1xuIiwiY29uc3QgVzNDV2ViU29ja2V0ID0gcmVxdWlyZSgnd2Vic29ja2V0JykudzNjd2Vic29ja2V0O1xuY29uc3QgcmV0cnkgPSByZXF1aXJlKCdyZXRyeScpO1xuY29uc3QgTG9nZ2VyID0gcmVxdWlyZSgnLi4vTG9nZ2VyJyk7XG5jb25zdCBFbmhhbmNlZEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJy4uL0VuaGFuY2VkRXZlbnRFbWl0dGVyJyk7XG5jb25zdCBNZXNzYWdlID0gcmVxdWlyZSgnLi4vTWVzc2FnZScpO1xuXG5jb25zdCBXU19TVUJQUk9UT0NPTCA9ICdwcm90b28nO1xuY29uc3QgREVGQVVMVF9SRVRSWV9PUFRJT05TID1cbntcblx0cmV0cmllcyAgICA6IDEwLFxuXHRmYWN0b3IgICAgIDogMixcblx0bWluVGltZW91dCA6IDEgKiAxMDAwLFxuXHRtYXhUaW1lb3V0IDogOCAqIDEwMDBcbn07XG5cbmNvbnN0IGxvZ2dlciA9IG5ldyBMb2dnZXIoJ1dlYlNvY2tldFRyYW5zcG9ydCcpO1xuXG5jbGFzcyBXZWJTb2NrZXRUcmFuc3BvcnQgZXh0ZW5kcyBFbmhhbmNlZEV2ZW50RW1pdHRlclxue1xuXHQvKipcblx0ICogQHBhcmFtIHtTdHJpbmd9IHVybCAtIFdlYlNvY2tldCBVUkwuXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciBXZWJTb2NrZXQtTm9kZS5XM0NXZWJTb2NrZXQgYW5kIHJldHJ5LlxuXHQgKi9cblx0Y29uc3RydWN0b3IodXJsLCBvcHRpb25zKVxuXHR7XG5cdFx0c3VwZXIobG9nZ2VyKTtcblxuXHRcdGxvZ2dlci5kZWJ1ZygnY29uc3RydWN0b3IoKSBbdXJsOiVzLCBvcHRpb25zOiVvXScsIHVybCwgb3B0aW9ucyk7XG5cblx0XHQvLyBDbG9zZWQgZmxhZy5cblx0XHQvLyBAdHlwZSB7Qm9vbGVhbn1cblx0XHR0aGlzLl9jbG9zZWQgPSBmYWxzZTtcblxuXHRcdC8vIFdlYlNvY2tldCBVUkwuXG5cdFx0Ly8gQHR5cGUge1N0cmluZ31cblx0XHR0aGlzLl91cmwgPSB1cmw7XG5cblx0XHQvLyBPcHRpb25zLlxuXHRcdC8vIEB0eXBlIHtPYmplY3R9XG5cdFx0dGhpcy5fb3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0XHQvLyBXZWJTb2NrZXQgaW5zdGFuY2UuXG5cdFx0Ly8gQHR5cGUge1dlYlNvY2tldH1cblx0XHR0aGlzLl93cyA9IG51bGw7XG5cblx0XHQvLyBSdW4gdGhlIFdlYlNvY2tldC5cblx0XHR0aGlzLl9ydW5XZWJTb2NrZXQoKTtcblx0fVxuXG5cdGdldCBjbG9zZWQoKVxuXHR7XG5cdFx0cmV0dXJuIHRoaXMuX2Nsb3NlZDtcblx0fVxuXG5cdGNsb3NlKClcblx0e1xuXHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0XHRyZXR1cm47XG5cblx0XHRsb2dnZXIuZGVidWcoJ2Nsb3NlKCknKTtcblxuXHRcdC8vIERvbid0IHdhaXQgZm9yIHRoZSBXZWJTb2NrZXQgJ2Nsb3NlJyBldmVudCwgZG8gaXQgbm93LlxuXHRcdHRoaXMuX2Nsb3NlZCA9IHRydWU7XG5cdFx0dGhpcy5zYWZlRW1pdCgnY2xvc2UnKTtcblxuXHRcdHRyeVxuXHRcdHtcblx0XHRcdHRoaXMuX3dzLm9ub3BlbiA9IG51bGw7XG5cdFx0XHR0aGlzLl93cy5vbmNsb3NlID0gbnVsbDtcblx0XHRcdHRoaXMuX3dzLm9uZXJyb3IgPSBudWxsO1xuXHRcdFx0dGhpcy5fd3Mub25tZXNzYWdlID0gbnVsbDtcblx0XHRcdHRoaXMuX3dzLmNsb3NlKCk7XG5cdFx0fVxuXHRcdGNhdGNoIChlcnJvcilcblx0XHR7XG5cdFx0XHRsb2dnZXIuZXJyb3IoJ2Nsb3NlKCkgfCBlcnJvciBjbG9zaW5nIHRoZSBXZWJTb2NrZXQ6ICVvJywgZXJyb3IpO1xuXHRcdH1cblx0fVxuXG5cdGFzeW5jIHNlbmQobWVzc2FnZSlcblx0e1xuXHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoJ3RyYW5zcG9ydCBjbG9zZWQnKTtcblxuXHRcdHRyeVxuXHRcdHtcblx0XHRcdHRoaXMuX3dzLnNlbmQoSlNPTi5zdHJpbmdpZnkobWVzc2FnZSkpO1xuXHRcdH1cblx0XHRjYXRjaCAoZXJyb3IpXG5cdFx0e1xuXHRcdFx0bG9nZ2VyLndhcm4oJ3NlbmQoKSBmYWlsZWQ6JW8nLCBlcnJvcik7XG5cblx0XHRcdHRocm93IGVycm9yO1xuXHRcdH1cblx0fVxuXG5cdF9ydW5XZWJTb2NrZXQoKVxuXHR7XG5cdFx0Y29uc3Qgb3BlcmF0aW9uID1cblx0XHRcdHJldHJ5Lm9wZXJhdGlvbih0aGlzLl9vcHRpb25zLnJldHJ5IHx8IERFRkFVTFRfUkVUUllfT1BUSU9OUyk7XG5cblx0XHRsZXQgd2FzQ29ubmVjdGVkID0gZmFsc2U7XG5cblx0XHRvcGVyYXRpb24uYXR0ZW1wdCgoY3VycmVudEF0dGVtcHQpID0+XG5cdFx0e1xuXHRcdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdHtcblx0XHRcdFx0b3BlcmF0aW9uLnN0b3AoKTtcblxuXHRcdFx0XHRyZXR1cm47XG5cdFx0XHR9XG5cblx0XHRcdGxvZ2dlci5kZWJ1ZygnX3J1bldlYlNvY2tldCgpIFtjdXJyZW50QXR0ZW1wdDolc10nLCBjdXJyZW50QXR0ZW1wdCk7XG5cblx0XHRcdHRoaXMuX3dzID0gbmV3IFczQ1dlYlNvY2tldChcblx0XHRcdFx0dGhpcy5fdXJsLFxuXHRcdFx0XHRXU19TVUJQUk9UT0NPTCxcblx0XHRcdFx0dGhpcy5fb3B0aW9ucy5vcmlnaW4sXG5cdFx0XHRcdHRoaXMuX29wdGlvbnMuaGVhZGVycyxcblx0XHRcdFx0dGhpcy5fb3B0aW9ucy5yZXF1ZXN0T3B0aW9ucyxcblx0XHRcdFx0dGhpcy5fb3B0aW9ucy5jbGllbnRDb25maWcpO1xuXG5cdFx0XHR0aGlzLl93cy5vbm9wZW4gPSAoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAodGhpcy5fY2xvc2VkKVxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHR3YXNDb25uZWN0ZWQgPSB0cnVlO1xuXG5cdFx0XHRcdC8vIEVtaXQgJ29wZW4nIGV2ZW50LlxuXHRcdFx0XHR0aGlzLnNhZmVFbWl0KCdvcGVuJyk7XG5cdFx0XHR9O1xuXG5cdFx0XHR0aGlzLl93cy5vbmNsb3NlID0gKGV2ZW50KSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAodGhpcy5fY2xvc2VkKVxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRsb2dnZXIud2Fybihcblx0XHRcdFx0XHQnV2ViU29ja2V0IFwiY2xvc2VcIiBldmVudCBbd2FzQ2xlYW46JXMsIGNvZGU6JXMsIHJlYXNvbjpcIiVzXCJdJyxcblx0XHRcdFx0XHRldmVudC53YXNDbGVhbiwgZXZlbnQuY29kZSwgZXZlbnQucmVhc29uKTtcblxuXHRcdFx0XHQvLyBEb24ndCByZXRyeSBpZiBjb2RlIGlzIDQwMDAgKGNsb3NlZCBieSB0aGUgc2VydmVyKS5cblx0XHRcdFx0aWYgKGV2ZW50LmNvZGUgIT09IDQwMDApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHQvLyBJZiBpdCB3YXMgbm90IGNvbm5lY3RlZCwgdHJ5IGFnYWluLlxuXHRcdFx0XHRcdGlmICghd2FzQ29ubmVjdGVkKVxuXHRcdFx0XHRcdHtcblx0XHRcdFx0XHRcdHRoaXMuc2FmZUVtaXQoJ2ZhaWxlZCcsIGN1cnJlbnRBdHRlbXB0KTtcblxuXHRcdFx0XHRcdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdFx0XHRcdFx0cmV0dXJuO1xuXG5cdFx0XHRcdFx0XHRpZiAob3BlcmF0aW9uLnJldHJ5KHRydWUpKVxuXHRcdFx0XHRcdFx0XHRyZXR1cm47XG5cdFx0XHRcdFx0fVxuXHRcdFx0XHRcdC8vIElmIGl0IHdhcyBjb25uZWN0ZWQsIHN0YXJ0IGZyb20gc2NyYXRjaC5cblx0XHRcdFx0XHRlbHNlXG5cdFx0XHRcdFx0e1xuXHRcdFx0XHRcdFx0b3BlcmF0aW9uLnN0b3AoKTtcblxuXHRcdFx0XHRcdFx0dGhpcy5zYWZlRW1pdCgnZGlzY29ubmVjdGVkJyk7XG5cblx0XHRcdFx0XHRcdGlmICh0aGlzLl9jbG9zZWQpXG5cdFx0XHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRcdFx0dGhpcy5fcnVuV2ViU29ja2V0KCk7XG5cblx0XHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0XHR9XG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0aGlzLl9jbG9zZWQgPSB0cnVlO1xuXG5cdFx0XHRcdC8vIEVtaXQgJ2Nsb3NlJyBldmVudC5cblx0XHRcdFx0dGhpcy5zYWZlRW1pdCgnY2xvc2UnKTtcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuX3dzLm9uZXJyb3IgPSAoKSA9PlxuXHRcdFx0e1xuXHRcdFx0XHRpZiAodGhpcy5fY2xvc2VkKVxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRsb2dnZXIuZXJyb3IoJ1dlYlNvY2tldCBcImVycm9yXCIgZXZlbnQnKTtcblx0XHRcdH07XG5cblx0XHRcdHRoaXMuX3dzLm9ubWVzc2FnZSA9IChldmVudCkgPT5cblx0XHRcdHtcblx0XHRcdFx0aWYgKHRoaXMuX2Nsb3NlZClcblx0XHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdFx0Y29uc3QgbWVzc2FnZSA9IE1lc3NhZ2UucGFyc2UoZXZlbnQuZGF0YSk7XG5cblx0XHRcdFx0aWYgKCFtZXNzYWdlKVxuXHRcdFx0XHRcdHJldHVybjtcblxuXHRcdFx0XHRpZiAodGhpcy5saXN0ZW5lckNvdW50KCdtZXNzYWdlJykgPT09IDApXG5cdFx0XHRcdHtcblx0XHRcdFx0XHRsb2dnZXIuZXJyb3IoXG5cdFx0XHRcdFx0XHQnbm8gbGlzdGVuZXJzIGZvciBXZWJTb2NrZXQgXCJtZXNzYWdlXCIgZXZlbnQsIGlnbm9yaW5nIHJlY2VpdmVkIG1lc3NhZ2UnKTtcblxuXHRcdFx0XHRcdHJldHVybjtcblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIEVtaXQgJ21lc3NhZ2UnIGV2ZW50LlxuXHRcdFx0XHR0aGlzLnNhZmVFbWl0KCdtZXNzYWdlJywgbWVzc2FnZSk7XG5cdFx0XHR9O1xuXHRcdH0pO1xuXHR9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gV2ViU29ja2V0VHJhbnNwb3J0O1xuIiwiLyoqXG4gKiBHZW5lcmF0ZXMgYSByYW5kb20gcG9zaXRpdmUgaW50ZWdlci5cbiAqXG4gKiBAcmV0dXJucyB7TnVtYmVyfVxuICovXG5leHBvcnRzLmdlbmVyYXRlUmFuZG9tTnVtYmVyID0gZnVuY3Rpb24oKVxue1xuXHRyZXR1cm4gTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpICogMTAwMDAwMDApO1xufTtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJfZnJvbVwiOiBcInByb3Rvby1jbGllbnRAXjQuMC40XCIsXG4gIFwiX2lkXCI6IFwicHJvdG9vLWNsaWVudEA0LjAuNlwiLFxuICBcIl9pbkJ1bmRsZVwiOiBmYWxzZSxcbiAgXCJfaW50ZWdyaXR5XCI6IFwic2hhNTEyLVpxSW1rS0hwZUpoU2xndnlJNlFBZlpOYy9hWGNDZ21tb2NNeDRTMXcybEFheFh0Y2t4eGVEdGNWTnRrT0lTVVdtL21iQytCcm1ZUFhvR01rZmhrS09RPT1cIixcbiAgXCJfbG9jYXRpb25cIjogXCIvcHJvdG9vLWNsaWVudFwiLFxuICBcIl9waGFudG9tQ2hpbGRyZW5cIjoge30sXG4gIFwiX3JlcXVlc3RlZFwiOiB7XG4gICAgXCJ0eXBlXCI6IFwicmFuZ2VcIixcbiAgICBcInJlZ2lzdHJ5XCI6IHRydWUsXG4gICAgXCJyYXdcIjogXCJwcm90b28tY2xpZW50QF40LjAuNFwiLFxuICAgIFwibmFtZVwiOiBcInByb3Rvby1jbGllbnRcIixcbiAgICBcImVzY2FwZWROYW1lXCI6IFwicHJvdG9vLWNsaWVudFwiLFxuICAgIFwicmF3U3BlY1wiOiBcIl40LjAuNFwiLFxuICAgIFwic2F2ZVNwZWNcIjogbnVsbCxcbiAgICBcImZldGNoU3BlY1wiOiBcIl40LjAuNFwiXG4gIH0sXG4gIFwiX3JlcXVpcmVkQnlcIjogW1xuICAgIFwiL1wiXG4gIF0sXG4gIFwiX3Jlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvcHJvdG9vLWNsaWVudC8tL3Byb3Rvby1jbGllbnQtNC4wLjYudGd6XCIsXG4gIFwiX3NoYXN1bVwiOiBcIjAyYTg5Zjk5N2VlNWE0ZjM4NWRhYjdiZTkzOGRkYTFhMmM1MTU4ZTRcIixcbiAgXCJfc3BlY1wiOiBcInByb3Rvby1jbGllbnRAXjQuMC40XCIsXG4gIFwiX3doZXJlXCI6IFwiL2hvbWUvdWJ1bnR1L3VtYnJlbGxhLXZvaWNlL2FwcFwiLFxuICBcImF1dGhvclwiOiB7XG4gICAgXCJuYW1lXCI6IFwiScOxYWtpIEJheiBDYXN0aWxsb1wiLFxuICAgIFwiZW1haWxcIjogXCJpYmNAYWxpYXgubmV0XCJcbiAgfSxcbiAgXCJidWdzXCI6IHtcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS9pYmMvcHJvdG9vL2lzc3Vlc1wiXG4gIH0sXG4gIFwiYnVuZGxlRGVwZW5kZW5jaWVzXCI6IGZhbHNlLFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJkZWJ1Z1wiOiBcIl40LjMuMVwiLFxuICAgIFwiZXZlbnRzXCI6IFwiXjMuMi4wXCIsXG4gICAgXCJyZXRyeVwiOiBcIl4wLjEyLjBcIixcbiAgICBcIndlYnNvY2tldFwiOiBcIl4xLjAuMzNcIlxuICB9LFxuICBcImRlcHJlY2F0ZWRcIjogZmFsc2UsXG4gIFwiZGVzY3JpcHRpb25cIjogXCJwcm90b28gSmF2YVNjcmlwdCBjbGllbnQgbW9kdWxlXCIsXG4gIFwiZGV2RGVwZW5kZW5jaWVzXCI6IHtcbiAgICBcImVzbGludFwiOiBcIl41LjE2LjBcIlxuICB9LFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49OC4wLjBcIlxuICB9LFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9wcm90b28udmVyc2F0aWNhLmNvbVwiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcIm5vZGVqc1wiLFxuICAgIFwiYnJvd3NlclwiLFxuICAgIFwid2Vic29ja2V0XCJcbiAgXSxcbiAgXCJsaWNlbnNlXCI6IFwiTUlUXCIsXG4gIFwibWFpblwiOiBcImxpYi9pbmRleC5qc1wiLFxuICBcIm5hbWVcIjogXCJwcm90b28tY2xpZW50XCIsXG4gIFwib3B0aW9uYWxEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwid2Vic29ja2V0XCI6IFwiXjEuMC4zM1wiXG4gIH0sXG4gIFwicmVwb3NpdG9yeVwiOiB7XG4gICAgXCJ0eXBlXCI6IFwiZ2l0XCIsXG4gICAgXCJ1cmxcIjogXCJnaXQraHR0cHM6Ly9naXRodWIuY29tL2liYy9wcm90b28uZ2l0XCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImxpbnRcIjogXCJlc2xpbnQgLWMgLmVzbGludHJjLmpzIGxpYlwiXG4gIH0sXG4gIFwidmVyc2lvblwiOiBcIjQuMC42XCJcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHlcbiAgLCB1bmRlZjtcblxuLyoqXG4gKiBEZWNvZGUgYSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBVUkkgZW5jb2RlZCBzdHJpbmcuXG4gKiBAcmV0dXJucyB7U3RyaW5nfE51bGx9IFRoZSBkZWNvZGVkIHN0cmluZy5cbiAqIEBhcGkgcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBkZWNvZGUoaW5wdXQpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGVjb2RlVVJJQ29tcG9uZW50KGlucHV0LnJlcGxhY2UoL1xcKy9nLCAnICcpKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHJldHVybiBudWxsO1xuICB9XG59XG5cbi8qKlxuICogQXR0ZW1wdHMgdG8gZW5jb2RlIGEgZ2l2ZW4gaW5wdXQuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGlucHV0IFRoZSBzdHJpbmcgdGhhdCBuZWVkcyB0byBiZSBlbmNvZGVkLlxuICogQHJldHVybnMge1N0cmluZ3xOdWxsfSBUaGUgZW5jb2RlZCBzdHJpbmcuXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gZW5jb2RlKGlucHV0KSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudChpbnB1dCk7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIFNpbXBsZSBxdWVyeSBzdHJpbmcgcGFyc2VyLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBxdWVyeSBUaGUgcXVlcnkgc3RyaW5nIHRoYXQgbmVlZHMgdG8gYmUgcGFyc2VkLlxuICogQHJldHVybnMge09iamVjdH1cbiAqIEBhcGkgcHVibGljXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5c3RyaW5nKHF1ZXJ5KSB7XG4gIHZhciBwYXJzZXIgPSAvKFtePT8jJl0rKT0/KFteJl0qKS9nXG4gICAgLCByZXN1bHQgPSB7fVxuICAgICwgcGFydDtcblxuICB3aGlsZSAocGFydCA9IHBhcnNlci5leGVjKHF1ZXJ5KSkge1xuICAgIHZhciBrZXkgPSBkZWNvZGUocGFydFsxXSlcbiAgICAgICwgdmFsdWUgPSBkZWNvZGUocGFydFsyXSk7XG5cbiAgICAvL1xuICAgIC8vIFByZXZlbnQgb3ZlcnJpZGluZyBvZiBleGlzdGluZyBwcm9wZXJ0aWVzLiBUaGlzIGVuc3VyZXMgdGhhdCBidWlsZC1pblxuICAgIC8vIG1ldGhvZHMgbGlrZSBgdG9TdHJpbmdgIG9yIF9fcHJvdG9fXyBhcmUgbm90IG92ZXJyaWRlbiBieSBtYWxpY2lvdXNcbiAgICAvLyBxdWVyeXN0cmluZ3MuXG4gICAgLy9cbiAgICAvLyBJbiB0aGUgY2FzZSBpZiBmYWlsZWQgZGVjb2RpbmcsIHdlIHdhbnQgdG8gb21pdCB0aGUga2V5L3ZhbHVlIHBhaXJzXG4gICAgLy8gZnJvbSB0aGUgcmVzdWx0LlxuICAgIC8vXG4gICAgaWYgKGtleSA9PT0gbnVsbCB8fCB2YWx1ZSA9PT0gbnVsbCB8fCBrZXkgaW4gcmVzdWx0KSBjb250aW51ZTtcbiAgICByZXN1bHRba2V5XSA9IHZhbHVlO1xuICB9XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBUcmFuc2Zvcm0gYSBxdWVyeSBzdHJpbmcgdG8gYW4gb2JqZWN0LlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmogT2JqZWN0IHRoYXQgc2hvdWxkIGJlIHRyYW5zZm9ybWVkLlxuICogQHBhcmFtIHtTdHJpbmd9IHByZWZpeCBPcHRpb25hbCBwcmVmaXguXG4gKiBAcmV0dXJucyB7U3RyaW5nfVxuICogQGFwaSBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gcXVlcnlzdHJpbmdpZnkob2JqLCBwcmVmaXgpIHtcbiAgcHJlZml4ID0gcHJlZml4IHx8ICcnO1xuXG4gIHZhciBwYWlycyA9IFtdXG4gICAgLCB2YWx1ZVxuICAgICwga2V5O1xuXG4gIC8vXG4gIC8vIE9wdGlvbmFsbHkgcHJlZml4IHdpdGggYSAnPycgaWYgbmVlZGVkXG4gIC8vXG4gIGlmICgnc3RyaW5nJyAhPT0gdHlwZW9mIHByZWZpeCkgcHJlZml4ID0gJz8nO1xuXG4gIGZvciAoa2V5IGluIG9iaikge1xuICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcbiAgICAgIHZhbHVlID0gb2JqW2tleV07XG5cbiAgICAgIC8vXG4gICAgICAvLyBFZGdlIGNhc2VzIHdoZXJlIHdlIGFjdHVhbGx5IHdhbnQgdG8gZW5jb2RlIHRoZSB2YWx1ZSB0byBhbiBlbXB0eVxuICAgICAgLy8gc3RyaW5nIGluc3RlYWQgb2YgdGhlIHN0cmluZ2lmaWVkIHZhbHVlLlxuICAgICAgLy9cbiAgICAgIGlmICghdmFsdWUgJiYgKHZhbHVlID09PSBudWxsIHx8IHZhbHVlID09PSB1bmRlZiB8fCBpc05hTih2YWx1ZSkpKSB7XG4gICAgICAgIHZhbHVlID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGtleSA9IGVuY29kZShrZXkpO1xuICAgICAgdmFsdWUgPSBlbmNvZGUodmFsdWUpO1xuXG4gICAgICAvL1xuICAgICAgLy8gSWYgd2UgZmFpbGVkIHRvIGVuY29kZSB0aGUgc3RyaW5ncywgd2Ugc2hvdWxkIGJhaWwgb3V0IGFzIHdlIGRvbid0XG4gICAgICAvLyB3YW50IHRvIGFkZCBpbnZhbGlkIHN0cmluZ3MgdG8gdGhlIHF1ZXJ5LlxuICAgICAgLy9cbiAgICAgIGlmIChrZXkgPT09IG51bGwgfHwgdmFsdWUgPT09IG51bGwpIGNvbnRpbnVlO1xuICAgICAgcGFpcnMucHVzaChrZXkgKyc9JysgdmFsdWUpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBwYWlycy5sZW5ndGggPyBwcmVmaXggKyBwYWlycy5qb2luKCcmJykgOiAnJztcbn1cblxuLy9cbi8vIEV4cG9zZSB0aGUgbW9kdWxlLlxuLy9cbmV4cG9ydHMuc3RyaW5naWZ5ID0gcXVlcnlzdHJpbmdpZnk7XG5leHBvcnRzLnBhcnNlID0gcXVlcnlzdHJpbmc7XG4iLCIvKipcbiAqIENvcHlyaWdodCAoYykgMjAxNC1wcmVzZW50LCBGYWNlYm9vaywgSW5jLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbnZhciBydW50aW1lID0gKGZ1bmN0aW9uIChleHBvcnRzKSB7XG4gIFwidXNlIHN0cmljdFwiO1xuXG4gIHZhciBPcCA9IE9iamVjdC5wcm90b3R5cGU7XG4gIHZhciBoYXNPd24gPSBPcC5oYXNPd25Qcm9wZXJ0eTtcbiAgdmFyIHVuZGVmaW5lZDsgLy8gTW9yZSBjb21wcmVzc2libGUgdGhhbiB2b2lkIDAuXG4gIHZhciAkU3ltYm9sID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiID8gU3ltYm9sIDoge307XG4gIHZhciBpdGVyYXRvclN5bWJvbCA9ICRTeW1ib2wuaXRlcmF0b3IgfHwgXCJAQGl0ZXJhdG9yXCI7XG4gIHZhciBhc3luY0l0ZXJhdG9yU3ltYm9sID0gJFN5bWJvbC5hc3luY0l0ZXJhdG9yIHx8IFwiQEBhc3luY0l0ZXJhdG9yXCI7XG4gIHZhciB0b1N0cmluZ1RhZ1N5bWJvbCA9ICRTeW1ib2wudG9TdHJpbmdUYWcgfHwgXCJAQHRvU3RyaW5nVGFnXCI7XG5cbiAgZnVuY3Rpb24gZGVmaW5lKG9iaiwga2V5LCB2YWx1ZSkge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gICAgcmV0dXJuIG9ialtrZXldO1xuICB9XG4gIHRyeSB7XG4gICAgLy8gSUUgOCBoYXMgYSBicm9rZW4gT2JqZWN0LmRlZmluZVByb3BlcnR5IHRoYXQgb25seSB3b3JrcyBvbiBET00gb2JqZWN0cy5cbiAgICBkZWZpbmUoe30sIFwiXCIpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBkZWZpbmUgPSBmdW5jdGlvbihvYmosIGtleSwgdmFsdWUpIHtcbiAgICAgIHJldHVybiBvYmpba2V5XSA9IHZhbHVlO1xuICAgIH07XG4gIH1cblxuICBmdW5jdGlvbiB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSB7XG4gICAgLy8gSWYgb3V0ZXJGbiBwcm92aWRlZCBhbmQgb3V0ZXJGbi5wcm90b3R5cGUgaXMgYSBHZW5lcmF0b3IsIHRoZW4gb3V0ZXJGbi5wcm90b3R5cGUgaW5zdGFuY2VvZiBHZW5lcmF0b3IuXG4gICAgdmFyIHByb3RvR2VuZXJhdG9yID0gb3V0ZXJGbiAmJiBvdXRlckZuLnByb3RvdHlwZSBpbnN0YW5jZW9mIEdlbmVyYXRvciA/IG91dGVyRm4gOiBHZW5lcmF0b3I7XG4gICAgdmFyIGdlbmVyYXRvciA9IE9iamVjdC5jcmVhdGUocHJvdG9HZW5lcmF0b3IucHJvdG90eXBlKTtcbiAgICB2YXIgY29udGV4dCA9IG5ldyBDb250ZXh0KHRyeUxvY3NMaXN0IHx8IFtdKTtcblxuICAgIC8vIFRoZSAuX2ludm9rZSBtZXRob2QgdW5pZmllcyB0aGUgaW1wbGVtZW50YXRpb25zIG9mIHRoZSAubmV4dCxcbiAgICAvLyAudGhyb3csIGFuZCAucmV0dXJuIG1ldGhvZHMuXG4gICAgZ2VuZXJhdG9yLl9pbnZva2UgPSBtYWtlSW52b2tlTWV0aG9kKGlubmVyRm4sIHNlbGYsIGNvbnRleHQpO1xuXG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBleHBvcnRzLndyYXAgPSB3cmFwO1xuXG4gIC8vIFRyeS9jYXRjaCBoZWxwZXIgdG8gbWluaW1pemUgZGVvcHRpbWl6YXRpb25zLiBSZXR1cm5zIGEgY29tcGxldGlvblxuICAvLyByZWNvcmQgbGlrZSBjb250ZXh0LnRyeUVudHJpZXNbaV0uY29tcGxldGlvbi4gVGhpcyBpbnRlcmZhY2UgY291bGRcbiAgLy8gaGF2ZSBiZWVuIChhbmQgd2FzIHByZXZpb3VzbHkpIGRlc2lnbmVkIHRvIHRha2UgYSBjbG9zdXJlIHRvIGJlXG4gIC8vIGludm9rZWQgd2l0aG91dCBhcmd1bWVudHMsIGJ1dCBpbiBhbGwgdGhlIGNhc2VzIHdlIGNhcmUgYWJvdXQgd2VcbiAgLy8gYWxyZWFkeSBoYXZlIGFuIGV4aXN0aW5nIG1ldGhvZCB3ZSB3YW50IHRvIGNhbGwsIHNvIHRoZXJlJ3Mgbm8gbmVlZFxuICAvLyB0byBjcmVhdGUgYSBuZXcgZnVuY3Rpb24gb2JqZWN0LiBXZSBjYW4gZXZlbiBnZXQgYXdheSB3aXRoIGFzc3VtaW5nXG4gIC8vIHRoZSBtZXRob2QgdGFrZXMgZXhhY3RseSBvbmUgYXJndW1lbnQsIHNpbmNlIHRoYXQgaGFwcGVucyB0byBiZSB0cnVlXG4gIC8vIGluIGV2ZXJ5IGNhc2UsIHNvIHdlIGRvbid0IGhhdmUgdG8gdG91Y2ggdGhlIGFyZ3VtZW50cyBvYmplY3QuIFRoZVxuICAvLyBvbmx5IGFkZGl0aW9uYWwgYWxsb2NhdGlvbiByZXF1aXJlZCBpcyB0aGUgY29tcGxldGlvbiByZWNvcmQsIHdoaWNoXG4gIC8vIGhhcyBhIHN0YWJsZSBzaGFwZSBhbmQgc28gaG9wZWZ1bGx5IHNob3VsZCBiZSBjaGVhcCB0byBhbGxvY2F0ZS5cbiAgZnVuY3Rpb24gdHJ5Q2F0Y2goZm4sIG9iaiwgYXJnKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwibm9ybWFsXCIsIGFyZzogZm4uY2FsbChvYmosIGFyZykgfTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHJldHVybiB7IHR5cGU6IFwidGhyb3dcIiwgYXJnOiBlcnIgfTtcbiAgICB9XG4gIH1cblxuICB2YXIgR2VuU3RhdGVTdXNwZW5kZWRTdGFydCA9IFwic3VzcGVuZGVkU3RhcnRcIjtcbiAgdmFyIEdlblN0YXRlU3VzcGVuZGVkWWllbGQgPSBcInN1c3BlbmRlZFlpZWxkXCI7XG4gIHZhciBHZW5TdGF0ZUV4ZWN1dGluZyA9IFwiZXhlY3V0aW5nXCI7XG4gIHZhciBHZW5TdGF0ZUNvbXBsZXRlZCA9IFwiY29tcGxldGVkXCI7XG5cbiAgLy8gUmV0dXJuaW5nIHRoaXMgb2JqZWN0IGZyb20gdGhlIGlubmVyRm4gaGFzIHRoZSBzYW1lIGVmZmVjdCBhc1xuICAvLyBicmVha2luZyBvdXQgb2YgdGhlIGRpc3BhdGNoIHN3aXRjaCBzdGF0ZW1lbnQuXG4gIHZhciBDb250aW51ZVNlbnRpbmVsID0ge307XG5cbiAgLy8gRHVtbXkgY29uc3RydWN0b3IgZnVuY3Rpb25zIHRoYXQgd2UgdXNlIGFzIHRoZSAuY29uc3RydWN0b3IgYW5kXG4gIC8vIC5jb25zdHJ1Y3Rvci5wcm90b3R5cGUgcHJvcGVydGllcyBmb3IgZnVuY3Rpb25zIHRoYXQgcmV0dXJuIEdlbmVyYXRvclxuICAvLyBvYmplY3RzLiBGb3IgZnVsbCBzcGVjIGNvbXBsaWFuY2UsIHlvdSBtYXkgd2lzaCB0byBjb25maWd1cmUgeW91clxuICAvLyBtaW5pZmllciBub3QgdG8gbWFuZ2xlIHRoZSBuYW1lcyBvZiB0aGVzZSB0d28gZnVuY3Rpb25zLlxuICBmdW5jdGlvbiBHZW5lcmF0b3IoKSB7fVxuICBmdW5jdGlvbiBHZW5lcmF0b3JGdW5jdGlvbigpIHt9XG4gIGZ1bmN0aW9uIEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlKCkge31cblxuICAvLyBUaGlzIGlzIGEgcG9seWZpbGwgZm9yICVJdGVyYXRvclByb3RvdHlwZSUgZm9yIGVudmlyb25tZW50cyB0aGF0XG4gIC8vIGRvbid0IG5hdGl2ZWx5IHN1cHBvcnQgaXQuXG4gIHZhciBJdGVyYXRvclByb3RvdHlwZSA9IHt9O1xuICBJdGVyYXRvclByb3RvdHlwZVtpdGVyYXRvclN5bWJvbF0gPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH07XG5cbiAgdmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xuICB2YXIgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgPSBnZXRQcm90byAmJiBnZXRQcm90byhnZXRQcm90byh2YWx1ZXMoW10pKSk7XG4gIGlmIChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSAmJlxuICAgICAgTmF0aXZlSXRlcmF0b3JQcm90b3R5cGUgIT09IE9wICYmXG4gICAgICBoYXNPd24uY2FsbChOYXRpdmVJdGVyYXRvclByb3RvdHlwZSwgaXRlcmF0b3JTeW1ib2wpKSB7XG4gICAgLy8gVGhpcyBlbnZpcm9ubWVudCBoYXMgYSBuYXRpdmUgJUl0ZXJhdG9yUHJvdG90eXBlJTsgdXNlIGl0IGluc3RlYWRcbiAgICAvLyBvZiB0aGUgcG9seWZpbGwuXG4gICAgSXRlcmF0b3JQcm90b3R5cGUgPSBOYXRpdmVJdGVyYXRvclByb3RvdHlwZTtcbiAgfVxuXG4gIHZhciBHcCA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlLnByb3RvdHlwZSA9XG4gICAgR2VuZXJhdG9yLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoSXRlcmF0b3JQcm90b3R5cGUpO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5wcm90b3R5cGUgPSBHcC5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uUHJvdG90eXBlO1xuICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZS5jb25zdHJ1Y3RvciA9IEdlbmVyYXRvckZ1bmN0aW9uO1xuICBHZW5lcmF0b3JGdW5jdGlvbi5kaXNwbGF5TmFtZSA9IGRlZmluZShcbiAgICBHZW5lcmF0b3JGdW5jdGlvblByb3RvdHlwZSxcbiAgICB0b1N0cmluZ1RhZ1N5bWJvbCxcbiAgICBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgKTtcblxuICAvLyBIZWxwZXIgZm9yIGRlZmluaW5nIHRoZSAubmV4dCwgLnRocm93LCBhbmQgLnJldHVybiBtZXRob2RzIG9mIHRoZVxuICAvLyBJdGVyYXRvciBpbnRlcmZhY2UgaW4gdGVybXMgb2YgYSBzaW5nbGUgLl9pbnZva2UgbWV0aG9kLlxuICBmdW5jdGlvbiBkZWZpbmVJdGVyYXRvck1ldGhvZHMocHJvdG90eXBlKSB7XG4gICAgW1wibmV4dFwiLCBcInRocm93XCIsIFwicmV0dXJuXCJdLmZvckVhY2goZnVuY3Rpb24obWV0aG9kKSB7XG4gICAgICBkZWZpbmUocHJvdG90eXBlLCBtZXRob2QsIGZ1bmN0aW9uKGFyZykge1xuICAgICAgICByZXR1cm4gdGhpcy5faW52b2tlKG1ldGhvZCwgYXJnKTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG5cbiAgZXhwb3J0cy5pc0dlbmVyYXRvckZ1bmN0aW9uID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgdmFyIGN0b3IgPSB0eXBlb2YgZ2VuRnVuID09PSBcImZ1bmN0aW9uXCIgJiYgZ2VuRnVuLmNvbnN0cnVjdG9yO1xuICAgIHJldHVybiBjdG9yXG4gICAgICA/IGN0b3IgPT09IEdlbmVyYXRvckZ1bmN0aW9uIHx8XG4gICAgICAgIC8vIEZvciB0aGUgbmF0aXZlIEdlbmVyYXRvckZ1bmN0aW9uIGNvbnN0cnVjdG9yLCB0aGUgYmVzdCB3ZSBjYW5cbiAgICAgICAgLy8gZG8gaXMgdG8gY2hlY2sgaXRzIC5uYW1lIHByb3BlcnR5LlxuICAgICAgICAoY3Rvci5kaXNwbGF5TmFtZSB8fCBjdG9yLm5hbWUpID09PSBcIkdlbmVyYXRvckZ1bmN0aW9uXCJcbiAgICAgIDogZmFsc2U7XG4gIH07XG5cbiAgZXhwb3J0cy5tYXJrID0gZnVuY3Rpb24oZ2VuRnVuKSB7XG4gICAgaWYgKE9iamVjdC5zZXRQcm90b3R5cGVPZikge1xuICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGdlbkZ1biwgR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGUpO1xuICAgIH0gZWxzZSB7XG4gICAgICBnZW5GdW4uX19wcm90b19fID0gR2VuZXJhdG9yRnVuY3Rpb25Qcm90b3R5cGU7XG4gICAgICBkZWZpbmUoZ2VuRnVuLCB0b1N0cmluZ1RhZ1N5bWJvbCwgXCJHZW5lcmF0b3JGdW5jdGlvblwiKTtcbiAgICB9XG4gICAgZ2VuRnVuLnByb3RvdHlwZSA9IE9iamVjdC5jcmVhdGUoR3ApO1xuICAgIHJldHVybiBnZW5GdW47XG4gIH07XG5cbiAgLy8gV2l0aGluIHRoZSBib2R5IG9mIGFueSBhc3luYyBmdW5jdGlvbiwgYGF3YWl0IHhgIGlzIHRyYW5zZm9ybWVkIHRvXG4gIC8vIGB5aWVsZCByZWdlbmVyYXRvclJ1bnRpbWUuYXdyYXAoeClgLCBzbyB0aGF0IHRoZSBydW50aW1lIGNhbiB0ZXN0XG4gIC8vIGBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpYCB0byBkZXRlcm1pbmUgaWYgdGhlIHlpZWxkZWQgdmFsdWUgaXNcbiAgLy8gbWVhbnQgdG8gYmUgYXdhaXRlZC5cbiAgZXhwb3J0cy5hd3JhcCA9IGZ1bmN0aW9uKGFyZykge1xuICAgIHJldHVybiB7IF9fYXdhaXQ6IGFyZyB9O1xuICB9O1xuXG4gIGZ1bmN0aW9uIEFzeW5jSXRlcmF0b3IoZ2VuZXJhdG9yLCBQcm9taXNlSW1wbCkge1xuICAgIGZ1bmN0aW9uIGludm9rZShtZXRob2QsIGFyZywgcmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICB2YXIgcmVjb3JkID0gdHJ5Q2F0Y2goZ2VuZXJhdG9yW21ldGhvZF0sIGdlbmVyYXRvciwgYXJnKTtcbiAgICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgIHJlamVjdChyZWNvcmQuYXJnKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciByZXN1bHQgPSByZWNvcmQuYXJnO1xuICAgICAgICB2YXIgdmFsdWUgPSByZXN1bHQudmFsdWU7XG4gICAgICAgIGlmICh2YWx1ZSAmJlxuICAgICAgICAgICAgdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmXG4gICAgICAgICAgICBoYXNPd24uY2FsbCh2YWx1ZSwgXCJfX2F3YWl0XCIpKSB7XG4gICAgICAgICAgcmV0dXJuIFByb21pc2VJbXBsLnJlc29sdmUodmFsdWUuX19hd2FpdCkudGhlbihmdW5jdGlvbih2YWx1ZSkge1xuICAgICAgICAgICAgaW52b2tlKFwibmV4dFwiLCB2YWx1ZSwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9LCBmdW5jdGlvbihlcnIpIHtcbiAgICAgICAgICAgIGludm9rZShcInRocm93XCIsIGVyciwgcmVzb2x2ZSwgcmVqZWN0KTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBQcm9taXNlSW1wbC5yZXNvbHZlKHZhbHVlKS50aGVuKGZ1bmN0aW9uKHVud3JhcHBlZCkge1xuICAgICAgICAgIC8vIFdoZW4gYSB5aWVsZGVkIFByb21pc2UgaXMgcmVzb2x2ZWQsIGl0cyBmaW5hbCB2YWx1ZSBiZWNvbWVzXG4gICAgICAgICAgLy8gdGhlIC52YWx1ZSBvZiB0aGUgUHJvbWlzZTx7dmFsdWUsZG9uZX0+IHJlc3VsdCBmb3IgdGhlXG4gICAgICAgICAgLy8gY3VycmVudCBpdGVyYXRpb24uXG4gICAgICAgICAgcmVzdWx0LnZhbHVlID0gdW53cmFwcGVkO1xuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcbiAgICAgICAgfSwgZnVuY3Rpb24oZXJyb3IpIHtcbiAgICAgICAgICAvLyBJZiBhIHJlamVjdGVkIFByb21pc2Ugd2FzIHlpZWxkZWQsIHRocm93IHRoZSByZWplY3Rpb24gYmFja1xuICAgICAgICAgIC8vIGludG8gdGhlIGFzeW5jIGdlbmVyYXRvciBmdW5jdGlvbiBzbyBpdCBjYW4gYmUgaGFuZGxlZCB0aGVyZS5cbiAgICAgICAgICByZXR1cm4gaW52b2tlKFwidGhyb3dcIiwgZXJyb3IsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBwcmV2aW91c1Byb21pc2U7XG5cbiAgICBmdW5jdGlvbiBlbnF1ZXVlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBmdW5jdGlvbiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBQcm9taXNlSW1wbChmdW5jdGlvbihyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgICBpbnZva2UobWV0aG9kLCBhcmcsIHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gcHJldmlvdXNQcm9taXNlID1cbiAgICAgICAgLy8gSWYgZW5xdWV1ZSBoYXMgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIHdlIHdhbnQgdG8gd2FpdCB1bnRpbFxuICAgICAgICAvLyBhbGwgcHJldmlvdXMgUHJvbWlzZXMgaGF2ZSBiZWVuIHJlc29sdmVkIGJlZm9yZSBjYWxsaW5nIGludm9rZSxcbiAgICAgICAgLy8gc28gdGhhdCByZXN1bHRzIGFyZSBhbHdheXMgZGVsaXZlcmVkIGluIHRoZSBjb3JyZWN0IG9yZGVyLiBJZlxuICAgICAgICAvLyBlbnF1ZXVlIGhhcyBub3QgYmVlbiBjYWxsZWQgYmVmb3JlLCB0aGVuIGl0IGlzIGltcG9ydGFudCB0b1xuICAgICAgICAvLyBjYWxsIGludm9rZSBpbW1lZGlhdGVseSwgd2l0aG91dCB3YWl0aW5nIG9uIGEgY2FsbGJhY2sgdG8gZmlyZSxcbiAgICAgICAgLy8gc28gdGhhdCB0aGUgYXN5bmMgZ2VuZXJhdG9yIGZ1bmN0aW9uIGhhcyB0aGUgb3Bwb3J0dW5pdHkgdG8gZG9cbiAgICAgICAgLy8gYW55IG5lY2Vzc2FyeSBzZXR1cCBpbiBhIHByZWRpY3RhYmxlIHdheS4gVGhpcyBwcmVkaWN0YWJpbGl0eVxuICAgICAgICAvLyBpcyB3aHkgdGhlIFByb21pc2UgY29uc3RydWN0b3Igc3luY2hyb25vdXNseSBpbnZva2VzIGl0c1xuICAgICAgICAvLyBleGVjdXRvciBjYWxsYmFjaywgYW5kIHdoeSBhc3luYyBmdW5jdGlvbnMgc3luY2hyb25vdXNseVxuICAgICAgICAvLyBleGVjdXRlIGNvZGUgYmVmb3JlIHRoZSBmaXJzdCBhd2FpdC4gU2luY2Ugd2UgaW1wbGVtZW50IHNpbXBsZVxuICAgICAgICAvLyBhc3luYyBmdW5jdGlvbnMgaW4gdGVybXMgb2YgYXN5bmMgZ2VuZXJhdG9ycywgaXQgaXMgZXNwZWNpYWxseVxuICAgICAgICAvLyBpbXBvcnRhbnQgdG8gZ2V0IHRoaXMgcmlnaHQsIGV2ZW4gdGhvdWdoIGl0IHJlcXVpcmVzIGNhcmUuXG4gICAgICAgIHByZXZpb3VzUHJvbWlzZSA/IHByZXZpb3VzUHJvbWlzZS50aGVuKFxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnLFxuICAgICAgICAgIC8vIEF2b2lkIHByb3BhZ2F0aW5nIGZhaWx1cmVzIHRvIFByb21pc2VzIHJldHVybmVkIGJ5IGxhdGVyXG4gICAgICAgICAgLy8gaW52b2NhdGlvbnMgb2YgdGhlIGl0ZXJhdG9yLlxuICAgICAgICAgIGNhbGxJbnZva2VXaXRoTWV0aG9kQW5kQXJnXG4gICAgICAgICkgOiBjYWxsSW52b2tlV2l0aE1ldGhvZEFuZEFyZygpO1xuICAgIH1cblxuICAgIC8vIERlZmluZSB0aGUgdW5pZmllZCBoZWxwZXIgbWV0aG9kIHRoYXQgaXMgdXNlZCB0byBpbXBsZW1lbnQgLm5leHQsXG4gICAgLy8gLnRocm93LCBhbmQgLnJldHVybiAoc2VlIGRlZmluZUl0ZXJhdG9yTWV0aG9kcykuXG4gICAgdGhpcy5faW52b2tlID0gZW5xdWV1ZTtcbiAgfVxuXG4gIGRlZmluZUl0ZXJhdG9yTWV0aG9kcyhBc3luY0l0ZXJhdG9yLnByb3RvdHlwZSk7XG4gIEFzeW5jSXRlcmF0b3IucHJvdG90eXBlW2FzeW5jSXRlcmF0b3JTeW1ib2xdID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuICBleHBvcnRzLkFzeW5jSXRlcmF0b3IgPSBBc3luY0l0ZXJhdG9yO1xuXG4gIC8vIE5vdGUgdGhhdCBzaW1wbGUgYXN5bmMgZnVuY3Rpb25zIGFyZSBpbXBsZW1lbnRlZCBvbiB0b3Agb2ZcbiAgLy8gQXN5bmNJdGVyYXRvciBvYmplY3RzOyB0aGV5IGp1c3QgcmV0dXJuIGEgUHJvbWlzZSBmb3IgdGhlIHZhbHVlIG9mXG4gIC8vIHRoZSBmaW5hbCByZXN1bHQgcHJvZHVjZWQgYnkgdGhlIGl0ZXJhdG9yLlxuICBleHBvcnRzLmFzeW5jID0gZnVuY3Rpb24oaW5uZXJGbiwgb3V0ZXJGbiwgc2VsZiwgdHJ5TG9jc0xpc3QsIFByb21pc2VJbXBsKSB7XG4gICAgaWYgKFByb21pc2VJbXBsID09PSB2b2lkIDApIFByb21pc2VJbXBsID0gUHJvbWlzZTtcblxuICAgIHZhciBpdGVyID0gbmV3IEFzeW5jSXRlcmF0b3IoXG4gICAgICB3cmFwKGlubmVyRm4sIG91dGVyRm4sIHNlbGYsIHRyeUxvY3NMaXN0KSxcbiAgICAgIFByb21pc2VJbXBsXG4gICAgKTtcblxuICAgIHJldHVybiBleHBvcnRzLmlzR2VuZXJhdG9yRnVuY3Rpb24ob3V0ZXJGbilcbiAgICAgID8gaXRlciAvLyBJZiBvdXRlckZuIGlzIGEgZ2VuZXJhdG9yLCByZXR1cm4gdGhlIGZ1bGwgaXRlcmF0b3IuXG4gICAgICA6IGl0ZXIubmV4dCgpLnRoZW4oZnVuY3Rpb24ocmVzdWx0KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc3VsdC5kb25lID8gcmVzdWx0LnZhbHVlIDogaXRlci5uZXh0KCk7XG4gICAgICAgIH0pO1xuICB9O1xuXG4gIGZ1bmN0aW9uIG1ha2VJbnZva2VNZXRob2QoaW5uZXJGbiwgc2VsZiwgY29udGV4dCkge1xuICAgIHZhciBzdGF0ZSA9IEdlblN0YXRlU3VzcGVuZGVkU3RhcnQ7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gaW52b2tlKG1ldGhvZCwgYXJnKSB7XG4gICAgICBpZiAoc3RhdGUgPT09IEdlblN0YXRlRXhlY3V0aW5nKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IHJ1bm5pbmdcIik7XG4gICAgICB9XG5cbiAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVDb21wbGV0ZWQpIHtcbiAgICAgICAgaWYgKG1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgdGhyb3cgYXJnO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gQmUgZm9yZ2l2aW5nLCBwZXIgMjUuMy4zLjMuMyBvZiB0aGUgc3BlYzpcbiAgICAgICAgLy8gaHR0cHM6Ly9wZW9wbGUubW96aWxsYS5vcmcvfmpvcmVuZG9yZmYvZXM2LWRyYWZ0Lmh0bWwjc2VjLWdlbmVyYXRvcnJlc3VtZVxuICAgICAgICByZXR1cm4gZG9uZVJlc3VsdCgpO1xuICAgICAgfVxuXG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgIGNvbnRleHQuYXJnID0gYXJnO1xuXG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICB2YXIgZGVsZWdhdGUgPSBjb250ZXh0LmRlbGVnYXRlO1xuICAgICAgICBpZiAoZGVsZWdhdGUpIHtcbiAgICAgICAgICB2YXIgZGVsZWdhdGVSZXN1bHQgPSBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcbiAgICAgICAgICBpZiAoZGVsZWdhdGVSZXN1bHQpIHtcbiAgICAgICAgICAgIGlmIChkZWxlZ2F0ZVJlc3VsdCA9PT0gQ29udGludWVTZW50aW5lbCkgY29udGludWU7XG4gICAgICAgICAgICByZXR1cm4gZGVsZWdhdGVSZXN1bHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGNvbnRleHQubWV0aG9kID09PSBcIm5leHRcIikge1xuICAgICAgICAgIC8vIFNldHRpbmcgY29udGV4dC5fc2VudCBmb3IgbGVnYWN5IHN1cHBvcnQgb2YgQmFiZWwnc1xuICAgICAgICAgIC8vIGZ1bmN0aW9uLnNlbnQgaW1wbGVtZW50YXRpb24uXG4gICAgICAgICAgY29udGV4dC5zZW50ID0gY29udGV4dC5fc2VudCA9IGNvbnRleHQuYXJnO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgIGlmIChzdGF0ZSA9PT0gR2VuU3RhdGVTdXNwZW5kZWRTdGFydCkge1xuICAgICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAgIHRocm93IGNvbnRleHQuYXJnO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGNvbnRleHQuZGlzcGF0Y2hFeGNlcHRpb24oY29udGV4dC5hcmcpO1xuXG4gICAgICAgIH0gZWxzZSBpZiAoY29udGV4dC5tZXRob2QgPT09IFwicmV0dXJuXCIpIHtcbiAgICAgICAgICBjb250ZXh0LmFicnVwdChcInJldHVyblwiLCBjb250ZXh0LmFyZyk7XG4gICAgICAgIH1cblxuICAgICAgICBzdGF0ZSA9IEdlblN0YXRlRXhlY3V0aW5nO1xuXG4gICAgICAgIHZhciByZWNvcmQgPSB0cnlDYXRjaChpbm5lckZuLCBzZWxmLCBjb250ZXh0KTtcbiAgICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcIm5vcm1hbFwiKSB7XG4gICAgICAgICAgLy8gSWYgYW4gZXhjZXB0aW9uIGlzIHRocm93biBmcm9tIGlubmVyRm4sIHdlIGxlYXZlIHN0YXRlID09PVxuICAgICAgICAgIC8vIEdlblN0YXRlRXhlY3V0aW5nIGFuZCBsb29wIGJhY2sgZm9yIGFub3RoZXIgaW52b2NhdGlvbi5cbiAgICAgICAgICBzdGF0ZSA9IGNvbnRleHQuZG9uZVxuICAgICAgICAgICAgPyBHZW5TdGF0ZUNvbXBsZXRlZFxuICAgICAgICAgICAgOiBHZW5TdGF0ZVN1c3BlbmRlZFlpZWxkO1xuXG4gICAgICAgICAgaWYgKHJlY29yZC5hcmcgPT09IENvbnRpbnVlU2VudGluZWwpIHtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB2YWx1ZTogcmVjb3JkLmFyZyxcbiAgICAgICAgICAgIGRvbmU6IGNvbnRleHQuZG9uZVxuICAgICAgICAgIH07XG5cbiAgICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgc3RhdGUgPSBHZW5TdGF0ZUNvbXBsZXRlZDtcbiAgICAgICAgICAvLyBEaXNwYXRjaCB0aGUgZXhjZXB0aW9uIGJ5IGxvb3BpbmcgYmFjayBhcm91bmQgdG8gdGhlXG4gICAgICAgICAgLy8gY29udGV4dC5kaXNwYXRjaEV4Y2VwdGlvbihjb250ZXh0LmFyZykgY2FsbCBhYm92ZS5cbiAgICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHJlY29yZC5hcmc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgLy8gQ2FsbCBkZWxlZ2F0ZS5pdGVyYXRvcltjb250ZXh0Lm1ldGhvZF0oY29udGV4dC5hcmcpIGFuZCBoYW5kbGUgdGhlXG4gIC8vIHJlc3VsdCwgZWl0aGVyIGJ5IHJldHVybmluZyBhIHsgdmFsdWUsIGRvbmUgfSByZXN1bHQgZnJvbSB0aGVcbiAgLy8gZGVsZWdhdGUgaXRlcmF0b3IsIG9yIGJ5IG1vZGlmeWluZyBjb250ZXh0Lm1ldGhvZCBhbmQgY29udGV4dC5hcmcsXG4gIC8vIHNldHRpbmcgY29udGV4dC5kZWxlZ2F0ZSB0byBudWxsLCBhbmQgcmV0dXJuaW5nIHRoZSBDb250aW51ZVNlbnRpbmVsLlxuICBmdW5jdGlvbiBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KSB7XG4gICAgdmFyIG1ldGhvZCA9IGRlbGVnYXRlLml0ZXJhdG9yW2NvbnRleHQubWV0aG9kXTtcbiAgICBpZiAobWV0aG9kID09PSB1bmRlZmluZWQpIHtcbiAgICAgIC8vIEEgLnRocm93IG9yIC5yZXR1cm4gd2hlbiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIG5vIC50aHJvd1xuICAgICAgLy8gbWV0aG9kIGFsd2F5cyB0ZXJtaW5hdGVzIHRoZSB5aWVsZCogbG9vcC5cbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuXG4gICAgICBpZiAoY29udGV4dC5tZXRob2QgPT09IFwidGhyb3dcIikge1xuICAgICAgICAvLyBOb3RlOiBbXCJyZXR1cm5cIl0gbXVzdCBiZSB1c2VkIGZvciBFUzMgcGFyc2luZyBjb21wYXRpYmlsaXR5LlxuICAgICAgICBpZiAoZGVsZWdhdGUuaXRlcmF0b3JbXCJyZXR1cm5cIl0pIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGVsZWdhdGUgaXRlcmF0b3IgaGFzIGEgcmV0dXJuIG1ldGhvZCwgZ2l2ZSBpdCBhXG4gICAgICAgICAgLy8gY2hhbmNlIHRvIGNsZWFuIHVwLlxuICAgICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJyZXR1cm5cIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgICBtYXliZUludm9rZURlbGVnYXRlKGRlbGVnYXRlLCBjb250ZXh0KTtcblxuICAgICAgICAgIGlmIChjb250ZXh0Lm1ldGhvZCA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICAgICAgICAvLyBJZiBtYXliZUludm9rZURlbGVnYXRlKGNvbnRleHQpIGNoYW5nZWQgY29udGV4dC5tZXRob2QgZnJvbVxuICAgICAgICAgICAgLy8gXCJyZXR1cm5cIiB0byBcInRocm93XCIsIGxldCB0aGF0IG92ZXJyaWRlIHRoZSBUeXBlRXJyb3IgYmVsb3cuXG4gICAgICAgICAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgICAgY29udGV4dC5hcmcgPSBuZXcgVHlwZUVycm9yKFxuICAgICAgICAgIFwiVGhlIGl0ZXJhdG9yIGRvZXMgbm90IHByb3ZpZGUgYSAndGhyb3cnIG1ldGhvZFwiKTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIHJlY29yZCA9IHRyeUNhdGNoKG1ldGhvZCwgZGVsZWdhdGUuaXRlcmF0b3IsIGNvbnRleHQuYXJnKTtcblxuICAgIGlmIChyZWNvcmQudHlwZSA9PT0gXCJ0aHJvd1wiKSB7XG4gICAgICBjb250ZXh0Lm1ldGhvZCA9IFwidGhyb3dcIjtcbiAgICAgIGNvbnRleHQuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgdmFyIGluZm8gPSByZWNvcmQuYXJnO1xuXG4gICAgaWYgKCEgaW5mbykge1xuICAgICAgY29udGV4dC5tZXRob2QgPSBcInRocm93XCI7XG4gICAgICBjb250ZXh0LmFyZyA9IG5ldyBUeXBlRXJyb3IoXCJpdGVyYXRvciByZXN1bHQgaXMgbm90IGFuIG9iamVjdFwiKTtcbiAgICAgIGNvbnRleHQuZGVsZWdhdGUgPSBudWxsO1xuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfVxuXG4gICAgaWYgKGluZm8uZG9uZSkge1xuICAgICAgLy8gQXNzaWduIHRoZSByZXN1bHQgb2YgdGhlIGZpbmlzaGVkIGRlbGVnYXRlIHRvIHRoZSB0ZW1wb3JhcnlcbiAgICAgIC8vIHZhcmlhYmxlIHNwZWNpZmllZCBieSBkZWxlZ2F0ZS5yZXN1bHROYW1lIChzZWUgZGVsZWdhdGVZaWVsZCkuXG4gICAgICBjb250ZXh0W2RlbGVnYXRlLnJlc3VsdE5hbWVdID0gaW5mby52YWx1ZTtcblxuICAgICAgLy8gUmVzdW1lIGV4ZWN1dGlvbiBhdCB0aGUgZGVzaXJlZCBsb2NhdGlvbiAoc2VlIGRlbGVnYXRlWWllbGQpLlxuICAgICAgY29udGV4dC5uZXh0ID0gZGVsZWdhdGUubmV4dExvYztcblxuICAgICAgLy8gSWYgY29udGV4dC5tZXRob2Qgd2FzIFwidGhyb3dcIiBidXQgdGhlIGRlbGVnYXRlIGhhbmRsZWQgdGhlXG4gICAgICAvLyBleGNlcHRpb24sIGxldCB0aGUgb3V0ZXIgZ2VuZXJhdG9yIHByb2NlZWQgbm9ybWFsbHkuIElmXG4gICAgICAvLyBjb250ZXh0Lm1ldGhvZCB3YXMgXCJuZXh0XCIsIGZvcmdldCBjb250ZXh0LmFyZyBzaW5jZSBpdCBoYXMgYmVlblxuICAgICAgLy8gXCJjb25zdW1lZFwiIGJ5IHRoZSBkZWxlZ2F0ZSBpdGVyYXRvci4gSWYgY29udGV4dC5tZXRob2Qgd2FzXG4gICAgICAvLyBcInJldHVyblwiLCBhbGxvdyB0aGUgb3JpZ2luYWwgLnJldHVybiBjYWxsIHRvIGNvbnRpbnVlIGluIHRoZVxuICAgICAgLy8gb3V0ZXIgZ2VuZXJhdG9yLlxuICAgICAgaWYgKGNvbnRleHQubWV0aG9kICE9PSBcInJldHVyblwiKSB7XG4gICAgICAgIGNvbnRleHQubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICAgIGNvbnRleHQuYXJnID0gdW5kZWZpbmVkO1xuICAgICAgfVxuXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFJlLXlpZWxkIHRoZSByZXN1bHQgcmV0dXJuZWQgYnkgdGhlIGRlbGVnYXRlIG1ldGhvZC5cbiAgICAgIHJldHVybiBpbmZvO1xuICAgIH1cblxuICAgIC8vIFRoZSBkZWxlZ2F0ZSBpdGVyYXRvciBpcyBmaW5pc2hlZCwgc28gZm9yZ2V0IGl0IGFuZCBjb250aW51ZSB3aXRoXG4gICAgLy8gdGhlIG91dGVyIGdlbmVyYXRvci5cbiAgICBjb250ZXh0LmRlbGVnYXRlID0gbnVsbDtcbiAgICByZXR1cm4gQ29udGludWVTZW50aW5lbDtcbiAgfVxuXG4gIC8vIERlZmluZSBHZW5lcmF0b3IucHJvdG90eXBlLntuZXh0LHRocm93LHJldHVybn0gaW4gdGVybXMgb2YgdGhlXG4gIC8vIHVuaWZpZWQgLl9pbnZva2UgaGVscGVyIG1ldGhvZC5cbiAgZGVmaW5lSXRlcmF0b3JNZXRob2RzKEdwKTtcblxuICBkZWZpbmUoR3AsIHRvU3RyaW5nVGFnU3ltYm9sLCBcIkdlbmVyYXRvclwiKTtcblxuICAvLyBBIEdlbmVyYXRvciBzaG91bGQgYWx3YXlzIHJldHVybiBpdHNlbGYgYXMgdGhlIGl0ZXJhdG9yIG9iamVjdCB3aGVuIHRoZVxuICAvLyBAQGl0ZXJhdG9yIGZ1bmN0aW9uIGlzIGNhbGxlZCBvbiBpdC4gU29tZSBicm93c2VycycgaW1wbGVtZW50YXRpb25zIG9mIHRoZVxuICAvLyBpdGVyYXRvciBwcm90b3R5cGUgY2hhaW4gaW5jb3JyZWN0bHkgaW1wbGVtZW50IHRoaXMsIGNhdXNpbmcgdGhlIEdlbmVyYXRvclxuICAvLyBvYmplY3QgdG8gbm90IGJlIHJldHVybmVkIGZyb20gdGhpcyBjYWxsLiBUaGlzIGVuc3VyZXMgdGhhdCBkb2Vzbid0IGhhcHBlbi5cbiAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWdlbmVyYXRvci9pc3N1ZXMvMjc0IGZvciBtb3JlIGRldGFpbHMuXG4gIEdwW2l0ZXJhdG9yU3ltYm9sXSA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9O1xuXG4gIEdwLnRvU3RyaW5nID0gZnVuY3Rpb24oKSB7XG4gICAgcmV0dXJuIFwiW29iamVjdCBHZW5lcmF0b3JdXCI7XG4gIH07XG5cbiAgZnVuY3Rpb24gcHVzaFRyeUVudHJ5KGxvY3MpIHtcbiAgICB2YXIgZW50cnkgPSB7IHRyeUxvYzogbG9jc1swXSB9O1xuXG4gICAgaWYgKDEgaW4gbG9jcykge1xuICAgICAgZW50cnkuY2F0Y2hMb2MgPSBsb2NzWzFdO1xuICAgIH1cblxuICAgIGlmICgyIGluIGxvY3MpIHtcbiAgICAgIGVudHJ5LmZpbmFsbHlMb2MgPSBsb2NzWzJdO1xuICAgICAgZW50cnkuYWZ0ZXJMb2MgPSBsb2NzWzNdO1xuICAgIH1cblxuICAgIHRoaXMudHJ5RW50cmllcy5wdXNoKGVudHJ5KTtcbiAgfVxuXG4gIGZ1bmN0aW9uIHJlc2V0VHJ5RW50cnkoZW50cnkpIHtcbiAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbiB8fCB7fTtcbiAgICByZWNvcmQudHlwZSA9IFwibm9ybWFsXCI7XG4gICAgZGVsZXRlIHJlY29yZC5hcmc7XG4gICAgZW50cnkuY29tcGxldGlvbiA9IHJlY29yZDtcbiAgfVxuXG4gIGZ1bmN0aW9uIENvbnRleHQodHJ5TG9jc0xpc3QpIHtcbiAgICAvLyBUaGUgcm9vdCBlbnRyeSBvYmplY3QgKGVmZmVjdGl2ZWx5IGEgdHJ5IHN0YXRlbWVudCB3aXRob3V0IGEgY2F0Y2hcbiAgICAvLyBvciBhIGZpbmFsbHkgYmxvY2spIGdpdmVzIHVzIGEgcGxhY2UgdG8gc3RvcmUgdmFsdWVzIHRocm93biBmcm9tXG4gICAgLy8gbG9jYXRpb25zIHdoZXJlIHRoZXJlIGlzIG5vIGVuY2xvc2luZyB0cnkgc3RhdGVtZW50LlxuICAgIHRoaXMudHJ5RW50cmllcyA9IFt7IHRyeUxvYzogXCJyb290XCIgfV07XG4gICAgdHJ5TG9jc0xpc3QuZm9yRWFjaChwdXNoVHJ5RW50cnksIHRoaXMpO1xuICAgIHRoaXMucmVzZXQodHJ1ZSk7XG4gIH1cblxuICBleHBvcnRzLmtleXMgPSBmdW5jdGlvbihvYmplY3QpIHtcbiAgICB2YXIga2V5cyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmplY3QpIHtcbiAgICAgIGtleXMucHVzaChrZXkpO1xuICAgIH1cbiAgICBrZXlzLnJldmVyc2UoKTtcblxuICAgIC8vIFJhdGhlciB0aGFuIHJldHVybmluZyBhbiBvYmplY3Qgd2l0aCBhIG5leHQgbWV0aG9kLCB3ZSBrZWVwXG4gICAgLy8gdGhpbmdzIHNpbXBsZSBhbmQgcmV0dXJuIHRoZSBuZXh0IGZ1bmN0aW9uIGl0c2VsZi5cbiAgICByZXR1cm4gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgIHdoaWxlIChrZXlzLmxlbmd0aCkge1xuICAgICAgICB2YXIga2V5ID0ga2V5cy5wb3AoKTtcbiAgICAgICAgaWYgKGtleSBpbiBvYmplY3QpIHtcbiAgICAgICAgICBuZXh0LnZhbHVlID0ga2V5O1xuICAgICAgICAgIG5leHQuZG9uZSA9IGZhbHNlO1xuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFRvIGF2b2lkIGNyZWF0aW5nIGFuIGFkZGl0aW9uYWwgb2JqZWN0LCB3ZSBqdXN0IGhhbmcgdGhlIC52YWx1ZVxuICAgICAgLy8gYW5kIC5kb25lIHByb3BlcnRpZXMgb2ZmIHRoZSBuZXh0IGZ1bmN0aW9uIG9iamVjdCBpdHNlbGYuIFRoaXNcbiAgICAgIC8vIGFsc28gZW5zdXJlcyB0aGF0IHRoZSBtaW5pZmllciB3aWxsIG5vdCBhbm9ueW1pemUgdGhlIGZ1bmN0aW9uLlxuICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcbiAgICAgIHJldHVybiBuZXh0O1xuICAgIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gdmFsdWVzKGl0ZXJhYmxlKSB7XG4gICAgaWYgKGl0ZXJhYmxlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JNZXRob2QgPSBpdGVyYWJsZVtpdGVyYXRvclN5bWJvbF07XG4gICAgICBpZiAoaXRlcmF0b3JNZXRob2QpIHtcbiAgICAgICAgcmV0dXJuIGl0ZXJhdG9yTWV0aG9kLmNhbGwoaXRlcmFibGUpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhYmxlLm5leHQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICByZXR1cm4gaXRlcmFibGU7XG4gICAgICB9XG5cbiAgICAgIGlmICghaXNOYU4oaXRlcmFibGUubGVuZ3RoKSkge1xuICAgICAgICB2YXIgaSA9IC0xLCBuZXh0ID0gZnVuY3Rpb24gbmV4dCgpIHtcbiAgICAgICAgICB3aGlsZSAoKytpIDwgaXRlcmFibGUubGVuZ3RoKSB7XG4gICAgICAgICAgICBpZiAoaGFzT3duLmNhbGwoaXRlcmFibGUsIGkpKSB7XG4gICAgICAgICAgICAgIG5leHQudmFsdWUgPSBpdGVyYWJsZVtpXTtcbiAgICAgICAgICAgICAgbmV4dC5kb25lID0gZmFsc2U7XG4gICAgICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cblxuICAgICAgICAgIG5leHQudmFsdWUgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgbmV4dC5kb25lID0gdHJ1ZTtcblxuICAgICAgICAgIHJldHVybiBuZXh0O1xuICAgICAgICB9O1xuXG4gICAgICAgIHJldHVybiBuZXh0Lm5leHQgPSBuZXh0O1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIFJldHVybiBhbiBpdGVyYXRvciB3aXRoIG5vIHZhbHVlcy5cbiAgICByZXR1cm4geyBuZXh0OiBkb25lUmVzdWx0IH07XG4gIH1cbiAgZXhwb3J0cy52YWx1ZXMgPSB2YWx1ZXM7XG5cbiAgZnVuY3Rpb24gZG9uZVJlc3VsdCgpIHtcbiAgICByZXR1cm4geyB2YWx1ZTogdW5kZWZpbmVkLCBkb25lOiB0cnVlIH07XG4gIH1cblxuICBDb250ZXh0LnByb3RvdHlwZSA9IHtcbiAgICBjb25zdHJ1Y3RvcjogQ29udGV4dCxcblxuICAgIHJlc2V0OiBmdW5jdGlvbihza2lwVGVtcFJlc2V0KSB7XG4gICAgICB0aGlzLnByZXYgPSAwO1xuICAgICAgdGhpcy5uZXh0ID0gMDtcbiAgICAgIC8vIFJlc2V0dGluZyBjb250ZXh0Ll9zZW50IGZvciBsZWdhY3kgc3VwcG9ydCBvZiBCYWJlbCdzXG4gICAgICAvLyBmdW5jdGlvbi5zZW50IGltcGxlbWVudGF0aW9uLlxuICAgICAgdGhpcy5zZW50ID0gdGhpcy5fc2VudCA9IHVuZGVmaW5lZDtcbiAgICAgIHRoaXMuZG9uZSA9IGZhbHNlO1xuICAgICAgdGhpcy5kZWxlZ2F0ZSA9IG51bGw7XG5cbiAgICAgIHRoaXMubWV0aG9kID0gXCJuZXh0XCI7XG4gICAgICB0aGlzLmFyZyA9IHVuZGVmaW5lZDtcblxuICAgICAgdGhpcy50cnlFbnRyaWVzLmZvckVhY2gocmVzZXRUcnlFbnRyeSk7XG5cbiAgICAgIGlmICghc2tpcFRlbXBSZXNldCkge1xuICAgICAgICBmb3IgKHZhciBuYW1lIGluIHRoaXMpIHtcbiAgICAgICAgICAvLyBOb3Qgc3VyZSBhYm91dCB0aGUgb3B0aW1hbCBvcmRlciBvZiB0aGVzZSBjb25kaXRpb25zOlxuICAgICAgICAgIGlmIChuYW1lLmNoYXJBdCgwKSA9PT0gXCJ0XCIgJiZcbiAgICAgICAgICAgICAgaGFzT3duLmNhbGwodGhpcywgbmFtZSkgJiZcbiAgICAgICAgICAgICAgIWlzTmFOKCtuYW1lLnNsaWNlKDEpKSkge1xuICAgICAgICAgICAgdGhpc1tuYW1lXSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgc3RvcDogZnVuY3Rpb24oKSB7XG4gICAgICB0aGlzLmRvbmUgPSB0cnVlO1xuXG4gICAgICB2YXIgcm9vdEVudHJ5ID0gdGhpcy50cnlFbnRyaWVzWzBdO1xuICAgICAgdmFyIHJvb3RSZWNvcmQgPSByb290RW50cnkuY29tcGxldGlvbjtcbiAgICAgIGlmIChyb290UmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICB0aHJvdyByb290UmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHRoaXMucnZhbDtcbiAgICB9LFxuXG4gICAgZGlzcGF0Y2hFeGNlcHRpb246IGZ1bmN0aW9uKGV4Y2VwdGlvbikge1xuICAgICAgaWYgKHRoaXMuZG9uZSkge1xuICAgICAgICB0aHJvdyBleGNlcHRpb247XG4gICAgICB9XG5cbiAgICAgIHZhciBjb250ZXh0ID0gdGhpcztcbiAgICAgIGZ1bmN0aW9uIGhhbmRsZShsb2MsIGNhdWdodCkge1xuICAgICAgICByZWNvcmQudHlwZSA9IFwidGhyb3dcIjtcbiAgICAgICAgcmVjb3JkLmFyZyA9IGV4Y2VwdGlvbjtcbiAgICAgICAgY29udGV4dC5uZXh0ID0gbG9jO1xuXG4gICAgICAgIGlmIChjYXVnaHQpIHtcbiAgICAgICAgICAvLyBJZiB0aGUgZGlzcGF0Y2hlZCBleGNlcHRpb24gd2FzIGNhdWdodCBieSBhIGNhdGNoIGJsb2NrLFxuICAgICAgICAgIC8vIHRoZW4gbGV0IHRoYXQgY2F0Y2ggYmxvY2sgaGFuZGxlIHRoZSBleGNlcHRpb24gbm9ybWFsbHkuXG4gICAgICAgICAgY29udGV4dC5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgICBjb250ZXh0LmFyZyA9IHVuZGVmaW5lZDtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiAhISBjYXVnaHQ7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcblxuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSBcInJvb3RcIikge1xuICAgICAgICAgIC8vIEV4Y2VwdGlvbiB0aHJvd24gb3V0c2lkZSBvZiBhbnkgdHJ5IGJsb2NrIHRoYXQgY291bGQgaGFuZGxlXG4gICAgICAgICAgLy8gaXQsIHNvIHNldCB0aGUgY29tcGxldGlvbiB2YWx1ZSBvZiB0aGUgZW50aXJlIGZ1bmN0aW9uIHRvXG4gICAgICAgICAgLy8gdGhyb3cgdGhlIGV4Y2VwdGlvbi5cbiAgICAgICAgICByZXR1cm4gaGFuZGxlKFwiZW5kXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYpIHtcbiAgICAgICAgICB2YXIgaGFzQ2F0Y2ggPSBoYXNPd24uY2FsbChlbnRyeSwgXCJjYXRjaExvY1wiKTtcbiAgICAgICAgICB2YXIgaGFzRmluYWxseSA9IGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIik7XG5cbiAgICAgICAgICBpZiAoaGFzQ2F0Y2ggJiYgaGFzRmluYWxseSkge1xuICAgICAgICAgICAgaWYgKHRoaXMucHJldiA8IGVudHJ5LmNhdGNoTG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuY2F0Y2hMb2MsIHRydWUpO1xuICAgICAgICAgICAgfSBlbHNlIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0NhdGNoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5wcmV2IDwgZW50cnkuY2F0Y2hMb2MpIHtcbiAgICAgICAgICAgICAgcmV0dXJuIGhhbmRsZShlbnRyeS5jYXRjaExvYywgdHJ1ZSk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2UgaWYgKGhhc0ZpbmFsbHkpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnByZXYgPCBlbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgICAgICAgIHJldHVybiBoYW5kbGUoZW50cnkuZmluYWxseUxvYyk7XG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidHJ5IHN0YXRlbWVudCB3aXRob3V0IGNhdGNoIG9yIGZpbmFsbHlcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcblxuICAgIGFicnVwdDogZnVuY3Rpb24odHlwZSwgYXJnKSB7XG4gICAgICBmb3IgKHZhciBpID0gdGhpcy50cnlFbnRyaWVzLmxlbmd0aCAtIDE7IGkgPj0gMDsgLS1pKSB7XG4gICAgICAgIHZhciBlbnRyeSA9IHRoaXMudHJ5RW50cmllc1tpXTtcbiAgICAgICAgaWYgKGVudHJ5LnRyeUxvYyA8PSB0aGlzLnByZXYgJiZcbiAgICAgICAgICAgIGhhc093bi5jYWxsKGVudHJ5LCBcImZpbmFsbHlMb2NcIikgJiZcbiAgICAgICAgICAgIHRoaXMucHJldiA8IGVudHJ5LmZpbmFsbHlMb2MpIHtcbiAgICAgICAgICB2YXIgZmluYWxseUVudHJ5ID0gZW50cnk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgaWYgKGZpbmFsbHlFbnRyeSAmJlxuICAgICAgICAgICh0eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICAgdHlwZSA9PT0gXCJjb250aW51ZVwiKSAmJlxuICAgICAgICAgIGZpbmFsbHlFbnRyeS50cnlMb2MgPD0gYXJnICYmXG4gICAgICAgICAgYXJnIDw9IGZpbmFsbHlFbnRyeS5maW5hbGx5TG9jKSB7XG4gICAgICAgIC8vIElnbm9yZSB0aGUgZmluYWxseSBlbnRyeSBpZiBjb250cm9sIGlzIG5vdCBqdW1waW5nIHRvIGFcbiAgICAgICAgLy8gbG9jYXRpb24gb3V0c2lkZSB0aGUgdHJ5L2NhdGNoIGJsb2NrLlxuICAgICAgICBmaW5hbGx5RW50cnkgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVjb3JkID0gZmluYWxseUVudHJ5ID8gZmluYWxseUVudHJ5LmNvbXBsZXRpb24gOiB7fTtcbiAgICAgIHJlY29yZC50eXBlID0gdHlwZTtcbiAgICAgIHJlY29yZC5hcmcgPSBhcmc7XG5cbiAgICAgIGlmIChmaW5hbGx5RW50cnkpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcIm5leHRcIjtcbiAgICAgICAgdGhpcy5uZXh0ID0gZmluYWxseUVudHJ5LmZpbmFsbHlMb2M7XG4gICAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gdGhpcy5jb21wbGV0ZShyZWNvcmQpO1xuICAgIH0sXG5cbiAgICBjb21wbGV0ZTogZnVuY3Rpb24ocmVjb3JkLCBhZnRlckxvYykge1xuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcInRocm93XCIpIHtcbiAgICAgICAgdGhyb3cgcmVjb3JkLmFyZztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlY29yZC50eXBlID09PSBcImJyZWFrXCIgfHxcbiAgICAgICAgICByZWNvcmQudHlwZSA9PT0gXCJjb250aW51ZVwiKSB7XG4gICAgICAgIHRoaXMubmV4dCA9IHJlY29yZC5hcmc7XG4gICAgICB9IGVsc2UgaWYgKHJlY29yZC50eXBlID09PSBcInJldHVyblwiKSB7XG4gICAgICAgIHRoaXMucnZhbCA9IHRoaXMuYXJnID0gcmVjb3JkLmFyZztcbiAgICAgICAgdGhpcy5tZXRob2QgPSBcInJldHVyblwiO1xuICAgICAgICB0aGlzLm5leHQgPSBcImVuZFwiO1xuICAgICAgfSBlbHNlIGlmIChyZWNvcmQudHlwZSA9PT0gXCJub3JtYWxcIiAmJiBhZnRlckxvYykge1xuICAgICAgICB0aGlzLm5leHQgPSBhZnRlckxvYztcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgfSxcblxuICAgIGZpbmlzaDogZnVuY3Rpb24oZmluYWxseUxvYykge1xuICAgICAgZm9yICh2YXIgaSA9IHRoaXMudHJ5RW50cmllcy5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xuICAgICAgICB2YXIgZW50cnkgPSB0aGlzLnRyeUVudHJpZXNbaV07XG4gICAgICAgIGlmIChlbnRyeS5maW5hbGx5TG9jID09PSBmaW5hbGx5TG9jKSB7XG4gICAgICAgICAgdGhpcy5jb21wbGV0ZShlbnRyeS5jb21wbGV0aW9uLCBlbnRyeS5hZnRlckxvYyk7XG4gICAgICAgICAgcmVzZXRUcnlFbnRyeShlbnRyeSk7XG4gICAgICAgICAgcmV0dXJuIENvbnRpbnVlU2VudGluZWw7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuXG4gICAgXCJjYXRjaFwiOiBmdW5jdGlvbih0cnlMb2MpIHtcbiAgICAgIGZvciAodmFyIGkgPSB0aGlzLnRyeUVudHJpZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyAtLWkpIHtcbiAgICAgICAgdmFyIGVudHJ5ID0gdGhpcy50cnlFbnRyaWVzW2ldO1xuICAgICAgICBpZiAoZW50cnkudHJ5TG9jID09PSB0cnlMb2MpIHtcbiAgICAgICAgICB2YXIgcmVjb3JkID0gZW50cnkuY29tcGxldGlvbjtcbiAgICAgICAgICBpZiAocmVjb3JkLnR5cGUgPT09IFwidGhyb3dcIikge1xuICAgICAgICAgICAgdmFyIHRocm93biA9IHJlY29yZC5hcmc7XG4gICAgICAgICAgICByZXNldFRyeUVudHJ5KGVudHJ5KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHRocm93bjtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyBUaGUgY29udGV4dC5jYXRjaCBtZXRob2QgbXVzdCBvbmx5IGJlIGNhbGxlZCB3aXRoIGEgbG9jYXRpb25cbiAgICAgIC8vIGFyZ3VtZW50IHRoYXQgY29ycmVzcG9uZHMgdG8gYSBrbm93biBjYXRjaCBibG9jay5cbiAgICAgIHRocm93IG5ldyBFcnJvcihcImlsbGVnYWwgY2F0Y2ggYXR0ZW1wdFwiKTtcbiAgICB9LFxuXG4gICAgZGVsZWdhdGVZaWVsZDogZnVuY3Rpb24oaXRlcmFibGUsIHJlc3VsdE5hbWUsIG5leHRMb2MpIHtcbiAgICAgIHRoaXMuZGVsZWdhdGUgPSB7XG4gICAgICAgIGl0ZXJhdG9yOiB2YWx1ZXMoaXRlcmFibGUpLFxuICAgICAgICByZXN1bHROYW1lOiByZXN1bHROYW1lLFxuICAgICAgICBuZXh0TG9jOiBuZXh0TG9jXG4gICAgICB9O1xuXG4gICAgICBpZiAodGhpcy5tZXRob2QgPT09IFwibmV4dFwiKSB7XG4gICAgICAgIC8vIERlbGliZXJhdGVseSBmb3JnZXQgdGhlIGxhc3Qgc2VudCB2YWx1ZSBzbyB0aGF0IHdlIGRvbid0XG4gICAgICAgIC8vIGFjY2lkZW50YWxseSBwYXNzIGl0IG9uIHRvIHRoZSBkZWxlZ2F0ZS5cbiAgICAgICAgdGhpcy5hcmcgPSB1bmRlZmluZWQ7XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBDb250aW51ZVNlbnRpbmVsO1xuICAgIH1cbiAgfTtcblxuICAvLyBSZWdhcmRsZXNzIG9mIHdoZXRoZXIgdGhpcyBzY3JpcHQgaXMgZXhlY3V0aW5nIGFzIGEgQ29tbW9uSlMgbW9kdWxlXG4gIC8vIG9yIG5vdCwgcmV0dXJuIHRoZSBydW50aW1lIG9iamVjdCBzbyB0aGF0IHdlIGNhbiBkZWNsYXJlIHRoZSB2YXJpYWJsZVxuICAvLyByZWdlbmVyYXRvclJ1bnRpbWUgaW4gdGhlIG91dGVyIHNjb3BlLCB3aGljaCBhbGxvd3MgdGhpcyBtb2R1bGUgdG8gYmVcbiAgLy8gaW5qZWN0ZWQgZWFzaWx5IGJ5IGBiaW4vcmVnZW5lcmF0b3IgLS1pbmNsdWRlLXJ1bnRpbWUgc2NyaXB0LmpzYC5cbiAgcmV0dXJuIGV4cG9ydHM7XG5cbn0oXG4gIC8vIElmIHRoaXMgc2NyaXB0IGlzIGV4ZWN1dGluZyBhcyBhIENvbW1vbkpTIG1vZHVsZSwgdXNlIG1vZHVsZS5leHBvcnRzXG4gIC8vIGFzIHRoZSByZWdlbmVyYXRvclJ1bnRpbWUgbmFtZXNwYWNlLiBPdGhlcndpc2UgY3JlYXRlIGEgbmV3IGVtcHR5XG4gIC8vIG9iamVjdC4gRWl0aGVyIHdheSwgdGhlIHJlc3VsdGluZyBvYmplY3Qgd2lsbCBiZSB1c2VkIHRvIGluaXRpYWxpemVcbiAgLy8gdGhlIHJlZ2VuZXJhdG9yUnVudGltZSB2YXJpYWJsZSBhdCB0aGUgdG9wIG9mIHRoaXMgZmlsZS5cbiAgdHlwZW9mIG1vZHVsZSA9PT0gXCJvYmplY3RcIiA/IG1vZHVsZS5leHBvcnRzIDoge31cbikpO1xuXG50cnkge1xuICByZWdlbmVyYXRvclJ1bnRpbWUgPSBydW50aW1lO1xufSBjYXRjaCAoYWNjaWRlbnRhbFN0cmljdE1vZGUpIHtcbiAgLy8gVGhpcyBtb2R1bGUgc2hvdWxkIG5vdCBiZSBydW5uaW5nIGluIHN0cmljdCBtb2RlLCBzbyB0aGUgYWJvdmVcbiAgLy8gYXNzaWdubWVudCBzaG91bGQgYWx3YXlzIHdvcmsgdW5sZXNzIHNvbWV0aGluZyBpcyBtaXNjb25maWd1cmVkLiBKdXN0XG4gIC8vIGluIGNhc2UgcnVudGltZS5qcyBhY2NpZGVudGFsbHkgcnVucyBpbiBzdHJpY3QgbW9kZSwgd2UgY2FuIGVzY2FwZVxuICAvLyBzdHJpY3QgbW9kZSB1c2luZyBhIGdsb2JhbCBGdW5jdGlvbiBjYWxsLiBUaGlzIGNvdWxkIGNvbmNlaXZhYmx5IGZhaWxcbiAgLy8gaWYgYSBDb250ZW50IFNlY3VyaXR5IFBvbGljeSBmb3JiaWRzIHVzaW5nIEZ1bmN0aW9uLCBidXQgaW4gdGhhdCBjYXNlXG4gIC8vIHRoZSBwcm9wZXIgc29sdXRpb24gaXMgdG8gZml4IHRoZSBhY2NpZGVudGFsIHN0cmljdCBtb2RlIHByb2JsZW0uIElmXG4gIC8vIHlvdSd2ZSBtaXNjb25maWd1cmVkIHlvdXIgYnVuZGxlciB0byBmb3JjZSBzdHJpY3QgbW9kZSBhbmQgYXBwbGllZCBhXG4gIC8vIENTUCB0byBmb3JiaWQgRnVuY3Rpb24sIGFuZCB5b3UncmUgbm90IHdpbGxpbmcgdG8gZml4IGVpdGhlciBvZiB0aG9zZVxuICAvLyBwcm9ibGVtcywgcGxlYXNlIGRldGFpbCB5b3VyIHVuaXF1ZSBwcmVkaWNhbWVudCBpbiBhIEdpdEh1YiBpc3N1ZS5cbiAgRnVuY3Rpb24oXCJyXCIsIFwicmVnZW5lcmF0b3JSdW50aW1lID0gclwiKShydW50aW1lKTtcbn1cbiIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBDaGVjayBpZiB3ZSdyZSByZXF1aXJlZCB0byBhZGQgYSBwb3J0IG51bWJlci5cbiAqXG4gKiBAc2VlIGh0dHBzOi8vdXJsLnNwZWMud2hhdHdnLm9yZy8jZGVmYXVsdC1wb3J0XG4gKiBAcGFyYW0ge051bWJlcnxTdHJpbmd9IHBvcnQgUG9ydCBudW1iZXIgd2UgbmVlZCB0byBjaGVja1xuICogQHBhcmFtIHtTdHJpbmd9IHByb3RvY29sIFByb3RvY29sIHdlIG5lZWQgdG8gY2hlY2sgYWdhaW5zdC5cbiAqIEByZXR1cm5zIHtCb29sZWFufSBJcyBpdCBhIGRlZmF1bHQgcG9ydCBmb3IgdGhlIGdpdmVuIHByb3RvY29sXG4gKiBAYXBpIHByaXZhdGVcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiByZXF1aXJlZChwb3J0LCBwcm90b2NvbCkge1xuICBwcm90b2NvbCA9IHByb3RvY29sLnNwbGl0KCc6JylbMF07XG4gIHBvcnQgPSArcG9ydDtcblxuICBpZiAoIXBvcnQpIHJldHVybiBmYWxzZTtcblxuICBzd2l0Y2ggKHByb3RvY29sKSB7XG4gICAgY2FzZSAnaHR0cCc6XG4gICAgY2FzZSAnd3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA4MDtcblxuICAgIGNhc2UgJ2h0dHBzJzpcbiAgICBjYXNlICd3c3MnOlxuICAgIHJldHVybiBwb3J0ICE9PSA0NDM7XG5cbiAgICBjYXNlICdmdHAnOlxuICAgIHJldHVybiBwb3J0ICE9PSAyMTtcblxuICAgIGNhc2UgJ2dvcGhlcic6XG4gICAgcmV0dXJuIHBvcnQgIT09IDcwO1xuXG4gICAgY2FzZSAnZmlsZSc6XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIHBvcnQgIT09IDA7XG59O1xuIiwibW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2xpYi9yZXRyeScpOyIsInZhciBSZXRyeU9wZXJhdGlvbiA9IHJlcXVpcmUoJy4vcmV0cnlfb3BlcmF0aW9uJyk7XG5cbmV4cG9ydHMub3BlcmF0aW9uID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICB2YXIgdGltZW91dHMgPSBleHBvcnRzLnRpbWVvdXRzKG9wdGlvbnMpO1xuICByZXR1cm4gbmV3IFJldHJ5T3BlcmF0aW9uKHRpbWVvdXRzLCB7XG4gICAgICBmb3JldmVyOiBvcHRpb25zICYmIG9wdGlvbnMuZm9yZXZlcixcbiAgICAgIHVucmVmOiBvcHRpb25zICYmIG9wdGlvbnMudW5yZWYsXG4gICAgICBtYXhSZXRyeVRpbWU6IG9wdGlvbnMgJiYgb3B0aW9ucy5tYXhSZXRyeVRpbWVcbiAgfSk7XG59O1xuXG5leHBvcnRzLnRpbWVvdXRzID0gZnVuY3Rpb24ob3B0aW9ucykge1xuICBpZiAob3B0aW9ucyBpbnN0YW5jZW9mIEFycmF5KSB7XG4gICAgcmV0dXJuIFtdLmNvbmNhdChvcHRpb25zKTtcbiAgfVxuXG4gIHZhciBvcHRzID0ge1xuICAgIHJldHJpZXM6IDEwLFxuICAgIGZhY3RvcjogMixcbiAgICBtaW5UaW1lb3V0OiAxICogMTAwMCxcbiAgICBtYXhUaW1lb3V0OiBJbmZpbml0eSxcbiAgICByYW5kb21pemU6IGZhbHNlXG4gIH07XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zKSB7XG4gICAgb3B0c1trZXldID0gb3B0aW9uc1trZXldO1xuICB9XG5cbiAgaWYgKG9wdHMubWluVGltZW91dCA+IG9wdHMubWF4VGltZW91dCkge1xuICAgIHRocm93IG5ldyBFcnJvcignbWluVGltZW91dCBpcyBncmVhdGVyIHRoYW4gbWF4VGltZW91dCcpO1xuICB9XG5cbiAgdmFyIHRpbWVvdXRzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgb3B0cy5yZXRyaWVzOyBpKyspIHtcbiAgICB0aW1lb3V0cy5wdXNoKHRoaXMuY3JlYXRlVGltZW91dChpLCBvcHRzKSk7XG4gIH1cblxuICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmZvcmV2ZXIgJiYgIXRpbWVvdXRzLmxlbmd0aCkge1xuICAgIHRpbWVvdXRzLnB1c2godGhpcy5jcmVhdGVUaW1lb3V0KGksIG9wdHMpKTtcbiAgfVxuXG4gIC8vIHNvcnQgdGhlIGFycmF5IG51bWVyaWNhbGx5IGFzY2VuZGluZ1xuICB0aW1lb3V0cy5zb3J0KGZ1bmN0aW9uKGEsYikge1xuICAgIHJldHVybiBhIC0gYjtcbiAgfSk7XG5cbiAgcmV0dXJuIHRpbWVvdXRzO1xufTtcblxuZXhwb3J0cy5jcmVhdGVUaW1lb3V0ID0gZnVuY3Rpb24oYXR0ZW1wdCwgb3B0cykge1xuICB2YXIgcmFuZG9tID0gKG9wdHMucmFuZG9taXplKVxuICAgID8gKE1hdGgucmFuZG9tKCkgKyAxKVxuICAgIDogMTtcblxuICB2YXIgdGltZW91dCA9IE1hdGgucm91bmQocmFuZG9tICogb3B0cy5taW5UaW1lb3V0ICogTWF0aC5wb3cob3B0cy5mYWN0b3IsIGF0dGVtcHQpKTtcbiAgdGltZW91dCA9IE1hdGgubWluKHRpbWVvdXQsIG9wdHMubWF4VGltZW91dCk7XG5cbiAgcmV0dXJuIHRpbWVvdXQ7XG59O1xuXG5leHBvcnRzLndyYXAgPSBmdW5jdGlvbihvYmosIG9wdGlvbnMsIG1ldGhvZHMpIHtcbiAgaWYgKG9wdGlvbnMgaW5zdGFuY2VvZiBBcnJheSkge1xuICAgIG1ldGhvZHMgPSBvcHRpb25zO1xuICAgIG9wdGlvbnMgPSBudWxsO1xuICB9XG5cbiAgaWYgKCFtZXRob2RzKSB7XG4gICAgbWV0aG9kcyA9IFtdO1xuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcbiAgICAgIGlmICh0eXBlb2Ygb2JqW2tleV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgbWV0aG9kcy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXRob2RzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG1ldGhvZCAgID0gbWV0aG9kc1tpXTtcbiAgICB2YXIgb3JpZ2luYWwgPSBvYmpbbWV0aG9kXTtcblxuICAgIG9ialttZXRob2RdID0gZnVuY3Rpb24gcmV0cnlXcmFwcGVyKG9yaWdpbmFsKSB7XG4gICAgICB2YXIgb3AgICAgICAgPSBleHBvcnRzLm9wZXJhdGlvbihvcHRpb25zKTtcbiAgICAgIHZhciBhcmdzICAgICA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgICB2YXIgY2FsbGJhY2sgPSBhcmdzLnBvcCgpO1xuXG4gICAgICBhcmdzLnB1c2goZnVuY3Rpb24oZXJyKSB7XG4gICAgICAgIGlmIChvcC5yZXRyeShlcnIpKSB7XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICBhcmd1bWVudHNbMF0gPSBvcC5tYWluRXJyb3IoKTtcbiAgICAgICAgfVxuICAgICAgICBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgICAgfSk7XG5cbiAgICAgIG9wLmF0dGVtcHQoZnVuY3Rpb24oKSB7XG4gICAgICAgIG9yaWdpbmFsLmFwcGx5KG9iaiwgYXJncyk7XG4gICAgICB9KTtcbiAgICB9LmJpbmQob2JqLCBvcmlnaW5hbCk7XG4gICAgb2JqW21ldGhvZF0ub3B0aW9ucyA9IG9wdGlvbnM7XG4gIH1cbn07XG4iLCJmdW5jdGlvbiBSZXRyeU9wZXJhdGlvbih0aW1lb3V0cywgb3B0aW9ucykge1xuICAvLyBDb21wYXRpYmlsaXR5IGZvciB0aGUgb2xkICh0aW1lb3V0cywgcmV0cnlGb3JldmVyKSBzaWduYXR1cmVcbiAgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnYm9vbGVhbicpIHtcbiAgICBvcHRpb25zID0geyBmb3JldmVyOiBvcHRpb25zIH07XG4gIH1cblxuICB0aGlzLl9vcmlnaW5hbFRpbWVvdXRzID0gSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeSh0aW1lb3V0cykpO1xuICB0aGlzLl90aW1lb3V0cyA9IHRpbWVvdXRzO1xuICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgdGhpcy5fbWF4UmV0cnlUaW1lID0gb3B0aW9ucyAmJiBvcHRpb25zLm1heFJldHJ5VGltZSB8fCBJbmZpbml0eTtcbiAgdGhpcy5fZm4gPSBudWxsO1xuICB0aGlzLl9lcnJvcnMgPSBbXTtcbiAgdGhpcy5fYXR0ZW1wdHMgPSAxO1xuICB0aGlzLl9vcGVyYXRpb25UaW1lb3V0ID0gbnVsbDtcbiAgdGhpcy5fb3BlcmF0aW9uVGltZW91dENiID0gbnVsbDtcbiAgdGhpcy5fdGltZW91dCA9IG51bGw7XG4gIHRoaXMuX29wZXJhdGlvblN0YXJ0ID0gbnVsbDtcblxuICBpZiAodGhpcy5fb3B0aW9ucy5mb3JldmVyKSB7XG4gICAgdGhpcy5fY2FjaGVkVGltZW91dHMgPSB0aGlzLl90aW1lb3V0cy5zbGljZSgwKTtcbiAgfVxufVxubW9kdWxlLmV4cG9ydHMgPSBSZXRyeU9wZXJhdGlvbjtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnJlc2V0ID0gZnVuY3Rpb24oKSB7XG4gIHRoaXMuX2F0dGVtcHRzID0gMTtcbiAgdGhpcy5fdGltZW91dHMgPSB0aGlzLl9vcmlnaW5hbFRpbWVvdXRzO1xufVxuXG5SZXRyeU9wZXJhdGlvbi5wcm90b3R5cGUuc3RvcCA9IGZ1bmN0aW9uKCkge1xuICBpZiAodGhpcy5fdGltZW91dCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgfVxuXG4gIHRoaXMuX3RpbWVvdXRzICAgICAgID0gW107XG4gIHRoaXMuX2NhY2hlZFRpbWVvdXRzID0gbnVsbDtcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5yZXRyeSA9IGZ1bmN0aW9uKGVycikge1xuICBpZiAodGhpcy5fdGltZW91dCkge1xuICAgIGNsZWFyVGltZW91dCh0aGlzLl90aW1lb3V0KTtcbiAgfVxuXG4gIGlmICghZXJyKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHZhciBjdXJyZW50VGltZSA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICBpZiAoZXJyICYmIGN1cnJlbnRUaW1lIC0gdGhpcy5fb3BlcmF0aW9uU3RhcnQgPj0gdGhpcy5fbWF4UmV0cnlUaW1lKSB7XG4gICAgdGhpcy5fZXJyb3JzLnVuc2hpZnQobmV3IEVycm9yKCdSZXRyeU9wZXJhdGlvbiB0aW1lb3V0IG9jY3VycmVkJykpO1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuXG4gIHRoaXMuX2Vycm9ycy5wdXNoKGVycik7XG5cbiAgdmFyIHRpbWVvdXQgPSB0aGlzLl90aW1lb3V0cy5zaGlmdCgpO1xuICBpZiAodGltZW91dCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgaWYgKHRoaXMuX2NhY2hlZFRpbWVvdXRzKSB7XG4gICAgICAvLyByZXRyeSBmb3JldmVyLCBvbmx5IGtlZXAgbGFzdCBlcnJvclxuICAgICAgdGhpcy5fZXJyb3JzLnNwbGljZSh0aGlzLl9lcnJvcnMubGVuZ3RoIC0gMSwgdGhpcy5fZXJyb3JzLmxlbmd0aCk7XG4gICAgICB0aGlzLl90aW1lb3V0cyA9IHRoaXMuX2NhY2hlZFRpbWVvdXRzLnNsaWNlKDApO1xuICAgICAgdGltZW91dCA9IHRoaXMuX3RpbWVvdXRzLnNoaWZ0KCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gIH1cblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciB0aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24oKSB7XG4gICAgc2VsZi5fYXR0ZW1wdHMrKztcblxuICAgIGlmIChzZWxmLl9vcGVyYXRpb25UaW1lb3V0Q2IpIHtcbiAgICAgIHNlbGYuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgICBzZWxmLl9vcGVyYXRpb25UaW1lb3V0Q2Ioc2VsZi5fYXR0ZW1wdHMpO1xuICAgICAgfSwgc2VsZi5fb3BlcmF0aW9uVGltZW91dCk7XG5cbiAgICAgIGlmIChzZWxmLl9vcHRpb25zLnVucmVmKSB7XG4gICAgICAgICAgc2VsZi5fdGltZW91dC51bnJlZigpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHNlbGYuX2ZuKHNlbGYuX2F0dGVtcHRzKTtcbiAgfSwgdGltZW91dCk7XG5cbiAgaWYgKHRoaXMuX29wdGlvbnMudW5yZWYpIHtcbiAgICAgIHRpbWVyLnVucmVmKCk7XG4gIH1cblxuICByZXR1cm4gdHJ1ZTtcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5hdHRlbXB0ID0gZnVuY3Rpb24oZm4sIHRpbWVvdXRPcHMpIHtcbiAgdGhpcy5fZm4gPSBmbjtcblxuICBpZiAodGltZW91dE9wcykge1xuICAgIGlmICh0aW1lb3V0T3BzLnRpbWVvdXQpIHtcbiAgICAgIHRoaXMuX29wZXJhdGlvblRpbWVvdXQgPSB0aW1lb3V0T3BzLnRpbWVvdXQ7XG4gICAgfVxuICAgIGlmICh0aW1lb3V0T3BzLmNiKSB7XG4gICAgICB0aGlzLl9vcGVyYXRpb25UaW1lb3V0Q2IgPSB0aW1lb3V0T3BzLmNiO1xuICAgIH1cbiAgfVxuXG4gIHZhciBzZWxmID0gdGhpcztcbiAgaWYgKHRoaXMuX29wZXJhdGlvblRpbWVvdXRDYikge1xuICAgIHRoaXMuX3RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uKCkge1xuICAgICAgc2VsZi5fb3BlcmF0aW9uVGltZW91dENiKCk7XG4gICAgfSwgc2VsZi5fb3BlcmF0aW9uVGltZW91dCk7XG4gIH1cblxuICB0aGlzLl9vcGVyYXRpb25TdGFydCA9IG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuXG4gIHRoaXMuX2ZuKHRoaXMuX2F0dGVtcHRzKTtcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS50cnkgPSBmdW5jdGlvbihmbikge1xuICBjb25zb2xlLmxvZygnVXNpbmcgUmV0cnlPcGVyYXRpb24udHJ5KCkgaXMgZGVwcmVjYXRlZCcpO1xuICB0aGlzLmF0dGVtcHQoZm4pO1xufTtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnN0YXJ0ID0gZnVuY3Rpb24oZm4pIHtcbiAgY29uc29sZS5sb2coJ1VzaW5nIFJldHJ5T3BlcmF0aW9uLnN0YXJ0KCkgaXMgZGVwcmVjYXRlZCcpO1xuICB0aGlzLmF0dGVtcHQoZm4pO1xufTtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnN0YXJ0ID0gUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLnRyeTtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLmVycm9ycyA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gdGhpcy5fZXJyb3JzO1xufTtcblxuUmV0cnlPcGVyYXRpb24ucHJvdG90eXBlLmF0dGVtcHRzID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB0aGlzLl9hdHRlbXB0cztcbn07XG5cblJldHJ5T3BlcmF0aW9uLnByb3RvdHlwZS5tYWluRXJyb3IgPSBmdW5jdGlvbigpIHtcbiAgaWYgKHRoaXMuX2Vycm9ycy5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBjb3VudHMgPSB7fTtcbiAgdmFyIG1haW5FcnJvciA9IG51bGw7XG4gIHZhciBtYWluRXJyb3JDb3VudCA9IDA7XG5cbiAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLl9lcnJvcnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZXJyb3IgPSB0aGlzLl9lcnJvcnNbaV07XG4gICAgdmFyIG1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xuICAgIHZhciBjb3VudCA9IChjb3VudHNbbWVzc2FnZV0gfHwgMCkgKyAxO1xuXG4gICAgY291bnRzW21lc3NhZ2VdID0gY291bnQ7XG5cbiAgICBpZiAoY291bnQgPj0gbWFpbkVycm9yQ291bnQpIHtcbiAgICAgIG1haW5FcnJvciA9IGVycm9yO1xuICAgICAgbWFpbkVycm9yQ291bnQgPSBjb3VudDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gbWFpbkVycm9yO1xufTtcbiIsInZhciBncmFtbWFyID0gbW9kdWxlLmV4cG9ydHMgPSB7XG4gIHY6IFt7XG4gICAgbmFtZTogJ3ZlcnNpb24nLFxuICAgIHJlZzogL14oXFxkKikkL1xuICB9XSxcbiAgbzogW3tcbiAgICAvLyBvPS0gMjA1MTggMCBJTiBJUDQgMjAzLjAuMTEzLjFcbiAgICAvLyBOQjogc2Vzc2lvbklkIHdpbGwgYmUgYSBTdHJpbmcgaW4gbW9zdCBjYXNlcyBiZWNhdXNlIGl0IGlzIGh1Z2VcbiAgICBuYW1lOiAnb3JpZ2luJyxcbiAgICByZWc6IC9eKFxcUyopIChcXGQqKSAoXFxkKikgKFxcUyopIElQKFxcZCkgKFxcUyopLyxcbiAgICBuYW1lczogWyd1c2VybmFtZScsICdzZXNzaW9uSWQnLCAnc2Vzc2lvblZlcnNpb24nLCAnbmV0VHlwZScsICdpcFZlcicsICdhZGRyZXNzJ10sXG4gICAgZm9ybWF0OiAnJXMgJXMgJWQgJXMgSVAlZCAlcydcbiAgfV0sXG4gIC8vIGRlZmF1bHQgcGFyc2luZyBvZiB0aGVzZSBvbmx5ICh0aG91Z2ggc29tZSBvZiB0aGVzZSBmZWVsIG91dGRhdGVkKVxuICBzOiBbeyBuYW1lOiAnbmFtZScgfV0sXG4gIGk6IFt7IG5hbWU6ICdkZXNjcmlwdGlvbicgfV0sXG4gIHU6IFt7IG5hbWU6ICd1cmknIH1dLFxuICBlOiBbeyBuYW1lOiAnZW1haWwnIH1dLFxuICBwOiBbeyBuYW1lOiAncGhvbmUnIH1dLFxuICB6OiBbeyBuYW1lOiAndGltZXpvbmVzJyB9XSwgLy8gVE9ETzogdGhpcyBvbmUgY2FuIGFjdHVhbGx5IGJlIHBhcnNlZCBwcm9wZXJseS4uLlxuICByOiBbeyBuYW1lOiAncmVwZWF0cycgfV0sICAgLy8gVE9ETzogdGhpcyBvbmUgY2FuIGFsc28gYmUgcGFyc2VkIHByb3Blcmx5XG4gIC8vIGs6IFt7fV0sIC8vIG91dGRhdGVkIHRoaW5nIGlnbm9yZWRcbiAgdDogW3tcbiAgICAvLyB0PTAgMFxuICAgIG5hbWU6ICd0aW1pbmcnLFxuICAgIHJlZzogL14oXFxkKikgKFxcZCopLyxcbiAgICBuYW1lczogWydzdGFydCcsICdzdG9wJ10sXG4gICAgZm9ybWF0OiAnJWQgJWQnXG4gIH1dLFxuICBjOiBbe1xuICAgIC8vIGM9SU4gSVA0IDEwLjQ3LjE5Ny4yNlxuICAgIG5hbWU6ICdjb25uZWN0aW9uJyxcbiAgICByZWc6IC9eSU4gSVAoXFxkKSAoXFxTKikvLFxuICAgIG5hbWVzOiBbJ3ZlcnNpb24nLCAnaXAnXSxcbiAgICBmb3JtYXQ6ICdJTiBJUCVkICVzJ1xuICB9XSxcbiAgYjogW3tcbiAgICAvLyBiPUFTOjQwMDBcbiAgICBwdXNoOiAnYmFuZHdpZHRoJyxcbiAgICByZWc6IC9eKFRJQVN8QVN8Q1R8UlJ8UlMpOihcXGQqKS8sXG4gICAgbmFtZXM6IFsndHlwZScsICdsaW1pdCddLFxuICAgIGZvcm1hdDogJyVzOiVzJ1xuICB9XSxcbiAgbTogW3tcbiAgICAvLyBtPXZpZGVvIDUxNzQ0IFJUUC9BVlAgMTI2IDk3IDk4IDM0IDMxXG4gICAgLy8gTkI6IHNwZWNpYWwgLSBwdXNoZXMgdG8gc2Vzc2lvblxuICAgIC8vIFRPRE86IHJ0cC9mbXRwIHNob3VsZCBiZSBmaWx0ZXJlZCBieSB0aGUgcGF5bG9hZHMgZm91bmQgaGVyZT9cbiAgICByZWc6IC9eKFxcdyopIChcXGQqKSAoW1xcdy9dKikoPzogKC4qKSk/LyxcbiAgICBuYW1lczogWyd0eXBlJywgJ3BvcnQnLCAncHJvdG9jb2wnLCAncGF5bG9hZHMnXSxcbiAgICBmb3JtYXQ6ICclcyAlZCAlcyAlcydcbiAgfV0sXG4gIGE6IFtcbiAgICB7XG4gICAgICAvLyBhPXJ0cG1hcDoxMTAgb3B1cy80ODAwMC8yXG4gICAgICBwdXNoOiAncnRwJyxcbiAgICAgIHJlZzogL15ydHBtYXA6KFxcZCopIChbXFx3XFwtLl0qKSg/OlxccypcXC8oXFxkKikoPzpcXHMqXFwvKFxcUyopKT8pPy8sXG4gICAgICBuYW1lczogWydwYXlsb2FkJywgJ2NvZGVjJywgJ3JhdGUnLCAnZW5jb2RpbmcnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChvLmVuY29kaW5nKVxuICAgICAgICAgID8gJ3J0cG1hcDolZCAlcy8lcy8lcydcbiAgICAgICAgICA6IG8ucmF0ZVxuICAgICAgICAgICAgPyAncnRwbWFwOiVkICVzLyVzJ1xuICAgICAgICAgICAgOiAncnRwbWFwOiVkICVzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Zm10cDoxMDggcHJvZmlsZS1sZXZlbC1pZD0yNDtvYmplY3Q9MjM7Yml0cmF0ZT02NDAwMFxuICAgICAgLy8gYT1mbXRwOjExMSBtaW5wdGltZT0xMDsgdXNlaW5iYW5kZmVjPTFcbiAgICAgIHB1c2g6ICdmbXRwJyxcbiAgICAgIHJlZzogL15mbXRwOihcXGQqKSAoW1xcU3wgXSopLyxcbiAgICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAnY29uZmlnJ10sXG4gICAgICBmb3JtYXQ6ICdmbXRwOiVkICVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1jb250cm9sOnN0cmVhbWlkPTBcbiAgICAgIG5hbWU6ICdjb250cm9sJyxcbiAgICAgIHJlZzogL15jb250cm9sOiguKikvLFxuICAgICAgZm9ybWF0OiAnY29udHJvbDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cnRjcDo2NTE3OSBJTiBJUDQgMTkzLjg0Ljc3LjE5NFxuICAgICAgbmFtZTogJ3J0Y3AnLFxuICAgICAgcmVnOiAvXnJ0Y3A6KFxcZCopKD86IChcXFMqKSBJUChcXGQpIChcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ3BvcnQnLCAnbmV0VHlwZScsICdpcFZlcicsICdhZGRyZXNzJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoby5hZGRyZXNzICE9IG51bGwpXG4gICAgICAgICAgPyAncnRjcDolZCAlcyBJUCVkICVzJ1xuICAgICAgICAgIDogJ3J0Y3A6JWQnO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1ydGNwLWZiOjk4IHRyci1pbnQgMTAwXG4gICAgICBwdXNoOiAncnRjcEZiVHJySW50JyxcbiAgICAgIHJlZzogL15ydGNwLWZiOihcXCp8XFxkKikgdHJyLWludCAoXFxkKikvLFxuICAgICAgbmFtZXM6IFsncGF5bG9hZCcsICd2YWx1ZSddLFxuICAgICAgZm9ybWF0OiAncnRjcC1mYjolcyB0cnItaW50ICVkJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1ydGNwLWZiOjk4IG5hY2sgcnBzaVxuICAgICAgcHVzaDogJ3J0Y3BGYicsXG4gICAgICByZWc6IC9ecnRjcC1mYjooXFwqfFxcZCopIChbXFx3LV9dKikoPzogKFtcXHctX10qKSk/LyxcbiAgICAgIG5hbWVzOiBbJ3BheWxvYWQnLCAndHlwZScsICdzdWJ0eXBlJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoby5zdWJ0eXBlICE9IG51bGwpXG4gICAgICAgICAgPyAncnRjcC1mYjolcyAlcyAlcydcbiAgICAgICAgICA6ICdydGNwLWZiOiVzICVzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9ZXh0bWFwOjIgdXJuOmlldGY6cGFyYW1zOnJ0cC1oZHJleHQ6dG9mZnNldFxuICAgICAgLy8gYT1leHRtYXA6MS9yZWN2b25seSBVUkktZ3BzLXN0cmluZ1xuICAgICAgLy8gYT1leHRtYXA6MyB1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDplbmNyeXB0IHVybjppZXRmOnBhcmFtczpydHAtaGRyZXh0OnNtcHRlLXRjIDI1QDYwMC8yNFxuICAgICAgcHVzaDogJ2V4dCcsXG4gICAgICByZWc6IC9eZXh0bWFwOihcXGQrKSg/OlxcLyhcXHcrKSk/KD86ICh1cm46aWV0ZjpwYXJhbXM6cnRwLWhkcmV4dDplbmNyeXB0KSk/IChcXFMqKSg/OiAoXFxTKikpPy8sXG4gICAgICBuYW1lczogWyd2YWx1ZScsICdkaXJlY3Rpb24nLCAnZW5jcnlwdC11cmknLCAndXJpJywgJ2NvbmZpZyddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICdleHRtYXA6JWQnICtcbiAgICAgICAgICAoby5kaXJlY3Rpb24gPyAnLyVzJyA6ICcldicpICtcbiAgICAgICAgICAob1snZW5jcnlwdC11cmknXSA/ICcgJXMnIDogJyV2JykgK1xuICAgICAgICAgICcgJXMnICtcbiAgICAgICAgICAoby5jb25maWcgPyAnICVzJyA6ICcnKVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1leHRtYXAtYWxsb3ctbWl4ZWRcbiAgICAgIG5hbWU6ICdleHRtYXBBbGxvd01peGVkJyxcbiAgICAgIHJlZzogL14oZXh0bWFwLWFsbG93LW1peGVkKS9cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Y3J5cHRvOjEgQUVTX0NNXzEyOF9ITUFDX1NIQTFfODAgaW5saW5lOlBTMXVRQ1ZlZUNGQ2FuVm1jamtwUHl3ak5XaGNZRDBtWFh0eGFWQlJ8Ml4yMHwxOjMyXG4gICAgICBwdXNoOiAnY3J5cHRvJyxcbiAgICAgIHJlZzogL15jcnlwdG86KFxcZCopIChbXFx3X10qKSAoXFxTKikoPzogKFxcUyopKT8vLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnc3VpdGUnLCAnY29uZmlnJywgJ3Nlc3Npb25Db25maWcnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuIChvLnNlc3Npb25Db25maWcgIT0gbnVsbClcbiAgICAgICAgICA/ICdjcnlwdG86JWQgJXMgJXMgJXMnXG4gICAgICAgICAgOiAnY3J5cHRvOiVkICVzICVzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9c2V0dXA6YWN0cGFzc1xuICAgICAgbmFtZTogJ3NldHVwJyxcbiAgICAgIHJlZzogL15zZXR1cDooXFx3KikvLFxuICAgICAgZm9ybWF0OiAnc2V0dXA6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWNvbm5lY3Rpb246bmV3XG4gICAgICBuYW1lOiAnY29ubmVjdGlvblR5cGUnLFxuICAgICAgcmVnOiAvXmNvbm5lY3Rpb246KG5ld3xleGlzdGluZykvLFxuICAgICAgZm9ybWF0OiAnY29ubmVjdGlvbjolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9bWlkOjFcbiAgICAgIG5hbWU6ICdtaWQnLFxuICAgICAgcmVnOiAvXm1pZDooW15cXHNdKikvLFxuICAgICAgZm9ybWF0OiAnbWlkOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1tc2lkOjBjOGIwNjRkLWQ4MDctNDNiNC1iNDM0LWY5MmE4ODlkODU4NyA5ODE3ODY4NS1kNDA5LTQ2ZTAtOGUxNi03ZWYwZGIwZGI2NGFcbiAgICAgIG5hbWU6ICdtc2lkJyxcbiAgICAgIHJlZzogL15tc2lkOiguKikvLFxuICAgICAgZm9ybWF0OiAnbXNpZDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cHRpbWU6MjBcbiAgICAgIG5hbWU6ICdwdGltZScsXG4gICAgICByZWc6IC9ecHRpbWU6KFxcZCooPzpcXC5cXGQqKSopLyxcbiAgICAgIGZvcm1hdDogJ3B0aW1lOiVkJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1tYXhwdGltZTo2MFxuICAgICAgbmFtZTogJ21heHB0aW1lJyxcbiAgICAgIHJlZzogL15tYXhwdGltZTooXFxkKig/OlxcLlxcZCopKikvLFxuICAgICAgZm9ybWF0OiAnbWF4cHRpbWU6JWQnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXNlbmRyZWN2XG4gICAgICBuYW1lOiAnZGlyZWN0aW9uJyxcbiAgICAgIHJlZzogL14oc2VuZHJlY3Z8cmVjdm9ubHl8c2VuZG9ubHl8aW5hY3RpdmUpL1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1pY2UtbGl0ZVxuICAgICAgbmFtZTogJ2ljZWxpdGUnLFxuICAgICAgcmVnOiAvXihpY2UtbGl0ZSkvXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWljZS11ZnJhZzpGN2dJXG4gICAgICBuYW1lOiAnaWNlVWZyYWcnLFxuICAgICAgcmVnOiAvXmljZS11ZnJhZzooXFxTKikvLFxuICAgICAgZm9ybWF0OiAnaWNlLXVmcmFnOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1pY2UtcHdkOng5Y21sL1l6aWNoVjIrWGxoaU11OGdcbiAgICAgIG5hbWU6ICdpY2VQd2QnLFxuICAgICAgcmVnOiAvXmljZS1wd2Q6KFxcUyopLyxcbiAgICAgIGZvcm1hdDogJ2ljZS1wd2Q6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWZpbmdlcnByaW50OlNIQS0xIDAwOjExOjIyOjMzOjQ0OjU1OjY2Ojc3Ojg4Ojk5OkFBOkJCOkNDOkREOkVFOkZGOjAwOjExOjIyOjMzXG4gICAgICBuYW1lOiAnZmluZ2VycHJpbnQnLFxuICAgICAgcmVnOiAvXmZpbmdlcnByaW50OihcXFMqKSAoXFxTKikvLFxuICAgICAgbmFtZXM6IFsndHlwZScsICdoYXNoJ10sXG4gICAgICBmb3JtYXQ6ICdmaW5nZXJwcmludDolcyAlcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjAgMSBVRFAgMjExMzY2NzMyNyAyMDMuMC4xMTMuMSA1NDQwMCB0eXAgaG9zdFxuICAgICAgLy8gYT1jYW5kaWRhdGU6MTE2Mjg3NTA4MSAxIHVkcCAyMTEzOTM3MTUxIDE5Mi4xNjguMzQuNzUgNjAwMTcgdHlwIGhvc3QgZ2VuZXJhdGlvbiAwIG5ldHdvcmstaWQgMyBuZXR3b3JrLWNvc3QgMTBcbiAgICAgIC8vIGE9Y2FuZGlkYXRlOjMyODk5MTI5NTcgMiB1ZHAgMTg0NTUwMTY5NSAxOTMuODQuNzcuMTk0IDYwMDE3IHR5cCBzcmZseCByYWRkciAxOTIuMTY4LjM0Ljc1IHJwb3J0IDYwMDE3IGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXG4gICAgICAvLyBhPWNhbmRpZGF0ZToyMjk4MTU2MjAgMSB0Y3AgMTUxODI4MDQ0NyAxOTIuMTY4LjE1MC4xOSA2MDAxNyB0eXAgaG9zdCB0Y3B0eXBlIGFjdGl2ZSBnZW5lcmF0aW9uIDAgbmV0d29yay1pZCAzIG5ldHdvcmstY29zdCAxMFxuICAgICAgLy8gYT1jYW5kaWRhdGU6MzI4OTkxMjk1NyAyIHRjcCAxODQ1NTAxNjk1IDE5My44NC43Ny4xOTQgNjAwMTcgdHlwIHNyZmx4IHJhZGRyIDE5Mi4xNjguMzQuNzUgcnBvcnQgNjAwMTcgdGNwdHlwZSBwYXNzaXZlIGdlbmVyYXRpb24gMCBuZXR3b3JrLWlkIDMgbmV0d29yay1jb3N0IDEwXG4gICAgICBwdXNoOidjYW5kaWRhdGVzJyxcbiAgICAgIHJlZzogL15jYW5kaWRhdGU6KFxcUyopIChcXGQqKSAoXFxTKikgKFxcZCopIChcXFMqKSAoXFxkKikgdHlwIChcXFMqKSg/OiByYWRkciAoXFxTKikgcnBvcnQgKFxcZCopKT8oPzogdGNwdHlwZSAoXFxTKikpPyg/OiBnZW5lcmF0aW9uIChcXGQqKSk/KD86IG5ldHdvcmstaWQgKFxcZCopKT8oPzogbmV0d29yay1jb3N0IChcXGQqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2ZvdW5kYXRpb24nLCAnY29tcG9uZW50JywgJ3RyYW5zcG9ydCcsICdwcmlvcml0eScsICdpcCcsICdwb3J0JywgJ3R5cGUnLCAncmFkZHInLCAncnBvcnQnLCAndGNwdHlwZScsICdnZW5lcmF0aW9uJywgJ25ldHdvcmstaWQnLCAnbmV0d29yay1jb3N0J10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHZhciBzdHIgPSAnY2FuZGlkYXRlOiVzICVkICVzICVkICVzICVkIHR5cCAlcyc7XG5cbiAgICAgICAgc3RyICs9IChvLnJhZGRyICE9IG51bGwpID8gJyByYWRkciAlcyBycG9ydCAlZCcgOiAnJXYldic7XG5cbiAgICAgICAgLy8gTkI6IGNhbmRpZGF0ZSBoYXMgdGhyZWUgb3B0aW9uYWwgY2h1bmtzLCBzbyAldm9pZCBtaWRkbGVzIG9uZSBpZiBpdCdzIG1pc3NpbmdcbiAgICAgICAgc3RyICs9IChvLnRjcHR5cGUgIT0gbnVsbCkgPyAnIHRjcHR5cGUgJXMnIDogJyV2JztcblxuICAgICAgICBpZiAoby5nZW5lcmF0aW9uICE9IG51bGwpIHtcbiAgICAgICAgICBzdHIgKz0gJyBnZW5lcmF0aW9uICVkJztcbiAgICAgICAgfVxuXG4gICAgICAgIHN0ciArPSAob1snbmV0d29yay1pZCddICE9IG51bGwpID8gJyBuZXR3b3JrLWlkICVkJyA6ICcldic7XG4gICAgICAgIHN0ciArPSAob1snbmV0d29yay1jb3N0J10gIT0gbnVsbCkgPyAnIG5ldHdvcmstY29zdCAlZCcgOiAnJXYnO1xuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1lbmQtb2YtY2FuZGlkYXRlcyAoa2VlcCBhZnRlciB0aGUgY2FuZGlkYXRlcyBsaW5lIGZvciByZWFkYWJpbGl0eSlcbiAgICAgIG5hbWU6ICdlbmRPZkNhbmRpZGF0ZXMnLFxuICAgICAgcmVnOiAvXihlbmQtb2YtY2FuZGlkYXRlcykvXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXJlbW90ZS1jYW5kaWRhdGVzOjEgMjAzLjAuMTEzLjEgNTQ0MDAgMiAyMDMuMC4xMTMuMSA1NDQwMSAuLi5cbiAgICAgIG5hbWU6ICdyZW1vdGVDYW5kaWRhdGVzJyxcbiAgICAgIHJlZzogL15yZW1vdGUtY2FuZGlkYXRlczooLiopLyxcbiAgICAgIGZvcm1hdDogJ3JlbW90ZS1jYW5kaWRhdGVzOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1pY2Utb3B0aW9uczpnb29nbGUtaWNlXG4gICAgICBuYW1lOiAnaWNlT3B0aW9ucycsXG4gICAgICByZWc6IC9eaWNlLW9wdGlvbnM6KFxcUyopLyxcbiAgICAgIGZvcm1hdDogJ2ljZS1vcHRpb25zOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1zc3JjOjI1NjYxMDc1NjkgY25hbWU6dDlZVThNMVV4VEY4WTFBMVxuICAgICAgcHVzaDogJ3NzcmNzJyxcbiAgICAgIHJlZzogL15zc3JjOihcXGQqKSAoW1xcd18tXSopKD86OiguKikpPy8sXG4gICAgICBuYW1lczogWydpZCcsICdhdHRyaWJ1dGUnLCAndmFsdWUnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgdmFyIHN0ciA9ICdzc3JjOiVkJztcbiAgICAgICAgaWYgKG8uYXR0cmlidXRlICE9IG51bGwpIHtcbiAgICAgICAgICBzdHIgKz0gJyAlcyc7XG4gICAgICAgICAgaWYgKG8udmFsdWUgIT0gbnVsbCkge1xuICAgICAgICAgICAgc3RyICs9ICc6JXMnO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gc3RyO1xuICAgICAgfVxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1zc3JjLWdyb3VwOkZFQyAxIDJcbiAgICAgIC8vIGE9c3NyYy1ncm91cDpGRUMtRlIgMzAwNDM2NDE5NSAxMDgwNzcyMjQxXG4gICAgICBwdXNoOiAnc3NyY0dyb3VwcycsXG4gICAgICAvLyB0b2tlbi1jaGFyID0gJXgyMSAvICV4MjMtMjcgLyAleDJBLTJCIC8gJXgyRC0yRSAvICV4MzAtMzkgLyAleDQxLTVBIC8gJXg1RS03RVxuICAgICAgcmVnOiAvXnNzcmMtZ3JvdXA6KFtcXHgyMVxceDIzXFx4MjRcXHgyNVxceDI2XFx4MjdcXHgyQVxceDJCXFx4MkRcXHgyRVxcd10qKSAoLiopLyxcbiAgICAgIG5hbWVzOiBbJ3NlbWFudGljcycsICdzc3JjcyddLFxuICAgICAgZm9ybWF0OiAnc3NyYy1ncm91cDolcyAlcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9bXNpZC1zZW1hbnRpYzogV01TIEp2bGFtNVgzU1gxT1A2cG4yMHpXb2d2YUtKejVIamY5T25sVlxuICAgICAgbmFtZTogJ21zaWRTZW1hbnRpYycsXG4gICAgICByZWc6IC9ebXNpZC1zZW1hbnRpYzpcXHM/KFxcdyopIChcXFMqKS8sXG4gICAgICBuYW1lczogWydzZW1hbnRpYycsICd0b2tlbiddLFxuICAgICAgZm9ybWF0OiAnbXNpZC1zZW1hbnRpYzogJXMgJXMnIC8vIHNwYWNlIGFmdGVyICc6JyBpcyBub3QgYWNjaWRlbnRhbFxuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1ncm91cDpCVU5ETEUgYXVkaW8gdmlkZW9cbiAgICAgIHB1c2g6ICdncm91cHMnLFxuICAgICAgcmVnOiAvXmdyb3VwOihcXHcqKSAoLiopLyxcbiAgICAgIG5hbWVzOiBbJ3R5cGUnLCAnbWlkcyddLFxuICAgICAgZm9ybWF0OiAnZ3JvdXA6JXMgJXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXJ0Y3AtbXV4XG4gICAgICBuYW1lOiAncnRjcE11eCcsXG4gICAgICByZWc6IC9eKHJ0Y3AtbXV4KS9cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9cnRjcC1yc2l6ZVxuICAgICAgbmFtZTogJ3J0Y3BSc2l6ZScsXG4gICAgICByZWc6IC9eKHJ0Y3AtcnNpemUpL1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1zY3RwbWFwOjUwMDAgd2VicnRjLWRhdGFjaGFubmVsIDEwMjRcbiAgICAgIG5hbWU6ICdzY3RwbWFwJyxcbiAgICAgIHJlZzogL15zY3RwbWFwOihbXFx3Xy9dKikgKFxcUyopKD86IChcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ3NjdHBtYXBOdW1iZXInLCAnYXBwJywgJ21heE1lc3NhZ2VTaXplJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoby5tYXhNZXNzYWdlU2l6ZSAhPSBudWxsKVxuICAgICAgICAgID8gJ3NjdHBtYXA6JXMgJXMgJXMnXG4gICAgICAgICAgOiAnc2N0cG1hcDolcyAlcyc7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXgtZ29vZ2xlLWZsYWc6Y29uZmVyZW5jZVxuICAgICAgbmFtZTogJ3hHb29nbGVGbGFnJyxcbiAgICAgIHJlZzogL154LWdvb2dsZS1mbGFnOihbXlxcc10qKS8sXG4gICAgICBmb3JtYXQ6ICd4LWdvb2dsZS1mbGFnOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1yaWQ6MSBzZW5kIG1heC13aWR0aD0xMjgwO21heC1oZWlnaHQ9NzIwO21heC1mcHM9MzA7ZGVwZW5kPTBcbiAgICAgIHB1c2g6ICdyaWRzJyxcbiAgICAgIHJlZzogL15yaWQ6KFtcXGRcXHddKykgKFxcdyspKD86IChbXFxTfCBdKikpPy8sXG4gICAgICBuYW1lczogWydpZCcsICdkaXJlY3Rpb24nLCAncGFyYW1zJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAoby5wYXJhbXMpID8gJ3JpZDolcyAlcyAlcycgOiAncmlkOiVzICVzJztcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9aW1hZ2VhdHRyOjk3IHNlbmQgW3g9ODAwLHk9NjQwLHNhcj0xLjEscT0wLjZdIFt4PTQ4MCx5PTMyMF0gcmVjdiBbeD0zMzAseT0yNTBdXG4gICAgICAvLyBhPWltYWdlYXR0cjoqIHNlbmQgW3g9ODAwLHk9NjQwXSByZWN2ICpcbiAgICAgIC8vIGE9aW1hZ2VhdHRyOjEwMCByZWN2IFt4PTMyMCx5PTI0MF1cbiAgICAgIHB1c2g6ICdpbWFnZWF0dHJzJyxcbiAgICAgIHJlZzogbmV3IFJlZ0V4cChcbiAgICAgICAgLy8gYT1pbWFnZWF0dHI6OTdcbiAgICAgICAgJ15pbWFnZWF0dHI6KFxcXFxkK3xcXFxcKiknICtcbiAgICAgICAgLy8gc2VuZCBbeD04MDAseT02NDAsc2FyPTEuMSxxPTAuNl0gW3g9NDgwLHk9MzIwXVxuICAgICAgICAnW1xcXFxzXFxcXHRdKyhzZW5kfHJlY3YpW1xcXFxzXFxcXHRdKyhcXFxcKnxcXFxcW1xcXFxTK1xcXFxdKD86W1xcXFxzXFxcXHRdK1xcXFxbXFxcXFMrXFxcXF0pKiknICtcbiAgICAgICAgLy8gcmVjdiBbeD0zMzAseT0yNTBdXG4gICAgICAgICcoPzpbXFxcXHNcXFxcdF0rKHJlY3Z8c2VuZClbXFxcXHNcXFxcdF0rKFxcXFwqfFxcXFxbXFxcXFMrXFxcXF0oPzpbXFxcXHNcXFxcdF0rXFxcXFtcXFxcUytcXFxcXSkqKSk/J1xuICAgICAgKSxcbiAgICAgIG5hbWVzOiBbJ3B0JywgJ2RpcjEnLCAnYXR0cnMxJywgJ2RpcjInLCAnYXR0cnMyJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAnaW1hZ2VhdHRyOiVzICVzICVzJyArIChvLmRpcjIgPyAnICVzICVzJyA6ICcnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGE9c2ltdWxjYXN0OnNlbmQgMSwyLDM7fjQsfjUgcmVjdiA2O343LH44XG4gICAgICAvLyBhPXNpbXVsY2FzdDpyZWN2IDE7NCw1IHNlbmQgNjs3XG4gICAgICBuYW1lOiAnc2ltdWxjYXN0JyxcbiAgICAgIHJlZzogbmV3IFJlZ0V4cChcbiAgICAgICAgLy8gYT1zaW11bGNhc3Q6XG4gICAgICAgICdec2ltdWxjYXN0OicgK1xuICAgICAgICAvLyBzZW5kIDEsMiwzO340LH41XG4gICAgICAgICcoc2VuZHxyZWN2KSAoW2EtekEtWjAtOVxcXFwtX347LF0rKScgK1xuICAgICAgICAvLyBzcGFjZSArIHJlY3YgNjt+Nyx+OFxuICAgICAgICAnKD86XFxcXHM/KHNlbmR8cmVjdikgKFthLXpBLVowLTlcXFxcLV9+OyxdKykpPycgK1xuICAgICAgICAvLyBlbmRcbiAgICAgICAgJyQnXG4gICAgICApLFxuICAgICAgbmFtZXM6IFsnZGlyMScsICdsaXN0MScsICdkaXIyJywgJ2xpc3QyJ10sXG4gICAgICBmb3JtYXQ6IGZ1bmN0aW9uIChvKSB7XG4gICAgICAgIHJldHVybiAnc2ltdWxjYXN0OiVzICVzJyArIChvLmRpcjIgPyAnICVzICVzJyA6ICcnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIG9sZCBzaW11bGNhc3QgZHJhZnQgMDMgKGltcGxlbWVudGVkIGJ5IEZpcmVmb3gpXG4gICAgICAvLyAgIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLW1tdXNpYy1zZHAtc2ltdWxjYXN0LTAzXG4gICAgICAvLyBhPXNpbXVsY2FzdDogcmVjdiBwdD05Nzs5OCBzZW5kIHB0PTk3XG4gICAgICAvLyBhPXNpbXVsY2FzdDogc2VuZCByaWQ9NTs2OzcgcGF1c2VkPTYsN1xuICAgICAgbmFtZTogJ3NpbXVsY2FzdF8wMycsXG4gICAgICByZWc6IC9ec2ltdWxjYXN0OltcXHNcXHRdKyhbXFxTK1xcc1xcdF0rKSQvLFxuICAgICAgbmFtZXM6IFsndmFsdWUnXSxcbiAgICAgIGZvcm1hdDogJ3NpbXVsY2FzdDogJXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWZyYW1lcmF0ZToyNVxuICAgICAgLy8gYT1mcmFtZXJhdGU6MjkuOTdcbiAgICAgIG5hbWU6ICdmcmFtZXJhdGUnLFxuICAgICAgcmVnOiAvXmZyYW1lcmF0ZTooXFxkKyg/OiR8XFwuXFxkKykpLyxcbiAgICAgIGZvcm1hdDogJ2ZyYW1lcmF0ZTolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIFJGQzQ1NzBcbiAgICAgIC8vIGE9c291cmNlLWZpbHRlcjogaW5jbCBJTiBJUDQgMjM5LjUuMi4zMSAxMC4xLjE1LjVcbiAgICAgIG5hbWU6ICdzb3VyY2VGaWx0ZXInLFxuICAgICAgcmVnOiAvXnNvdXJjZS1maWx0ZXI6ICooZXhjbHxpbmNsKSAoXFxTKikgKElQNHxJUDZ8XFwqKSAoXFxTKikgKC4qKS8sXG4gICAgICBuYW1lczogWydmaWx0ZXJNb2RlJywgJ25ldFR5cGUnLCAnYWRkcmVzc1R5cGVzJywgJ2Rlc3RBZGRyZXNzJywgJ3NyY0xpc3QnXSxcbiAgICAgIGZvcm1hdDogJ3NvdXJjZS1maWx0ZXI6ICVzICVzICVzICVzICVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1idW5kbGUtb25seVxuICAgICAgbmFtZTogJ2J1bmRsZU9ubHknLFxuICAgICAgcmVnOiAvXihidW5kbGUtb25seSkvXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWxhYmVsOjFcbiAgICAgIG5hbWU6ICdsYWJlbCcsXG4gICAgICByZWc6IC9ebGFiZWw6KC4rKS8sXG4gICAgICBmb3JtYXQ6ICdsYWJlbDolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIFJGQyB2ZXJzaW9uIDI2IGZvciBTQ1RQIG92ZXIgRFRMU1xuICAgICAgLy8gaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL2RyYWZ0LWlldGYtbW11c2ljLXNjdHAtc2RwLTI2I3NlY3Rpb24tNVxuICAgICAgbmFtZTogJ3NjdHBQb3J0JyxcbiAgICAgIHJlZzogL15zY3RwLXBvcnQ6KFxcZCspJC8sXG4gICAgICBmb3JtYXQ6ICdzY3RwLXBvcnQ6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBSRkMgdmVyc2lvbiAyNiBmb3IgU0NUUCBvdmVyIERUTFNcbiAgICAgIC8vIGh0dHBzOi8vdG9vbHMuaWV0Zi5vcmcvaHRtbC9kcmFmdC1pZXRmLW1tdXNpYy1zY3RwLXNkcC0yNiNzZWN0aW9uLTZcbiAgICAgIG5hbWU6ICdtYXhNZXNzYWdlU2l6ZScsXG4gICAgICByZWc6IC9ebWF4LW1lc3NhZ2Utc2l6ZTooXFxkKykkLyxcbiAgICAgIGZvcm1hdDogJ21heC1tZXNzYWdlLXNpemU6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBSRkM3MjczXG4gICAgICAvLyBhPXRzLXJlZmNsazpwdHA9SUVFRTE1ODgtMjAwODozOS1BNy05NC1GRi1GRS0wNy1DQi1EMDozN1xuICAgICAgcHVzaDondHNSZWZDbG9ja3MnLFxuICAgICAgcmVnOiAvXnRzLXJlZmNsazooW15cXHM9XSopKD86PShcXFMqKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2Nsa3NyYycsICdjbGtzcmNFeHQnXSxcbiAgICAgIGZvcm1hdDogZnVuY3Rpb24gKG8pIHtcbiAgICAgICAgcmV0dXJuICd0cy1yZWZjbGs6JXMnICsgKG8uY2xrc3JjRXh0ICE9IG51bGwgPyAnPSVzJyA6ICcnKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIFJGQzcyNzNcbiAgICAgIC8vIGE9bWVkaWFjbGs6ZGlyZWN0PTk2MzIxNDQyNFxuICAgICAgbmFtZTonbWVkaWFDbGsnLFxuICAgICAgcmVnOiAvXm1lZGlhY2xrOig/OmlkPShcXFMqKSk/ICooW15cXHM9XSopKD86PShcXFMqKSk/KD86ICpyYXRlPShcXGQrKVxcLyhcXGQrKSk/LyxcbiAgICAgIG5hbWVzOiBbJ2lkJywgJ21lZGlhQ2xvY2tOYW1lJywgJ21lZGlhQ2xvY2tWYWx1ZScsICdyYXRlTnVtZXJhdG9yJywgJ3JhdGVEZW5vbWluYXRvciddLFxuICAgICAgZm9ybWF0OiBmdW5jdGlvbiAobykge1xuICAgICAgICB2YXIgc3RyID0gJ21lZGlhY2xrOic7XG4gICAgICAgIHN0ciArPSAoby5pZCAhPSBudWxsID8gJ2lkPSVzICVzJyA6ICcldiVzJyk7XG4gICAgICAgIHN0ciArPSAoby5tZWRpYUNsb2NrVmFsdWUgIT0gbnVsbCA/ICc9JXMnIDogJycpO1xuICAgICAgICBzdHIgKz0gKG8ucmF0ZU51bWVyYXRvciAhPSBudWxsID8gJyByYXRlPSVzJyA6ICcnKTtcbiAgICAgICAgc3RyICs9IChvLnJhdGVEZW5vbWluYXRvciAhPSBudWxsID8gJy8lcycgOiAnJyk7XG4gICAgICAgIHJldHVybiBzdHI7XG4gICAgICB9XG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWtleXdkczprZXl3b3Jkc1xuICAgICAgbmFtZTogJ2tleXdvcmRzJyxcbiAgICAgIHJlZzogL15rZXl3ZHM6KC4rKSQvLFxuICAgICAgZm9ybWF0OiAna2V5d2RzOiVzJ1xuICAgIH0sXG4gICAge1xuICAgICAgLy8gYT1jb250ZW50Om1haW5cbiAgICAgIG5hbWU6ICdjb250ZW50JyxcbiAgICAgIHJlZzogL15jb250ZW50OiguKykvLFxuICAgICAgZm9ybWF0OiAnY29udGVudDolcydcbiAgICB9LFxuICAgIC8vIEJGQ1AgaHR0cHM6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ1ODNcbiAgICB7XG4gICAgICAvLyBhPWZsb29yY3RybDpjLXNcbiAgICAgIG5hbWU6ICdiZmNwRmxvb3JDdHJsJyxcbiAgICAgIHJlZzogL15mbG9vcmN0cmw6KGMtb25seXxzLW9ubHl8Yy1zKS8sXG4gICAgICBmb3JtYXQ6ICdmbG9vcmN0cmw6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWNvbmZpZDoxXG4gICAgICBuYW1lOiAnYmZjcENvbmZJZCcsXG4gICAgICByZWc6IC9eY29uZmlkOihcXGQrKS8sXG4gICAgICBmb3JtYXQ6ICdjb25maWQ6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPXVzZXJpZDoxXG4gICAgICBuYW1lOiAnYmZjcFVzZXJJZCcsXG4gICAgICByZWc6IC9edXNlcmlkOihcXGQrKS8sXG4gICAgICBmb3JtYXQ6ICd1c2VyaWQ6JXMnXG4gICAgfSxcbiAgICB7XG4gICAgICAvLyBhPWZsb29yaWQ6MVxuICAgICAgbmFtZTogJ2JmY3BGbG9vcklkJyxcbiAgICAgIHJlZzogL15mbG9vcmlkOiguKykgKD86bS1zdHJlYW18bXN0cm0pOiguKykvLFxuICAgICAgbmFtZXM6IFsnaWQnLCAnbVN0cmVhbSddLFxuICAgICAgZm9ybWF0OiAnZmxvb3JpZDolcyBtc3RybTolcydcbiAgICB9LFxuICAgIHtcbiAgICAgIC8vIGFueSBhPSB0aGF0IHdlIGRvbid0IHVuZGVyc3RhbmQgaXMga2VwdCB2ZXJiYXRpbSBvbiBtZWRpYS5pbnZhbGlkXG4gICAgICBwdXNoOiAnaW52YWxpZCcsXG4gICAgICBuYW1lczogWyd2YWx1ZSddXG4gICAgfVxuICBdXG59O1xuXG4vLyBzZXQgc2Vuc2libGUgZGVmYXVsdHMgdG8gYXZvaWQgcG9sbHV0aW5nIHRoZSBncmFtbWFyIHdpdGggYm9yaW5nIGRldGFpbHNcbk9iamVjdC5rZXlzKGdyYW1tYXIpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICB2YXIgb2JqcyA9IGdyYW1tYXJba2V5XTtcbiAgb2Jqcy5mb3JFYWNoKGZ1bmN0aW9uIChvYmopIHtcbiAgICBpZiAoIW9iai5yZWcpIHtcbiAgICAgIG9iai5yZWcgPSAvKC4qKS87XG4gICAgfVxuICAgIGlmICghb2JqLmZvcm1hdCkge1xuICAgICAgb2JqLmZvcm1hdCA9ICclcyc7XG4gICAgfVxuICB9KTtcbn0pO1xuIiwidmFyIHBhcnNlciA9IHJlcXVpcmUoJy4vcGFyc2VyJyk7XG52YXIgd3JpdGVyID0gcmVxdWlyZSgnLi93cml0ZXInKTtcblxuZXhwb3J0cy53cml0ZSA9IHdyaXRlcjtcbmV4cG9ydHMucGFyc2UgPSBwYXJzZXIucGFyc2U7XG5leHBvcnRzLnBhcnNlUGFyYW1zID0gcGFyc2VyLnBhcnNlUGFyYW1zO1xuZXhwb3J0cy5wYXJzZUZtdHBDb25maWcgPSBwYXJzZXIucGFyc2VGbXRwQ29uZmlnOyAvLyBBbGlhcyBvZiBwYXJzZVBhcmFtcygpLlxuZXhwb3J0cy5wYXJzZVBheWxvYWRzID0gcGFyc2VyLnBhcnNlUGF5bG9hZHM7XG5leHBvcnRzLnBhcnNlUmVtb3RlQ2FuZGlkYXRlcyA9IHBhcnNlci5wYXJzZVJlbW90ZUNhbmRpZGF0ZXM7XG5leHBvcnRzLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzID0gcGFyc2VyLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzO1xuZXhwb3J0cy5wYXJzZVNpbXVsY2FzdFN0cmVhbUxpc3QgPSBwYXJzZXIucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0O1xuIiwidmFyIHRvSW50SWZJbnQgPSBmdW5jdGlvbiAodikge1xuICByZXR1cm4gU3RyaW5nKE51bWJlcih2KSkgPT09IHYgPyBOdW1iZXIodikgOiB2O1xufTtcblxudmFyIGF0dGFjaFByb3BlcnRpZXMgPSBmdW5jdGlvbiAobWF0Y2gsIGxvY2F0aW9uLCBuYW1lcywgcmF3TmFtZSkge1xuICBpZiAocmF3TmFtZSAmJiAhbmFtZXMpIHtcbiAgICBsb2NhdGlvbltyYXdOYW1lXSA9IHRvSW50SWZJbnQobWF0Y2hbMV0pO1xuICB9XG4gIGVsc2Uge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbmFtZXMubGVuZ3RoOyBpICs9IDEpIHtcbiAgICAgIGlmIChtYXRjaFtpKzFdICE9IG51bGwpIHtcbiAgICAgICAgbG9jYXRpb25bbmFtZXNbaV1dID0gdG9JbnRJZkludChtYXRjaFtpKzFdKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn07XG5cbnZhciBwYXJzZVJlZyA9IGZ1bmN0aW9uIChvYmosIGxvY2F0aW9uLCBjb250ZW50KSB7XG4gIHZhciBuZWVkc0JsYW5rID0gb2JqLm5hbWUgJiYgb2JqLm5hbWVzO1xuICBpZiAob2JqLnB1c2ggJiYgIWxvY2F0aW9uW29iai5wdXNoXSkge1xuICAgIGxvY2F0aW9uW29iai5wdXNoXSA9IFtdO1xuICB9XG4gIGVsc2UgaWYgKG5lZWRzQmxhbmsgJiYgIWxvY2F0aW9uW29iai5uYW1lXSkge1xuICAgIGxvY2F0aW9uW29iai5uYW1lXSA9IHt9O1xuICB9XG4gIHZhciBrZXlMb2NhdGlvbiA9IG9iai5wdXNoID9cbiAgICB7fSA6ICAvLyBibGFuayBvYmplY3QgdGhhdCB3aWxsIGJlIHB1c2hlZFxuICAgIG5lZWRzQmxhbmsgPyBsb2NhdGlvbltvYmoubmFtZV0gOiBsb2NhdGlvbjsgLy8gb3RoZXJ3aXNlLCBuYW1lZCBsb2NhdGlvbiBvciByb290XG5cbiAgYXR0YWNoUHJvcGVydGllcyhjb250ZW50Lm1hdGNoKG9iai5yZWcpLCBrZXlMb2NhdGlvbiwgb2JqLm5hbWVzLCBvYmoubmFtZSk7XG5cbiAgaWYgKG9iai5wdXNoKSB7XG4gICAgbG9jYXRpb25bb2JqLnB1c2hdLnB1c2goa2V5TG9jYXRpb24pO1xuICB9XG59O1xuXG52YXIgZ3JhbW1hciA9IHJlcXVpcmUoJy4vZ3JhbW1hcicpO1xudmFyIHZhbGlkTGluZSA9IFJlZ0V4cC5wcm90b3R5cGUudGVzdC5iaW5kKC9eKFthLXpdKT0oLiopLyk7XG5cbmV4cG9ydHMucGFyc2UgPSBmdW5jdGlvbiAoc2RwKSB7XG4gIHZhciBzZXNzaW9uID0ge31cbiAgICAsIG1lZGlhID0gW11cbiAgICAsIGxvY2F0aW9uID0gc2Vzc2lvbjsgLy8gcG9pbnRzIGF0IHdoZXJlIHByb3BlcnRpZXMgZ28gdW5kZXIgKG9uZSBvZiB0aGUgYWJvdmUpXG5cbiAgLy8gcGFyc2UgbGluZXMgd2UgdW5kZXJzdGFuZFxuICBzZHAuc3BsaXQoLyhcXHJcXG58XFxyfFxcbikvKS5maWx0ZXIodmFsaWRMaW5lKS5mb3JFYWNoKGZ1bmN0aW9uIChsKSB7XG4gICAgdmFyIHR5cGUgPSBsWzBdO1xuICAgIHZhciBjb250ZW50ID0gbC5zbGljZSgyKTtcbiAgICBpZiAodHlwZSA9PT0gJ20nKSB7XG4gICAgICBtZWRpYS5wdXNoKHtydHA6IFtdLCBmbXRwOiBbXX0pO1xuICAgICAgbG9jYXRpb24gPSBtZWRpYVttZWRpYS5sZW5ndGgtMV07IC8vIHBvaW50IGF0IGxhdGVzdCBtZWRpYSBsaW5lXG4gICAgfVxuXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCAoZ3JhbW1hclt0eXBlXSB8fCBbXSkubGVuZ3RoOyBqICs9IDEpIHtcbiAgICAgIHZhciBvYmogPSBncmFtbWFyW3R5cGVdW2pdO1xuICAgICAgaWYgKG9iai5yZWcudGVzdChjb250ZW50KSkge1xuICAgICAgICByZXR1cm4gcGFyc2VSZWcob2JqLCBsb2NhdGlvbiwgY29udGVudCk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcblxuICBzZXNzaW9uLm1lZGlhID0gbWVkaWE7IC8vIGxpbmsgaXQgdXBcbiAgcmV0dXJuIHNlc3Npb247XG59O1xuXG52YXIgcGFyYW1SZWR1Y2VyID0gZnVuY3Rpb24gKGFjYywgZXhwcikge1xuICB2YXIgcyA9IGV4cHIuc3BsaXQoLz0oLispLywgMik7XG4gIGlmIChzLmxlbmd0aCA9PT0gMikge1xuICAgIGFjY1tzWzBdXSA9IHRvSW50SWZJbnQoc1sxXSk7XG4gIH0gZWxzZSBpZiAocy5sZW5ndGggPT09IDEgJiYgZXhwci5sZW5ndGggPiAxKSB7XG4gICAgYWNjW3NbMF1dID0gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBhY2M7XG59O1xuXG5leHBvcnRzLnBhcnNlUGFyYW1zID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KC87XFxzPy8pLnJlZHVjZShwYXJhbVJlZHVjZXIsIHt9KTtcbn07XG5cbi8vIEZvciBiYWNrd2FyZCBjb21wYXRpYmlsaXR5IC0gYWxpYXMgd2lsbCBiZSByZW1vdmVkIGluIDMuMC4wXG5leHBvcnRzLnBhcnNlRm10cENvbmZpZyA9IGV4cG9ydHMucGFyc2VQYXJhbXM7XG5cbmV4cG9ydHMucGFyc2VQYXlsb2FkcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci50b1N0cmluZygpLnNwbGl0KCcgJykubWFwKE51bWJlcik7XG59O1xuXG5leHBvcnRzLnBhcnNlUmVtb3RlQ2FuZGlkYXRlcyA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgdmFyIGNhbmRpZGF0ZXMgPSBbXTtcbiAgdmFyIHBhcnRzID0gc3RyLnNwbGl0KCcgJykubWFwKHRvSW50SWZJbnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgaSArPSAzKSB7XG4gICAgY2FuZGlkYXRlcy5wdXNoKHtcbiAgICAgIGNvbXBvbmVudDogcGFydHNbaV0sXG4gICAgICBpcDogcGFydHNbaSArIDFdLFxuICAgICAgcG9ydDogcGFydHNbaSArIDJdXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGNhbmRpZGF0ZXM7XG59O1xuXG5leHBvcnRzLnBhcnNlSW1hZ2VBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KCcgJykubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgcmV0dXJuIGl0ZW0uc3Vic3RyaW5nKDEsIGl0ZW0ubGVuZ3RoLTEpLnNwbGl0KCcsJykucmVkdWNlKHBhcmFtUmVkdWNlciwge30pO1xuICB9KTtcbn07XG5cbmV4cG9ydHMucGFyc2VTaW11bGNhc3RTdHJlYW1MaXN0ID0gZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnNwbGl0KCc7JykubWFwKGZ1bmN0aW9uIChzdHJlYW0pIHtcbiAgICByZXR1cm4gc3RyZWFtLnNwbGl0KCcsJykubWFwKGZ1bmN0aW9uIChmb3JtYXQpIHtcbiAgICAgIHZhciBzY2lkLCBwYXVzZWQgPSBmYWxzZTtcblxuICAgICAgaWYgKGZvcm1hdFswXSAhPT0gJ34nKSB7XG4gICAgICAgIHNjaWQgPSB0b0ludElmSW50KGZvcm1hdCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzY2lkID0gdG9JbnRJZkludChmb3JtYXQuc3Vic3RyaW5nKDEsIGZvcm1hdC5sZW5ndGgpKTtcbiAgICAgICAgcGF1c2VkID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc2NpZDogc2NpZCxcbiAgICAgICAgcGF1c2VkOiBwYXVzZWRcbiAgICAgIH07XG4gICAgfSk7XG4gIH0pO1xufTtcbiIsInZhciBncmFtbWFyID0gcmVxdWlyZSgnLi9ncmFtbWFyJyk7XG5cbi8vIGN1c3RvbWl6ZWQgdXRpbC5mb3JtYXQgLSBkaXNjYXJkcyBleGNlc3MgYXJndW1lbnRzIGFuZCBjYW4gdm9pZCBtaWRkbGUgb25lc1xudmFyIGZvcm1hdFJlZ0V4cCA9IC8lW3NkdiVdL2c7XG52YXIgZm9ybWF0ID0gZnVuY3Rpb24gKGZvcm1hdFN0cikge1xuICB2YXIgaSA9IDE7XG4gIHZhciBhcmdzID0gYXJndW1lbnRzO1xuICB2YXIgbGVuID0gYXJncy5sZW5ndGg7XG4gIHJldHVybiBmb3JtYXRTdHIucmVwbGFjZShmb3JtYXRSZWdFeHAsIGZ1bmN0aW9uICh4KSB7XG4gICAgaWYgKGkgPj0gbGVuKSB7XG4gICAgICByZXR1cm4geDsgLy8gbWlzc2luZyBhcmd1bWVudFxuICAgIH1cbiAgICB2YXIgYXJnID0gYXJnc1tpXTtcbiAgICBpICs9IDE7XG4gICAgc3dpdGNoICh4KSB7XG4gICAgY2FzZSAnJSUnOlxuICAgICAgcmV0dXJuICclJztcbiAgICBjYXNlICclcyc6XG4gICAgICByZXR1cm4gU3RyaW5nKGFyZyk7XG4gICAgY2FzZSAnJWQnOlxuICAgICAgcmV0dXJuIE51bWJlcihhcmcpO1xuICAgIGNhc2UgJyV2JzpcbiAgICAgIHJldHVybiAnJztcbiAgICB9XG4gIH0pO1xuICAvLyBOQjogd2UgZGlzY2FyZCBleGNlc3MgYXJndW1lbnRzIC0gdGhleSBhcmUgdHlwaWNhbGx5IHVuZGVmaW5lZCBmcm9tIG1ha2VMaW5lXG59O1xuXG52YXIgbWFrZUxpbmUgPSBmdW5jdGlvbiAodHlwZSwgb2JqLCBsb2NhdGlvbikge1xuICB2YXIgc3RyID0gb2JqLmZvcm1hdCBpbnN0YW5jZW9mIEZ1bmN0aW9uID9cbiAgICAob2JqLmZvcm1hdChvYmoucHVzaCA/IGxvY2F0aW9uIDogbG9jYXRpb25bb2JqLm5hbWVdKSkgOlxuICAgIG9iai5mb3JtYXQ7XG5cbiAgdmFyIGFyZ3MgPSBbdHlwZSArICc9JyArIHN0cl07XG4gIGlmIChvYmoubmFtZXMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iai5uYW1lcy5sZW5ndGg7IGkgKz0gMSkge1xuICAgICAgdmFyIG4gPSBvYmoubmFtZXNbaV07XG4gICAgICBpZiAob2JqLm5hbWUpIHtcbiAgICAgICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lXVtuXSk7XG4gICAgICB9XG4gICAgICBlbHNlIHsgLy8gZm9yIG1MaW5lIGFuZCBwdXNoIGF0dHJpYnV0ZXNcbiAgICAgICAgYXJncy5wdXNoKGxvY2F0aW9uW29iai5uYW1lc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBlbHNlIHtcbiAgICBhcmdzLnB1c2gobG9jYXRpb25bb2JqLm5hbWVdKTtcbiAgfVxuICByZXR1cm4gZm9ybWF0LmFwcGx5KG51bGwsIGFyZ3MpO1xufTtcblxuLy8gUkZDIHNwZWNpZmllZCBvcmRlclxuLy8gVE9ETzogZXh0ZW5kIHRoaXMgd2l0aCBhbGwgdGhlIHJlc3RcbnZhciBkZWZhdWx0T3V0ZXJPcmRlciA9IFtcbiAgJ3YnLCAnbycsICdzJywgJ2knLFxuICAndScsICdlJywgJ3AnLCAnYycsXG4gICdiJywgJ3QnLCAncicsICd6JywgJ2EnXG5dO1xudmFyIGRlZmF1bHRJbm5lck9yZGVyID0gWydpJywgJ2MnLCAnYicsICdhJ107XG5cblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc2Vzc2lvbiwgb3B0cykge1xuICBvcHRzID0gb3B0cyB8fCB7fTtcbiAgLy8gZW5zdXJlIGNlcnRhaW4gcHJvcGVydGllcyBleGlzdFxuICBpZiAoc2Vzc2lvbi52ZXJzaW9uID09IG51bGwpIHtcbiAgICBzZXNzaW9uLnZlcnNpb24gPSAwOyAvLyAndj0wJyBtdXN0IGJlIHRoZXJlIChvbmx5IGRlZmluZWQgdmVyc2lvbiBhdG0pXG4gIH1cbiAgaWYgKHNlc3Npb24ubmFtZSA9PSBudWxsKSB7XG4gICAgc2Vzc2lvbi5uYW1lID0gJyAnOyAvLyAncz0gJyBtdXN0IGJlIHRoZXJlIGlmIG5vIG1lYW5pbmdmdWwgbmFtZSBzZXRcbiAgfVxuICBzZXNzaW9uLm1lZGlhLmZvckVhY2goZnVuY3Rpb24gKG1MaW5lKSB7XG4gICAgaWYgKG1MaW5lLnBheWxvYWRzID09IG51bGwpIHtcbiAgICAgIG1MaW5lLnBheWxvYWRzID0gJyc7XG4gICAgfVxuICB9KTtcblxuICB2YXIgb3V0ZXJPcmRlciA9IG9wdHMub3V0ZXJPcmRlciB8fCBkZWZhdWx0T3V0ZXJPcmRlcjtcbiAgdmFyIGlubmVyT3JkZXIgPSBvcHRzLmlubmVyT3JkZXIgfHwgZGVmYXVsdElubmVyT3JkZXI7XG4gIHZhciBzZHAgPSBbXTtcblxuICAvLyBsb29wIHRocm91Z2ggb3V0ZXJPcmRlciBmb3IgbWF0Y2hpbmcgcHJvcGVydGllcyBvbiBzZXNzaW9uXG4gIG91dGVyT3JkZXIuZm9yRWFjaChmdW5jdGlvbiAodHlwZSkge1xuICAgIGdyYW1tYXJbdHlwZV0uZm9yRWFjaChmdW5jdGlvbiAob2JqKSB7XG4gICAgICBpZiAob2JqLm5hbWUgaW4gc2Vzc2lvbiAmJiBzZXNzaW9uW29iai5uYW1lXSAhPSBudWxsKSB7XG4gICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgc2Vzc2lvbikpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAob2JqLnB1c2ggaW4gc2Vzc2lvbiAmJiBzZXNzaW9uW29iai5wdXNoXSAhPSBudWxsKSB7XG4gICAgICAgIHNlc3Npb25bb2JqLnB1c2hdLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgc2RwLnB1c2gobWFrZUxpbmUodHlwZSwgb2JqLCBlbCkpO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gdGhlbiBmb3IgZWFjaCBtZWRpYSBsaW5lLCBmb2xsb3cgdGhlIGlubmVyT3JkZXJcbiAgc2Vzc2lvbi5tZWRpYS5mb3JFYWNoKGZ1bmN0aW9uIChtTGluZSkge1xuICAgIHNkcC5wdXNoKG1ha2VMaW5lKCdtJywgZ3JhbW1hci5tWzBdLCBtTGluZSkpO1xuXG4gICAgaW5uZXJPcmRlci5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gICAgICBncmFtbWFyW3R5cGVdLmZvckVhY2goZnVuY3Rpb24gKG9iaikge1xuICAgICAgICBpZiAob2JqLm5hbWUgaW4gbUxpbmUgJiYgbUxpbmVbb2JqLm5hbWVdICE9IG51bGwpIHtcbiAgICAgICAgICBzZHAucHVzaChtYWtlTGluZSh0eXBlLCBvYmosIG1MaW5lKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAob2JqLnB1c2ggaW4gbUxpbmUgJiYgbUxpbmVbb2JqLnB1c2hdICE9IG51bGwpIHtcbiAgICAgICAgICBtTGluZVtvYmoucHVzaF0uZm9yRWFjaChmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgIHNkcC5wdXNoKG1ha2VMaW5lKHR5cGUsIG9iaiwgZWwpKTtcbiAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH0pO1xuXG4gIHJldHVybiBzZHAuam9pbignXFxyXFxuJykgKyAnXFxyXFxuJztcbn07XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciByZXF1aXJlZCA9IHJlcXVpcmUoJ3JlcXVpcmVzLXBvcnQnKVxuICAsIHFzID0gcmVxdWlyZSgncXVlcnlzdHJpbmdpZnknKVxuICAsIHNsYXNoZXMgPSAvXltBLVphLXpdW0EtWmEtejAtOSstLl0qOltcXFxcL10rL1xuICAsIHByb3RvY29scmUgPSAvXihbYS16XVthLXowLTkuKy1dKjopPyhbXFxcXC9dezEsfSk/KFtcXFNcXHNdKikvaVxuICAsIHdoaXRlc3BhY2UgPSAnW1xcXFx4MDlcXFxceDBBXFxcXHgwQlxcXFx4MENcXFxceDBEXFxcXHgyMFxcXFx4QTBcXFxcdTE2ODBcXFxcdTE4MEVcXFxcdTIwMDBcXFxcdTIwMDFcXFxcdTIwMDJcXFxcdTIwMDNcXFxcdTIwMDRcXFxcdTIwMDVcXFxcdTIwMDZcXFxcdTIwMDdcXFxcdTIwMDhcXFxcdTIwMDlcXFxcdTIwMEFcXFxcdTIwMkZcXFxcdTIwNUZcXFxcdTMwMDBcXFxcdTIwMjhcXFxcdTIwMjlcXFxcdUZFRkZdJ1xuICAsIGxlZnQgPSBuZXcgUmVnRXhwKCdeJysgd2hpdGVzcGFjZSArJysnKTtcblxuLyoqXG4gKiBUcmltIGEgZ2l2ZW4gc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgU3RyaW5nIHRvIHRyaW0uXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRyaW1MZWZ0KHN0cikge1xuICByZXR1cm4gKHN0ciA/IHN0ciA6ICcnKS50b1N0cmluZygpLnJlcGxhY2UobGVmdCwgJycpO1xufVxuXG4vKipcbiAqIFRoZXNlIGFyZSB0aGUgcGFyc2UgcnVsZXMgZm9yIHRoZSBVUkwgcGFyc2VyLCBpdCBpbmZvcm1zIHRoZSBwYXJzZXJcbiAqIGFib3V0OlxuICpcbiAqIDAuIFRoZSBjaGFyIGl0IE5lZWRzIHRvIHBhcnNlLCBpZiBpdCdzIGEgc3RyaW5nIGl0IHNob3VsZCBiZSBkb25lIHVzaW5nXG4gKiAgICBpbmRleE9mLCBSZWdFeHAgdXNpbmcgZXhlYyBhbmQgTmFOIG1lYW5zIHNldCBhcyBjdXJyZW50IHZhbHVlLlxuICogMS4gVGhlIHByb3BlcnR5IHdlIHNob3VsZCBzZXQgd2hlbiBwYXJzaW5nIHRoaXMgdmFsdWUuXG4gKiAyLiBJbmRpY2F0aW9uIGlmIGl0J3MgYmFja3dhcmRzIG9yIGZvcndhcmQgcGFyc2luZywgd2hlbiBzZXQgYXMgbnVtYmVyIGl0J3NcbiAqICAgIHRoZSB2YWx1ZSBvZiBleHRyYSBjaGFycyB0aGF0IHNob3VsZCBiZSBzcGxpdCBvZmYuXG4gKiAzLiBJbmhlcml0IGZyb20gbG9jYXRpb24gaWYgbm9uIGV4aXN0aW5nIGluIHRoZSBwYXJzZXIuXG4gKiA0LiBgdG9Mb3dlckNhc2VgIHRoZSByZXN1bHRpbmcgdmFsdWUuXG4gKi9cbnZhciBydWxlcyA9IFtcbiAgWycjJywgJ2hhc2gnXSwgICAgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGJhY2suXG4gIFsnPycsICdxdWVyeSddLCAgICAgICAgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBmcm9tIHRoZSBiYWNrLlxuICBmdW5jdGlvbiBzYW5pdGl6ZShhZGRyZXNzKSB7ICAgICAgICAgIC8vIFNhbml0aXplIHdoYXQgaXMgbGVmdCBvZiB0aGUgYWRkcmVzc1xuICAgIHJldHVybiBhZGRyZXNzLnJlcGxhY2UoJ1xcXFwnLCAnLycpO1xuICB9LFxuICBbJy8nLCAncGF0aG5hbWUnXSwgICAgICAgICAgICAgICAgICAgIC8vIEV4dHJhY3QgZnJvbSB0aGUgYmFjay5cbiAgWydAJywgJ2F1dGgnLCAxXSwgICAgICAgICAgICAgICAgICAgICAvLyBFeHRyYWN0IGZyb20gdGhlIGZyb250LlxuICBbTmFOLCAnaG9zdCcsIHVuZGVmaW5lZCwgMSwgMV0sICAgICAgIC8vIFNldCBsZWZ0IG92ZXIgdmFsdWUuXG4gIFsvOihcXGQrKSQvLCAncG9ydCcsIHVuZGVmaW5lZCwgMV0sICAgIC8vIFJlZ0V4cCB0aGUgYmFjay5cbiAgW05hTiwgJ2hvc3RuYW1lJywgdW5kZWZpbmVkLCAxLCAxXSAgICAvLyBTZXQgbGVmdCBvdmVyLlxuXTtcblxuLyoqXG4gKiBUaGVzZSBwcm9wZXJ0aWVzIHNob3VsZCBub3QgYmUgY29waWVkIG9yIGluaGVyaXRlZCBmcm9tLiBUaGlzIGlzIG9ubHkgbmVlZGVkXG4gKiBmb3IgYWxsIG5vbiBibG9iIFVSTCdzIGFzIGEgYmxvYiBVUkwgZG9lcyBub3QgaW5jbHVkZSBhIGhhc2gsIG9ubHkgdGhlXG4gKiBvcmlnaW4uXG4gKlxuICogQHR5cGUge09iamVjdH1cbiAqIEBwcml2YXRlXG4gKi9cbnZhciBpZ25vcmUgPSB7IGhhc2g6IDEsIHF1ZXJ5OiAxIH07XG5cbi8qKlxuICogVGhlIGxvY2F0aW9uIG9iamVjdCBkaWZmZXJzIHdoZW4geW91ciBjb2RlIGlzIGxvYWRlZCB0aHJvdWdoIGEgbm9ybWFsIHBhZ2UsXG4gKiBXb3JrZXIgb3IgdGhyb3VnaCBhIHdvcmtlciB1c2luZyBhIGJsb2IuIEFuZCB3aXRoIHRoZSBibG9iYmxlIGJlZ2lucyB0aGVcbiAqIHRyb3VibGUgYXMgdGhlIGxvY2F0aW9uIG9iamVjdCB3aWxsIGNvbnRhaW4gdGhlIFVSTCBvZiB0aGUgYmxvYiwgbm90IHRoZVxuICogbG9jYXRpb24gb2YgdGhlIHBhZ2Ugd2hlcmUgb3VyIGNvZGUgaXMgbG9hZGVkIGluLiBUaGUgYWN0dWFsIG9yaWdpbiBpc1xuICogZW5jb2RlZCBpbiB0aGUgYHBhdGhuYW1lYCBzbyB3ZSBjYW4gdGhhbmtmdWxseSBnZW5lcmF0ZSBhIGdvb2QgXCJkZWZhdWx0XCJcbiAqIGxvY2F0aW9uIGZyb20gaXQgc28gd2UgY2FuIGdlbmVyYXRlIHByb3BlciByZWxhdGl2ZSBVUkwncyBhZ2Fpbi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGxvYyBPcHRpb25hbCBkZWZhdWx0IGxvY2F0aW9uIG9iamVjdC5cbiAqIEByZXR1cm5zIHtPYmplY3R9IGxvbGNhdGlvbiBvYmplY3QuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIGxvbGNhdGlvbihsb2MpIHtcbiAgdmFyIGdsb2JhbFZhcjtcblxuICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IHdpbmRvdztcbiAgZWxzZSBpZiAodHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcpIGdsb2JhbFZhciA9IGdsb2JhbDtcbiAgZWxzZSBpZiAodHlwZW9mIHNlbGYgIT09ICd1bmRlZmluZWQnKSBnbG9iYWxWYXIgPSBzZWxmO1xuICBlbHNlIGdsb2JhbFZhciA9IHt9O1xuXG4gIHZhciBsb2NhdGlvbiA9IGdsb2JhbFZhci5sb2NhdGlvbiB8fCB7fTtcbiAgbG9jID0gbG9jIHx8IGxvY2F0aW9uO1xuXG4gIHZhciBmaW5hbGRlc3RpbmF0aW9uID0ge31cbiAgICAsIHR5cGUgPSB0eXBlb2YgbG9jXG4gICAgLCBrZXk7XG5cbiAgaWYgKCdibG9iOicgPT09IGxvYy5wcm90b2NvbCkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKHVuZXNjYXBlKGxvYy5wYXRobmFtZSksIHt9KTtcbiAgfSBlbHNlIGlmICgnc3RyaW5nJyA9PT0gdHlwZSkge1xuICAgIGZpbmFsZGVzdGluYXRpb24gPSBuZXcgVXJsKGxvYywge30pO1xuICAgIGZvciAoa2V5IGluIGlnbm9yZSkgZGVsZXRlIGZpbmFsZGVzdGluYXRpb25ba2V5XTtcbiAgfSBlbHNlIGlmICgnb2JqZWN0JyA9PT0gdHlwZSkge1xuICAgIGZvciAoa2V5IGluIGxvYykge1xuICAgICAgaWYgKGtleSBpbiBpZ25vcmUpIGNvbnRpbnVlO1xuICAgICAgZmluYWxkZXN0aW5hdGlvbltrZXldID0gbG9jW2tleV07XG4gICAgfVxuXG4gICAgaWYgKGZpbmFsZGVzdGluYXRpb24uc2xhc2hlcyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBmaW5hbGRlc3RpbmF0aW9uLnNsYXNoZXMgPSBzbGFzaGVzLnRlc3QobG9jLmhyZWYpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmaW5hbGRlc3RpbmF0aW9uO1xufVxuXG4vKipcbiAqIEB0eXBlZGVmIFByb3RvY29sRXh0cmFjdFxuICogQHR5cGUgT2JqZWN0XG4gKiBAcHJvcGVydHkge1N0cmluZ30gcHJvdG9jb2wgUHJvdG9jb2wgbWF0Y2hlZCBpbiB0aGUgVVJMLCBpbiBsb3dlcmNhc2UuXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IHNsYXNoZXMgYHRydWVgIGlmIHByb3RvY29sIGlzIGZvbGxvd2VkIGJ5IFwiLy9cIiwgZWxzZSBgZmFsc2VgLlxuICogQHByb3BlcnR5IHtTdHJpbmd9IHJlc3QgUmVzdCBvZiB0aGUgVVJMIHRoYXQgaXMgbm90IHBhcnQgb2YgdGhlIHByb3RvY29sLlxuICovXG5cbi8qKlxuICogRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBmcm9tIGEgVVJMIHdpdGgvd2l0aG91dCBkb3VibGUgc2xhc2ggKFwiLy9cIikuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IGFkZHJlc3MgVVJMIHdlIHdhbnQgdG8gZXh0cmFjdCBmcm9tLlxuICogQHJldHVybiB7UHJvdG9jb2xFeHRyYWN0fSBFeHRyYWN0ZWQgaW5mb3JtYXRpb24uXG4gKiBAcHJpdmF0ZVxuICovXG5mdW5jdGlvbiBleHRyYWN0UHJvdG9jb2woYWRkcmVzcykge1xuICBhZGRyZXNzID0gdHJpbUxlZnQoYWRkcmVzcyk7XG5cbiAgdmFyIG1hdGNoID0gcHJvdG9jb2xyZS5leGVjKGFkZHJlc3MpXG4gICAgLCBwcm90b2NvbCA9IG1hdGNoWzFdID8gbWF0Y2hbMV0udG9Mb3dlckNhc2UoKSA6ICcnXG4gICAgLCBzbGFzaGVzID0gISEobWF0Y2hbMl0gJiYgbWF0Y2hbMl0ubGVuZ3RoID49IDIpXG4gICAgLCByZXN0ID0gIG1hdGNoWzJdICYmIG1hdGNoWzJdLmxlbmd0aCA9PT0gMSA/ICcvJyArIG1hdGNoWzNdIDogbWF0Y2hbM107XG5cbiAgcmV0dXJuIHtcbiAgICBwcm90b2NvbDogcHJvdG9jb2wsXG4gICAgc2xhc2hlczogc2xhc2hlcyxcbiAgICByZXN0OiByZXN0XG4gIH07XG59XG5cbi8qKlxuICogUmVzb2x2ZSBhIHJlbGF0aXZlIFVSTCBwYXRobmFtZSBhZ2FpbnN0IGEgYmFzZSBVUkwgcGF0aG5hbWUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd9IHJlbGF0aXZlIFBhdGhuYW1lIG9mIHRoZSByZWxhdGl2ZSBVUkwuXG4gKiBAcGFyYW0ge1N0cmluZ30gYmFzZSBQYXRobmFtZSBvZiB0aGUgYmFzZSBVUkwuXG4gKiBAcmV0dXJuIHtTdHJpbmd9IFJlc29sdmVkIHBhdGhuYW1lLlxuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZShyZWxhdGl2ZSwgYmFzZSkge1xuICBpZiAocmVsYXRpdmUgPT09ICcnKSByZXR1cm4gYmFzZTtcblxuICB2YXIgcGF0aCA9IChiYXNlIHx8ICcvJykuc3BsaXQoJy8nKS5zbGljZSgwLCAtMSkuY29uY2F0KHJlbGF0aXZlLnNwbGl0KCcvJykpXG4gICAgLCBpID0gcGF0aC5sZW5ndGhcbiAgICAsIGxhc3QgPSBwYXRoW2kgLSAxXVxuICAgICwgdW5zaGlmdCA9IGZhbHNlXG4gICAgLCB1cCA9IDA7XG5cbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChwYXRoW2ldID09PSAnLicpIHtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgIH0gZWxzZSBpZiAocGF0aFtpXSA9PT0gJy4uJykge1xuICAgICAgcGF0aC5zcGxpY2UoaSwgMSk7XG4gICAgICB1cCsrO1xuICAgIH0gZWxzZSBpZiAodXApIHtcbiAgICAgIGlmIChpID09PSAwKSB1bnNoaWZ0ID0gdHJ1ZTtcbiAgICAgIHBhdGguc3BsaWNlKGksIDEpO1xuICAgICAgdXAtLTtcbiAgICB9XG4gIH1cblxuICBpZiAodW5zaGlmdCkgcGF0aC51bnNoaWZ0KCcnKTtcbiAgaWYgKGxhc3QgPT09ICcuJyB8fCBsYXN0ID09PSAnLi4nKSBwYXRoLnB1c2goJycpO1xuXG4gIHJldHVybiBwYXRoLmpvaW4oJy8nKTtcbn1cblxuLyoqXG4gKiBUaGUgYWN0dWFsIFVSTCBpbnN0YW5jZS4gSW5zdGVhZCBvZiByZXR1cm5pbmcgYW4gb2JqZWN0IHdlJ3ZlIG9wdGVkLWluIHRvXG4gKiBjcmVhdGUgYW4gYWN0dWFsIGNvbnN0cnVjdG9yIGFzIGl0J3MgbXVjaCBtb3JlIG1lbW9yeSBlZmZpY2llbnQgYW5kXG4gKiBmYXN0ZXIgYW5kIGl0IHBsZWFzZXMgbXkgT0NELlxuICpcbiAqIEl0IGlzIHdvcnRoIG5vdGluZyB0aGF0IHdlIHNob3VsZCBub3QgdXNlIGBVUkxgIGFzIGNsYXNzIG5hbWUgdG8gcHJldmVudFxuICogY2xhc2hlcyB3aXRoIHRoZSBnbG9iYWwgVVJMIGluc3RhbmNlIHRoYXQgZ290IGludHJvZHVjZWQgaW4gYnJvd3NlcnMuXG4gKlxuICogQGNvbnN0cnVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gYWRkcmVzcyBVUkwgd2Ugd2FudCB0byBwYXJzZS5cbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gW2xvY2F0aW9uXSBMb2NhdGlvbiBkZWZhdWx0cyBmb3IgcmVsYXRpdmUgcGF0aHMuXG4gKiBAcGFyYW0ge0Jvb2xlYW58RnVuY3Rpb259IFtwYXJzZXJdIFBhcnNlciBmb3IgdGhlIHF1ZXJ5IHN0cmluZy5cbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIFVybChhZGRyZXNzLCBsb2NhdGlvbiwgcGFyc2VyKSB7XG4gIGFkZHJlc3MgPSB0cmltTGVmdChhZGRyZXNzKTtcblxuICBpZiAoISh0aGlzIGluc3RhbmNlb2YgVXJsKSkge1xuICAgIHJldHVybiBuZXcgVXJsKGFkZHJlc3MsIGxvY2F0aW9uLCBwYXJzZXIpO1xuICB9XG5cbiAgdmFyIHJlbGF0aXZlLCBleHRyYWN0ZWQsIHBhcnNlLCBpbnN0cnVjdGlvbiwgaW5kZXgsIGtleVxuICAgICwgaW5zdHJ1Y3Rpb25zID0gcnVsZXMuc2xpY2UoKVxuICAgICwgdHlwZSA9IHR5cGVvZiBsb2NhdGlvblxuICAgICwgdXJsID0gdGhpc1xuICAgICwgaSA9IDA7XG5cbiAgLy9cbiAgLy8gVGhlIGZvbGxvd2luZyBpZiBzdGF0ZW1lbnRzIGFsbG93cyB0aGlzIG1vZHVsZSB0d28gaGF2ZSBjb21wYXRpYmlsaXR5IHdpdGhcbiAgLy8gMiBkaWZmZXJlbnQgQVBJOlxuICAvL1xuICAvLyAxLiBOb2RlLmpzJ3MgYHVybC5wYXJzZWAgYXBpIHdoaWNoIGFjY2VwdHMgYSBVUkwsIGJvb2xlYW4gYXMgYXJndW1lbnRzXG4gIC8vICAgIHdoZXJlIHRoZSBib29sZWFuIGluZGljYXRlcyB0aGF0IHRoZSBxdWVyeSBzdHJpbmcgc2hvdWxkIGFsc28gYmUgcGFyc2VkLlxuICAvL1xuICAvLyAyLiBUaGUgYFVSTGAgaW50ZXJmYWNlIG9mIHRoZSBicm93c2VyIHdoaWNoIGFjY2VwdHMgYSBVUkwsIG9iamVjdCBhc1xuICAvLyAgICBhcmd1bWVudHMuIFRoZSBzdXBwbGllZCBvYmplY3Qgd2lsbCBiZSB1c2VkIGFzIGRlZmF1bHQgdmFsdWVzIC8gZmFsbC1iYWNrXG4gIC8vICAgIGZvciByZWxhdGl2ZSBwYXRocy5cbiAgLy9cbiAgaWYgKCdvYmplY3QnICE9PSB0eXBlICYmICdzdHJpbmcnICE9PSB0eXBlKSB7XG4gICAgcGFyc2VyID0gbG9jYXRpb247XG4gICAgbG9jYXRpb24gPSBudWxsO1xuICB9XG5cbiAgaWYgKHBhcnNlciAmJiAnZnVuY3Rpb24nICE9PSB0eXBlb2YgcGFyc2VyKSBwYXJzZXIgPSBxcy5wYXJzZTtcblxuICBsb2NhdGlvbiA9IGxvbGNhdGlvbihsb2NhdGlvbik7XG5cbiAgLy9cbiAgLy8gRXh0cmFjdCBwcm90b2NvbCBpbmZvcm1hdGlvbiBiZWZvcmUgcnVubmluZyB0aGUgaW5zdHJ1Y3Rpb25zLlxuICAvL1xuICBleHRyYWN0ZWQgPSBleHRyYWN0UHJvdG9jb2woYWRkcmVzcyB8fCAnJyk7XG4gIHJlbGF0aXZlID0gIWV4dHJhY3RlZC5wcm90b2NvbCAmJiAhZXh0cmFjdGVkLnNsYXNoZXM7XG4gIHVybC5zbGFzaGVzID0gZXh0cmFjdGVkLnNsYXNoZXMgfHwgcmVsYXRpdmUgJiYgbG9jYXRpb24uc2xhc2hlcztcbiAgdXJsLnByb3RvY29sID0gZXh0cmFjdGVkLnByb3RvY29sIHx8IGxvY2F0aW9uLnByb3RvY29sIHx8ICcnO1xuICBhZGRyZXNzID0gZXh0cmFjdGVkLnJlc3Q7XG5cbiAgLy9cbiAgLy8gV2hlbiB0aGUgYXV0aG9yaXR5IGNvbXBvbmVudCBpcyBhYnNlbnQgdGhlIFVSTCBzdGFydHMgd2l0aCBhIHBhdGhcbiAgLy8gY29tcG9uZW50LlxuICAvL1xuICBpZiAoIWV4dHJhY3RlZC5zbGFzaGVzKSBpbnN0cnVjdGlvbnNbM10gPSBbLyguKikvLCAncGF0aG5hbWUnXTtcblxuICBmb3IgKDsgaSA8IGluc3RydWN0aW9ucy5sZW5ndGg7IGkrKykge1xuICAgIGluc3RydWN0aW9uID0gaW5zdHJ1Y3Rpb25zW2ldO1xuXG4gICAgaWYgKHR5cGVvZiBpbnN0cnVjdGlvbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYWRkcmVzcyA9IGluc3RydWN0aW9uKGFkZHJlc3MpO1xuICAgICAgY29udGludWU7XG4gICAgfVxuXG4gICAgcGFyc2UgPSBpbnN0cnVjdGlvblswXTtcbiAgICBrZXkgPSBpbnN0cnVjdGlvblsxXTtcblxuICAgIGlmIChwYXJzZSAhPT0gcGFyc2UpIHtcbiAgICAgIHVybFtrZXldID0gYWRkcmVzcztcbiAgICB9IGVsc2UgaWYgKCdzdHJpbmcnID09PSB0eXBlb2YgcGFyc2UpIHtcbiAgICAgIGlmICh+KGluZGV4ID0gYWRkcmVzcy5pbmRleE9mKHBhcnNlKSkpIHtcbiAgICAgICAgaWYgKCdudW1iZXInID09PSB0eXBlb2YgaW5zdHJ1Y3Rpb25bMl0pIHtcbiAgICAgICAgICB1cmxba2V5XSA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKGluZGV4ICsgaW5zdHJ1Y3Rpb25bMl0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHVybFtrZXldID0gYWRkcmVzcy5zbGljZShpbmRleCk7XG4gICAgICAgICAgYWRkcmVzcyA9IGFkZHJlc3Muc2xpY2UoMCwgaW5kZXgpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICgoaW5kZXggPSBwYXJzZS5leGVjKGFkZHJlc3MpKSkge1xuICAgICAgdXJsW2tleV0gPSBpbmRleFsxXTtcbiAgICAgIGFkZHJlc3MgPSBhZGRyZXNzLnNsaWNlKDAsIGluZGV4LmluZGV4KTtcbiAgICB9XG5cbiAgICB1cmxba2V5XSA9IHVybFtrZXldIHx8IChcbiAgICAgIHJlbGF0aXZlICYmIGluc3RydWN0aW9uWzNdID8gbG9jYXRpb25ba2V5XSB8fCAnJyA6ICcnXG4gICAgKTtcblxuICAgIC8vXG4gICAgLy8gSG9zdG5hbWUsIGhvc3QgYW5kIHByb3RvY29sIHNob3VsZCBiZSBsb3dlcmNhc2VkIHNvIHRoZXkgY2FuIGJlIHVzZWQgdG9cbiAgICAvLyBjcmVhdGUgYSBwcm9wZXIgYG9yaWdpbmAuXG4gICAgLy9cbiAgICBpZiAoaW5zdHJ1Y3Rpb25bNF0pIHVybFtrZXldID0gdXJsW2tleV0udG9Mb3dlckNhc2UoKTtcbiAgfVxuXG4gIC8vXG4gIC8vIEFsc28gcGFyc2UgdGhlIHN1cHBsaWVkIHF1ZXJ5IHN0cmluZyBpbiB0byBhbiBvYmplY3QuIElmIHdlJ3JlIHN1cHBsaWVkXG4gIC8vIHdpdGggYSBjdXN0b20gcGFyc2VyIGFzIGZ1bmN0aW9uIHVzZSB0aGF0IGluc3RlYWQgb2YgdGhlIGRlZmF1bHQgYnVpbGQtaW5cbiAgLy8gcGFyc2VyLlxuICAvL1xuICBpZiAocGFyc2VyKSB1cmwucXVlcnkgPSBwYXJzZXIodXJsLnF1ZXJ5KTtcblxuICAvL1xuICAvLyBJZiB0aGUgVVJMIGlzIHJlbGF0aXZlLCByZXNvbHZlIHRoZSBwYXRobmFtZSBhZ2FpbnN0IHRoZSBiYXNlIFVSTC5cbiAgLy9cbiAgaWYgKFxuICAgICAgcmVsYXRpdmVcbiAgICAmJiBsb2NhdGlvbi5zbGFzaGVzXG4gICAgJiYgdXJsLnBhdGhuYW1lLmNoYXJBdCgwKSAhPT0gJy8nXG4gICAgJiYgKHVybC5wYXRobmFtZSAhPT0gJycgfHwgbG9jYXRpb24ucGF0aG5hbWUgIT09ICcnKVxuICApIHtcbiAgICB1cmwucGF0aG5hbWUgPSByZXNvbHZlKHVybC5wYXRobmFtZSwgbG9jYXRpb24ucGF0aG5hbWUpO1xuICB9XG5cbiAgLy9cbiAgLy8gRGVmYXVsdCB0byBhIC8gZm9yIHBhdGhuYW1lIGlmIG5vbmUgZXhpc3RzLiBUaGlzIG5vcm1hbGl6ZXMgdGhlIFVSTFxuICAvLyB0byBhbHdheXMgaGF2ZSBhIC9cbiAgLy9cbiAgaWYgKHVybC5wYXRobmFtZS5jaGFyQXQoMCkgIT09ICcvJyAmJiB1cmwuaG9zdG5hbWUpIHtcbiAgICB1cmwucGF0aG5hbWUgPSAnLycgKyB1cmwucGF0aG5hbWU7XG4gIH1cblxuICAvL1xuICAvLyBXZSBzaG91bGQgbm90IGFkZCBwb3J0IG51bWJlcnMgaWYgdGhleSBhcmUgYWxyZWFkeSB0aGUgZGVmYXVsdCBwb3J0IG51bWJlclxuICAvLyBmb3IgYSBnaXZlbiBwcm90b2NvbC4gQXMgdGhlIGhvc3QgYWxzbyBjb250YWlucyB0aGUgcG9ydCBudW1iZXIgd2UncmUgZ29pbmdcbiAgLy8gb3ZlcnJpZGUgaXQgd2l0aCB0aGUgaG9zdG5hbWUgd2hpY2ggY29udGFpbnMgbm8gcG9ydCBudW1iZXIuXG4gIC8vXG4gIGlmICghcmVxdWlyZWQodXJsLnBvcnQsIHVybC5wcm90b2NvbCkpIHtcbiAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZTtcbiAgICB1cmwucG9ydCA9ICcnO1xuICB9XG5cbiAgLy9cbiAgLy8gUGFyc2UgZG93biB0aGUgYGF1dGhgIGZvciB0aGUgdXNlcm5hbWUgYW5kIHBhc3N3b3JkLlxuICAvL1xuICB1cmwudXNlcm5hbWUgPSB1cmwucGFzc3dvcmQgPSAnJztcbiAgaWYgKHVybC5hdXRoKSB7XG4gICAgaW5zdHJ1Y3Rpb24gPSB1cmwuYXV0aC5zcGxpdCgnOicpO1xuICAgIHVybC51c2VybmFtZSA9IGluc3RydWN0aW9uWzBdIHx8ICcnO1xuICAgIHVybC5wYXNzd29yZCA9IGluc3RydWN0aW9uWzFdIHx8ICcnO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICAvL1xuICAvLyBUaGUgaHJlZiBpcyBqdXN0IHRoZSBjb21waWxlZCByZXN1bHQuXG4gIC8vXG4gIHVybC5ocmVmID0gdXJsLnRvU3RyaW5nKCk7XG59XG5cbi8qKlxuICogVGhpcyBpcyBjb252ZW5pZW5jZSBtZXRob2QgZm9yIGNoYW5naW5nIHByb3BlcnRpZXMgaW4gdGhlIFVSTCBpbnN0YW5jZSB0b1xuICogaW5zdXJlIHRoYXQgdGhleSBhbGwgcHJvcGFnYXRlIGNvcnJlY3RseS5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gcGFydCAgICAgICAgICBQcm9wZXJ0eSB3ZSBuZWVkIHRvIGFkanVzdC5cbiAqIEBwYXJhbSB7TWl4ZWR9IHZhbHVlICAgICAgICAgIFRoZSBuZXdseSBhc3NpZ25lZCB2YWx1ZS5cbiAqIEBwYXJhbSB7Qm9vbGVhbnxGdW5jdGlvbn0gZm4gIFdoZW4gc2V0dGluZyB0aGUgcXVlcnksIGl0IHdpbGwgYmUgdGhlIGZ1bmN0aW9uXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB1c2VkIHRvIHBhcnNlIHRoZSBxdWVyeS5cbiAqICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFdoZW4gc2V0dGluZyB0aGUgcHJvdG9jb2wsIGRvdWJsZSBzbGFzaCB3aWxsIGJlXG4gKiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZW1vdmVkIGZyb20gdGhlIGZpbmFsIHVybCBpZiBpdCBpcyB0cnVlLlxuICogQHJldHVybnMge1VSTH0gVVJMIGluc3RhbmNlIGZvciBjaGFpbmluZy5cbiAqIEBwdWJsaWNcbiAqL1xuZnVuY3Rpb24gc2V0KHBhcnQsIHZhbHVlLCBmbikge1xuICB2YXIgdXJsID0gdGhpcztcblxuICBzd2l0Y2ggKHBhcnQpIHtcbiAgICBjYXNlICdxdWVyeSc6XG4gICAgICBpZiAoJ3N0cmluZycgPT09IHR5cGVvZiB2YWx1ZSAmJiB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdmFsdWUgPSAoZm4gfHwgcXMucGFyc2UpKHZhbHVlKTtcbiAgICAgIH1cblxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gICAgICBicmVhaztcblxuICAgIGNhc2UgJ3BvcnQnOlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG5cbiAgICAgIGlmICghcmVxdWlyZWQodmFsdWUsIHVybC5wcm90b2NvbCkpIHtcbiAgICAgICAgdXJsLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgICAgIHVybFtwYXJ0XSA9ICcnO1xuICAgICAgfSBlbHNlIGlmICh2YWx1ZSkge1xuICAgICAgICB1cmwuaG9zdCA9IHVybC5ob3N0bmFtZSArJzonKyB2YWx1ZTtcbiAgICAgIH1cblxuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdob3N0bmFtZSc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKHVybC5wb3J0KSB2YWx1ZSArPSAnOicrIHVybC5wb3J0O1xuICAgICAgdXJsLmhvc3QgPSB2YWx1ZTtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAnaG9zdCc6XG4gICAgICB1cmxbcGFydF0gPSB2YWx1ZTtcblxuICAgICAgaWYgKC86XFxkKyQvLnRlc3QodmFsdWUpKSB7XG4gICAgICAgIHZhbHVlID0gdmFsdWUuc3BsaXQoJzonKTtcbiAgICAgICAgdXJsLnBvcnQgPSB2YWx1ZS5wb3AoKTtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWUuam9pbignOicpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdXJsLmhvc3RuYW1lID0gdmFsdWU7XG4gICAgICAgIHVybC5wb3J0ID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSAncHJvdG9jb2wnOlxuICAgICAgdXJsLnByb3RvY29sID0gdmFsdWUudG9Mb3dlckNhc2UoKTtcbiAgICAgIHVybC5zbGFzaGVzID0gIWZuO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlICdwYXRobmFtZSc6XG4gICAgY2FzZSAnaGFzaCc6XG4gICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgdmFyIGNoYXIgPSBwYXJ0ID09PSAncGF0aG5hbWUnID8gJy8nIDogJyMnO1xuICAgICAgICB1cmxbcGFydF0gPSB2YWx1ZS5jaGFyQXQoMCkgIT09IGNoYXIgPyBjaGFyICsgdmFsdWUgOiB2YWx1ZTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHVybFtwYXJ0XSA9IHZhbHVlO1xuICAgICAgfVxuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgdXJsW3BhcnRdID0gdmFsdWU7XG4gIH1cblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHJ1bGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIGlucyA9IHJ1bGVzW2ldO1xuXG4gICAgaWYgKGluc1s0XSkgdXJsW2luc1sxXV0gPSB1cmxbaW5zWzFdXS50b0xvd2VyQ2FzZSgpO1xuICB9XG5cbiAgdXJsLm9yaWdpbiA9IHVybC5wcm90b2NvbCAmJiB1cmwuaG9zdCAmJiB1cmwucHJvdG9jb2wgIT09ICdmaWxlOidcbiAgICA/IHVybC5wcm90b2NvbCArJy8vJysgdXJsLmhvc3RcbiAgICA6ICdudWxsJztcblxuICB1cmwuaHJlZiA9IHVybC50b1N0cmluZygpO1xuXG4gIHJldHVybiB1cmw7XG59XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBwcm9wZXJ0aWVzIGJhY2sgaW4gdG8gYSB2YWxpZCBhbmQgZnVsbCBVUkwgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHN0cmluZ2lmeSBPcHRpb25hbCBxdWVyeSBzdHJpbmdpZnkgZnVuY3Rpb24uXG4gKiBAcmV0dXJucyB7U3RyaW5nfSBDb21waWxlZCB2ZXJzaW9uIG9mIHRoZSBVUkwuXG4gKiBAcHVibGljXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nKHN0cmluZ2lmeSkge1xuICBpZiAoIXN0cmluZ2lmeSB8fCAnZnVuY3Rpb24nICE9PSB0eXBlb2Ygc3RyaW5naWZ5KSBzdHJpbmdpZnkgPSBxcy5zdHJpbmdpZnk7XG5cbiAgdmFyIHF1ZXJ5XG4gICAgLCB1cmwgPSB0aGlzXG4gICAgLCBwcm90b2NvbCA9IHVybC5wcm90b2NvbDtcblxuICBpZiAocHJvdG9jb2wgJiYgcHJvdG9jb2wuY2hhckF0KHByb3RvY29sLmxlbmd0aCAtIDEpICE9PSAnOicpIHByb3RvY29sICs9ICc6JztcblxuICB2YXIgcmVzdWx0ID0gcHJvdG9jb2wgKyAodXJsLnNsYXNoZXMgPyAnLy8nIDogJycpO1xuXG4gIGlmICh1cmwudXNlcm5hbWUpIHtcbiAgICByZXN1bHQgKz0gdXJsLnVzZXJuYW1lO1xuICAgIGlmICh1cmwucGFzc3dvcmQpIHJlc3VsdCArPSAnOicrIHVybC5wYXNzd29yZDtcbiAgICByZXN1bHQgKz0gJ0AnO1xuICB9XG5cbiAgcmVzdWx0ICs9IHVybC5ob3N0ICsgdXJsLnBhdGhuYW1lO1xuXG4gIHF1ZXJ5ID0gJ29iamVjdCcgPT09IHR5cGVvZiB1cmwucXVlcnkgPyBzdHJpbmdpZnkodXJsLnF1ZXJ5KSA6IHVybC5xdWVyeTtcbiAgaWYgKHF1ZXJ5KSByZXN1bHQgKz0gJz8nICE9PSBxdWVyeS5jaGFyQXQoMCkgPyAnPycrIHF1ZXJ5IDogcXVlcnk7XG5cbiAgaWYgKHVybC5oYXNoKSByZXN1bHQgKz0gdXJsLmhhc2g7XG5cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuVXJsLnByb3RvdHlwZSA9IHsgc2V0OiBzZXQsIHRvU3RyaW5nOiB0b1N0cmluZyB9O1xuXG4vL1xuLy8gRXhwb3NlIHRoZSBVUkwgcGFyc2VyIGFuZCBzb21lIGFkZGl0aW9uYWwgcHJvcGVydGllcyB0aGF0IG1pZ2h0IGJlIHVzZWZ1bCBmb3Jcbi8vIG90aGVycyBvciB0ZXN0aW5nLlxuLy9cblVybC5leHRyYWN0UHJvdG9jb2wgPSBleHRyYWN0UHJvdG9jb2w7XG5VcmwubG9jYXRpb24gPSBsb2xjYXRpb247XG5VcmwudHJpbUxlZnQgPSB0cmltTGVmdDtcblVybC5xcyA9IHFzO1xuXG5tb2R1bGUuZXhwb3J0cyA9IFVybDtcbiIsInZhciBfZ2xvYmFsVGhpcztcbmlmICh0eXBlb2YgZ2xvYmFsVGhpcyA9PT0gJ29iamVjdCcpIHtcblx0X2dsb2JhbFRoaXMgPSBnbG9iYWxUaGlzO1xufSBlbHNlIHtcblx0dHJ5IHtcblx0XHRfZ2xvYmFsVGhpcyA9IHJlcXVpcmUoJ2VzNS1leHQvZ2xvYmFsJyk7XG5cdH0gY2F0Y2ggKGVycm9yKSB7XG5cdH0gZmluYWxseSB7XG5cdFx0aWYgKCFfZ2xvYmFsVGhpcyAmJiB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJykgeyBfZ2xvYmFsVGhpcyA9IHdpbmRvdzsgfVxuXHRcdGlmICghX2dsb2JhbFRoaXMpIHsgdGhyb3cgbmV3IEVycm9yKCdDb3VsZCBub3QgZGV0ZXJtaW5lIGdsb2JhbCB0aGlzJyk7IH1cblx0fVxufVxuXG52YXIgTmF0aXZlV2ViU29ja2V0ID0gX2dsb2JhbFRoaXMuV2ViU29ja2V0IHx8IF9nbG9iYWxUaGlzLk1veldlYlNvY2tldDtcbnZhciB3ZWJzb2NrZXRfdmVyc2lvbiA9IHJlcXVpcmUoJy4vdmVyc2lvbicpO1xuXG5cbi8qKlxuICogRXhwb3NlIGEgVzNDIFdlYlNvY2tldCBjbGFzcyB3aXRoIGp1c3Qgb25lIG9yIHR3byBhcmd1bWVudHMuXG4gKi9cbmZ1bmN0aW9uIFczQ1dlYlNvY2tldCh1cmksIHByb3RvY29scykge1xuXHR2YXIgbmF0aXZlX2luc3RhbmNlO1xuXG5cdGlmIChwcm90b2NvbHMpIHtcblx0XHRuYXRpdmVfaW5zdGFuY2UgPSBuZXcgTmF0aXZlV2ViU29ja2V0KHVyaSwgcHJvdG9jb2xzKTtcblx0fVxuXHRlbHNlIHtcblx0XHRuYXRpdmVfaW5zdGFuY2UgPSBuZXcgTmF0aXZlV2ViU29ja2V0KHVyaSk7XG5cdH1cblxuXHQvKipcblx0ICogJ25hdGl2ZV9pbnN0YW5jZScgaXMgYW4gaW5zdGFuY2Ugb2YgbmF0aXZlV2ViU29ja2V0ICh0aGUgYnJvd3NlcidzIFdlYlNvY2tldFxuXHQgKiBjbGFzcykuIFNpbmNlIGl0IGlzIGFuIE9iamVjdCBpdCB3aWxsIGJlIHJldHVybmVkIGFzIGl0IGlzIHdoZW4gY3JlYXRpbmcgYW5cblx0ICogaW5zdGFuY2Ugb2YgVzNDV2ViU29ja2V0IHZpYSAnbmV3IFczQ1dlYlNvY2tldCgpJy5cblx0ICpcblx0ICogRUNNQVNjcmlwdCA1OiBodHRwOi8vYmNsYXJ5LmNvbS8yMDA0LzExLzA3LyNhLTEzLjIuMlxuXHQgKi9cblx0cmV0dXJuIG5hdGl2ZV9pbnN0YW5jZTtcbn1cbmlmIChOYXRpdmVXZWJTb2NrZXQpIHtcblx0WydDT05ORUNUSU5HJywgJ09QRU4nLCAnQ0xPU0lORycsICdDTE9TRUQnXS5mb3JFYWNoKGZ1bmN0aW9uKHByb3ApIHtcblx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoVzNDV2ViU29ja2V0LCBwcm9wLCB7XG5cdFx0XHRnZXQ6IGZ1bmN0aW9uKCkgeyByZXR1cm4gTmF0aXZlV2ViU29ja2V0W3Byb3BdOyB9XG5cdFx0fSk7XG5cdH0pO1xufVxuXG4vKipcbiAqIE1vZHVsZSBleHBvcnRzLlxuICovXG5tb2R1bGUuZXhwb3J0cyA9IHtcbiAgICAndzNjd2Vic29ja2V0JyA6IE5hdGl2ZVdlYlNvY2tldCA/IFczQ1dlYlNvY2tldCA6IG51bGwsXG4gICAgJ3ZlcnNpb24nICAgICAgOiB3ZWJzb2NrZXRfdmVyc2lvblxufTtcbiIsIm1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbjtcbiIsIm1vZHVsZS5leHBvcnRzPXtcbiAgXCJfZnJvbVwiOiBcIndlYnNvY2tldEBeMS4wLjMzXCIsXG4gIFwiX2lkXCI6IFwid2Vic29ja2V0QDEuMC4zNFwiLFxuICBcIl9pbkJ1bmRsZVwiOiBmYWxzZSxcbiAgXCJfaW50ZWdyaXR5XCI6IFwic2hhNTEyLVBSRHNvMnNHd0Y2a003NVF5a0llc0JpaktTVmNlUjZqTDJHOE5HWXlxMlhySXROQzJQNS9xTDVYZVIwNTZHaEErTHk3Sk1GdkpiOUkzMTJtSmZtcW5RPT1cIixcbiAgXCJfbG9jYXRpb25cIjogXCIvd2Vic29ja2V0XCIsXG4gIFwiX3BoYW50b21DaGlsZHJlblwiOiB7fSxcbiAgXCJfcmVxdWVzdGVkXCI6IHtcbiAgICBcInR5cGVcIjogXCJyYW5nZVwiLFxuICAgIFwicmVnaXN0cnlcIjogdHJ1ZSxcbiAgICBcInJhd1wiOiBcIndlYnNvY2tldEBeMS4wLjMzXCIsXG4gICAgXCJuYW1lXCI6IFwid2Vic29ja2V0XCIsXG4gICAgXCJlc2NhcGVkTmFtZVwiOiBcIndlYnNvY2tldFwiLFxuICAgIFwicmF3U3BlY1wiOiBcIl4xLjAuMzNcIixcbiAgICBcInNhdmVTcGVjXCI6IG51bGwsXG4gICAgXCJmZXRjaFNwZWNcIjogXCJeMS4wLjMzXCJcbiAgfSxcbiAgXCJfcmVxdWlyZWRCeVwiOiBbXG4gICAgXCIvcHJvdG9vLWNsaWVudFwiXG4gIF0sXG4gIFwiX3Jlc29sdmVkXCI6IFwiaHR0cHM6Ly9yZWdpc3RyeS5ucG1qcy5vcmcvd2Vic29ja2V0Ly0vd2Vic29ja2V0LTEuMC4zNC50Z3pcIixcbiAgXCJfc2hhc3VtXCI6IFwiMmJkYzI2MDJjMDhiZjJjODIyNTNiNzMwNjU1YzBlZjdkY2FiMzExMVwiLFxuICBcIl9zcGVjXCI6IFwid2Vic29ja2V0QF4xLjAuMzNcIixcbiAgXCJfd2hlcmVcIjogXCIvaG9tZS91YnVudHUvdW1icmVsbGEtdm9pY2UvYXBwL25vZGVfbW9kdWxlcy9wcm90b28tY2xpZW50XCIsXG4gIFwiYXV0aG9yXCI6IHtcbiAgICBcIm5hbWVcIjogXCJCcmlhbiBNY0tlbHZleVwiLFxuICAgIFwiZW1haWxcIjogXCJ0aGV0dXJ0bGUzMkBnbWFpbC5jb21cIixcbiAgICBcInVybFwiOiBcImh0dHBzOi8vZ2l0aHViLmNvbS90aGV0dXJ0bGUzMlwiXG4gIH0sXG4gIFwiYnJvd3NlclwiOiBcImxpYi9icm93c2VyLmpzXCIsXG4gIFwiYnVnc1wiOiB7XG4gICAgXCJ1cmxcIjogXCJodHRwczovL2dpdGh1Yi5jb20vdGhldHVydGxlMzIvV2ViU29ja2V0LU5vZGUvaXNzdWVzXCJcbiAgfSxcbiAgXCJidW5kbGVEZXBlbmRlbmNpZXNcIjogZmFsc2UsXG4gIFwiY29uZmlnXCI6IHtcbiAgICBcInZlcmJvc2VcIjogZmFsc2VcbiAgfSxcbiAgXCJjb250cmlidXRvcnNcIjogW1xuICAgIHtcbiAgICAgIFwibmFtZVwiOiBcIknDsWFraSBCYXogQ2FzdGlsbG9cIixcbiAgICAgIFwiZW1haWxcIjogXCJpYmNAYWxpYXgubmV0XCIsXG4gICAgICBcInVybFwiOiBcImh0dHA6Ly9kZXYuc2lwZG9jLm5ldFwiXG4gICAgfVxuICBdLFxuICBcImRlcGVuZGVuY2llc1wiOiB7XG4gICAgXCJidWZmZXJ1dGlsXCI6IFwiXjQuMC4xXCIsXG4gICAgXCJkZWJ1Z1wiOiBcIl4yLjIuMFwiLFxuICAgIFwiZXM1LWV4dFwiOiBcIl4wLjEwLjUwXCIsXG4gICAgXCJ0eXBlZGFycmF5LXRvLWJ1ZmZlclwiOiBcIl4zLjEuNVwiLFxuICAgIFwidXRmLTgtdmFsaWRhdGVcIjogXCJeNS4wLjJcIixcbiAgICBcInlhZXRpXCI6IFwiXjAuMC42XCJcbiAgfSxcbiAgXCJkZXByZWNhdGVkXCI6IGZhbHNlLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiV2Vic29ja2V0IENsaWVudCAmIFNlcnZlciBMaWJyYXJ5IGltcGxlbWVudGluZyB0aGUgV2ViU29ja2V0IHByb3RvY29sIGFzIHNwZWNpZmllZCBpbiBSRkMgNjQ1NS5cIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiYnVmZmVyLWVxdWFsXCI6IFwiXjEuMC4wXCIsXG4gICAgXCJndWxwXCI6IFwiXjQuMC4yXCIsXG4gICAgXCJndWxwLWpzaGludFwiOiBcIl4yLjAuNFwiLFxuICAgIFwianNoaW50XCI6IFwiXjIuMC4wXCIsXG4gICAgXCJqc2hpbnQtc3R5bGlzaFwiOiBcIl4yLjIuMVwiLFxuICAgIFwidGFwZVwiOiBcIl40LjkuMVwiXG4gIH0sXG4gIFwiZGlyZWN0b3JpZXNcIjoge1xuICAgIFwibGliXCI6IFwiLi9saWJcIlxuICB9LFxuICBcImVuZ2luZXNcIjoge1xuICAgIFwibm9kZVwiOiBcIj49NC4wLjBcIlxuICB9LFxuICBcImhvbWVwYWdlXCI6IFwiaHR0cHM6Ly9naXRodWIuY29tL3RoZXR1cnRsZTMyL1dlYlNvY2tldC1Ob2RlXCIsXG4gIFwia2V5d29yZHNcIjogW1xuICAgIFwid2Vic29ja2V0XCIsXG4gICAgXCJ3ZWJzb2NrZXRzXCIsXG4gICAgXCJzb2NrZXRcIixcbiAgICBcIm5ldHdvcmtpbmdcIixcbiAgICBcImNvbWV0XCIsXG4gICAgXCJwdXNoXCIsXG4gICAgXCJSRkMtNjQ1NVwiLFxuICAgIFwicmVhbHRpbWVcIixcbiAgICBcInNlcnZlclwiLFxuICAgIFwiY2xpZW50XCJcbiAgXSxcbiAgXCJsaWNlbnNlXCI6IFwiQXBhY2hlLTIuMFwiLFxuICBcIm1haW5cIjogXCJpbmRleFwiLFxuICBcIm5hbWVcIjogXCJ3ZWJzb2NrZXRcIixcbiAgXCJyZXBvc2l0b3J5XCI6IHtcbiAgICBcInR5cGVcIjogXCJnaXRcIixcbiAgICBcInVybFwiOiBcImdpdCtodHRwczovL2dpdGh1Yi5jb20vdGhldHVydGxlMzIvV2ViU29ja2V0LU5vZGUuZ2l0XCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImd1bHBcIjogXCJndWxwXCIsXG4gICAgXCJ0ZXN0XCI6IFwidGFwZSB0ZXN0L3VuaXQvKi5qc1wiXG4gIH0sXG4gIFwidmVyc2lvblwiOiBcIjEuMC4zNFwiXG59XG4iXX0=
  